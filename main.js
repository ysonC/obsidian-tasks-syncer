/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.7",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs3 = require("fs");
    var path3 = require("path");
    var os = require("os");
    var crypto4 = require("crypto");
    var packageJson = require_package();
    var version3 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version3}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version3}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version3}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs3.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path3.resolve(process.cwd(), ".env.vault");
      }
      if (fs3.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path3.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path3.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path4 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs3.readFileSync(path4, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path4} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config2(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto4.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config: config2,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports, module2) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto4 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto4.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto4.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto4.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto4.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto4.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto4.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto4.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto4.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto4.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto4.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports, module2) {
    var jws = require_jws();
    module2.exports = function(jwt2, options) {
      options = options || {};
      var decoded = jws.decode(jwt2, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error) this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name3) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports, module2) {
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name3, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name3, index, value);
      t[name3] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module2) {
    var parse = require_parse();
    var valid = (version3, options) => {
      const v = parse(version3, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module2) {
    var parse = require_parse();
    var clean = (version3, options) => {
      const s = parse(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module2) {
    var SemVer = require_semver();
    var inc = (version3, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module2) {
    var parse = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module2) {
    var parse = require_parse();
    var prerelease = (version3, options) => {
      const parsed = parse(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version3, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range = require_range();
    var satisfies = (version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module2) {
    var outside = require_outside();
    var gtr = (version3, range, options) => outside(version3, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module2) {
    var outside = require_outside();
    var ltr = (version3, range, options) => outside(version3, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version3 of v) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module2) {
    var internalRe = require_re();
    var constants2 = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants2.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports, module2) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key) {
      if (!algorithm || !key) return;
      const keyType = key.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require("crypto");
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err) throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require("crypto");
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/@electron/remote/dist/src/renderer/callbacks-registry.js
var require_callbacks_registry = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/callbacks-registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallbacksRegistry = void 0;
    var CallbacksRegistry = class {
      constructor() {
        this.nextId = 0;
        this.callbacks = {};
        this.callbackIds = /* @__PURE__ */ new WeakMap();
        this.locationInfo = /* @__PURE__ */ new WeakMap();
      }
      add(callback) {
        let id = this.callbackIds.get(callback);
        if (id != null)
          return id;
        id = this.nextId += 1;
        this.callbacks[id] = callback;
        this.callbackIds.set(callback, id);
        const regexp = /at (.*)/gi;
        const stackString = new Error().stack;
        if (!stackString)
          return id;
        let filenameAndLine;
        let match;
        while ((match = regexp.exec(stackString)) !== null) {
          const location = match[1];
          if (location.includes("(native)"))
            continue;
          if (location.includes("(<anonymous>)"))
            continue;
          if (location.includes("callbacks-registry.js"))
            continue;
          if (location.includes("remote.js"))
            continue;
          if (location.includes("@electron/remote/dist"))
            continue;
          const ref = /([^/^)]*)\)?$/gi.exec(location);
          if (ref)
            filenameAndLine = ref[1];
          break;
        }
        this.locationInfo.set(callback, filenameAndLine);
        return id;
      }
      get(id) {
        return this.callbacks[id] || function() {
        };
      }
      getLocation(callback) {
        return this.locationInfo.get(callback);
      }
      apply(id, ...args) {
        return this.get(id).apply(global, ...args);
      }
      remove(id) {
        const callback = this.callbacks[id];
        if (callback) {
          this.callbackIds.delete(callback);
          delete this.callbacks[id];
        }
      }
    };
    exports.CallbacksRegistry = CallbacksRegistry;
  }
});

// node_modules/@electron/remote/dist/src/common/type-utils.js
var require_type_utils = __commonJS({
  "node_modules/@electron/remote/dist/src/common/type-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserialize = exports.serialize = exports.isSerializableObject = exports.isPromise = void 0;
    var electron_1 = require("electron");
    function isPromise(val) {
      return val && val.then && val.then instanceof Function && val.constructor && val.constructor.reject && val.constructor.reject instanceof Function && val.constructor.resolve && val.constructor.resolve instanceof Function;
    }
    exports.isPromise = isPromise;
    var serializableTypes = [
      Boolean,
      Number,
      String,
      Date,
      Error,
      RegExp,
      ArrayBuffer
    ];
    function isSerializableObject(value) {
      return value === null || ArrayBuffer.isView(value) || serializableTypes.some((type) => value instanceof type);
    }
    exports.isSerializableObject = isSerializableObject;
    var objectMap = function(source, mapper) {
      const sourceEntries = Object.entries(source);
      const targetEntries = sourceEntries.map(([key, val]) => [key, mapper(val)]);
      return Object.fromEntries(targetEntries);
    };
    function serializeNativeImage(image) {
      const representations = [];
      const scaleFactors = image.getScaleFactors();
      if (scaleFactors.length === 1) {
        const scaleFactor = scaleFactors[0];
        const size = image.getSize(scaleFactor);
        const buffer = image.toBitmap({ scaleFactor });
        representations.push({ scaleFactor, size, buffer });
      } else {
        for (const scaleFactor of scaleFactors) {
          const size = image.getSize(scaleFactor);
          const dataURL = image.toDataURL({ scaleFactor });
          representations.push({ scaleFactor, size, dataURL });
        }
      }
      return { __ELECTRON_SERIALIZED_NativeImage__: true, representations };
    }
    function deserializeNativeImage(value) {
      const image = electron_1.nativeImage.createEmpty();
      if (value.representations.length === 1) {
        const { buffer, size, scaleFactor } = value.representations[0];
        const { width, height } = size;
        image.addRepresentation({ buffer, scaleFactor, width, height });
      } else {
        for (const rep of value.representations) {
          const { dataURL, size, scaleFactor } = rep;
          const { width, height } = size;
          image.addRepresentation({ dataURL, scaleFactor, width, height });
        }
      }
      return image;
    }
    function serialize(value) {
      if (value && value.constructor && value.constructor.name === "NativeImage") {
        return serializeNativeImage(value);
      }
      if (Array.isArray(value)) {
        return value.map(serialize);
      } else if (isSerializableObject(value)) {
        return value;
      } else if (value instanceof Object) {
        return objectMap(value, serialize);
      } else {
        return value;
      }
    }
    exports.serialize = serialize;
    function deserialize(value) {
      if (value && value.__ELECTRON_SERIALIZED_NativeImage__) {
        return deserializeNativeImage(value);
      } else if (Array.isArray(value)) {
        return value.map(deserialize);
      } else if (isSerializableObject(value)) {
        return value;
      } else if (value instanceof Object) {
        return objectMap(value, deserialize);
      } else {
        return value;
      }
    }
    exports.deserialize = deserialize;
  }
});

// node_modules/@electron/remote/dist/src/common/get-electron-binding.js
var require_get_electron_binding = __commonJS({
  "node_modules/@electron/remote/dist/src/common/get-electron-binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElectronBinding = void 0;
    var getElectronBinding = (name3) => {
      if (process._linkedBinding) {
        return process._linkedBinding("electron_common_" + name3);
      } else if (process.electronBinding) {
        return process.electronBinding(name3);
      } else {
        return null;
      }
    };
    exports.getElectronBinding = getElectronBinding;
  }
});

// node_modules/@electron/remote/dist/src/common/module-names.js
var require_module_names = __commonJS({
  "node_modules/@electron/remote/dist/src/common/module-names.js"(exports) {
    "use strict";
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.browserModuleNames = exports.commonModuleNames = void 0;
    var get_electron_binding_1 = require_get_electron_binding();
    exports.commonModuleNames = [
      "clipboard",
      "nativeImage",
      "shell"
    ];
    exports.browserModuleNames = [
      "app",
      "autoUpdater",
      "BaseWindow",
      "BrowserView",
      "BrowserWindow",
      "contentTracing",
      "crashReporter",
      "dialog",
      "globalShortcut",
      "ipcMain",
      "inAppPurchase",
      "Menu",
      "MenuItem",
      "nativeTheme",
      "net",
      "netLog",
      "MessageChannelMain",
      "Notification",
      "powerMonitor",
      "powerSaveBlocker",
      "protocol",
      "pushNotifications",
      "safeStorage",
      "screen",
      "session",
      "ShareMenu",
      "systemPreferences",
      "TopLevelWindow",
      "TouchBar",
      "Tray",
      "utilityProcess",
      "View",
      "webContents",
      "WebContentsView",
      "webFrameMain"
    ].concat(exports.commonModuleNames);
    var features = get_electron_binding_1.getElectronBinding("features");
    if (((_a = features === null || features === void 0 ? void 0 : features.isDesktopCapturerEnabled) === null || _a === void 0 ? void 0 : _a.call(features)) !== false) {
      exports.browserModuleNames.push("desktopCapturer");
    }
    if (((_b = features === null || features === void 0 ? void 0 : features.isViewApiEnabled) === null || _b === void 0 ? void 0 : _b.call(features)) !== false) {
      exports.browserModuleNames.push("ImageView");
    }
  }
});

// node_modules/@electron/remote/dist/src/renderer/remote.js
var require_remote = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/remote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFunctionWithReturnValue = exports.getGlobal = exports.getCurrentWebContents = exports.getCurrentWindow = exports.getBuiltin = void 0;
    var callbacks_registry_1 = require_callbacks_registry();
    var type_utils_1 = require_type_utils();
    var electron_1 = require("electron");
    var module_names_1 = require_module_names();
    var get_electron_binding_1 = require_get_electron_binding();
    var { Promise: Promise2 } = global;
    var callbacksRegistry = new callbacks_registry_1.CallbacksRegistry();
    var remoteObjectCache = /* @__PURE__ */ new Map();
    var finalizationRegistry = new FinalizationRegistry((id) => {
      const ref = remoteObjectCache.get(id);
      if (ref !== void 0 && ref.deref() === void 0) {
        remoteObjectCache.delete(id);
        electron_1.ipcRenderer.send("REMOTE_BROWSER_DEREFERENCE", contextId, id, 0);
      }
    });
    var electronIds = /* @__PURE__ */ new WeakMap();
    var isReturnValue = /* @__PURE__ */ new WeakSet();
    function getCachedRemoteObject(id) {
      const ref = remoteObjectCache.get(id);
      if (ref !== void 0) {
        const deref = ref.deref();
        if (deref !== void 0)
          return deref;
      }
    }
    function setCachedRemoteObject(id, value) {
      const wr = new WeakRef(value);
      remoteObjectCache.set(id, wr);
      finalizationRegistry.register(value, id);
      return value;
    }
    function getContextId() {
      const v8Util = get_electron_binding_1.getElectronBinding("v8_util");
      if (v8Util) {
        return v8Util.getHiddenValue(global, "contextId");
      } else {
        throw new Error("Electron >=v13.0.0-beta.6 required to support sandboxed renderers");
      }
    }
    var contextId = process.contextId || getContextId();
    process.on("exit", () => {
      const command = "REMOTE_BROWSER_CONTEXT_RELEASE";
      electron_1.ipcRenderer.send(command, contextId);
    });
    var IS_REMOTE_PROXY = Symbol("is-remote-proxy");
    function wrapArgs(args, visited = /* @__PURE__ */ new Set()) {
      const valueToMeta = (value) => {
        if (visited.has(value)) {
          return {
            type: "value",
            value: null
          };
        }
        if (value && value.constructor && value.constructor.name === "NativeImage") {
          return { type: "nativeimage", value: type_utils_1.serialize(value) };
        } else if (Array.isArray(value)) {
          visited.add(value);
          const meta = {
            type: "array",
            value: wrapArgs(value, visited)
          };
          visited.delete(value);
          return meta;
        } else if (value instanceof Buffer) {
          return {
            type: "buffer",
            value
          };
        } else if (type_utils_1.isSerializableObject(value)) {
          return {
            type: "value",
            value
          };
        } else if (typeof value === "object") {
          if (type_utils_1.isPromise(value)) {
            return {
              type: "promise",
              then: valueToMeta(function(onFulfilled, onRejected) {
                value.then(onFulfilled, onRejected);
              })
            };
          } else if (electronIds.has(value)) {
            return {
              type: "remote-object",
              id: electronIds.get(value)
            };
          }
          const meta = {
            type: "object",
            name: value.constructor ? value.constructor.name : "",
            members: []
          };
          visited.add(value);
          for (const prop in value) {
            meta.members.push({
              name: prop,
              value: valueToMeta(value[prop])
            });
          }
          visited.delete(value);
          return meta;
        } else if (typeof value === "function" && isReturnValue.has(value)) {
          return {
            type: "function-with-return-value",
            value: valueToMeta(value())
          };
        } else if (typeof value === "function") {
          return {
            type: "function",
            id: callbacksRegistry.add(value),
            location: callbacksRegistry.getLocation(value),
            length: value.length
          };
        } else {
          return {
            type: "value",
            value
          };
        }
      };
      return args.map(valueToMeta);
    }
    function setObjectMembers(ref, object, metaId, members) {
      if (!Array.isArray(members))
        return;
      for (const member of members) {
        if (Object.prototype.hasOwnProperty.call(object, member.name))
          continue;
        const descriptor = { enumerable: member.enumerable };
        if (member.type === "method") {
          const remoteMemberFunction = function(...args) {
            let command;
            if (this && this.constructor === remoteMemberFunction) {
              command = "REMOTE_BROWSER_MEMBER_CONSTRUCTOR";
            } else {
              command = "REMOTE_BROWSER_MEMBER_CALL";
            }
            const ret = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name, wrapArgs(args));
            return metaToValue(ret);
          };
          let descriptorFunction = proxyFunctionProperties(remoteMemberFunction, metaId, member.name);
          descriptor.get = () => {
            descriptorFunction.ref = ref;
            return descriptorFunction;
          };
          descriptor.set = (value) => {
            descriptorFunction = value;
            return value;
          };
          descriptor.configurable = true;
        } else if (member.type === "get") {
          descriptor.get = () => {
            const command = "REMOTE_BROWSER_MEMBER_GET";
            const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name);
            return metaToValue(meta);
          };
          if (member.writable) {
            descriptor.set = (value) => {
              const args = wrapArgs([value]);
              const command = "REMOTE_BROWSER_MEMBER_SET";
              const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name, args);
              if (meta != null)
                metaToValue(meta);
              return value;
            };
          }
        }
        Object.defineProperty(object, member.name, descriptor);
      }
    }
    function setObjectPrototype(ref, object, metaId, descriptor) {
      if (descriptor === null)
        return;
      const proto = {};
      setObjectMembers(ref, proto, metaId, descriptor.members);
      setObjectPrototype(ref, proto, metaId, descriptor.proto);
      Object.setPrototypeOf(object, proto);
    }
    function proxyFunctionProperties(remoteMemberFunction, metaId, name3) {
      let loaded = false;
      const loadRemoteProperties = () => {
        if (loaded)
          return;
        loaded = true;
        const command = "REMOTE_BROWSER_MEMBER_GET";
        const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, name3);
        setObjectMembers(remoteMemberFunction, remoteMemberFunction, meta.id, meta.members);
      };
      return new Proxy(remoteMemberFunction, {
        set: (target, property, value) => {
          if (property !== "ref")
            loadRemoteProperties();
          target[property] = value;
          return true;
        },
        get: (target, property) => {
          if (property === IS_REMOTE_PROXY)
            return true;
          if (!Object.prototype.hasOwnProperty.call(target, property))
            loadRemoteProperties();
          const value = target[property];
          if (property === "toString" && typeof value === "function") {
            return value.bind(target);
          }
          return value;
        },
        ownKeys: (target) => {
          loadRemoteProperties();
          return Object.getOwnPropertyNames(target);
        },
        getOwnPropertyDescriptor: (target, property) => {
          const descriptor = Object.getOwnPropertyDescriptor(target, property);
          if (descriptor)
            return descriptor;
          loadRemoteProperties();
          return Object.getOwnPropertyDescriptor(target, property);
        }
      });
    }
    function metaToValue(meta) {
      if (!meta)
        return {};
      if (meta.type === "value") {
        return meta.value;
      } else if (meta.type === "array") {
        return meta.members.map((member) => metaToValue(member));
      } else if (meta.type === "nativeimage") {
        return type_utils_1.deserialize(meta.value);
      } else if (meta.type === "buffer") {
        return Buffer.from(meta.value.buffer, meta.value.byteOffset, meta.value.byteLength);
      } else if (meta.type === "promise") {
        return Promise2.resolve({ then: metaToValue(meta.then) });
      } else if (meta.type === "error") {
        return metaToError(meta);
      } else if (meta.type === "exception") {
        if (meta.value.type === "error") {
          throw metaToError(meta.value);
        } else {
          throw new Error(`Unexpected value type in exception: ${meta.value.type}`);
        }
      } else {
        let ret;
        if ("id" in meta) {
          const cached = getCachedRemoteObject(meta.id);
          if (cached !== void 0) {
            return cached;
          }
        }
        if (meta.type === "function") {
          const remoteFunction = function(...args) {
            let command;
            if (this && this.constructor === remoteFunction) {
              command = "REMOTE_BROWSER_CONSTRUCTOR";
            } else {
              command = "REMOTE_BROWSER_FUNCTION_CALL";
            }
            const obj = electron_1.ipcRenderer.sendSync(command, contextId, meta.id, wrapArgs(args));
            return metaToValue(obj);
          };
          ret = remoteFunction;
        } else {
          ret = {};
        }
        setObjectMembers(ret, ret, meta.id, meta.members);
        setObjectPrototype(ret, ret, meta.id, meta.proto);
        if (ret.constructor && ret.constructor[IS_REMOTE_PROXY]) {
          Object.defineProperty(ret.constructor, "name", { value: meta.name });
        }
        electronIds.set(ret, meta.id);
        setCachedRemoteObject(meta.id, ret);
        return ret;
      }
    }
    function metaToError(meta) {
      const obj = meta.value;
      for (const { name: name3, value } of meta.members) {
        obj[name3] = metaToValue(value);
      }
      return obj;
    }
    function hasSenderId(input) {
      return typeof input.senderId === "number";
    }
    function handleMessage(channel, handler) {
      electron_1.ipcRenderer.on(channel, (event, passedContextId, id, ...args) => {
        if (hasSenderId(event)) {
          if (event.senderId !== 0 && event.senderId !== void 0) {
            console.error(`Message ${channel} sent by unexpected WebContents (${event.senderId})`);
            return;
          }
        }
        if (passedContextId === contextId) {
          handler(id, ...args);
        } else {
          electron_1.ipcRenderer.send("REMOTE_BROWSER_WRONG_CONTEXT_ERROR", contextId, passedContextId, id);
        }
      });
    }
    var enableStacks = process.argv.includes("--enable-api-filtering-logging");
    function getCurrentStack() {
      const target = { stack: void 0 };
      if (enableStacks) {
        Error.captureStackTrace(target, getCurrentStack);
      }
      return target.stack;
    }
    handleMessage("REMOTE_RENDERER_CALLBACK", (id, args) => {
      callbacksRegistry.apply(id, metaToValue(args));
    });
    handleMessage("REMOTE_RENDERER_RELEASE_CALLBACK", (id) => {
      callbacksRegistry.remove(id);
    });
    exports.require = (module3) => {
      const command = "REMOTE_BROWSER_REQUIRE";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, module3, getCurrentStack());
      return metaToValue(meta);
    };
    function getBuiltin(module3) {
      const command = "REMOTE_BROWSER_GET_BUILTIN";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, module3, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getBuiltin = getBuiltin;
    function getCurrentWindow() {
      const command = "REMOTE_BROWSER_GET_CURRENT_WINDOW";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getCurrentWindow = getCurrentWindow;
    function getCurrentWebContents() {
      const command = "REMOTE_BROWSER_GET_CURRENT_WEB_CONTENTS";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getCurrentWebContents = getCurrentWebContents;
    function getGlobal(name3) {
      const command = "REMOTE_BROWSER_GET_GLOBAL";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, name3, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getGlobal = getGlobal;
    Object.defineProperty(exports, "process", {
      enumerable: true,
      get: () => exports.getGlobal("process")
    });
    function createFunctionWithReturnValue(returnValue) {
      const func = () => returnValue;
      isReturnValue.add(func);
      return func;
    }
    exports.createFunctionWithReturnValue = createFunctionWithReturnValue;
    var addBuiltinProperty = (name3) => {
      Object.defineProperty(exports, name3, {
        enumerable: true,
        get: () => exports.getBuiltin(name3)
      });
    };
    module_names_1.browserModuleNames.forEach(addBuiltinProperty);
  }
});

// node_modules/@electron/remote/dist/src/renderer/index.js
var require_renderer = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    if (process.type === "browser")
      throw new Error(`"@electron/remote" cannot be required in the browser process. Instead require("@electron/remote/main").`);
    __exportStar(require_remote(), exports);
  }
});

// node_modules/@electron/remote/renderer/index.js
var require_renderer2 = __commonJS({
  "node_modules/@electron/remote/renderer/index.js"(exports, module2) {
    module2.exports = require_renderer();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TaskSyncerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");
var fs2 = __toESM(require("fs"));
var dotenv = __toESM(require_main());
var path2 = __toESM(require("path"));

// src/setting.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  selectedTaskListId: "",
  taskLists: [],
  clientId: "",
  clientSecret: "",
  redirectUrl: "http://localhost:5000"
};
var MyTodoSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Microsoft To\u2011Do Settings" });
    new import_obsidian.Setting(containerEl).setName("Client Details").setDesc(
      "Enter the client ID and client secret of your Azure AD app."
    ).addText(
      (text) => text.setPlaceholder("Client ID").setValue(this.plugin.settings.clientId).onChange(async (value) => {
        this.plugin.settings.clientId = value;
        await this.plugin.saveSettings();
      })
    ).addText(
      (text) => text.setPlaceholder("Client Secret").setValue(this.plugin.settings.clientSecret).onChange(async (value) => {
        this.plugin.settings.clientSecret = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Redirect URL").setDesc("Enter the URL to redirect to after authentication.").addText(
      (text) => text.setPlaceholder("http://localhost:5000").setValue(this.plugin.settings.redirectUrl).onChange(async (value) => {
        this.plugin.settings.redirectUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Get Task Lists").setDesc("Click to get the list of available task lists.").addButton((button) => {
      button.setButtonText("Get Task Lists").onClick(async () => {
        await this.plugin.loadAvailableTaskLists();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Task List").setDesc(
      "Select the Microsoft To\u2011Do list to store your Obsidian tasks."
    ).addDropdown((drop) => {
      drop.addOption("", "Select a task list");
      if (this.settings.taskLists.length > 0) {
        this.settings.taskLists.forEach((list) => {
          drop.addOption(list.id, list.title);
        });
      } else {
        drop.addOption("none", "No task lists available");
      }
      drop.setValue(this.settings.selectedTaskListId);
      drop.onChange(async (value) => {
        this.settings.selectedTaskListId = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/right-sidebar-view.ts
var import_obsidian3 = require("obsidian");

// src/utils.ts
var import_obsidian2 = require("obsidian");
function notify(message, type = "info") {
  let prefix = "";
  switch (type) {
    case "error":
      prefix = "\u274C ";
      break;
    case "warning":
      prefix = "\u26A0\uFE0F ";
      break;
    case "success":
      prefix = "\u2705 ";
      break;
  }
  new import_obsidian2.Notice(`${prefix}${message}`);
}

// src/right-sidebar-view.ts
var VIEW_TYPE_TODO_SIDEBAR = "tasks-syncer-sidebar";
var TaskSidebarView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_TODO_SIDEBAR;
  }
  getDisplayText() {
    return "To-Do Tasks";
  }
  async onOpen() {
    this.render(/* @__PURE__ */ new Map());
    this.plugin.getTasksFromSelectedList().then((tasks) => this.render(tasks)).catch((error) => {
      console.error("Error loading tasks in sidebar:", error);
      notify("Error loading tasks in sidebar", error);
    });
  }
  /**
   * Setup button for refreshing sidebar tasks.
   * @param Container for button
   */
  async setupRefreshButton(container) {
    const button = container.createEl("button", { text: "Refresh Tasks" });
    button.onclick = async () => {
      notify("Refreshing tasks...");
      const tasks = await this.plugin.refreshTaskCache();
      this.render(tasks);
      notify("Task refreshed!", "success");
    };
  }
  async render(tasks) {
    const container = this.containerEl.children[1];
    container.empty();
    this.setupRefreshButton(container);
    container.createEl("h3", { text: "Tasks" });
    if (tasks.size === 0) {
      container.createEl("p", {
        text: "No tasks found or not authenticated."
      });
      return;
    }
    Array.from(tasks.values()).sort((a, b) => {
      if (a.status === "completed" && b.status !== "completed")
        return 1;
      if (a.status !== "completed" && b.status === "completed")
        return -1;
      return 0;
    }).forEach((task) => {
      const line = container.createEl("div", { cls: "task-line" });
      const checkbox = line.createEl("input", {
        type: "checkbox"
      });
      checkbox.checked = task.status === "completed";
      checkbox.disabled = true;
      line.createEl("span", {
        text: task.title
      });
    });
  }
  async onClose() {
  }
};

// src/api.ts
var import_obsidian4 = require("obsidian");
async function fetchTasks(settings, accessToken) {
  const tasks = /* @__PURE__ */ new Map();
  const response = await (0, import_obsidian4.requestUrl)({
    url: `https://graph.microsoft.com/v1.0/me/todo/lists/${settings.selectedTaskListId}/tasks`,
    method: "GET",
    headers: { Authorization: `Bearer ${accessToken}` }
  });
  if (response.status !== 200) {
    throw new Error("Failed to fetch tasks: " + response.text);
  }
  const data = response.json;
  if (data.value && Array.isArray(data.value)) {
    for (const task of data.value) {
      const title = task.title.trim();
      tasks.set(title, { title, status: task.status, id: task.id });
    }
  }
  return tasks;
}
async function createTask(settings, accessToken, taskTitle, status = "notStarted") {
  const response = await (0, import_obsidian4.requestUrl)({
    url: `https://graph.microsoft.com/v1.0/me/todo/lists/${settings.selectedTaskListId}/tasks`,
    method: "POST",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      title: taskTitle,
      status
    })
  });
  if (response.status !== 201) {
    throw new Error(`Failed to create task: ${response.text}`);
  }
}
async function updateTask(settings, accessToken, taskId, complete) {
  const newStatus = complete ? "completed" : "notStarted";
  const response = await (0, import_obsidian4.requestUrl)({
    url: `https://graph.microsoft.com/v1.0/me/todo/lists/${settings.selectedTaskListId}/tasks/${taskId}`,
    method: "PATCH",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ status: newStatus })
  });
  if (response.status !== 200) {
    throw new Error(`Failed to update task: ${response.text}`);
  }
}
async function fetchTaskLists(accessToken) {
  const response = await (0, import_obsidian4.requestUrl)({
    url: "https://graph.microsoft.com/v1.0/me/todo/lists",
    method: "GET",
    headers: { Authorization: `Bearer ${accessToken}` }
  });
  if (response.status !== 200) {
    throw new Error("Failed to fetch task lists: " + response.text);
  }
  const data = response.json;
  const taskLists = new Array();
  console.log("Task lists data:", data);
  if (data.value && Array.isArray(data.value)) {
    for (const list of data.value) {
      taskLists.push({ title: list.displayName, id: list.id });
    }
  }
  return taskLists;
}
async function deleteTask(settings, accessToken, taskId) {
  const response = await (0, import_obsidian4.requestUrl)({
    url: `https://graph.microsoft.com/v1.0/me/todo/lists/${settings.selectedTaskListId}/tasks/${taskId}`,
    method: "DELETE",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    }
  });
  if (response.status !== 204) {
    throw new Error(`Failed to delete task: ${response.text}`);
  }
}

// node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs
var Serializer = class {
  /**
   * serialize the JSON blob
   * @param data - JSON blob cache
   */
  static serializeJSONBlob(data) {
    return JSON.stringify(data);
  }
  /**
   * Serialize Accounts
   * @param accCache - cache of accounts
   */
  static serializeAccounts(accCache) {
    const accounts = {};
    Object.keys(accCache).map(function(key) {
      var _a;
      const accountEntity = accCache[key];
      accounts[key] = {
        home_account_id: accountEntity.homeAccountId,
        environment: accountEntity.environment,
        realm: accountEntity.realm,
        local_account_id: accountEntity.localAccountId,
        username: accountEntity.username,
        authority_type: accountEntity.authorityType,
        name: accountEntity.name,
        client_info: accountEntity.clientInfo,
        last_modification_time: accountEntity.lastModificationTime,
        last_modification_app: accountEntity.lastModificationApp,
        tenantProfiles: (_a = accountEntity.tenantProfiles) == null ? void 0 : _a.map((tenantProfile) => {
          return JSON.stringify(tenantProfile);
        })
      };
    });
    return accounts;
  }
  /**
   * Serialize IdTokens
   * @param idTCache - cache of ID tokens
   */
  static serializeIdTokens(idTCache) {
    const idTokens = {};
    Object.keys(idTCache).map(function(key) {
      const idTEntity = idTCache[key];
      idTokens[key] = {
        home_account_id: idTEntity.homeAccountId,
        environment: idTEntity.environment,
        credential_type: idTEntity.credentialType,
        client_id: idTEntity.clientId,
        secret: idTEntity.secret,
        realm: idTEntity.realm
      };
    });
    return idTokens;
  }
  /**
   * Serializes AccessTokens
   * @param atCache - cache of access tokens
   */
  static serializeAccessTokens(atCache) {
    const accessTokens = {};
    Object.keys(atCache).map(function(key) {
      const atEntity = atCache[key];
      accessTokens[key] = {
        home_account_id: atEntity.homeAccountId,
        environment: atEntity.environment,
        credential_type: atEntity.credentialType,
        client_id: atEntity.clientId,
        secret: atEntity.secret,
        realm: atEntity.realm,
        target: atEntity.target,
        cached_at: atEntity.cachedAt,
        expires_on: atEntity.expiresOn,
        extended_expires_on: atEntity.extendedExpiresOn,
        refresh_on: atEntity.refreshOn,
        key_id: atEntity.keyId,
        token_type: atEntity.tokenType,
        requestedClaims: atEntity.requestedClaims,
        requestedClaimsHash: atEntity.requestedClaimsHash,
        userAssertionHash: atEntity.userAssertionHash
      };
    });
    return accessTokens;
  }
  /**
   * Serialize refreshTokens
   * @param rtCache - cache of refresh tokens
   */
  static serializeRefreshTokens(rtCache) {
    const refreshTokens = {};
    Object.keys(rtCache).map(function(key) {
      const rtEntity = rtCache[key];
      refreshTokens[key] = {
        home_account_id: rtEntity.homeAccountId,
        environment: rtEntity.environment,
        credential_type: rtEntity.credentialType,
        client_id: rtEntity.clientId,
        secret: rtEntity.secret,
        family_id: rtEntity.familyId,
        target: rtEntity.target,
        realm: rtEntity.realm
      };
    });
    return refreshTokens;
  }
  /**
   * Serialize amdtCache
   * @param amdtCache - cache of app metadata
   */
  static serializeAppMetadata(amdtCache) {
    const appMetadata = {};
    Object.keys(amdtCache).map(function(key) {
      const amdtEntity = amdtCache[key];
      appMetadata[key] = {
        client_id: amdtEntity.clientId,
        environment: amdtEntity.environment,
        family_id: amdtEntity.familyId
      };
    });
    return appMetadata;
  }
  /**
   * Serialize the cache
   * @param inMemCache - itemised cache read from the JSON
   */
  static serializeAllCache(inMemCache) {
    return {
      Account: this.serializeAccounts(inMemCache.accounts),
      IdToken: this.serializeIdTokens(inMemCache.idTokens),
      AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
      RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
      AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
    };
  }
};

// node_modules/@azure/msal-common/dist/utils/Constants.mjs
var Constants = {
  LIBRARY_NAME: "MSAL.JS",
  SKU: "msal.js.common",
  // Prefix for all library cache entries
  CACHE_PREFIX: "msal",
  // default authority
  DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
  DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
  DEFAULT_COMMON_TENANT: "common",
  // ADFS String
  ADFS: "adfs",
  DSTS: "dstsv2",
  // Default AAD Instance Discovery Endpoint
  AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
  // CIAM URL
  CIAM_AUTH_URL: ".ciamlogin.com",
  AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
  // Resource delimiter - used for certain cache entries
  RESOURCE_DELIM: "|",
  // Placeholder for non-existent account ids/objects
  NO_ACCOUNT: "NO_ACCOUNT",
  // Claims
  CLAIMS: "claims",
  // Consumer UTID
  CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
  // Default scopes
  OPENID_SCOPE: "openid",
  PROFILE_SCOPE: "profile",
  OFFLINE_ACCESS_SCOPE: "offline_access",
  EMAIL_SCOPE: "email",
  CODE_GRANT_TYPE: "authorization_code",
  RT_GRANT_TYPE: "refresh_token",
  S256_CODE_CHALLENGE_METHOD: "S256",
  URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
  AUTHORIZATION_PENDING: "authorization_pending",
  NOT_DEFINED: "not_defined",
  EMPTY_STRING: "",
  NOT_APPLICABLE: "N/A",
  NOT_AVAILABLE: "Not Available",
  FORWARD_SLASH: "/",
  IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
  IMDS_VERSION: "2020-06-01",
  IMDS_TIMEOUT: 2e3,
  AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
  REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
  KNOWN_PUBLIC_CLOUDS: [
    "login.microsoftonline.com",
    "login.windows.net",
    "login.microsoft.com",
    "sts.windows.net"
  ],
  SHR_NONCE_VALIDITY: 240,
  INVALID_INSTANCE: "invalid_instance"
};
var HttpStatus = {
  SUCCESS: 200,
  SUCCESS_RANGE_START: 200,
  SUCCESS_RANGE_END: 299,
  REDIRECT: 302,
  CLIENT_ERROR: 400,
  CLIENT_ERROR_RANGE_START: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  REQUEST_TIMEOUT: 408,
  TOO_MANY_REQUESTS: 429,
  CLIENT_ERROR_RANGE_END: 499,
  SERVER_ERROR: 500,
  SERVER_ERROR_RANGE_START: 500,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  SERVER_ERROR_RANGE_END: 599,
  MULTI_SIDED_ERROR: 600
};
var OIDC_DEFAULT_SCOPES = [
  Constants.OPENID_SCOPE,
  Constants.PROFILE_SCOPE,
  Constants.OFFLINE_ACCESS_SCOPE
];
var OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
var HeaderNames = {
  CONTENT_TYPE: "Content-Type",
  CONTENT_LENGTH: "Content-Length",
  RETRY_AFTER: "Retry-After",
  CCS_HEADER: "X-AnchorMailbox",
  WWWAuthenticate: "WWW-Authenticate",
  AuthenticationInfo: "Authentication-Info",
  X_MS_REQUEST_ID: "x-ms-request-id",
  X_MS_HTTP_VERSION: "x-ms-httpver"
};
var AADAuthorityConstants = {
  COMMON: "common",
  ORGANIZATIONS: "organizations",
  CONSUMERS: "consumers"
};
var ClaimsRequestKeys = {
  ACCESS_TOKEN: "access_token",
  XMS_CC: "xms_cc"
};
var PromptValue = {
  LOGIN: "login",
  SELECT_ACCOUNT: "select_account",
  CONSENT: "consent",
  NONE: "none",
  CREATE: "create",
  NO_SESSION: "no_session"
};
var CodeChallengeMethodValues = {
  PLAIN: "plain",
  S256: "S256"
};
var OAuthResponseType = {
  CODE: "code",
  IDTOKEN_TOKEN: "id_token token",
  IDTOKEN_TOKEN_REFRESHTOKEN: "id_token token refresh_token"
};
var ResponseMode = {
  QUERY: "query",
  FRAGMENT: "fragment",
  FORM_POST: "form_post"
};
var GrantType = {
  IMPLICIT_GRANT: "implicit",
  AUTHORIZATION_CODE_GRANT: "authorization_code",
  CLIENT_CREDENTIALS_GRANT: "client_credentials",
  RESOURCE_OWNER_PASSWORD_GRANT: "password",
  REFRESH_TOKEN_GRANT: "refresh_token",
  DEVICE_CODE_GRANT: "device_code",
  JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer"
};
var CacheAccountType = {
  MSSTS_ACCOUNT_TYPE: "MSSTS",
  ADFS_ACCOUNT_TYPE: "ADFS",
  MSAV1_ACCOUNT_TYPE: "MSA",
  GENERIC_ACCOUNT_TYPE: "Generic"
  // NTLM, Kerberos, FBA, Basic etc
};
var Separators = {
  CACHE_KEY_SEPARATOR: "-",
  CLIENT_INFO_SEPARATOR: "."
};
var CredentialType = {
  ID_TOKEN: "IdToken",
  ACCESS_TOKEN: "AccessToken",
  ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
  REFRESH_TOKEN: "RefreshToken"
};
var APP_METADATA = "appmetadata";
var CLIENT_INFO = "client_info";
var THE_FAMILY_ID = "1";
var AUTHORITY_METADATA_CONSTANTS = {
  CACHE_KEY: "authority-metadata",
  REFRESH_TIME_SECONDS: 3600 * 24
  // 24 Hours
};
var AuthorityMetadataSource = {
  CONFIG: "config",
  CACHE: "cache",
  NETWORK: "network",
  HARDCODED_VALUES: "hardcoded_values"
};
var SERVER_TELEM_CONSTANTS = {
  SCHEMA_VERSION: 5,
  MAX_CUR_HEADER_BYTES: 80,
  MAX_LAST_HEADER_BYTES: 330,
  MAX_CACHED_ERRORS: 50,
  CACHE_KEY: "server-telemetry",
  CATEGORY_SEPARATOR: "|",
  VALUE_SEPARATOR: ",",
  OVERFLOW_TRUE: "1",
  OVERFLOW_FALSE: "0",
  UNKNOWN_ERROR: "unknown_error"
};
var AuthenticationScheme = {
  BEARER: "Bearer",
  POP: "pop",
  SSH: "ssh-cert"
};
var ThrottlingConstants = {
  // Default time to throttle RequestThumbprint in seconds
  DEFAULT_THROTTLE_TIME_SECONDS: 60,
  // Default maximum time to throttle in seconds, overrides what the server sends back
  DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
  // Prefix for storing throttling entries
  THROTTLING_PREFIX: "throttling",
  // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
  X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
};
var Errors = {
  INVALID_GRANT_ERROR: "invalid_grant",
  CLIENT_MISMATCH_ERROR: "client_mismatch"
};
var PasswordGrantConstants = {
  username: "username",
  password: "password"
};
var ResponseCodes = {
  httpSuccess: 200,
  httpBadRequest: 400
};
var RegionDiscoverySources = {
  FAILED_AUTO_DETECTION: "1",
  INTERNAL_CACHE: "2",
  ENVIRONMENT_VARIABLE: "3",
  IMDS: "4"
};
var RegionDiscoveryOutcomes = {
  CONFIGURED_MATCHES_DETECTED: "1",
  CONFIGURED_NO_AUTO_DETECTION: "2",
  CONFIGURED_NOT_DETECTED: "3",
  AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
  AUTO_DETECTION_REQUESTED_FAILED: "5"
};
var CacheOutcome = {
  // When a token is found in the cache or the cache is not supposed to be hit when making the request
  NOT_APPLICABLE: "0",
  // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
  FORCE_REFRESH_OR_CLAIMS: "1",
  // When the token request goes to the identity provider because no cached access token exists
  NO_CACHED_ACCESS_TOKEN: "2",
  // When the token request goes to the identity provider because cached access token expired
  CACHED_ACCESS_TOKEN_EXPIRED: "3",
  // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
  PROACTIVELY_REFRESHED: "4"
};
var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;

// node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs
var unexpectedError = "unexpected_error";
var postRequestFailed = "post_request_failed";

// node_modules/@azure/msal-common/dist/error/AuthError.mjs
var AuthErrorMessages = {
  [unexpectedError]: "Unexpected error in authentication.",
  [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
};
var AuthErrorMessage = {
  unexpectedError: {
    code: unexpectedError,
    desc: AuthErrorMessages[unexpectedError]
  },
  postRequestFailed: {
    code: postRequestFailed,
    desc: AuthErrorMessages[postRequestFailed]
  }
};
var AuthError = class _AuthError extends Error {
  constructor(errorCode, errorMessage, suberror) {
    const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;
    super(errorString);
    Object.setPrototypeOf(this, _AuthError.prototype);
    this.errorCode = errorCode || Constants.EMPTY_STRING;
    this.errorMessage = errorMessage || Constants.EMPTY_STRING;
    this.subError = suberror || Constants.EMPTY_STRING;
    this.name = "AuthError";
  }
  setCorrelationId(correlationId) {
    this.correlationId = correlationId;
  }
};

// node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs
var ClientAuthErrorCodes_exports = {};
__export(ClientAuthErrorCodes_exports, {
  authTimeNotFound: () => authTimeNotFound,
  authorizationCodeMissingFromServerResponse: () => authorizationCodeMissingFromServerResponse,
  bindingKeyNotRemoved: () => bindingKeyNotRemoved,
  cannotAppendScopeSet: () => cannotAppendScopeSet,
  cannotRemoveEmptyScope: () => cannotRemoveEmptyScope,
  clientInfoDecodingError: () => clientInfoDecodingError,
  clientInfoEmptyError: () => clientInfoEmptyError,
  deviceCodeExpired: () => deviceCodeExpired,
  deviceCodePollingCancelled: () => deviceCodePollingCancelled,
  deviceCodeUnknownError: () => deviceCodeUnknownError,
  emptyInputScopeSet: () => emptyInputScopeSet,
  endSessionEndpointNotSupported: () => endSessionEndpointNotSupported,
  endpointResolutionError: () => endpointResolutionError,
  hashNotDeserialized: () => hashNotDeserialized,
  invalidAssertion: () => invalidAssertion,
  invalidCacheEnvironment: () => invalidCacheEnvironment,
  invalidCacheRecord: () => invalidCacheRecord,
  invalidClientCredential: () => invalidClientCredential,
  invalidState: () => invalidState,
  keyIdMissing: () => keyIdMissing,
  maxAgeTranspired: () => maxAgeTranspired,
  methodNotImplemented: () => methodNotImplemented,
  missingTenantIdError: () => missingTenantIdError,
  multipleMatchingAccounts: () => multipleMatchingAccounts,
  multipleMatchingAppMetadata: () => multipleMatchingAppMetadata,
  multipleMatchingTokens: () => multipleMatchingTokens,
  nestedAppAuthBridgeDisabled: () => nestedAppAuthBridgeDisabled,
  networkError: () => networkError,
  noAccountFound: () => noAccountFound,
  noAccountInSilentRequest: () => noAccountInSilentRequest,
  noCryptoObject: () => noCryptoObject,
  noNetworkConnectivity: () => noNetworkConnectivity,
  nonceMismatch: () => nonceMismatch,
  nullOrEmptyToken: () => nullOrEmptyToken,
  openIdConfigError: () => openIdConfigError,
  requestCannotBeMade: () => requestCannotBeMade,
  stateMismatch: () => stateMismatch,
  stateNotFound: () => stateNotFound,
  tokenClaimsCnfRequiredForSignedJwt: () => tokenClaimsCnfRequiredForSignedJwt,
  tokenParsingError: () => tokenParsingError,
  tokenRefreshRequired: () => tokenRefreshRequired,
  unexpectedCredentialType: () => unexpectedCredentialType,
  userCanceled: () => userCanceled,
  userTimeoutReached: () => userTimeoutReached
});
var clientInfoDecodingError = "client_info_decoding_error";
var clientInfoEmptyError = "client_info_empty_error";
var tokenParsingError = "token_parsing_error";
var nullOrEmptyToken = "null_or_empty_token";
var endpointResolutionError = "endpoints_resolution_error";
var networkError = "network_error";
var openIdConfigError = "openid_config_error";
var hashNotDeserialized = "hash_not_deserialized";
var invalidState = "invalid_state";
var stateMismatch = "state_mismatch";
var stateNotFound = "state_not_found";
var nonceMismatch = "nonce_mismatch";
var authTimeNotFound = "auth_time_not_found";
var maxAgeTranspired = "max_age_transpired";
var multipleMatchingTokens = "multiple_matching_tokens";
var multipleMatchingAccounts = "multiple_matching_accounts";
var multipleMatchingAppMetadata = "multiple_matching_appMetadata";
var requestCannotBeMade = "request_cannot_be_made";
var cannotRemoveEmptyScope = "cannot_remove_empty_scope";
var cannotAppendScopeSet = "cannot_append_scopeset";
var emptyInputScopeSet = "empty_input_scopeset";
var deviceCodePollingCancelled = "device_code_polling_cancelled";
var deviceCodeExpired = "device_code_expired";
var deviceCodeUnknownError = "device_code_unknown_error";
var noAccountInSilentRequest = "no_account_in_silent_request";
var invalidCacheRecord = "invalid_cache_record";
var invalidCacheEnvironment = "invalid_cache_environment";
var noAccountFound = "no_account_found";
var noCryptoObject = "no_crypto_object";
var unexpectedCredentialType = "unexpected_credential_type";
var invalidAssertion = "invalid_assertion";
var invalidClientCredential = "invalid_client_credential";
var tokenRefreshRequired = "token_refresh_required";
var userTimeoutReached = "user_timeout_reached";
var tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
var authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
var bindingKeyNotRemoved = "binding_key_not_removed";
var endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
var keyIdMissing = "key_id_missing";
var noNetworkConnectivity = "no_network_connectivity";
var userCanceled = "user_canceled";
var missingTenantIdError = "missing_tenant_id_error";
var methodNotImplemented = "method_not_implemented";
var nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";

// node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs
var ClientAuthErrorMessages = {
  [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
  [clientInfoEmptyError]: "The client info was empty",
  [tokenParsingError]: "Token cannot be parsed",
  [nullOrEmptyToken]: "The token is null or empty",
  [endpointResolutionError]: "Endpoints cannot be resolved",
  [networkError]: "Network request failed",
  [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
  [hashNotDeserialized]: "The hash parameters could not be deserialized",
  [invalidState]: "State was not the expected format",
  [stateMismatch]: "State mismatch error",
  [stateNotFound]: "State not found",
  [nonceMismatch]: "Nonce mismatch error",
  [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.",
  [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
  [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.",
  [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
  [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
  [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
  [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
  [cannotAppendScopeSet]: "Cannot append ScopeSet",
  [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
  [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
  [deviceCodeExpired]: "Device code is expired.",
  [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
  [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
  [invalidCacheRecord]: "Cache record object was null or undefined.",
  [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
  [noAccountFound]: "No account found in cache for given key.",
  [noCryptoObject]: "No crypto object detected.",
  [unexpectedCredentialType]: "Unexpected credential type.",
  [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
  [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
  [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
  [userTimeoutReached]: "User defined timeout for device code polling reached",
  [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
  [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
  [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
  [endSessionEndpointNotSupported]: "The provided authority does not support logout",
  [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
  [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
  [userCanceled]: "User cancelled the flow.",
  [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
  [methodNotImplemented]: "This method has not been implemented",
  [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled"
};
var ClientAuthErrorMessage = {
  clientInfoDecodingError: {
    code: clientInfoDecodingError,
    desc: ClientAuthErrorMessages[clientInfoDecodingError]
  },
  clientInfoEmptyError: {
    code: clientInfoEmptyError,
    desc: ClientAuthErrorMessages[clientInfoEmptyError]
  },
  tokenParsingError: {
    code: tokenParsingError,
    desc: ClientAuthErrorMessages[tokenParsingError]
  },
  nullOrEmptyToken: {
    code: nullOrEmptyToken,
    desc: ClientAuthErrorMessages[nullOrEmptyToken]
  },
  endpointResolutionError: {
    code: endpointResolutionError,
    desc: ClientAuthErrorMessages[endpointResolutionError]
  },
  networkError: {
    code: networkError,
    desc: ClientAuthErrorMessages[networkError]
  },
  unableToGetOpenidConfigError: {
    code: openIdConfigError,
    desc: ClientAuthErrorMessages[openIdConfigError]
  },
  hashNotDeserialized: {
    code: hashNotDeserialized,
    desc: ClientAuthErrorMessages[hashNotDeserialized]
  },
  invalidStateError: {
    code: invalidState,
    desc: ClientAuthErrorMessages[invalidState]
  },
  stateMismatchError: {
    code: stateMismatch,
    desc: ClientAuthErrorMessages[stateMismatch]
  },
  stateNotFoundError: {
    code: stateNotFound,
    desc: ClientAuthErrorMessages[stateNotFound]
  },
  nonceMismatchError: {
    code: nonceMismatch,
    desc: ClientAuthErrorMessages[nonceMismatch]
  },
  authTimeNotFoundError: {
    code: authTimeNotFound,
    desc: ClientAuthErrorMessages[authTimeNotFound]
  },
  maxAgeTranspired: {
    code: maxAgeTranspired,
    desc: ClientAuthErrorMessages[maxAgeTranspired]
  },
  multipleMatchingTokens: {
    code: multipleMatchingTokens,
    desc: ClientAuthErrorMessages[multipleMatchingTokens]
  },
  multipleMatchingAccounts: {
    code: multipleMatchingAccounts,
    desc: ClientAuthErrorMessages[multipleMatchingAccounts]
  },
  multipleMatchingAppMetadata: {
    code: multipleMatchingAppMetadata,
    desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]
  },
  tokenRequestCannotBeMade: {
    code: requestCannotBeMade,
    desc: ClientAuthErrorMessages[requestCannotBeMade]
  },
  removeEmptyScopeError: {
    code: cannotRemoveEmptyScope,
    desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]
  },
  appendScopeSetError: {
    code: cannotAppendScopeSet,
    desc: ClientAuthErrorMessages[cannotAppendScopeSet]
  },
  emptyInputScopeSetError: {
    code: emptyInputScopeSet,
    desc: ClientAuthErrorMessages[emptyInputScopeSet]
  },
  DeviceCodePollingCancelled: {
    code: deviceCodePollingCancelled,
    desc: ClientAuthErrorMessages[deviceCodePollingCancelled]
  },
  DeviceCodeExpired: {
    code: deviceCodeExpired,
    desc: ClientAuthErrorMessages[deviceCodeExpired]
  },
  DeviceCodeUnknownError: {
    code: deviceCodeUnknownError,
    desc: ClientAuthErrorMessages[deviceCodeUnknownError]
  },
  NoAccountInSilentRequest: {
    code: noAccountInSilentRequest,
    desc: ClientAuthErrorMessages[noAccountInSilentRequest]
  },
  invalidCacheRecord: {
    code: invalidCacheRecord,
    desc: ClientAuthErrorMessages[invalidCacheRecord]
  },
  invalidCacheEnvironment: {
    code: invalidCacheEnvironment,
    desc: ClientAuthErrorMessages[invalidCacheEnvironment]
  },
  noAccountFound: {
    code: noAccountFound,
    desc: ClientAuthErrorMessages[noAccountFound]
  },
  noCryptoObj: {
    code: noCryptoObject,
    desc: ClientAuthErrorMessages[noCryptoObject]
  },
  unexpectedCredentialType: {
    code: unexpectedCredentialType,
    desc: ClientAuthErrorMessages[unexpectedCredentialType]
  },
  invalidAssertion: {
    code: invalidAssertion,
    desc: ClientAuthErrorMessages[invalidAssertion]
  },
  invalidClientCredential: {
    code: invalidClientCredential,
    desc: ClientAuthErrorMessages[invalidClientCredential]
  },
  tokenRefreshRequired: {
    code: tokenRefreshRequired,
    desc: ClientAuthErrorMessages[tokenRefreshRequired]
  },
  userTimeoutReached: {
    code: userTimeoutReached,
    desc: ClientAuthErrorMessages[userTimeoutReached]
  },
  tokenClaimsRequired: {
    code: tokenClaimsCnfRequiredForSignedJwt,
    desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]
  },
  noAuthorizationCodeFromServer: {
    code: authorizationCodeMissingFromServerResponse,
    desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]
  },
  bindingKeyNotRemovedError: {
    code: bindingKeyNotRemoved,
    desc: ClientAuthErrorMessages[bindingKeyNotRemoved]
  },
  logoutNotSupported: {
    code: endSessionEndpointNotSupported,
    desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]
  },
  keyIdMissing: {
    code: keyIdMissing,
    desc: ClientAuthErrorMessages[keyIdMissing]
  },
  noNetworkConnectivity: {
    code: noNetworkConnectivity,
    desc: ClientAuthErrorMessages[noNetworkConnectivity]
  },
  userCanceledError: {
    code: userCanceled,
    desc: ClientAuthErrorMessages[userCanceled]
  },
  missingTenantIdError: {
    code: missingTenantIdError,
    desc: ClientAuthErrorMessages[missingTenantIdError]
  },
  nestedAppAuthBridgeDisabled: {
    code: nestedAppAuthBridgeDisabled,
    desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]
  }
};
var ClientAuthError = class _ClientAuthError extends AuthError {
  constructor(errorCode, additionalMessage) {
    super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);
    this.name = "ClientAuthError";
    Object.setPrototypeOf(this, _ClientAuthError.prototype);
  }
};
function createClientAuthError(errorCode, additionalMessage) {
  return new ClientAuthError(errorCode, additionalMessage);
}

// node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs
var DEFAULT_CRYPTO_IMPLEMENTATION = {
  createNewGuid: () => {
    throw createClientAuthError(methodNotImplemented);
  },
  base64Decode: () => {
    throw createClientAuthError(methodNotImplemented);
  },
  base64Encode: () => {
    throw createClientAuthError(methodNotImplemented);
  },
  base64UrlEncode: () => {
    throw createClientAuthError(methodNotImplemented);
  },
  encodeKid: () => {
    throw createClientAuthError(methodNotImplemented);
  },
  async getPublicKeyThumbprint() {
    throw createClientAuthError(methodNotImplemented);
  },
  async removeTokenBindingKey() {
    throw createClientAuthError(methodNotImplemented);
  },
  async clearKeystore() {
    throw createClientAuthError(methodNotImplemented);
  },
  async signJwt() {
    throw createClientAuthError(methodNotImplemented);
  },
  async hashString() {
    throw createClientAuthError(methodNotImplemented);
  }
};

// node_modules/@azure/msal-common/dist/logger/Logger.mjs
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
  LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
})(LogLevel || (LogLevel = {}));
var Logger = class _Logger {
  constructor(loggerOptions, packageName, packageVersion) {
    this.level = LogLevel.Info;
    const defaultLoggerCallback = () => {
      return;
    };
    const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
    this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback;
    this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
    this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : LogLevel.Info;
    this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
    this.packageName = packageName || Constants.EMPTY_STRING;
    this.packageVersion = packageVersion || Constants.EMPTY_STRING;
  }
  static createDefaultLoggerOptions() {
    return {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel.Info
    };
  }
  /**
   * Create new Logger with existing configurations.
   */
  clone(packageName, packageVersion, correlationId) {
    return new _Logger({
      loggerCallback: this.localCallback,
      piiLoggingEnabled: this.piiLoggingEnabled,
      logLevel: this.level,
      correlationId: correlationId || this.correlationId
    }, packageName, packageVersion);
  }
  /**
   * Log message with required options.
   */
  logMessage(logMessage, options) {
    if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
      return;
    }
    const timestamp = (/* @__PURE__ */ new Date()).toUTCString();
    const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
    const log = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${LogLevel[options.logLevel]} - ${logMessage}`;
    this.executeCallback(options.logLevel, log, options.containsPii || false);
  }
  /**
   * Execute callback with message.
   */
  executeCallback(level, message, containsPii) {
    if (this.localCallback) {
      this.localCallback(level, message, containsPii);
    }
  }
  /**
   * Logs error messages.
   */
  error(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Error,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs error messages with PII.
   */
  errorPii(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Error,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs warning messages.
   */
  warning(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Warning,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs warning messages with PII.
   */
  warningPii(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Warning,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs info messages.
   */
  info(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Info,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs info messages with PII.
   */
  infoPii(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Info,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs verbose messages.
   */
  verbose(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Verbose,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs verbose messages with PII.
   */
  verbosePii(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Verbose,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs trace messages.
   */
  trace(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Trace,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Logs trace messages with PII.
   */
  tracePii(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Trace,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  }
  /**
   * Returns whether PII Logging is enabled or not.
   */
  isPiiLoggingEnabled() {
    return this.piiLoggingEnabled || false;
  }
};

// node_modules/@azure/msal-common/dist/packageMetadata.mjs
var name = "@azure/msal-common";
var version = "15.4.0";

// node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs
var AzureCloudInstance = {
  // AzureCloudInstance is not specified.
  None: "none",
  // Microsoft Azure public cloud
  AzurePublic: "https://login.microsoftonline.com",
  // Microsoft PPE
  AzurePpe: "https://login.windows-ppe.net",
  // Microsoft Chinese national/regional cloud
  AzureChina: "https://login.chinacloudapi.cn",
  // Microsoft German national/regional cloud ("Black Forest")
  AzureGermany: "https://login.microsoftonline.de",
  // US Government cloud
  AzureUsGovernment: "https://login.microsoftonline.us"
};

// node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
var CacheHelpers_exports = {};
__export(CacheHelpers_exports, {
  createAccessTokenEntity: () => createAccessTokenEntity,
  createIdTokenEntity: () => createIdTokenEntity,
  createRefreshTokenEntity: () => createRefreshTokenEntity,
  generateAppMetadataKey: () => generateAppMetadataKey,
  generateAuthorityMetadataExpiresAt: () => generateAuthorityMetadataExpiresAt,
  generateCredentialKey: () => generateCredentialKey,
  isAccessTokenEntity: () => isAccessTokenEntity,
  isAppMetadataEntity: () => isAppMetadataEntity,
  isAuthorityMetadataEntity: () => isAuthorityMetadataEntity,
  isAuthorityMetadataExpired: () => isAuthorityMetadataExpired,
  isCredentialEntity: () => isCredentialEntity,
  isIdTokenEntity: () => isIdTokenEntity,
  isRefreshTokenEntity: () => isRefreshTokenEntity,
  isServerTelemetryEntity: () => isServerTelemetryEntity,
  isThrottlingEntity: () => isThrottlingEntity,
  updateAuthorityEndpointMetadata: () => updateAuthorityEndpointMetadata,
  updateCloudDiscoveryMetadata: () => updateCloudDiscoveryMetadata
});

// node_modules/@azure/msal-common/dist/account/AuthToken.mjs
var AuthToken_exports = {};
__export(AuthToken_exports, {
  checkMaxAge: () => checkMaxAge,
  extractTokenClaims: () => extractTokenClaims,
  getJWSPayload: () => getJWSPayload
});
function extractTokenClaims(encodedToken, base64Decode) {
  const jswPayload = getJWSPayload(encodedToken);
  try {
    const base64Decoded = base64Decode(jswPayload);
    return JSON.parse(base64Decoded);
  } catch (err) {
    throw createClientAuthError(tokenParsingError);
  }
}
function getJWSPayload(authToken) {
  if (!authToken) {
    throw createClientAuthError(nullOrEmptyToken);
  }
  const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
  const matches = tokenPartsRegex.exec(authToken);
  if (!matches || matches.length < 4) {
    throw createClientAuthError(tokenParsingError);
  }
  return matches[2];
}
function checkMaxAge(authTime, maxAge) {
  const fiveMinuteSkew = 3e5;
  if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
    throw createClientAuthError(maxAgeTranspired);
  }
}

// node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs
var TimeUtils_exports = {};
__export(TimeUtils_exports, {
  delay: () => delay,
  isTokenExpired: () => isTokenExpired,
  nowSeconds: () => nowSeconds,
  toDateFromSeconds: () => toDateFromSeconds,
  toSecondsFromDate: () => toSecondsFromDate,
  wasClockTurnedBack: () => wasClockTurnedBack
});
function nowSeconds() {
  return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
}
function toSecondsFromDate(date) {
  return date.getTime() / 1e3;
}
function toDateFromSeconds(seconds) {
  if (seconds) {
    return new Date(Number(seconds) * 1e3);
  }
  return /* @__PURE__ */ new Date();
}
function isTokenExpired(expiresOn, offset) {
  const expirationSec = Number(expiresOn) || 0;
  const offsetCurrentTimeSec = nowSeconds() + offset;
  return offsetCurrentTimeSec > expirationSec;
}
function wasClockTurnedBack(cachedAt) {
  const cachedAtSec = Number(cachedAt);
  return cachedAtSec > nowSeconds();
}
function delay(t, value) {
  return new Promise((resolve) => setTimeout(() => resolve(value), t));
}

// node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
function generateCredentialKey(credentialEntity) {
  const credentialKey = [
    generateAccountId(credentialEntity),
    generateCredentialId(credentialEntity),
    generateTarget(credentialEntity),
    generateClaimsHash(credentialEntity),
    generateScheme(credentialEntity)
  ];
  return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
  const idTokenEntity = {
    credentialType: CredentialType.ID_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: idToken,
    realm: tenantId
  };
  return idTokenEntity;
}
function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
  var _a, _b;
  const atEntity = {
    homeAccountId,
    credentialType: CredentialType.ACCESS_TOKEN,
    secret: accessToken,
    cachedAt: nowSeconds().toString(),
    expiresOn: expiresOn.toString(),
    extendedExpiresOn: extExpiresOn.toString(),
    environment,
    clientId,
    realm: tenantId,
    target: scopes,
    tokenType: tokenType || AuthenticationScheme.BEARER
  };
  if (userAssertionHash) {
    atEntity.userAssertionHash = userAssertionHash;
  }
  if (refreshOn) {
    atEntity.refreshOn = refreshOn.toString();
  }
  if (requestedClaims) {
    atEntity.requestedClaims = requestedClaims;
    atEntity.requestedClaimsHash = requestedClaimsHash;
  }
  if (((_a = atEntity.tokenType) == null ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {
    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
    switch (atEntity.tokenType) {
      case AuthenticationScheme.POP:
        const tokenClaims = extractTokenClaims(accessToken, base64Decode);
        if (!((_b = tokenClaims == null ? void 0 : tokenClaims.cnf) == null ? void 0 : _b.kid)) {
          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
        }
        atEntity.keyId = tokenClaims.cnf.kid;
        break;
      case AuthenticationScheme.SSH:
        atEntity.keyId = keyId;
    }
  }
  return atEntity;
}
function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
  const rtEntity = {
    credentialType: CredentialType.REFRESH_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: refreshToken
  };
  if (userAssertionHash) {
    rtEntity.userAssertionHash = userAssertionHash;
  }
  if (familyId) {
    rtEntity.familyId = familyId;
  }
  if (expiresOn) {
    rtEntity.expiresOn = expiresOn.toString();
  }
  return rtEntity;
}
function isCredentialEntity(entity) {
  return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret");
}
function isAccessTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
}
function isIdTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity["credentialType"] === CredentialType.ID_TOKEN;
}
function isRefreshTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
}
function generateAccountId(credentialEntity) {
  const accountId = [
    credentialEntity.homeAccountId,
    credentialEntity.environment
  ];
  return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function generateCredentialId(credentialEntity) {
  const clientOrFamilyId = credentialEntity.credentialType === CredentialType.REFRESH_TOKEN ? credentialEntity.familyId || credentialEntity.clientId : credentialEntity.clientId;
  const credentialId = [
    credentialEntity.credentialType,
    clientOrFamilyId,
    credentialEntity.realm || ""
  ];
  return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function generateTarget(credentialEntity) {
  return (credentialEntity.target || "").toLowerCase();
}
function generateClaimsHash(credentialEntity) {
  return (credentialEntity.requestedClaimsHash || "").toLowerCase();
}
function generateScheme(credentialEntity) {
  return credentialEntity.tokenType && credentialEntity.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credentialEntity.tokenType.toLowerCase() : "";
}
function isServerTelemetryEntity(key, entity) {
  const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
  }
  return validateKey && validateEntity;
}
function isThrottlingEntity(key, entity) {
  let validateKey = false;
  if (key) {
    validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
  }
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("throttleTime");
  }
  return validateKey && validateEntity;
}
function generateAppMetadataKey({ environment, clientId }) {
  const appMetaDataKeyArray = [
    APP_METADATA,
    environment,
    clientId
  ];
  return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function isAppMetadataEntity(key, entity) {
  if (!entity) {
    return false;
  }
  return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
}
function isAuthorityMetadataEntity(key, entity) {
  if (!entity) {
    return false;
  }
  return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
}
function generateAuthorityMetadataExpiresAt() {
  return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
}
function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
  authorityMetadata.token_endpoint = updatedValues.token_endpoint;
  authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
  authorityMetadata.issuer = updatedValues.issuer;
  authorityMetadata.endpointsFromNetwork = fromNetwork;
  authorityMetadata.jwks_uri = updatedValues.jwks_uri;
}
function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.aliases = updatedValues.aliases;
  authorityMetadata.preferred_cache = updatedValues.preferred_cache;
  authorityMetadata.preferred_network = updatedValues.preferred_network;
  authorityMetadata.aliasesFromNetwork = fromNetwork;
}
function isAuthorityMetadataExpired(metadata) {
  return metadata.expiresAt <= nowSeconds();
}

// node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs
var redirectUriEmpty = "redirect_uri_empty";
var claimsRequestParsingError = "claims_request_parsing_error";
var authorityUriInsecure = "authority_uri_insecure";
var urlParseError = "url_parse_error";
var urlEmptyError = "empty_url_error";
var emptyInputScopesError = "empty_input_scopes_error";
var invalidPromptValue = "invalid_prompt_value";
var invalidClaims = "invalid_claims";
var tokenRequestEmpty = "token_request_empty";
var logoutRequestEmpty = "logout_request_empty";
var invalidCodeChallengeMethod = "invalid_code_challenge_method";
var pkceParamsMissing = "pkce_params_missing";
var invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
var invalidAuthorityMetadata = "invalid_authority_metadata";
var untrustedAuthority = "untrusted_authority";
var missingSshJwk = "missing_ssh_jwk";
var missingSshKid = "missing_ssh_kid";
var missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
var invalidAuthenticationHeader = "invalid_authentication_header";
var cannotSetOIDCOptions = "cannot_set_OIDCOptions";
var cannotAllowPlatformBroker = "cannot_allow_platform_broker";
var authorityMismatch = "authority_mismatch";

// node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs
var ClientConfigurationErrorMessages = {
  [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
  [claimsRequestParsingError]: "Could not parse the given claims request object.",
  [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
  [urlParseError]: "URL could not be parsed into appropriate segments.",
  [urlEmptyError]: "URL was empty or null.",
  [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
  [invalidPromptValue]: "Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest",
  [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
  [tokenRequestEmpty]: "Token request was empty and not found in cache.",
  [logoutRequestEmpty]: "The logout request was null or undefined.",
  [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
  [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
  [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
  [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
  [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
  [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
  [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
  [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
  [invalidAuthenticationHeader]: "Invalid authentication header provided",
  [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
  [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
  [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority."
};
var ClientConfigurationErrorMessage = {
  redirectUriNotSet: {
    code: redirectUriEmpty,
    desc: ClientConfigurationErrorMessages[redirectUriEmpty]
  },
  claimsRequestParsingError: {
    code: claimsRequestParsingError,
    desc: ClientConfigurationErrorMessages[claimsRequestParsingError]
  },
  authorityUriInsecure: {
    code: authorityUriInsecure,
    desc: ClientConfigurationErrorMessages[authorityUriInsecure]
  },
  urlParseError: {
    code: urlParseError,
    desc: ClientConfigurationErrorMessages[urlParseError]
  },
  urlEmptyError: {
    code: urlEmptyError,
    desc: ClientConfigurationErrorMessages[urlEmptyError]
  },
  emptyScopesError: {
    code: emptyInputScopesError,
    desc: ClientConfigurationErrorMessages[emptyInputScopesError]
  },
  invalidPrompt: {
    code: invalidPromptValue,
    desc: ClientConfigurationErrorMessages[invalidPromptValue]
  },
  invalidClaimsRequest: {
    code: invalidClaims,
    desc: ClientConfigurationErrorMessages[invalidClaims]
  },
  tokenRequestEmptyError: {
    code: tokenRequestEmpty,
    desc: ClientConfigurationErrorMessages[tokenRequestEmpty]
  },
  logoutRequestEmptyError: {
    code: logoutRequestEmpty,
    desc: ClientConfigurationErrorMessages[logoutRequestEmpty]
  },
  invalidCodeChallengeMethod: {
    code: invalidCodeChallengeMethod,
    desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod]
  },
  invalidCodeChallengeParams: {
    code: pkceParamsMissing,
    desc: ClientConfigurationErrorMessages[pkceParamsMissing]
  },
  invalidCloudDiscoveryMetadata: {
    code: invalidCloudDiscoveryMetadata,
    desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata]
  },
  invalidAuthorityMetadata: {
    code: invalidAuthorityMetadata,
    desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata]
  },
  untrustedAuthority: {
    code: untrustedAuthority,
    desc: ClientConfigurationErrorMessages[untrustedAuthority]
  },
  missingSshJwk: {
    code: missingSshJwk,
    desc: ClientConfigurationErrorMessages[missingSshJwk]
  },
  missingSshKid: {
    code: missingSshKid,
    desc: ClientConfigurationErrorMessages[missingSshKid]
  },
  missingNonceAuthenticationHeader: {
    code: missingNonceAuthenticationHeader,
    desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader]
  },
  invalidAuthenticationHeader: {
    code: invalidAuthenticationHeader,
    desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader]
  },
  cannotSetOIDCOptions: {
    code: cannotSetOIDCOptions,
    desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions]
  },
  cannotAllowPlatformBroker: {
    code: cannotAllowPlatformBroker,
    desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker]
  },
  authorityMismatch: {
    code: authorityMismatch,
    desc: ClientConfigurationErrorMessages[authorityMismatch]
  }
};
var ClientConfigurationError = class _ClientConfigurationError extends AuthError {
  constructor(errorCode) {
    super(errorCode, ClientConfigurationErrorMessages[errorCode]);
    this.name = "ClientConfigurationError";
    Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
  }
};
function createClientConfigurationError(errorCode) {
  return new ClientConfigurationError(errorCode);
}

// node_modules/@azure/msal-common/dist/utils/StringUtils.mjs
var StringUtils = class {
  /**
   * Check if stringified object is empty
   * @param strObj
   */
  static isEmptyObj(strObj) {
    if (strObj) {
      try {
        const obj = JSON.parse(strObj);
        return Object.keys(obj).length === 0;
      } catch (e) {
      }
    }
    return true;
  }
  static startsWith(str, search) {
    return str.indexOf(search) === 0;
  }
  static endsWith(str, search) {
    return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
  }
  /**
   * Parses string into an object.
   *
   * @param query
   */
  static queryStringToObject(query) {
    const obj = {};
    const params = query.split("&");
    const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
    params.forEach((pair) => {
      if (pair.trim()) {
        const [key, value] = pair.split(/=(.+)/g, 2);
        if (key && value) {
          obj[decode(key)] = decode(value);
        }
      }
    });
    return obj;
  }
  /**
   * Trims entries in an array.
   *
   * @param arr
   */
  static trimArrayEntries(arr) {
    return arr.map((entry) => entry.trim());
  }
  /**
   * Removes empty strings from array
   * @param arr
   */
  static removeEmptyStringsFromArray(arr) {
    return arr.filter((entry) => {
      return !!entry;
    });
  }
  /**
   * Attempts to parse a string into JSON
   * @param str
   */
  static jsonParseHelper(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return null;
    }
  }
  /**
   * Tests if a given string matches a given pattern, with support for wildcards and queries.
   * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
   * @param input String to match against
   */
  static matchPattern(pattern, input) {
    const regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
    return regex.test(input);
  }
};

// node_modules/@azure/msal-common/dist/request/ScopeSet.mjs
var ScopeSet = class _ScopeSet {
  constructor(inputScopes) {
    const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
    const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
    if (!filteredInput || !filteredInput.length) {
      throw createClientConfigurationError(emptyInputScopesError);
    }
    this.scopes = /* @__PURE__ */ new Set();
    filteredInput.forEach((scope) => this.scopes.add(scope));
  }
  /**
   * Factory method to create ScopeSet from space-delimited string
   * @param inputScopeString
   * @param appClientId
   * @param scopesRequired
   */
  static fromString(inputScopeString) {
    const scopeString = inputScopeString || Constants.EMPTY_STRING;
    const inputScopes = scopeString.split(" ");
    return new _ScopeSet(inputScopes);
  }
  /**
   * Creates the set of scopes to search for in cache lookups
   * @param inputScopeString
   * @returns
   */
  static createSearchScopes(inputScopeString) {
    const scopeSet = new _ScopeSet(inputScopeString);
    if (!scopeSet.containsOnlyOIDCScopes()) {
      scopeSet.removeOIDCScopes();
    } else {
      scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
    }
    return scopeSet;
  }
  /**
   * Check if a given scope is present in this set of scopes.
   * @param scope
   */
  containsScope(scope) {
    const lowerCaseScopes = this.printScopesLowerCase().split(" ");
    const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
    return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
  }
  /**
   * Check if a set of scopes is present in this set of scopes.
   * @param scopeSet
   */
  containsScopeSet(scopeSet) {
    if (!scopeSet || scopeSet.scopes.size <= 0) {
      return false;
    }
    return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every((scope) => this.containsScope(scope));
  }
  /**
   * Check if set of scopes contains only the defaults
   */
  containsOnlyOIDCScopes() {
    let defaultScopeCount = 0;
    OIDC_SCOPES.forEach((defaultScope) => {
      if (this.containsScope(defaultScope)) {
        defaultScopeCount += 1;
      }
    });
    return this.scopes.size === defaultScopeCount;
  }
  /**
   * Appends single scope if passed
   * @param newScope
   */
  appendScope(newScope) {
    if (newScope) {
      this.scopes.add(newScope.trim());
    }
  }
  /**
   * Appends multiple scopes if passed
   * @param newScopes
   */
  appendScopes(newScopes) {
    try {
      newScopes.forEach((newScope) => this.appendScope(newScope));
    } catch (e) {
      throw createClientAuthError(cannotAppendScopeSet);
    }
  }
  /**
   * Removes element from set of scopes.
   * @param scope
   */
  removeScope(scope) {
    if (!scope) {
      throw createClientAuthError(cannotRemoveEmptyScope);
    }
    this.scopes.delete(scope.trim());
  }
  /**
   * Removes default scopes from set of scopes
   * Primarily used to prevent cache misses if the default scopes are not returned from the server
   */
  removeOIDCScopes() {
    OIDC_SCOPES.forEach((defaultScope) => {
      this.scopes.delete(defaultScope);
    });
  }
  /**
   * Combines an array of scopes with the current set of scopes.
   * @param otherScopes
   */
  unionScopeSets(otherScopes) {
    if (!otherScopes) {
      throw createClientAuthError(emptyInputScopeSet);
    }
    const unionScopes = /* @__PURE__ */ new Set();
    otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
    this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
    return unionScopes;
  }
  /**
   * Check if scopes intersect between this set and another.
   * @param otherScopes
   */
  intersectingScopeSets(otherScopes) {
    if (!otherScopes) {
      throw createClientAuthError(emptyInputScopeSet);
    }
    if (!otherScopes.containsOnlyOIDCScopes()) {
      otherScopes.removeOIDCScopes();
    }
    const unionScopes = this.unionScopeSets(otherScopes);
    const sizeOtherScopes = otherScopes.getScopeCount();
    const sizeThisScopes = this.getScopeCount();
    const sizeUnionScopes = unionScopes.size;
    return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
  }
  /**
   * Returns size of set of scopes.
   */
  getScopeCount() {
    return this.scopes.size;
  }
  /**
   * Returns the scopes as an array of string values
   */
  asArray() {
    const array = [];
    this.scopes.forEach((val) => array.push(val));
    return array;
  }
  /**
   * Prints scopes into a space-delimited string
   */
  printScopes() {
    if (this.scopes) {
      const scopeArr = this.asArray();
      return scopeArr.join(" ");
    }
    return Constants.EMPTY_STRING;
  }
  /**
   * Prints scopes into a space-delimited lower-case string (used for caching)
   */
  printScopesLowerCase() {
    return this.printScopes().toLowerCase();
  }
};

// node_modules/@azure/msal-common/dist/account/ClientInfo.mjs
function buildClientInfo(rawClientInfo, base64Decode) {
  if (!rawClientInfo) {
    throw createClientAuthError(clientInfoEmptyError);
  }
  try {
    const decodedClientInfo = base64Decode(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw createClientAuthError(clientInfoDecodingError);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (!homeAccountId) {
    throw createClientAuthError(clientInfoDecodingError);
  }
  const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
  };
}

// node_modules/@azure/msal-common/dist/account/AccountInfo.mjs
function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
  return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split(".")[1];
}
function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
  if (idTokenClaims) {
    const { oid, sub, tid, name: name3, tfp, acr } = idTokenClaims;
    const tenantId2 = tid || tfp || acr || "";
    return {
      tenantId: tenantId2,
      localAccountId: oid || sub || "",
      name: name3,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId)
    };
  } else {
    return {
      tenantId,
      localAccountId,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId)
    };
  }
}
function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
  let updatedAccountInfo = baseAccountInfo;
  if (tenantProfile) {
    const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
    updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
  }
  if (idTokenClaims) {
    const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
    updatedAccountInfo = {
      ...updatedAccountInfo,
      ...claimsSourcedTenantProfile,
      idTokenClaims,
      idToken: idTokenSecret
    };
    return updatedAccountInfo;
  }
  return updatedAccountInfo;
}

// node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs
var AuthorityType = {
  Default: 0,
  Adfs: 1,
  Dsts: 2,
  Ciam: 3
};

// node_modules/@azure/msal-common/dist/account/TokenClaims.mjs
function getTenantIdFromIdTokenClaims(idTokenClaims) {
  if (idTokenClaims) {
    const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
    return tenantId || null;
  }
  return null;
}

// node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs
var ProtocolMode = {
  /**
   * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
   */
  AAD: "AAD",
  /**
   * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
   * Support is limited for this mode.
   */
  OIDC: "OIDC",
  /**
   * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
   */
  EAR: "EAR"
};

// node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs
var AccountEntity = class _AccountEntity {
  /**
   * Generate Account Id key component as per the schema: <home_account_id>-<environment>
   */
  generateAccountId() {
    const accountId = [this.homeAccountId, this.environment];
    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  }
  /**
   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>
   */
  generateAccountKey() {
    return _AccountEntity.generateAccountCacheKey({
      homeAccountId: this.homeAccountId,
      environment: this.environment,
      tenantId: this.realm,
      username: this.username,
      localAccountId: this.localAccountId
    });
  }
  /**
   * Returns the AccountInfo interface for this account.
   */
  getAccountInfo() {
    return {
      homeAccountId: this.homeAccountId,
      environment: this.environment,
      tenantId: this.realm,
      username: this.username,
      localAccountId: this.localAccountId,
      name: this.name,
      nativeAccountId: this.nativeAccountId,
      authorityType: this.authorityType,
      // Deserialize tenant profiles array into a Map
      tenantProfiles: new Map((this.tenantProfiles || []).map((tenantProfile) => {
        return [tenantProfile.tenantId, tenantProfile];
      }))
    };
  }
  /**
   * Returns true if the account entity is in single tenant format (outdated), false otherwise
   */
  isSingleTenant() {
    return !this.tenantProfiles;
  }
  /**
   * Generates account key from interface
   * @param accountInterface
   */
  static generateAccountCacheKey(accountInterface) {
    const homeTenantId = accountInterface.homeAccountId.split(".")[1];
    const accountKey = [
      accountInterface.homeAccountId,
      accountInterface.environment || "",
      homeTenantId || accountInterface.tenantId || ""
    ];
    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  }
  /**
   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
   * @param accountDetails
   */
  static createAccount(accountDetails, authority, base64Decode) {
    var _a, _b, _c, _d, _e, _f;
    const account = new _AccountEntity();
    if (authority.authorityType === AuthorityType.Adfs) {
      account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
    } else if (authority.protocolMode === ProtocolMode.OIDC) {
      account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
    } else {
      account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
    }
    let clientInfo;
    if (accountDetails.clientInfo && base64Decode) {
      clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
    }
    account.clientInfo = accountDetails.clientInfo;
    account.homeAccountId = accountDetails.homeAccountId;
    account.nativeAccountId = accountDetails.nativeAccountId;
    const env = accountDetails.environment || authority && authority.getPreferredCache();
    if (!env) {
      throw createClientAuthError(invalidCacheEnvironment);
    }
    account.environment = env;
    account.realm = (clientInfo == null ? void 0 : clientInfo.utid) || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || "";
    account.localAccountId = (clientInfo == null ? void 0 : clientInfo.uid) || ((_a = accountDetails.idTokenClaims) == null ? void 0 : _a.oid) || ((_b = accountDetails.idTokenClaims) == null ? void 0 : _b.sub) || "";
    const preferredUsername = ((_c = accountDetails.idTokenClaims) == null ? void 0 : _c.preferred_username) || ((_d = accountDetails.idTokenClaims) == null ? void 0 : _d.upn);
    const email = ((_e = accountDetails.idTokenClaims) == null ? void 0 : _e.emails) ? accountDetails.idTokenClaims.emails[0] : null;
    account.username = preferredUsername || email || "";
    account.name = ((_f = accountDetails.idTokenClaims) == null ? void 0 : _f.name) || "";
    account.cloudGraphHostName = accountDetails.cloudGraphHostName;
    account.msGraphHost = accountDetails.msGraphHost;
    if (accountDetails.tenantProfiles) {
      account.tenantProfiles = accountDetails.tenantProfiles;
    } else {
      const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
      account.tenantProfiles = [tenantProfile];
    }
    return account;
  }
  /**
   * Creates an AccountEntity object from AccountInfo
   * @param accountInfo
   * @param cloudGraphHostName
   * @param msGraphHost
   * @returns
   */
  static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
    var _a;
    const account = new _AccountEntity();
    account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
    account.homeAccountId = accountInfo.homeAccountId;
    account.localAccountId = accountInfo.localAccountId;
    account.nativeAccountId = accountInfo.nativeAccountId;
    account.realm = accountInfo.tenantId;
    account.environment = accountInfo.environment;
    account.username = accountInfo.username;
    account.name = accountInfo.name;
    account.cloudGraphHostName = cloudGraphHostName;
    account.msGraphHost = msGraphHost;
    account.tenantProfiles = Array.from(((_a = accountInfo.tenantProfiles) == null ? void 0 : _a.values()) || []);
    return account;
  }
  /**
   * Generate HomeAccountId from server response
   * @param serverClientInfo
   * @param authType
   */
  static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {
    if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
      if (serverClientInfo) {
        try {
          const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
          if (clientInfo.uid && clientInfo.utid) {
            return `${clientInfo.uid}.${clientInfo.utid}`;
          }
        } catch (e) {
        }
      }
      logger.warning("No client info in response");
    }
    return (idTokenClaims == null ? void 0 : idTokenClaims.sub) || "";
  }
  /**
   * Validates an entity: checks for all expected params
   * @param entity
   */
  static isAccountEntity(entity) {
    if (!entity) {
      return false;
    }
    return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
  }
  /**
   * Helper function to determine whether 2 accountInfo objects represent the same account
   * @param accountA
   * @param accountB
   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
   */
  static accountInfoIsEqual(accountA, accountB, compareClaims) {
    if (!accountA || !accountB) {
      return false;
    }
    let claimsMatch = true;
    if (compareClaims) {
      const accountAClaims = accountA.idTokenClaims || {};
      const accountBClaims = accountB.idTokenClaims || {};
      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
    }
    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
  }
};

// node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs
var UrlUtils_exports = {};
__export(UrlUtils_exports, {
  getDeserializedResponse: () => getDeserializedResponse,
  mapToQueryString: () => mapToQueryString,
  stripLeadingHashOrQuery: () => stripLeadingHashOrQuery
});
function stripLeadingHashOrQuery(responseString) {
  if (responseString.startsWith("#/")) {
    return responseString.substring(2);
  } else if (responseString.startsWith("#") || responseString.startsWith("?")) {
    return responseString.substring(1);
  }
  return responseString;
}
function getDeserializedResponse(responseString) {
  if (!responseString || responseString.indexOf("=") < 0) {
    return null;
  }
  try {
    const normalizedResponse = stripLeadingHashOrQuery(responseString);
    const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
    if (deserializedHash.code || deserializedHash.ear_jwe || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {
      return deserializedHash;
    }
  } catch (e) {
    throw createClientAuthError(hashNotDeserialized);
  }
  return null;
}
function mapToQueryString(parameters) {
  const queryParameterArray = new Array();
  parameters.forEach((value, key) => {
    queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);
  });
  return queryParameterArray.join("&");
}

// node_modules/@azure/msal-common/dist/url/UrlString.mjs
var UrlString = class _UrlString {
  get urlString() {
    return this._urlString;
  }
  constructor(url) {
    this._urlString = url;
    if (!this._urlString) {
      throw createClientConfigurationError(urlEmptyError);
    }
    if (!url.includes("#")) {
      this._urlString = _UrlString.canonicalizeUri(url);
    }
  }
  /**
   * Ensure urls are lower case and end with a / character.
   * @param url
   */
  static canonicalizeUri(url) {
    if (url) {
      let lowerCaseUrl = url.toLowerCase();
      if (StringUtils.endsWith(lowerCaseUrl, "?")) {
        lowerCaseUrl = lowerCaseUrl.slice(0, -1);
      } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
        lowerCaseUrl = lowerCaseUrl.slice(0, -2);
      }
      if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
        lowerCaseUrl += "/";
      }
      return lowerCaseUrl;
    }
    return url;
  }
  /**
   * Throws if urlString passed is not a valid authority URI string.
   */
  validateAsUri() {
    let components;
    try {
      components = this.getUrlComponents();
    } catch (e) {
      throw createClientConfigurationError(urlParseError);
    }
    if (!components.HostNameAndPort || !components.PathSegments) {
      throw createClientConfigurationError(urlParseError);
    }
    if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
      throw createClientConfigurationError(authorityUriInsecure);
    }
  }
  /**
   * Given a url and a query string return the url with provided query string appended
   * @param url
   * @param queryString
   */
  static appendQueryString(url, queryString) {
    if (!queryString) {
      return url;
    }
    return url.indexOf("?") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;
  }
  /**
   * Returns a url with the hash removed
   * @param url
   */
  static removeHashFromUrl(url) {
    return _UrlString.canonicalizeUri(url.split("#")[0]);
  }
  /**
   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
   * @param href The url
   * @param tenantId The tenant id to replace
   */
  replaceTenantPath(tenantId) {
    const urlObject = this.getUrlComponents();
    const pathArray = urlObject.PathSegments;
    if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
      pathArray[0] = tenantId;
    }
    return _UrlString.constructAuthorityUriFromObject(urlObject);
  }
  /**
   * Parses out the components from a url string.
   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
   */
  getUrlComponents() {
    const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
    const match = this.urlString.match(regEx);
    if (!match) {
      throw createClientConfigurationError(urlParseError);
    }
    const urlComponents = {
      Protocol: match[1],
      HostNameAndPort: match[4],
      AbsolutePath: match[5],
      QueryString: match[7]
    };
    let pathSegments = urlComponents.AbsolutePath.split("/");
    pathSegments = pathSegments.filter((val) => val && val.length > 0);
    urlComponents.PathSegments = pathSegments;
    if (urlComponents.QueryString && urlComponents.QueryString.endsWith("/")) {
      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
    }
    return urlComponents;
  }
  static getDomainFromUrl(url) {
    const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
    const match = url.match(regEx);
    if (!match) {
      throw createClientConfigurationError(urlParseError);
    }
    return match[2];
  }
  static getAbsoluteUrl(relativeUrl, baseUrl) {
    if (relativeUrl[0] === Constants.FORWARD_SLASH) {
      const url = new _UrlString(baseUrl);
      const baseComponents = url.getUrlComponents();
      return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
    }
    return relativeUrl;
  }
  static constructAuthorityUriFromObject(urlObject) {
    return new _UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
  }
  /**
   * Check if the hash of the URL string contains known properties
   * @deprecated This API will be removed in a future version
   */
  static hashContainsKnownProperties(response) {
    return !!getDeserializedResponse(response);
  }
};

// node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs
var rawMetdataJSON = {
  endpointMetadata: {
    "login.microsoftonline.com": {
      token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
      jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
      issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
      authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
      end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout"
    },
    "login.chinacloudapi.cn": {
      token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
      jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
      issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
      authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
      end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout"
    },
    "login.microsoftonline.us": {
      token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
      jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
      issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
      authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
      end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout"
    }
  },
  instanceDiscoveryMetadata: {
    tenant_discovery_endpoint: "https://{canonicalAuthority}/v2.0/.well-known/openid-configuration",
    metadata: [
      {
        preferred_network: "login.microsoftonline.com",
        preferred_cache: "login.windows.net",
        aliases: [
          "login.microsoftonline.com",
          "login.windows.net",
          "login.microsoft.com",
          "sts.windows.net"
        ]
      },
      {
        preferred_network: "login.partner.microsoftonline.cn",
        preferred_cache: "login.partner.microsoftonline.cn",
        aliases: [
          "login.partner.microsoftonline.cn",
          "login.chinacloudapi.cn"
        ]
      },
      {
        preferred_network: "login.microsoftonline.de",
        preferred_cache: "login.microsoftonline.de",
        aliases: ["login.microsoftonline.de"]
      },
      {
        preferred_network: "login.microsoftonline.us",
        preferred_cache: "login.microsoftonline.us",
        aliases: [
          "login.microsoftonline.us",
          "login.usgovcloudapi.net"
        ]
      },
      {
        preferred_network: "login-us.microsoftonline.com",
        preferred_cache: "login-us.microsoftonline.com",
        aliases: ["login-us.microsoftonline.com"]
      }
    ]
  }
};
var EndpointMetadata = rawMetdataJSON.endpointMetadata;
var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
var InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
  metadataEntry.aliases.forEach((alias) => {
    InstanceDiscoveryMetadataAliases.add(alias);
  });
});
function getAliasesFromStaticSources(staticAuthorityOptions, logger) {
  var _a;
  let staticAliases;
  const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
  if (canonicalAuthority) {
    const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
    staticAliases = getAliasesFromMetadata(authorityHost, (_a = staticAuthorityOptions.cloudDiscoveryMetadata) == null ? void 0 : _a.metadata, AuthorityMetadataSource.CONFIG, logger) || getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger) || staticAuthorityOptions.knownAuthorities;
  }
  return staticAliases || [];
}
function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger) {
  logger == null ? void 0 : logger.trace(`getAliasesFromMetadata called with source: ${source}`);
  if (authorityHost && cloudDiscoveryMetadata) {
    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
    if (metadata) {
      logger == null ? void 0 : logger.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
      return metadata.aliases;
    } else {
      logger == null ? void 0 : logger.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
    }
  }
  return null;
}
function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
  const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
  return metadata;
}
function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
  for (let i = 0; i < response.length; i++) {
    const metadata = response[i];
    if (metadata.aliases.includes(authorityHost)) {
      return metadata;
    }
  }
  return null;
}

// node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs
var cacheQuotaExceededErrorCode = "cache_quota_exceeded";
var cacheUnknownErrorCode = "cache_error_unknown";

// node_modules/@azure/msal-common/dist/error/CacheError.mjs
var CacheErrorMessages = {
  [cacheQuotaExceededErrorCode]: "Exceeded cache storage capacity.",
  [cacheUnknownErrorCode]: "Unexpected error occurred when using cache storage."
};
var CacheError = class _CacheError extends Error {
  constructor(errorCode, errorMessage) {
    const message = errorMessage || (CacheErrorMessages[errorCode] ? CacheErrorMessages[errorCode] : CacheErrorMessages[cacheUnknownErrorCode]);
    super(`${errorCode}: ${message}`);
    Object.setPrototypeOf(this, _CacheError.prototype);
    this.name = "CacheError";
    this.errorCode = errorCode;
    this.errorMessage = message;
  }
};

// node_modules/@azure/msal-common/dist/cache/CacheManager.mjs
var CacheManager = class {
  constructor(clientId, cryptoImpl, logger, staticAuthorityOptions) {
    this.clientId = clientId;
    this.cryptoImpl = cryptoImpl;
    this.commonLogger = logger.clone(name, version);
    this.staticAuthorityOptions = staticAuthorityOptions;
  }
  /**
   * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
   * @param accountFilter - (Optional) filter to narrow down the accounts returned
   * @returns Array of AccountInfo objects in cache
   */
  getAllAccounts(accountFilter) {
    return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter || {}), accountFilter);
  }
  /**
   * Gets first tenanted AccountInfo object found based on provided filters
   */
  getAccountInfoFilteredBy(accountFilter) {
    const allAccounts = this.getAllAccounts(accountFilter);
    if (allAccounts.length > 1) {
      const sortedAccounts = allAccounts.sort((account) => {
        return account.idTokenClaims ? -1 : 1;
      });
      return sortedAccounts[0];
    } else if (allAccounts.length === 1) {
      return allAccounts[0];
    } else {
      return null;
    }
  }
  /**
   * Returns a single matching
   * @param accountFilter
   * @returns
   */
  getBaseAccountInfo(accountFilter) {
    const accountEntities = this.getAccountsFilteredBy(accountFilter);
    if (accountEntities.length > 0) {
      return accountEntities[0].getAccountInfo();
    } else {
      return null;
    }
  }
  /**
   * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
   * and builds the account info objects from the matching ID token's claims
   * @param cachedAccounts
   * @param accountFilter
   * @returns Array of AccountInfo objects that match account and tenant profile filters
   */
  buildTenantProfiles(cachedAccounts, accountFilter) {
    return cachedAccounts.flatMap((accountEntity) => {
      return this.getTenantProfilesFromAccountEntity(accountEntity, accountFilter == null ? void 0 : accountFilter.tenantId, accountFilter);
    });
  }
  getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter) {
    let tenantedAccountInfo = null;
    let idTokenClaims;
    if (tenantProfileFilter) {
      if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
        return null;
      }
    }
    const idToken = this.getIdToken(accountInfo, tokenKeys, tenantProfile.tenantId);
    if (idToken) {
      idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
      if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
        return null;
      }
    }
    tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken == null ? void 0 : idToken.secret);
    return tenantedAccountInfo;
  }
  getTenantProfilesFromAccountEntity(accountEntity, targetTenantId, tenantProfileFilter) {
    const accountInfo = accountEntity.getAccountInfo();
    let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
    const tokenKeys = this.getTokenKeys();
    if (targetTenantId) {
      const tenantProfile = searchTenantProfiles.get(targetTenantId);
      if (tenantProfile) {
        searchTenantProfiles = /* @__PURE__ */ new Map([
          [targetTenantId, tenantProfile]
        ]);
      } else {
        return [];
      }
    }
    const matchingTenantProfiles = [];
    searchTenantProfiles.forEach((tenantProfile) => {
      const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter);
      if (tenantedAccountInfo) {
        matchingTenantProfiles.push(tenantedAccountInfo);
      }
    });
    return matchingTenantProfiles;
  }
  tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
    if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
      return false;
    }
    if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
      return false;
    }
    if (tenantProfileFilter.isHomeTenant !== void 0 && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
      return false;
    }
    return true;
  }
  idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
    if (tenantProfileFilter) {
      if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
        return false;
      }
      if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
        return false;
      }
      if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
        return false;
      }
      if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
        return false;
      }
      if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
        return false;
      }
    }
    return true;
  }
  /**
   * saves a cache record
   * @param cacheRecord {CacheRecord}
   * @param storeInCache {?StoreInCache}
   * @param correlationId {?string} correlation id
   */
  async saveCacheRecord(cacheRecord, correlationId, storeInCache) {
    var _a, _b, _c, _d;
    if (!cacheRecord) {
      throw createClientAuthError(invalidCacheRecord);
    }
    try {
      if (!!cacheRecord.account) {
        await this.setAccount(cacheRecord.account, correlationId);
      }
      if (!!cacheRecord.idToken && (storeInCache == null ? void 0 : storeInCache.idToken) !== false) {
        await this.setIdTokenCredential(cacheRecord.idToken, correlationId);
      }
      if (!!cacheRecord.accessToken && (storeInCache == null ? void 0 : storeInCache.accessToken) !== false) {
        await this.saveAccessToken(cacheRecord.accessToken, correlationId);
      }
      if (!!cacheRecord.refreshToken && (storeInCache == null ? void 0 : storeInCache.refreshToken) !== false) {
        await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId);
      }
      if (!!cacheRecord.appMetadata) {
        this.setAppMetadata(cacheRecord.appMetadata);
      }
    } catch (e) {
      (_a = this.commonLogger) == null ? void 0 : _a.error(`CacheManager.saveCacheRecord: failed`);
      if (e instanceof Error) {
        (_b = this.commonLogger) == null ? void 0 : _b.errorPii(`CacheManager.saveCacheRecord: ${e.message}`, correlationId);
        if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED" || e.message.includes("exceeded the quota")) {
          (_c = this.commonLogger) == null ? void 0 : _c.error(`CacheManager.saveCacheRecord: exceeded storage quota`, correlationId);
          throw new CacheError(cacheQuotaExceededErrorCode);
        } else {
          throw new CacheError(e.name, e.message);
        }
      } else {
        (_d = this.commonLogger) == null ? void 0 : _d.errorPii(`CacheManager.saveCacheRecord: ${e}`, correlationId);
        throw new CacheError(cacheUnknownErrorCode);
      }
    }
  }
  /**
   * saves access token credential
   * @param credential
   */
  async saveAccessToken(credential, correlationId) {
    const accessTokenFilter = {
      clientId: credential.clientId,
      credentialType: credential.credentialType,
      environment: credential.environment,
      homeAccountId: credential.homeAccountId,
      realm: credential.realm,
      tokenType: credential.tokenType,
      requestedClaimsHash: credential.requestedClaimsHash
    };
    const tokenKeys = this.getTokenKeys();
    const currentScopes = ScopeSet.fromString(credential.target);
    const removedAccessTokens = [];
    tokenKeys.accessToken.forEach((key) => {
      if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
        return;
      }
      const tokenEntity = this.getAccessTokenCredential(key);
      if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
        const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
        if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
          removedAccessTokens.push(this.removeAccessToken(key));
        }
      }
    });
    await Promise.all(removedAccessTokens);
    await this.setAccessTokenCredential(credential, correlationId);
  }
  /**
   * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
   * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
   * @param accountFilter - An object containing Account properties to filter by
   */
  getAccountsFilteredBy(accountFilter) {
    const allAccountKeys = this.getAccountKeys();
    const matchingAccounts = [];
    allAccountKeys.forEach((cacheKey) => {
      var _a;
      if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {
        return;
      }
      const entity = this.getAccount(cacheKey, this.commonLogger);
      if (!entity) {
        return;
      }
      if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
        return;
      }
      if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {
        return;
      }
      if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {
        return;
      }
      if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
        return;
      }
      if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
        return;
      }
      if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {
        return;
      }
      const tenantProfileFilter = {
        localAccountId: accountFilter == null ? void 0 : accountFilter.localAccountId,
        name: accountFilter == null ? void 0 : accountFilter.name
      };
      const matchingTenantProfiles = (_a = entity.tenantProfiles) == null ? void 0 : _a.filter((tenantProfile) => {
        return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
      });
      if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
        return;
      }
      matchingAccounts.push(entity);
    });
    return matchingAccounts;
  }
  /**
   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided
   * @param key
   * @param homeAccountId
   * @param tenantId
   * @returns
   */
  isAccountKey(key, homeAccountId, tenantId) {
    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {
      return false;
    }
    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {
      return false;
    }
    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {
      return false;
    }
    return true;
  }
  /**
   * Returns true if the given key matches our credential key schema.
   * @param key
   */
  isCredentialKey(key) {
    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {
      return false;
    }
    const lowerCaseKey = key.toLowerCase();
    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {
      return false;
    }
    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {
      const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;
      const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;
      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {
        return false;
      }
    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {
      return false;
    }
    return true;
  }
  /**
   * Returns whether or not the given credential entity matches the filter
   * @param entity
   * @param filter
   * @returns
   */
  credentialMatchesFilter(entity, filter) {
    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
      return false;
    }
    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
      return false;
    }
    if (typeof filter.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {
      return false;
    }
    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
      return false;
    }
    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
      return false;
    }
    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {
      return false;
    }
    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
      return false;
    }
    if (!!filter.target && !this.matchTarget(entity, filter.target)) {
      return false;
    }
    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
        return false;
      }
    }
    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {
        return false;
      }
      if (filter.tokenType === AuthenticationScheme.SSH) {
        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
   * @param filter
   */
  getAppMetadataFilteredBy(filter) {
    const allCacheKeys = this.getKeys();
    const matchingAppMetadata = {};
    allCacheKeys.forEach((cacheKey) => {
      if (!this.isAppMetadata(cacheKey)) {
        return;
      }
      const entity = this.getAppMetadata(cacheKey);
      if (!entity) {
        return;
      }
      if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
        return;
      }
      if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
        return;
      }
      matchingAppMetadata[cacheKey] = entity;
    });
    return matchingAppMetadata;
  }
  /**
   * retrieve authorityMetadata that contains a matching alias
   * @param filter
   */
  getAuthorityMetadataByAlias(host) {
    const allCacheKeys = this.getAuthorityMetadataKeys();
    let matchedEntity = null;
    allCacheKeys.forEach((cacheKey) => {
      if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
        return;
      }
      const entity = this.getAuthorityMetadata(cacheKey);
      if (!entity) {
        return;
      }
      if (entity.aliases.indexOf(host) === -1) {
        return;
      }
      matchedEntity = entity;
    });
    return matchedEntity;
  }
  /**
   * Removes all accounts and related tokens from cache.
   */
  async removeAllAccounts() {
    const allAccountKeys = this.getAccountKeys();
    const removedAccounts = [];
    allAccountKeys.forEach((cacheKey) => {
      removedAccounts.push(this.removeAccount(cacheKey));
    });
    await Promise.all(removedAccounts);
  }
  /**
   * Removes the account and related tokens for a given account key
   * @param account
   */
  async removeAccount(accountKey) {
    const account = this.getAccount(accountKey, this.commonLogger);
    if (!account) {
      return;
    }
    await this.removeAccountContext(account);
    this.removeItem(accountKey);
  }
  /**
   * Removes credentials associated with the provided account
   * @param account
   */
  async removeAccountContext(account) {
    const allTokenKeys = this.getTokenKeys();
    const accountId = account.generateAccountId();
    const removedCredentials = [];
    allTokenKeys.idToken.forEach((key) => {
      if (key.indexOf(accountId) === 0) {
        this.removeIdToken(key);
      }
    });
    allTokenKeys.accessToken.forEach((key) => {
      if (key.indexOf(accountId) === 0) {
        removedCredentials.push(this.removeAccessToken(key));
      }
    });
    allTokenKeys.refreshToken.forEach((key) => {
      if (key.indexOf(accountId) === 0) {
        this.removeRefreshToken(key);
      }
    });
    await Promise.all(removedCredentials);
  }
  /**
   * returns a boolean if the given credential is removed
   * @param credential
   */
  async removeAccessToken(key) {
    const credential = this.getAccessTokenCredential(key);
    if (!credential) {
      return;
    }
    if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {
      if (credential.tokenType === AuthenticationScheme.POP) {
        const accessTokenWithAuthSchemeEntity = credential;
        const kid = accessTokenWithAuthSchemeEntity.keyId;
        if (kid) {
          try {
            await this.cryptoImpl.removeTokenBindingKey(kid);
          } catch (error) {
            throw createClientAuthError(bindingKeyNotRemoved);
          }
        }
      }
    }
    return this.removeItem(key);
  }
  /**
   * Removes all app metadata objects from cache.
   */
  removeAppMetadata() {
    const allCacheKeys = this.getKeys();
    allCacheKeys.forEach((cacheKey) => {
      if (this.isAppMetadata(cacheKey)) {
        this.removeItem(cacheKey);
      }
    });
    return true;
  }
  /**
   * Retrieve AccountEntity from cache
   * @param account
   */
  readAccountFromCache(account) {
    const accountKey = AccountEntity.generateAccountCacheKey(account);
    return this.getAccount(accountKey, this.commonLogger);
  }
  /**
   * Retrieve IdTokenEntity from cache
   * @param account {AccountInfo}
   * @param tokenKeys {?TokenKeys}
   * @param targetRealm {?string}
   * @param performanceClient {?IPerformanceClient}
   * @param correlationId {?string}
   */
  getIdToken(account, tokenKeys, targetRealm, performanceClient, correlationId) {
    this.commonLogger.trace("CacheManager - getIdToken called");
    const idTokenFilter = {
      homeAccountId: account.homeAccountId,
      environment: account.environment,
      credentialType: CredentialType.ID_TOKEN,
      clientId: this.clientId,
      realm: targetRealm
    };
    const idTokenMap = this.getIdTokensByFilter(idTokenFilter, tokenKeys);
    const numIdTokens = idTokenMap.size;
    if (numIdTokens < 1) {
      this.commonLogger.info("CacheManager:getIdToken - No token found");
      return null;
    } else if (numIdTokens > 1) {
      let tokensToBeRemoved = idTokenMap;
      if (!targetRealm) {
        const homeIdTokenMap = /* @__PURE__ */ new Map();
        idTokenMap.forEach((idToken, key) => {
          if (idToken.realm === account.tenantId) {
            homeIdTokenMap.set(key, idToken);
          }
        });
        const numHomeIdTokens = homeIdTokenMap.size;
        if (numHomeIdTokens < 1) {
          this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
          return idTokenMap.values().next().value;
        } else if (numHomeIdTokens === 1) {
          this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
          return homeIdTokenMap.values().next().value;
        } else {
          tokensToBeRemoved = homeIdTokenMap;
        }
      }
      this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
      tokensToBeRemoved.forEach((idToken, key) => {
        this.removeIdToken(key);
      });
      if (performanceClient && correlationId) {
        performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
      }
      return null;
    }
    this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
    return idTokenMap.values().next().value;
  }
  /**
   * Gets all idTokens matching the given filter
   * @param filter
   * @returns
   */
  getIdTokensByFilter(filter, tokenKeys) {
    const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
    const idTokens = /* @__PURE__ */ new Map();
    idTokenKeys.forEach((key) => {
      if (!this.idTokenKeyMatchesFilter(key, {
        clientId: this.clientId,
        ...filter
      })) {
        return;
      }
      const idToken = this.getIdTokenCredential(key);
      if (idToken && this.credentialMatchesFilter(idToken, filter)) {
        idTokens.set(key, idToken);
      }
    });
    return idTokens;
  }
  /**
   * Validate the cache key against filter before retrieving and parsing cache value
   * @param key
   * @param filter
   * @returns
   */
  idTokenKeyMatchesFilter(inputKey, filter) {
    const key = inputKey.toLowerCase();
    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
      return false;
    }
    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
      return false;
    }
    return true;
  }
  /**
   * Removes idToken from the cache
   * @param key
   */
  removeIdToken(key) {
    this.removeItem(key);
  }
  /**
   * Removes refresh token from the cache
   * @param key
   */
  removeRefreshToken(key) {
    this.removeItem(key);
  }
  /**
   * Retrieve AccessTokenEntity from cache
   * @param account {AccountInfo}
   * @param request {BaseAuthRequest}
   * @param tokenKeys {?TokenKeys}
   * @param performanceClient {?IPerformanceClient}
   * @param correlationId {?string}
   */
  getAccessToken(account, request, tokenKeys, targetRealm, performanceClient, correlationId) {
    this.commonLogger.trace("CacheManager - getAccessToken called");
    const scopes = ScopeSet.createSearchScopes(request.scopes);
    const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
    const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
    const accessTokenFilter = {
      homeAccountId: account.homeAccountId,
      environment: account.environment,
      credentialType,
      clientId: this.clientId,
      realm: targetRealm || account.tenantId,
      target: scopes,
      tokenType: authScheme,
      keyId: request.sshKid,
      requestedClaimsHash: request.requestedClaimsHash
    };
    const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
    const accessTokens = [];
    accessTokenKeys.forEach((key) => {
      if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
        const accessToken = this.getAccessTokenCredential(key);
        if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
          accessTokens.push(accessToken);
        }
      }
    });
    const numAccessTokens = accessTokens.length;
    if (numAccessTokens < 1) {
      this.commonLogger.info("CacheManager:getAccessToken - No token found");
      return null;
    } else if (numAccessTokens > 1) {
      this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them");
      accessTokens.forEach((accessToken) => {
        void this.removeAccessToken(generateCredentialKey(accessToken));
      });
      if (performanceClient && correlationId) {
        performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
      }
      return null;
    }
    this.commonLogger.info("CacheManager:getAccessToken - Returning access token");
    return accessTokens[0];
  }
  /**
   * Validate the cache key against filter before retrieving and parsing cache value
   * @param key
   * @param filter
   * @param keyMustContainAllScopes
   * @returns
   */
  accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {
    const key = inputKey.toLowerCase();
    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
      return false;
    }
    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
      return false;
    }
    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
      return false;
    }
    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
      return false;
    }
    if (filter.target) {
      const scopes = filter.target.asArray();
      for (let i = 0; i < scopes.length; i++) {
        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {
          return false;
        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {
          return true;
        }
      }
    }
    return true;
  }
  /**
   * Gets all access tokens matching the filter
   * @param filter
   * @returns
   */
  getAccessTokensByFilter(filter) {
    const tokenKeys = this.getTokenKeys();
    const accessTokens = [];
    tokenKeys.accessToken.forEach((key) => {
      if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {
        return;
      }
      const accessToken = this.getAccessTokenCredential(key);
      if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {
        accessTokens.push(accessToken);
      }
    });
    return accessTokens;
  }
  /**
   * Helper to retrieve the appropriate refresh token from cache
   * @param account {AccountInfo}
   * @param familyRT {boolean}
   * @param tokenKeys {?TokenKeys}
   * @param performanceClient {?IPerformanceClient}
   * @param correlationId {?string}
   */
  getRefreshToken(account, familyRT, tokenKeys, performanceClient, correlationId) {
    this.commonLogger.trace("CacheManager - getRefreshToken called");
    const id = familyRT ? THE_FAMILY_ID : void 0;
    const refreshTokenFilter = {
      homeAccountId: account.homeAccountId,
      environment: account.environment,
      credentialType: CredentialType.REFRESH_TOKEN,
      clientId: this.clientId,
      familyId: id
    };
    const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
    const refreshTokens = [];
    refreshTokenKeys.forEach((key) => {
      if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
        const refreshToken = this.getRefreshTokenCredential(key);
        if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
          refreshTokens.push(refreshToken);
        }
      }
    });
    const numRefreshTokens = refreshTokens.length;
    if (numRefreshTokens < 1) {
      this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
      return null;
    }
    if (numRefreshTokens > 1 && performanceClient && correlationId) {
      performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
    }
    this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
    return refreshTokens[0];
  }
  /**
   * Validate the cache key against filter before retrieving and parsing cache value
   * @param key
   * @param filter
   */
  refreshTokenKeyMatchesFilter(inputKey, filter) {
    const key = inputKey.toLowerCase();
    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {
      return false;
    }
    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
      return false;
    }
    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
      return false;
    }
    return true;
  }
  /**
   * Retrieve AppMetadataEntity from cache
   */
  readAppMetadataFromCache(environment) {
    const appMetadataFilter = {
      environment,
      clientId: this.clientId
    };
    const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
    const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
    const numAppMetadata = appMetadataEntries.length;
    if (numAppMetadata < 1) {
      return null;
    } else if (numAppMetadata > 1) {
      throw createClientAuthError(multipleMatchingAppMetadata);
    }
    return appMetadataEntries[0];
  }
  /**
   * Return the family_id value associated  with FOCI
   * @param environment
   * @param clientId
   */
  isAppMetadataFOCI(environment) {
    const appMetadata = this.readAppMetadataFromCache(environment);
    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
  }
  /**
   * helper to match account ids
   * @param value
   * @param homeAccountId
   */
  matchHomeAccountId(entity, homeAccountId) {
    return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
  }
  /**
   * helper to match account ids
   * @param entity
   * @param localAccountId
   * @returns
   */
  matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
    const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
    return localAccountId === idTokenLocalAccountId;
  }
  matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
    return tenantProfile.localAccountId === localAccountId;
  }
  /**
   * helper to match names
   * @param entity
   * @param name
   * @returns true if the downcased name properties are present and match in the filter and the entity
   */
  matchName(claims, name3) {
    var _a;
    return !!(name3.toLowerCase() === ((_a = claims.name) == null ? void 0 : _a.toLowerCase()));
  }
  /**
   * helper to match usernames
   * @param entity
   * @param username
   * @returns
   */
  matchUsername(cachedUsername, filterUsername) {
    return !!(cachedUsername && typeof cachedUsername === "string" && (filterUsername == null ? void 0 : filterUsername.toLowerCase()) === cachedUsername.toLowerCase());
  }
  /**
   * helper to match assertion
   * @param value
   * @param oboAssertion
   */
  matchUserAssertionHash(entity, userAssertionHash) {
    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
  }
  /**
   * helper to match environment
   * @param value
   * @param environment
   */
  matchEnvironment(entity, environment) {
    if (this.staticAuthorityOptions) {
      const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
      if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
        return true;
      }
    }
    const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
      return true;
    }
    return false;
  }
  /**
   * helper to match credential type
   * @param entity
   * @param credentialType
   */
  matchCredentialType(entity, credentialType) {
    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
  }
  /**
   * helper to match client ids
   * @param entity
   * @param clientId
   */
  matchClientId(entity, clientId) {
    return !!(entity.clientId && clientId === entity.clientId);
  }
  /**
   * helper to match family ids
   * @param entity
   * @param familyId
   */
  matchFamilyId(entity, familyId) {
    return !!(entity.familyId && familyId === entity.familyId);
  }
  /**
   * helper to match realm
   * @param entity
   * @param realm
   */
  matchRealm(entity, realm) {
    var _a;
    return !!(((_a = entity.realm) == null ? void 0 : _a.toLowerCase()) === realm.toLowerCase());
  }
  /**
   * helper to match nativeAccountId
   * @param entity
   * @param nativeAccountId
   * @returns boolean indicating the match result
   */
  matchNativeAccountId(entity, nativeAccountId) {
    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
  }
  /**
   * helper to match loginHint which can be either:
   * 1. login_hint ID token claim
   * 2. username in cached account object
   * 3. upn in ID token claims
   * @param entity
   * @param loginHint
   * @returns
   */
  matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
    if (tokenClaims.login_hint === loginHint) {
      return true;
    }
    if (tokenClaims.preferred_username === loginHint) {
      return true;
    }
    if (tokenClaims.upn === loginHint) {
      return true;
    }
    return false;
  }
  /**
   * Helper to match sid
   * @param entity
   * @param sid
   * @returns true if the sid claim is present and matches the filter
   */
  matchSid(idTokenClaims, sid) {
    return idTokenClaims.sid === sid;
  }
  matchAuthorityType(entity, authorityType) {
    return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());
  }
  /**
   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
   * @param entity
   * @param target
   */
  matchTarget(entity, target) {
    const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
    if (isNotAccessTokenCredential || !entity.target) {
      return false;
    }
    const entityScopeSet = ScopeSet.fromString(entity.target);
    return entityScopeSet.containsScopeSet(target);
  }
  /**
   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
   * @param entity
   * @param tokenType
   */
  matchTokenType(entity, tokenType) {
    return !!(entity.tokenType && entity.tokenType === tokenType);
  }
  /**
   * Returns true if the credential's keyId matches the one in the request, false otherwise
   * @param entity
   * @param keyId
   */
  matchKeyId(entity, keyId) {
    return !!(entity.keyId && entity.keyId === keyId);
  }
  /**
   * returns if a given cache entity is of the type appmetadata
   * @param key
   */
  isAppMetadata(key) {
    return key.indexOf(APP_METADATA) !== -1;
  }
  /**
   * returns if a given cache entity is of the type authoritymetadata
   * @param key
   */
  isAuthorityMetadata(key) {
    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
  }
  /**
   * returns cache key used for cloud instance metadata
   */
  generateAuthorityMetadataCacheKey(authority) {
    return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
  }
  /**
   * Helper to convert serialized data to object
   * @param obj
   * @param json
   */
  static toObject(obj, json) {
    for (const propertyName in json) {
      obj[propertyName] = json[propertyName];
    }
    return obj;
  }
};
var DefaultStorageClass = class extends CacheManager {
  async setAccount() {
    throw createClientAuthError(methodNotImplemented);
  }
  getAccount() {
    throw createClientAuthError(methodNotImplemented);
  }
  async setIdTokenCredential() {
    throw createClientAuthError(methodNotImplemented);
  }
  getIdTokenCredential() {
    throw createClientAuthError(methodNotImplemented);
  }
  async setAccessTokenCredential() {
    throw createClientAuthError(methodNotImplemented);
  }
  getAccessTokenCredential() {
    throw createClientAuthError(methodNotImplemented);
  }
  async setRefreshTokenCredential() {
    throw createClientAuthError(methodNotImplemented);
  }
  getRefreshTokenCredential() {
    throw createClientAuthError(methodNotImplemented);
  }
  setAppMetadata() {
    throw createClientAuthError(methodNotImplemented);
  }
  getAppMetadata() {
    throw createClientAuthError(methodNotImplemented);
  }
  setServerTelemetry() {
    throw createClientAuthError(methodNotImplemented);
  }
  getServerTelemetry() {
    throw createClientAuthError(methodNotImplemented);
  }
  setAuthorityMetadata() {
    throw createClientAuthError(methodNotImplemented);
  }
  getAuthorityMetadata() {
    throw createClientAuthError(methodNotImplemented);
  }
  getAuthorityMetadataKeys() {
    throw createClientAuthError(methodNotImplemented);
  }
  setThrottlingCache() {
    throw createClientAuthError(methodNotImplemented);
  }
  getThrottlingCache() {
    throw createClientAuthError(methodNotImplemented);
  }
  removeItem() {
    throw createClientAuthError(methodNotImplemented);
  }
  getKeys() {
    throw createClientAuthError(methodNotImplemented);
  }
  getAccountKeys() {
    throw createClientAuthError(methodNotImplemented);
  }
  getTokenKeys() {
    throw createClientAuthError(methodNotImplemented);
  }
};

// node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs
var DEFAULT_SYSTEM_OPTIONS = {
  tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
  preventCorsPreflight: false
};
var DEFAULT_LOGGER_IMPLEMENTATION = {
  loggerCallback: () => {
  },
  piiLoggingEnabled: false,
  logLevel: LogLevel.Info,
  correlationId: Constants.EMPTY_STRING
};
var DEFAULT_CACHE_OPTIONS = {
  claimsBasedCachingEnabled: false
};
var DEFAULT_NETWORK_IMPLEMENTATION = {
  async sendGetRequestAsync() {
    throw createClientAuthError(methodNotImplemented);
  },
  async sendPostRequestAsync() {
    throw createClientAuthError(methodNotImplemented);
  }
};
var DEFAULT_LIBRARY_INFO = {
  sku: Constants.SKU,
  version,
  cpu: Constants.EMPTY_STRING,
  os: Constants.EMPTY_STRING
};
var DEFAULT_CLIENT_CREDENTIALS = {
  clientSecret: Constants.EMPTY_STRING,
  clientAssertion: void 0
};
var DEFAULT_AZURE_CLOUD_OPTIONS = {
  azureCloudInstance: AzureCloudInstance.None,
  tenant: `${Constants.DEFAULT_COMMON_TENANT}`
};
var DEFAULT_TELEMETRY_OPTIONS = {
  application: {
    appName: "",
    appVersion: ""
  }
};
function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials, libraryInfo, telemetry, serverTelemetryManager, persistencePlugin, serializableCache }) {
  const loggerOptions = {
    ...DEFAULT_LOGGER_IMPLEMENTATION,
    ...userLoggerOption
  };
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
    loggerOptions,
    cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
    storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions)),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null
  };
}
function buildAuthOptions(authOptions) {
  return {
    clientCapabilities: [],
    azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
    skipAuthorityMetadataCache: false,
    instanceAware: false,
    ...authOptions
  };
}
function isOidcProtocolMode(config2) {
  return config2.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
}

// node_modules/@azure/msal-common/dist/account/CcsCredential.mjs
var CcsCredentialType = {
  HOME_ACCOUNT_ID: "home_account_id",
  UPN: "UPN"
};

// node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
var RequestParameterBuilder_exports = {};
__export(RequestParameterBuilder_exports, {
  addApplicationTelemetry: () => addApplicationTelemetry,
  addAuthorizationCode: () => addAuthorizationCode,
  addBrokerParameters: () => addBrokerParameters,
  addCcsOid: () => addCcsOid,
  addCcsUpn: () => addCcsUpn,
  addClaims: () => addClaims,
  addClientAssertion: () => addClientAssertion,
  addClientAssertionType: () => addClientAssertionType,
  addClientCapabilitiesToClaims: () => addClientCapabilitiesToClaims,
  addClientId: () => addClientId,
  addClientInfo: () => addClientInfo,
  addClientSecret: () => addClientSecret,
  addCodeChallengeParams: () => addCodeChallengeParams,
  addCodeVerifier: () => addCodeVerifier,
  addCorrelationId: () => addCorrelationId,
  addDeviceCode: () => addDeviceCode,
  addDomainHint: () => addDomainHint,
  addEARParameters: () => addEARParameters,
  addExtraQueryParameters: () => addExtraQueryParameters,
  addGrantType: () => addGrantType,
  addIdTokenHint: () => addIdTokenHint,
  addInstanceAware: () => addInstanceAware,
  addLibraryInfo: () => addLibraryInfo,
  addLoginHint: () => addLoginHint,
  addLogoutHint: () => addLogoutHint,
  addNativeBroker: () => addNativeBroker,
  addNonce: () => addNonce,
  addOboAssertion: () => addOboAssertion,
  addPassword: () => addPassword,
  addPopToken: () => addPopToken,
  addPostLogoutRedirectUri: () => addPostLogoutRedirectUri,
  addPrompt: () => addPrompt,
  addRedirectUri: () => addRedirectUri,
  addRefreshToken: () => addRefreshToken,
  addRequestTokenUse: () => addRequestTokenUse,
  addResponseMode: () => addResponseMode,
  addResponseType: () => addResponseType,
  addScopes: () => addScopes,
  addServerTelemetry: () => addServerTelemetry,
  addSid: () => addSid,
  addSshJwk: () => addSshJwk,
  addState: () => addState,
  addThrottling: () => addThrottling,
  addUsername: () => addUsername,
  instrumentBrokerParams: () => instrumentBrokerParams
});

// node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs
var AADServerParamKeys_exports = {};
__export(AADServerParamKeys_exports, {
  ACCESS_TOKEN: () => ACCESS_TOKEN,
  BROKER_CLIENT_ID: () => BROKER_CLIENT_ID,
  BROKER_REDIRECT_URI: () => BROKER_REDIRECT_URI,
  CCS_HEADER: () => CCS_HEADER,
  CLAIMS: () => CLAIMS,
  CLIENT_ASSERTION: () => CLIENT_ASSERTION,
  CLIENT_ASSERTION_TYPE: () => CLIENT_ASSERTION_TYPE,
  CLIENT_ID: () => CLIENT_ID,
  CLIENT_INFO: () => CLIENT_INFO2,
  CLIENT_REQUEST_ID: () => CLIENT_REQUEST_ID,
  CLIENT_SECRET: () => CLIENT_SECRET,
  CODE: () => CODE,
  CODE_CHALLENGE: () => CODE_CHALLENGE,
  CODE_CHALLENGE_METHOD: () => CODE_CHALLENGE_METHOD,
  CODE_VERIFIER: () => CODE_VERIFIER,
  DEVICE_CODE: () => DEVICE_CODE,
  DOMAIN_HINT: () => DOMAIN_HINT,
  EAR_JWE_CRYPTO: () => EAR_JWE_CRYPTO,
  EAR_JWK: () => EAR_JWK,
  ERROR: () => ERROR,
  ERROR_DESCRIPTION: () => ERROR_DESCRIPTION,
  EXPIRES_IN: () => EXPIRES_IN,
  FOCI: () => FOCI,
  GRANT_TYPE: () => GRANT_TYPE,
  ID_TOKEN: () => ID_TOKEN,
  ID_TOKEN_HINT: () => ID_TOKEN_HINT,
  INSTANCE_AWARE: () => INSTANCE_AWARE,
  LOGIN_HINT: () => LOGIN_HINT,
  LOGOUT_HINT: () => LOGOUT_HINT,
  NATIVE_BROKER: () => NATIVE_BROKER,
  NONCE: () => NONCE,
  OBO_ASSERTION: () => OBO_ASSERTION,
  ON_BEHALF_OF: () => ON_BEHALF_OF,
  POST_LOGOUT_URI: () => POST_LOGOUT_URI,
  PROMPT: () => PROMPT,
  REDIRECT_URI: () => REDIRECT_URI,
  REFRESH_TOKEN: () => REFRESH_TOKEN,
  REFRESH_TOKEN_EXPIRES_IN: () => REFRESH_TOKEN_EXPIRES_IN,
  REQUESTED_TOKEN_USE: () => REQUESTED_TOKEN_USE,
  REQ_CNF: () => REQ_CNF,
  RESPONSE_MODE: () => RESPONSE_MODE,
  RESPONSE_TYPE: () => RESPONSE_TYPE,
  RETURN_SPA_CODE: () => RETURN_SPA_CODE,
  SCOPE: () => SCOPE,
  SESSION_STATE: () => SESSION_STATE,
  SID: () => SID,
  STATE: () => STATE,
  TOKEN_TYPE: () => TOKEN_TYPE,
  X_APP_NAME: () => X_APP_NAME,
  X_APP_VER: () => X_APP_VER,
  X_CLIENT_CPU: () => X_CLIENT_CPU,
  X_CLIENT_CURR_TELEM: () => X_CLIENT_CURR_TELEM,
  X_CLIENT_EXTRA_SKU: () => X_CLIENT_EXTRA_SKU,
  X_CLIENT_LAST_TELEM: () => X_CLIENT_LAST_TELEM,
  X_CLIENT_OS: () => X_CLIENT_OS,
  X_CLIENT_SKU: () => X_CLIENT_SKU,
  X_CLIENT_VER: () => X_CLIENT_VER,
  X_MS_LIB_CAPABILITY: () => X_MS_LIB_CAPABILITY
});
var CLIENT_ID = "client_id";
var REDIRECT_URI = "redirect_uri";
var RESPONSE_TYPE = "response_type";
var RESPONSE_MODE = "response_mode";
var GRANT_TYPE = "grant_type";
var CLAIMS = "claims";
var SCOPE = "scope";
var ERROR = "error";
var ERROR_DESCRIPTION = "error_description";
var ACCESS_TOKEN = "access_token";
var ID_TOKEN = "id_token";
var REFRESH_TOKEN = "refresh_token";
var EXPIRES_IN = "expires_in";
var REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";
var STATE = "state";
var NONCE = "nonce";
var PROMPT = "prompt";
var SESSION_STATE = "session_state";
var CLIENT_INFO2 = "client_info";
var CODE = "code";
var CODE_CHALLENGE = "code_challenge";
var CODE_CHALLENGE_METHOD = "code_challenge_method";
var CODE_VERIFIER = "code_verifier";
var CLIENT_REQUEST_ID = "client-request-id";
var X_CLIENT_SKU = "x-client-SKU";
var X_CLIENT_VER = "x-client-VER";
var X_CLIENT_OS = "x-client-OS";
var X_CLIENT_CPU = "x-client-CPU";
var X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
var X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
var X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
var X_APP_NAME = "x-app-name";
var X_APP_VER = "x-app-ver";
var POST_LOGOUT_URI = "post_logout_redirect_uri";
var ID_TOKEN_HINT = "id_token_hint";
var DEVICE_CODE = "device_code";
var CLIENT_SECRET = "client_secret";
var CLIENT_ASSERTION = "client_assertion";
var CLIENT_ASSERTION_TYPE = "client_assertion_type";
var TOKEN_TYPE = "token_type";
var REQ_CNF = "req_cnf";
var OBO_ASSERTION = "assertion";
var REQUESTED_TOKEN_USE = "requested_token_use";
var ON_BEHALF_OF = "on_behalf_of";
var FOCI = "foci";
var CCS_HEADER = "X-AnchorMailbox";
var RETURN_SPA_CODE = "return_spa_code";
var NATIVE_BROKER = "nativebroker";
var LOGOUT_HINT = "logout_hint";
var SID = "sid";
var LOGIN_HINT = "login_hint";
var DOMAIN_HINT = "domain_hint";
var X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
var BROKER_CLIENT_ID = "brk_client_id";
var BROKER_REDIRECT_URI = "brk_redirect_uri";
var INSTANCE_AWARE = "instance_aware";
var EAR_JWK = "ear_jwk";
var EAR_JWE_CRYPTO = "ear_jwe_crypto";

// node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
function instrumentBrokerParams(parameters, correlationId, performanceClient) {
  if (!correlationId) {
    return;
  }
  const clientId = parameters.get(CLIENT_ID);
  if (clientId && parameters.has(BROKER_CLIENT_ID)) {
    performanceClient == null ? void 0 : performanceClient.addFields({
      embeddedClientId: clientId,
      embeddedRedirectUri: parameters.get(REDIRECT_URI)
    }, correlationId);
  }
}
function addResponseType(parameters, responseType) {
  parameters.set(RESPONSE_TYPE, responseType);
}
function addResponseMode(parameters, responseMode) {
  parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
}
function addNativeBroker(parameters) {
  parameters.set(NATIVE_BROKER, "1");
}
function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
  if (addOidcScopes && !defaultScopes.includes("openid") && !scopes.includes("openid")) {
    defaultScopes.push("openid");
  }
  const requestScopes = addOidcScopes ? [...scopes || [], ...defaultScopes] : scopes || [];
  const scopeSet = new ScopeSet(requestScopes);
  parameters.set(SCOPE, scopeSet.printScopes());
}
function addClientId(parameters, clientId) {
  parameters.set(CLIENT_ID, clientId);
}
function addRedirectUri(parameters, redirectUri) {
  parameters.set(REDIRECT_URI, redirectUri);
}
function addPostLogoutRedirectUri(parameters, redirectUri) {
  parameters.set(POST_LOGOUT_URI, redirectUri);
}
function addIdTokenHint(parameters, idTokenHint) {
  parameters.set(ID_TOKEN_HINT, idTokenHint);
}
function addDomainHint(parameters, domainHint) {
  parameters.set(DOMAIN_HINT, domainHint);
}
function addLoginHint(parameters, loginHint) {
  parameters.set(LOGIN_HINT, loginHint);
}
function addCcsUpn(parameters, loginHint) {
  parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
}
function addCcsOid(parameters, clientInfo) {
  parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
}
function addSid(parameters, sid) {
  parameters.set(SID, sid);
}
function addClaims(parameters, claims, clientCapabilities) {
  const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
  try {
    JSON.parse(mergedClaims);
  } catch (e) {
    throw createClientConfigurationError(invalidClaims);
  }
  parameters.set(CLAIMS, mergedClaims);
}
function addCorrelationId(parameters, correlationId) {
  parameters.set(CLIENT_REQUEST_ID, correlationId);
}
function addLibraryInfo(parameters, libraryInfo) {
  parameters.set(X_CLIENT_SKU, libraryInfo.sku);
  parameters.set(X_CLIENT_VER, libraryInfo.version);
  if (libraryInfo.os) {
    parameters.set(X_CLIENT_OS, libraryInfo.os);
  }
  if (libraryInfo.cpu) {
    parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
  }
}
function addApplicationTelemetry(parameters, appTelemetry) {
  if (appTelemetry == null ? void 0 : appTelemetry.appName) {
    parameters.set(X_APP_NAME, appTelemetry.appName);
  }
  if (appTelemetry == null ? void 0 : appTelemetry.appVersion) {
    parameters.set(X_APP_VER, appTelemetry.appVersion);
  }
}
function addPrompt(parameters, prompt) {
  parameters.set(PROMPT, prompt);
}
function addState(parameters, state) {
  if (state) {
    parameters.set(STATE, state);
  }
}
function addNonce(parameters, nonce) {
  parameters.set(NONCE, nonce);
}
function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
  if (codeChallenge && codeChallengeMethod) {
    parameters.set(CODE_CHALLENGE, codeChallenge);
    parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
  } else {
    throw createClientConfigurationError(pkceParamsMissing);
  }
}
function addAuthorizationCode(parameters, code) {
  parameters.set(CODE, code);
}
function addDeviceCode(parameters, code) {
  parameters.set(DEVICE_CODE, code);
}
function addRefreshToken(parameters, refreshToken) {
  parameters.set(REFRESH_TOKEN, refreshToken);
}
function addCodeVerifier(parameters, codeVerifier) {
  parameters.set(CODE_VERIFIER, codeVerifier);
}
function addClientSecret(parameters, clientSecret) {
  parameters.set(CLIENT_SECRET, clientSecret);
}
function addClientAssertion(parameters, clientAssertion) {
  if (clientAssertion) {
    parameters.set(CLIENT_ASSERTION, clientAssertion);
  }
}
function addClientAssertionType(parameters, clientAssertionType) {
  if (clientAssertionType) {
    parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
  }
}
function addOboAssertion(parameters, oboAssertion) {
  parameters.set(OBO_ASSERTION, oboAssertion);
}
function addRequestTokenUse(parameters, tokenUse) {
  parameters.set(REQUESTED_TOKEN_USE, tokenUse);
}
function addGrantType(parameters, grantType) {
  parameters.set(GRANT_TYPE, grantType);
}
function addClientInfo(parameters) {
  parameters.set(CLIENT_INFO, "1");
}
function addInstanceAware(parameters) {
  if (!parameters.has(INSTANCE_AWARE)) {
    parameters.set(INSTANCE_AWARE, "true");
  }
}
function addExtraQueryParameters(parameters, eQParams) {
  Object.entries(eQParams).forEach(([key, value]) => {
    if (!parameters.has(key) && value) {
      parameters.set(key, value);
    }
  });
}
function addClientCapabilitiesToClaims(claims, clientCapabilities) {
  let mergedClaims;
  if (!claims) {
    mergedClaims = {};
  } else {
    try {
      mergedClaims = JSON.parse(claims);
    } catch (e) {
      throw createClientConfigurationError(invalidClaims);
    }
  }
  if (clientCapabilities && clientCapabilities.length > 0) {
    if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
      mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
    }
    mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
      values: clientCapabilities
    };
  }
  return JSON.stringify(mergedClaims);
}
function addUsername(parameters, username) {
  parameters.set(PasswordGrantConstants.username, username);
}
function addPassword(parameters, password) {
  parameters.set(PasswordGrantConstants.password, password);
}
function addPopToken(parameters, cnfString) {
  if (cnfString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
    parameters.set(REQ_CNF, cnfString);
  }
}
function addSshJwk(parameters, sshJwkString) {
  if (sshJwkString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
    parameters.set(REQ_CNF, sshJwkString);
  }
}
function addServerTelemetry(parameters, serverTelemetryManager) {
  parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
  parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
}
function addThrottling(parameters) {
  parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
}
function addLogoutHint(parameters, logoutHint) {
  parameters.set(LOGOUT_HINT, logoutHint);
}
function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
  if (!parameters.has(BROKER_CLIENT_ID)) {
    parameters.set(BROKER_CLIENT_ID, brokerClientId);
  }
  if (!parameters.has(BROKER_REDIRECT_URI)) {
    parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
  }
}
function addEARParameters(parameters, jwk) {
  parameters.set(EAR_JWK, encodeURIComponent(jwk));
  const jweCryptoB64Encoded = "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0";
  parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);
}

// node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
var AuthorityFactory_exports = {};
__export(AuthorityFactory_exports, {
  createDiscoveredInstance: () => createDiscoveredInstance
});

// node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs
function isOpenIdConfigResponse(response) {
  return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
}

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs
function isCloudInstanceDiscoveryResponse(response) {
  return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
}

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs
function isCloudInstanceDiscoveryErrorResponse(response) {
  return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
}

// node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs
var PerformanceEvents = {
  /**
   * acquireTokenByCode API (msal-browser and msal-node).
   * Used to acquire tokens by trading an authorization code against the token endpoint.
   */
  AcquireTokenByCode: "acquireTokenByCode",
  /**
   * acquireTokenByRefreshToken API (msal-browser and msal-node).
   * Used to renew an access token using a refresh token against the token endpoint.
   */
  AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
  /**
   * acquireTokenSilent API (msal-browser and msal-node).
   * Used to silently acquire a new access token (from the cache or the network).
   */
  AcquireTokenSilent: "acquireTokenSilent",
  /**
   * acquireTokenSilentAsync (msal-browser).
   * Internal API for acquireTokenSilent.
   */
  AcquireTokenSilentAsync: "acquireTokenSilentAsync",
  /**
   * acquireTokenPopup (msal-browser).
   * Used to acquire a new access token interactively through pop ups
   */
  AcquireTokenPopup: "acquireTokenPopup",
  /**
   * acquireTokenPreRedirect (msal-browser).
   * First part of the redirect flow.
   * Used to acquire a new access token interactively through redirects.
   */
  AcquireTokenPreRedirect: "acquireTokenPreRedirect",
  /**
   * acquireTokenRedirect (msal-browser).
   * Second part of the redirect flow.
   * Used to acquire a new access token interactively through redirects.
   */
  AcquireTokenRedirect: "acquireTokenRedirect",
  /**
   * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
   * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
   */
  CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
  /**
   * signJwt API in CryptoOpts class (msal-browser).
   * Used to signed a pop token.
   */
  CryptoOptsSignJwt: "cryptoOptsSignJwt",
  /**
   * acquireToken API in the SilentCacheClient class (msal-browser).
   * Used to read access tokens from the cache.
   */
  SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
  /**
   * acquireToken API in the SilentIframeClient class (msal-browser).
   * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
   */
  SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
  AwaitConcurrentIframe: "awaitConcurrentIframe",
  /**
   * acquireToken API in SilentRereshClient (msal-browser).
   * Used to acquire a new set of tokens from the token endpoint using a refresh token.
   */
  SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
  /**
   * ssoSilent API (msal-browser).
   * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
   */
  SsoSilent: "ssoSilent",
  /**
   * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
   * Used to load authority metadata for a request.
   */
  StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
  /**
   * acquireToken APIs in msal-browser.
   * Used to make an /authorize endpoint call with native brokering enabled.
   */
  FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
  /**
   * acquireToken API in NativeInteractionClient class (msal-browser).
   * Used to acquire a token from Native component when native brokering is enabled.
   */
  NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
  /**
   * Time spent creating default headers for requests to token endpoint
   */
  BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
  /**
   * Time spent sending/waiting for the response of a request to the token endpoint
   */
  NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
  RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
  AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
  /**
   * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
   */
  BrokerHandhshake: "brokerHandshake",
  /**
   * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
   */
  AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
  /**
   * Time taken for token acquisition by broker
   */
  AcquireTokenByBroker: "acquireTokenByBroker",
  /**
   * Time spent on the network for refresh token acquisition
   */
  RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
  /**
   * Time taken for acquiring refresh token , records RT size
   */
  RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
  /**
   * Time taken for acquiring cached refresh token
   */
  RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
  /**
   * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
   */
  RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
  /**
   * Helper function to create token request body in RefreshTokenClient (msal-common).
   */
  RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
  /**
   * acquireTokenFromCache (msal-browser).
   * Internal API for acquiring token from cache
   */
  AcquireTokenFromCache: "acquireTokenFromCache",
  SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
  SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
  /**
   * acquireTokenBySilentIframe (msal-browser).
   * Internal API for acquiring token by silent Iframe
   */
  AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
  /**
   * Internal API for initializing base request in BaseInteractionClient (msal-browser)
   */
  InitializeBaseRequest: "initializeBaseRequest",
  /**
   * Internal API for initializing silent request in SilentCacheClient (msal-browser)
   */
  InitializeSilentRequest: "initializeSilentRequest",
  InitializeClientApplication: "initializeClientApplication",
  InitializeCache: "initializeCache",
  /**
   * Helper function in SilentIframeClient class (msal-browser).
   */
  SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
  /**
   * SilentHandler
   */
  SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
  SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
  SilentHandlerLoadFrame: "silentHandlerLoadFrame",
  SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
  /**
   * Helper functions in StandardInteractionClient class (msal-browser)
   */
  StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
  StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
  StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
  /**
   * getAuthCodeUrl API (msal-browser and msal-node).
   */
  GetAuthCodeUrl: "getAuthCodeUrl",
  GetStandardParams: "getStandardParams",
  /**
   * Functions from InteractionHandler (msal-browser)
   */
  HandleCodeResponseFromServer: "handleCodeResponseFromServer",
  HandleCodeResponse: "handleCodeResponse",
  HandleResponseEar: "handleResponseEar",
  HandleResponsePlatformBroker: "handleResponsePlatformBroker",
  HandleResponseCode: "handleResponseCode",
  UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
  /**
   * APIs in Authorization Code Client (msal-common)
   */
  AuthClientAcquireToken: "authClientAcquireToken",
  AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
  AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
  /**
   * Generate functions in PopTokenGenerator (msal-common)
   */
  PopTokenGenerateCnf: "popTokenGenerateCnf",
  PopTokenGenerateKid: "popTokenGenerateKid",
  /**
   * handleServerTokenResponse API in ResponseHandler (msal-common)
   */
  HandleServerTokenResponse: "handleServerTokenResponse",
  DeserializeResponse: "deserializeResponse",
  /**
   * Authority functions
   */
  AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
  AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
  AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
  AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
  AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
  AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
  AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
  AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
  /**
   * Region Discovery functions
   */
  RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
  RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
  RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
  AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
  GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
  GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
  HandleRedirectPromiseMeasurement: "handleRedirectPromise",
  HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
  UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
  UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
  NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
  NativeGenerateAuthResult: "nativeGenerateAuthResult",
  RemoveHiddenIframe: "removeHiddenIframe",
  /**
   * Cache operations
   */
  ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
  CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
  ImportExistingCache: "importExistingCache",
  SetUserData: "setUserData",
  LocalStorageUpdated: "localStorageUpdated",
  /**
   * Crypto Operations
   */
  GeneratePkceCodes: "generatePkceCodes",
  GenerateCodeVerifier: "generateCodeVerifier",
  GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
  Sha256Digest: "sha256Digest",
  GetRandomValues: "getRandomValues",
  GenerateHKDF: "generateHKDF",
  GenerateBaseKey: "generateBaseKey",
  Base64Decode: "base64Decode",
  UrlEncodeArr: "urlEncodeArr",
  Encrypt: "encrypt",
  Decrypt: "decrypt",
  GenerateEarKey: "generateEarKey",
  DecryptEarResponse: "decryptEarResponse"
};
var PerformanceEventAbbreviations = /* @__PURE__ */ new Map([
  [PerformanceEvents.AcquireTokenByCode, "ATByCode"],
  [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],
  [PerformanceEvents.AcquireTokenSilent, "ATS"],
  [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],
  [PerformanceEvents.AcquireTokenPopup, "ATPopup"],
  [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],
  [
    PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,
    "CryptoGetPKThumb"
  ],
  [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],
  [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],
  [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],
  [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],
  [PerformanceEvents.SsoSilent, "SsoSlt"],
  [
    PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
    "StdIntClientGetDiscAuth"
  ],
  [
    PerformanceEvents.FetchAccountIdWithNativeBroker,
    "FetchAccIdWithNtvBroker"
  ],
  [
    PerformanceEvents.NativeInteractionClientAcquireToken,
    "NtvIntClientAT"
  ],
  [
    PerformanceEvents.BaseClientCreateTokenRequestHeaders,
    "BaseClientCreateTReqHead"
  ],
  [
    PerformanceEvents.NetworkClientSendPostRequestAsync,
    "NetClientSendPost"
  ],
  [
    PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
    "RTClientExecPost"
  ],
  [
    PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
    "AuthCodeClientExecPost"
  ],
  [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],
  [
    PerformanceEvents.AcquireTokenByRefreshTokenInBroker,
    "ATByRTInBroker"
  ],
  [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],
  [
    PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
    "RTClientExecTReq"
  ],
  [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],
  [
    PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
    "RTClientATWithCachedRT"
  ],
  [
    PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
    "RTClientATByRT"
  ],
  [
    PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
    "RTClientCreateTReqBody"
  ],
  [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],
  [
    PerformanceEvents.SilentFlowClientAcquireCachedToken,
    "SltFlowClientATCached"
  ],
  [
    PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
    "SltFlowClientGenResFromCache"
  ],
  [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],
  [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],
  [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],
  [
    PerformanceEvents.InitializeClientApplication,
    "InitClientApplication"
  ],
  [PerformanceEvents.InitializeCache, "InitCache"],
  [PerformanceEvents.ImportExistingCache, "importCache"],
  [PerformanceEvents.SetUserData, "setUserData"],
  [PerformanceEvents.LocalStorageUpdated, "localStorageUpdated"],
  [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],
  [
    PerformanceEvents.SilentHandlerInitiateAuthRequest,
    "SHandlerInitAuthReq"
  ],
  [
    PerformanceEvents.SilentHandlerMonitorIframeForHash,
    "SltHandlerMonitorIframeForHash"
  ],
  [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],
  [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],
  [
    PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
    "StdIntClientCreateAuthCodeClient"
  ],
  [
    PerformanceEvents.StandardInteractionClientGetClientConfiguration,
    "StdIntClientGetClientConf"
  ],
  [
    PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
    "StdIntClientInitAuthReq"
  ],
  [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],
  [
    PerformanceEvents.HandleCodeResponseFromServer,
    "HandleCodeResFromServer"
  ],
  [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],
  [PerformanceEvents.HandleResponseEar, "HandleRespEar"],
  [PerformanceEvents.HandleResponseCode, "HandleRespCode"],
  [
    PerformanceEvents.HandleResponsePlatformBroker,
    "HandleRespPlatBroker"
  ],
  [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],
  [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],
  [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],
  [
    PerformanceEvents.AuthClientCreateTokenRequestBody,
    "AuthClientCreateTReqBody"
  ],
  [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],
  [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],
  [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],
  [PerformanceEvents.DeserializeResponse, "DeserializeRes"],
  [
    PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
    "AuthFactCreateDiscInst"
  ],
  [
    PerformanceEvents.AuthorityResolveEndpointsAsync,
    "AuthResolveEndpointsAsync"
  ],
  [
    PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
    "AuthResolveEndpointsFromLocal"
  ],
  [
    PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
    "AuthGetCDMetaFromNet"
  ],
  [
    PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
    "AuthUpdCDMeta"
  ],
  [
    PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
    "AuthUpdCDMetaFromNet"
  ],
  [
    PerformanceEvents.AuthorityUpdateEndpointMetadata,
    "AuthUpdEndpointMeta"
  ],
  [
    PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
    "AuthUpdMetaWithRegInfo"
  ],
  [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],
  [
    PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
    "RegDiscGetRegFromIMDS"
  ],
  [
    PerformanceEvents.RegionDiscoveryGetCurrentVersion,
    "RegDiscGetCurrentVer"
  ],
  [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],
  [
    PerformanceEvents.GetEndpointMetadataFromNetwork,
    "GetEndpointMetaFromNet"
  ],
  [
    PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,
    "GetCDMetaFromNet"
  ],
  [
    PerformanceEvents.HandleRedirectPromiseMeasurement,
    "HandleRedirectPromise"
  ],
  [
    PerformanceEvents.HandleNativeRedirectPromiseMeasurement,
    "HandleNtvRedirectPromise"
  ],
  [
    PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,
    "UpdateCDMeta"
  ],
  [
    PerformanceEvents.UsernamePasswordClientAcquireToken,
    "UserPassClientAT"
  ],
  [
    PerformanceEvents.NativeMessageHandlerHandshake,
    "NtvMsgHandlerHandshake"
  ],
  [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],
  [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],
  [
    PerformanceEvents.ClearTokensAndKeysWithClaims,
    "ClearTAndKeysWithClaims"
  ],
  [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],
  [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],
  [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],
  [
    PerformanceEvents.GenerateCodeChallengeFromVerifier,
    "GenCodeChallengeFromVerifier"
  ],
  [PerformanceEvents.Sha256Digest, "Sha256Digest"],
  [PerformanceEvents.GetRandomValues, "GetRandomValues"],
  [PerformanceEvents.GenerateHKDF, "genHKDF"],
  [PerformanceEvents.GenerateBaseKey, "genBaseKey"],
  [PerformanceEvents.Base64Decode, "b64Decode"],
  [PerformanceEvents.UrlEncodeArr, "urlEncArr"],
  [PerformanceEvents.Encrypt, "encrypt"],
  [PerformanceEvents.Decrypt, "decrypt"],
  [PerformanceEvents.GenerateEarKey, "genEarKey"],
  [PerformanceEvents.DecryptEarResponse, "decryptEarResp"]
]);

// node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs
var invoke = (callback, eventName, logger, telemetryClient, correlationId) => {
  return (...args) => {
    logger.trace(`Executing function ${eventName}`);
    const inProgressEvent = telemetryClient == null ? void 0 : telemetryClient.startMeasurement(eventName, correlationId);
    if (correlationId) {
      const eventCount = eventName + "CallCount";
      telemetryClient == null ? void 0 : telemetryClient.incrementFields({ [eventCount]: 1 }, correlationId);
    }
    try {
      const result = callback(...args);
      inProgressEvent == null ? void 0 : inProgressEvent.end({
        success: true
      });
      logger.trace(`Returning result from ${eventName}`);
      return result;
    } catch (e) {
      logger.trace(`Error occurred in ${eventName}`);
      try {
        logger.trace(JSON.stringify(e));
      } catch (e2) {
        logger.trace("Unable to print error message.");
      }
      inProgressEvent == null ? void 0 : inProgressEvent.end({
        success: false
      }, e);
      throw e;
    }
  };
};
var invokeAsync = (callback, eventName, logger, telemetryClient, correlationId) => {
  return (...args) => {
    logger.trace(`Executing function ${eventName}`);
    const inProgressEvent = telemetryClient == null ? void 0 : telemetryClient.startMeasurement(eventName, correlationId);
    if (correlationId) {
      const eventCount = eventName + "CallCount";
      telemetryClient == null ? void 0 : telemetryClient.incrementFields({ [eventCount]: 1 }, correlationId);
    }
    telemetryClient == null ? void 0 : telemetryClient.setPreQueueTime(eventName, correlationId);
    return callback(...args).then((response) => {
      logger.trace(`Returning result from ${eventName}`);
      inProgressEvent == null ? void 0 : inProgressEvent.end({
        success: true
      });
      return response;
    }).catch((e) => {
      logger.trace(`Error occurred in ${eventName}`);
      try {
        logger.trace(JSON.stringify(e));
      } catch (e2) {
        logger.trace("Unable to print error message.");
      }
      inProgressEvent == null ? void 0 : inProgressEvent.end({
        success: false
      }, e);
      throw e;
    });
  };
};

// node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs
var RegionDiscovery = class _RegionDiscovery {
  constructor(networkInterface, logger, performanceClient, correlationId) {
    this.networkInterface = networkInterface;
    this.logger = logger;
    this.performanceClient = performanceClient;
    this.correlationId = correlationId;
  }
  /**
   * Detect the region from the application's environment.
   *
   * @returns Promise<string | null>
   */
  async detectRegion(environmentRegion, regionDiscoveryMetadata) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
    let autodetectedRegionName = environmentRegion;
    if (!autodetectedRegionName) {
      const options = _RegionDiscovery.IMDS_OPTIONS;
      try {
        const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);
        if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
          autodetectedRegionName = localIMDSVersionResponse.body;
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
        }
        if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {
          const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
          if (!currentIMDSVersion) {
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return null;
          }
          const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
          if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
            autodetectedRegionName = currentIMDSVersionResponse.body;
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
          }
        }
      } catch (e) {
        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
        return null;
      }
    } else {
      regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
    }
    if (!autodetectedRegionName) {
      regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
    }
    return autodetectedRegionName || null;
  }
  /**
   * Make the call to the IMDS endpoint
   *
   * @param imdsEndpointUrl
   * @returns Promise<NetworkResponse<string>>
   */
  async getRegionFromIMDS(version3, options) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
    return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version3}&format=text`, options, Constants.IMDS_TIMEOUT);
  }
  /**
   * Get the most recent version of the IMDS endpoint available
   *
   * @returns Promise<string | null>
   */
  async getCurrentVersion(options) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
    try {
      const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);
      if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
        return response.body["newest-versions"][0];
      }
      return null;
    } catch (e) {
      return null;
    }
  }
};
RegionDiscovery.IMDS_OPTIONS = {
  headers: {
    Metadata: "true"
  }
};

// node_modules/@azure/msal-common/dist/authority/Authority.mjs
var Authority = class _Authority {
  constructor(authority, networkInterface, cacheManager, authorityOptions, logger, correlationId, performanceClient, managedIdentity) {
    this.canonicalAuthority = authority;
    this._canonicalAuthority.validateAsUri();
    this.networkInterface = networkInterface;
    this.cacheManager = cacheManager;
    this.authorityOptions = authorityOptions;
    this.regionDiscoveryMetadata = {
      region_used: void 0,
      region_source: void 0,
      region_outcome: void 0
    };
    this.logger = logger;
    this.performanceClient = performanceClient;
    this.correlationId = correlationId;
    this.managedIdentity = managedIdentity || false;
    this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
  }
  /**
   * Get {@link AuthorityType}
   * @param authorityUri {@link IUri}
   * @private
   */
  getAuthorityType(authorityUri) {
    if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
      return AuthorityType.Ciam;
    }
    const pathSegments = authorityUri.PathSegments;
    if (pathSegments.length) {
      switch (pathSegments[0].toLowerCase()) {
        case Constants.ADFS:
          return AuthorityType.Adfs;
        case Constants.DSTS:
          return AuthorityType.Dsts;
      }
    }
    return AuthorityType.Default;
  }
  // See above for AuthorityType
  get authorityType() {
    return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
  }
  /**
   * ProtocolMode enum representing the way endpoints are constructed.
   */
  get protocolMode() {
    return this.authorityOptions.protocolMode;
  }
  /**
   * Returns authorityOptions which can be used to reinstantiate a new authority instance
   */
  get options() {
    return this.authorityOptions;
  }
  /**
   * A URL that is the authority set by the developer
   */
  get canonicalAuthority() {
    return this._canonicalAuthority.urlString;
  }
  /**
   * Sets canonical authority.
   */
  set canonicalAuthority(url) {
    this._canonicalAuthority = new UrlString(url);
    this._canonicalAuthority.validateAsUri();
    this._canonicalAuthorityUrlComponents = null;
  }
  /**
   * Get authority components.
   */
  get canonicalAuthorityUrlComponents() {
    if (!this._canonicalAuthorityUrlComponents) {
      this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
    }
    return this._canonicalAuthorityUrlComponents;
  }
  /**
   * Get hostname and port i.e. login.microsoftonline.com
   */
  get hostnameAndPort() {
    return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
  }
  /**
   * Get tenant for authority.
   */
  get tenant() {
    return this.canonicalAuthorityUrlComponents.PathSegments[0];
  }
  /**
   * OAuth /authorize endpoint for requests
   */
  get authorizationEndpoint() {
    if (this.discoveryComplete()) {
      return this.replacePath(this.metadata.authorization_endpoint);
    } else {
      throw createClientAuthError(endpointResolutionError);
    }
  }
  /**
   * OAuth /token endpoint for requests
   */
  get tokenEndpoint() {
    if (this.discoveryComplete()) {
      return this.replacePath(this.metadata.token_endpoint);
    } else {
      throw createClientAuthError(endpointResolutionError);
    }
  }
  get deviceCodeEndpoint() {
    if (this.discoveryComplete()) {
      return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
    } else {
      throw createClientAuthError(endpointResolutionError);
    }
  }
  /**
   * OAuth logout endpoint for requests
   */
  get endSessionEndpoint() {
    if (this.discoveryComplete()) {
      if (!this.metadata.end_session_endpoint) {
        throw createClientAuthError(endSessionEndpointNotSupported);
      }
      return this.replacePath(this.metadata.end_session_endpoint);
    } else {
      throw createClientAuthError(endpointResolutionError);
    }
  }
  /**
   * OAuth issuer for requests
   */
  get selfSignedJwtAudience() {
    if (this.discoveryComplete()) {
      return this.replacePath(this.metadata.issuer);
    } else {
      throw createClientAuthError(endpointResolutionError);
    }
  }
  /**
   * Jwks_uri for token signing keys
   */
  get jwksUri() {
    if (this.discoveryComplete()) {
      return this.replacePath(this.metadata.jwks_uri);
    } else {
      throw createClientAuthError(endpointResolutionError);
    }
  }
  /**
   * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
   * @param authorityUri {@link IUri}
   * @private
   */
  canReplaceTenant(authorityUri) {
    return authorityUri.PathSegments.length === 1 && !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode !== ProtocolMode.OIDC;
  }
  /**
   * Replaces tenant in url path with current tenant. Defaults to common.
   * @param urlString
   */
  replaceTenant(urlString) {
    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
  }
  /**
   * Replaces path such as tenant or policy with the current tenant or policy.
   * @param urlString
   */
  replacePath(urlString) {
    let endpoint = urlString;
    const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
    const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
    const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
    const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
    currentAuthorityParts.forEach((currentPart, index) => {
      let cachedPart = cachedAuthorityParts[index];
      if (index === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
        const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
        if (cachedPart !== tenantId) {
          this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
          cachedPart = tenantId;
        }
      }
      if (currentPart !== cachedPart) {
        endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
      }
    });
    return this.replaceTenant(endpoint);
  }
  /**
   * The default open id configuration endpoint for any canonical authority.
   */
  get defaultOpenIdConfigurationEndpoint() {
    const canonicalAuthorityHost = this.hostnameAndPort;
    if (this.canonicalAuthority.endsWith("v2.0/") || this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {
      return `${this.canonicalAuthority}.well-known/openid-configuration`;
    }
    return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
  }
  /**
   * Boolean that returns whether or not tenant discovery has been completed.
   */
  discoveryComplete() {
    return !!this.metadata;
  }
  /**
   * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
   * and the /authorize, /token and logout endpoints.
   */
  async resolveEndpointsAsync() {
    var _a, _b;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
    const metadataEntity = this.getCurrentMetadataEntity();
    const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
    this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
    const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
    this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
      source: endpointSource
    });
    (_b = this.performanceClient) == null ? void 0 : _b.addFields({
      cloudDiscoverySource,
      authorityEndpointSource: endpointSource
    }, this.correlationId);
  }
  /**
   * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
   * from the configured canonical authority
   * @returns
   */
  getCurrentMetadataEntity() {
    let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
    if (!metadataEntity) {
      metadataEntity = {
        aliases: [],
        preferred_cache: this.hostnameAndPort,
        preferred_network: this.hostnameAndPort,
        canonical_authority: this.canonicalAuthority,
        authorization_endpoint: "",
        token_endpoint: "",
        end_session_endpoint: "",
        issuer: "",
        aliasesFromNetwork: false,
        endpointsFromNetwork: false,
        expiresAt: generateAuthorityMetadataExpiresAt(),
        jwks_uri: ""
      };
    }
    return metadataEntity;
  }
  /**
   * Updates cached metadata based on metadata source and sets the instance's metadata
   * property to the same value
   * @param metadataEntity
   * @param cloudDiscoverySource
   * @param endpointMetadataResult
   */
  updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
    if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && (endpointMetadataResult == null ? void 0 : endpointMetadataResult.source) !== AuthorityMetadataSource.CACHE) {
      metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
      metadataEntity.canonical_authority = this.canonicalAuthority;
    }
    const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
    this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
    this.metadata = metadataEntity;
  }
  /**
   * Update AuthorityMetadataEntity with new endpoints and return where the information came from
   * @param metadataEntity
   */
  async updateEndpointMetadata(metadataEntity) {
    var _a, _b, _c;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
    const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
    if (localMetadata) {
      if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
        if ((_b = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _b.azureRegion) {
          if (localMetadata.metadata) {
            const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
            updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
            metadataEntity.canonical_authority = this.canonicalAuthority;
          }
        }
      }
      return localMetadata.source;
    }
    let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
    if (metadata) {
      if ((_c = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _c.azureRegion) {
        metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
      }
      updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
      return AuthorityMetadataSource.NETWORK;
    } else {
      throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
    }
  }
  /**
   * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
   * response if the source is hardcoded metadata
   * @param metadataEntity
   * @returns
   */
  updateEndpointMetadataFromLocalSources(metadataEntity) {
    this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
    const configMetadata = this.getEndpointMetadataFromConfig();
    if (configMetadata) {
      this.logger.verbose("Found endpoint metadata in authority configuration");
      updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
      return {
        source: AuthorityMetadataSource.CONFIG
      };
    }
    this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
    if (this.authorityOptions.skipAuthorityMetadataCache) {
      this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
    } else {
      const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
      if (hardcodedMetadata) {
        updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
        return {
          source: AuthorityMetadataSource.HARDCODED_VALUES,
          metadata: hardcodedMetadata
        };
      } else {
        this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
      }
    }
    const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
    if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {
      this.logger.verbose("Found endpoint metadata in the cache.");
      return { source: AuthorityMetadataSource.CACHE };
    } else if (metadataEntityExpired) {
      this.logger.verbose("The metadata entity is expired.");
    }
    return null;
  }
  /**
   * Compares the number of url components after the domain to determine if the cached
   * authority metadata can be used for the requested authority. Protects against same domain different
   * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
   * @param metadataEntity
   */
  isAuthoritySameType(metadataEntity) {
    const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
    const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
  }
  /**
   * Parse authorityMetadata config option
   */
  getEndpointMetadataFromConfig() {
    if (this.authorityOptions.authorityMetadata) {
      try {
        return JSON.parse(this.authorityOptions.authorityMetadata);
      } catch (e) {
        throw createClientConfigurationError(invalidAuthorityMetadata);
      }
    }
    return null;
  }
  /**
   * Gets OAuth endpoints from the given OpenID configuration endpoint.
   *
   * @param hasHardcodedMetadata boolean
   */
  async getEndpointMetadataFromNetwork() {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
    const options = {};
    const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
    this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
    try {
      const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
      const isValidResponse = isOpenIdConfigResponse(response.body);
      if (isValidResponse) {
        return response.body;
      } else {
        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
        return null;
      }
    } catch (e) {
      this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
      return null;
    }
  }
  /**
   * Get OAuth endpoints for common authorities.
   */
  getEndpointMetadataFromHardcodedValues() {
    if (this.hostnameAndPort in EndpointMetadata) {
      return EndpointMetadata[this.hostnameAndPort];
    }
    return null;
  }
  /**
   * Update the retrieved metadata with regional information.
   * User selected Azure region will be used if configured.
   */
  async updateMetadataWithRegionalInformation(metadata) {
    var _a, _b, _c;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
    const userConfiguredAzureRegion = (_b = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _b.azureRegion;
    if (userConfiguredAzureRegion) {
      if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
        this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
        return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
      }
      const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)((_c = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _c.environmentRegion, this.regionDiscoveryMetadata);
      if (autodetectedRegionName) {
        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
        this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
        return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
      }
      this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
    }
    return metadata;
  }
  /**
   * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
   * and returns where the information was retrieved from
   * @param metadataEntity
   * @returns AuthorityMetadataSource
   */
  async updateCloudDiscoveryMetadata(metadataEntity) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
    const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
    if (localMetadataSource) {
      return localMetadataSource;
    }
    const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
    if (metadata) {
      updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
      return AuthorityMetadataSource.NETWORK;
    }
    throw createClientConfigurationError(untrustedAuthority);
  }
  updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
    this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
    this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);
    this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);
    this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);
    const metadata = this.getCloudDiscoveryMetadataFromConfig();
    if (metadata) {
      this.logger.verbose("Found cloud discovery metadata in authority configuration");
      updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
      return AuthorityMetadataSource.CONFIG;
    }
    this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
    if (this.options.skipAuthorityMetadataCache) {
      this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
    } else {
      const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
      if (hardcodedMetadata) {
        this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
        updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
        return AuthorityMetadataSource.HARDCODED_VALUES;
      }
      this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
    }
    const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
    if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
      this.logger.verbose("Found cloud discovery metadata in the cache.");
      return AuthorityMetadataSource.CACHE;
    } else if (metadataEntityExpired) {
      this.logger.verbose("The metadata entity is expired.");
    }
    return null;
  }
  /**
   * Parse cloudDiscoveryMetadata config or check knownAuthorities
   */
  getCloudDiscoveryMetadataFromConfig() {
    if (this.authorityType === AuthorityType.Ciam) {
      this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
      return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
    }
    if (this.authorityOptions.cloudDiscoveryMetadata) {
      this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
      try {
        this.logger.verbose("Attempting to parse the cloud discovery metadata.");
        const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
        const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
        this.logger.verbose("Parsed the cloud discovery metadata.");
        if (metadata) {
          this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
          return metadata;
        } else {
          this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
        }
      } catch (e) {
        this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
        throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
      }
    }
    if (this.isInKnownAuthorities()) {
      this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
      return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
    }
    return null;
  }
  /**
   * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
   *
   * @param hasHardcodedMetadata boolean
   */
  async getCloudDiscoveryMetadataFromNetwork() {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
    const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
    const options = {};
    let match = null;
    try {
      const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
      let typedResponseBody;
      let metadata;
      if (isCloudInstanceDiscoveryResponse(response.body)) {
        typedResponseBody = response.body;
        metadata = typedResponseBody.metadata;
        this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
      } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
        this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
        typedResponseBody = response.body;
        if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
          this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
          return null;
        }
        this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
        this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
        this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
        metadata = [];
      } else {
        this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
        return null;
      }
      this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
      match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
    } catch (error) {
      if (error instanceof AuthError) {
        this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
      } else {
        const typedError = error;
        this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
      }
      return null;
    }
    if (!match) {
      this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
      this.logger.verbose("Creating custom Authority for custom domain scenario.");
      match = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
    }
    return match;
  }
  /**
   * Helper function to determine if this host is included in the knownAuthorities config option
   */
  isInKnownAuthorities() {
    const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
      return authority && UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;
    });
    return matches.length > 0;
  }
  /**
   * helper function to populate the authority based on azureCloudOptions
   * @param authorityString
   * @param azureCloudOptions
   */
  static generateAuthority(authorityString, azureCloudOptions) {
    let authorityAzureCloudInstance;
    if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
      const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
      authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
    }
    return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
  }
  /**
   * Creates cloud discovery metadata object from a given host
   * @param host
   */
  static createCloudDiscoveryMetadataFromHost(host) {
    return {
      preferred_network: host,
      preferred_cache: host,
      aliases: [host]
    };
  }
  /**
   * helper function to generate environment from authority object
   */
  getPreferredCache() {
    if (this.managedIdentity) {
      return Constants.DEFAULT_AUTHORITY_HOST;
    } else if (this.discoveryComplete()) {
      return this.metadata.preferred_cache;
    } else {
      throw createClientAuthError(endpointResolutionError);
    }
  }
  /**
   * Returns whether or not the provided host is an alias of this authority instance
   * @param host
   */
  isAlias(host) {
    return this.metadata.aliases.indexOf(host) > -1;
  }
  /**
   * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
   * @param host
   */
  isAliasOfKnownMicrosoftAuthority(host) {
    return InstanceDiscoveryMetadataAliases.has(host);
  }
  /**
   * Checks whether the provided host is that of a public cloud authority
   *
   * @param authority string
   * @returns bool
   */
  static isPublicCloudAuthority(host) {
    return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
  }
  /**
   * Rebuild the authority string with the region
   *
   * @param host string
   * @param region string
   */
  static buildRegionalAuthorityString(host, region, queryString) {
    const authorityUrlInstance = new UrlString(host);
    authorityUrlInstance.validateAsUri();
    const authorityUrlParts = authorityUrlInstance.getUrlComponents();
    let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
      hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
    }
    const url = UrlString.constructAuthorityUriFromObject({
      ...authorityUrlInstance.getUrlComponents(),
      HostNameAndPort: hostNameAndPort
    }).urlString;
    if (queryString)
      return `${url}?${queryString}`;
    return url;
  }
  /**
   * Replace the endpoints in the metadata object with their regional equivalents.
   *
   * @param metadata OpenIdConfigResponse
   * @param azureRegion string
   */
  static replaceWithRegionalInformation(metadata, azureRegion) {
    const regionalMetadata = { ...metadata };
    regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
    regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
    if (regionalMetadata.end_session_endpoint) {
      regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
    }
    return regionalMetadata;
  }
  /**
   * Transform CIAM_AUTHORIY as per the below rules:
   * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
   *
   * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
   * `ciamlogin.com` can also change in the future and we should accommodate the same
   *
   * @param authority
   */
  static transformCIAMAuthority(authority) {
    let ciamAuthority = authority;
    const authorityUrl = new UrlString(authority);
    const authorityUrlComponents = authorityUrl.getUrlComponents();
    if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
      const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
      ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
    }
    return ciamAuthority;
  }
};
Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
  "{tenant}",
  "{tenantid}",
  AADAuthorityConstants.COMMON,
  AADAuthorityConstants.CONSUMERS,
  AADAuthorityConstants.ORGANIZATIONS
]);
function getTenantFromAuthorityString(authority) {
  var _a;
  const authorityUrl = new UrlString(authority);
  const authorityUrlComponents = authorityUrl.getUrlComponents();
  const tenantId = (_a = authorityUrlComponents.PathSegments.slice(-1)[0]) == null ? void 0 : _a.toLowerCase();
  switch (tenantId) {
    case AADAuthorityConstants.COMMON:
    case AADAuthorityConstants.ORGANIZATIONS:
    case AADAuthorityConstants.CONSUMERS:
      return void 0;
    default:
      return tenantId;
  }
}
function formatAuthorityUri(authorityUri) {
  return authorityUri.endsWith(Constants.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants.FORWARD_SLASH}`;
}
function buildStaticAuthorityOptions(authOptions) {
  const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
  let cloudDiscoveryMetadata = void 0;
  if (rawCloudDiscoveryMetadata) {
    try {
      cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
    } catch (e) {
      throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
    }
  }
  return {
    canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
    knownAuthorities: authOptions.knownAuthorities,
    cloudDiscoveryMetadata
  };
}

// node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient) {
  performanceClient == null ? void 0 : performanceClient.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
  const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
  const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient);
  try {
    await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger, performanceClient, correlationId)();
    return acquireTokenAuthority;
  } catch (e) {
    throw createClientAuthError(endpointResolutionError);
  }
}

// node_modules/@azure/msal-common/dist/error/ServerError.mjs
var ServerError = class _ServerError extends AuthError {
  constructor(errorCode, errorMessage, subError, errorNo, status) {
    super(errorCode, errorMessage, subError);
    this.name = "ServerError";
    this.errorNo = errorNo;
    this.status = status;
    Object.setPrototypeOf(this, _ServerError.prototype);
  }
};

// node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs
function getRequestThumbprint(clientId, request, homeAccountId) {
  var _a;
  return {
    clientId,
    authority: request.authority,
    scopes: request.scopes,
    homeAccountIdentifier: homeAccountId,
    claims: request.claims,
    authenticationScheme: request.authenticationScheme,
    resourceRequestMethod: request.resourceRequestMethod,
    resourceRequestUri: request.resourceRequestUri,
    shrClaims: request.shrClaims,
    sshKid: request.sshKid,
    embeddedClientId: request.embeddedClientId || ((_a = request.tokenBodyParameters) == null ? void 0 : _a.clientId)
  };
}

// node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs
var ThrottlingUtils = class _ThrottlingUtils {
  /**
   * Prepares a RequestThumbprint to be stored as a key.
   * @param thumbprint
   */
  static generateThrottlingStorageKey(thumbprint) {
    return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
  }
  /**
   * Performs necessary throttling checks before a network request.
   * @param cacheManager
   * @param thumbprint
   */
  static preProcess(cacheManager, thumbprint) {
    var _a;
    const key = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
    const value = cacheManager.getThrottlingCache(key);
    if (value) {
      if (value.throttleTime < Date.now()) {
        cacheManager.removeItem(key);
        return;
      }
      throw new ServerError(((_a = value.errorCodes) == null ? void 0 : _a.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
    }
  }
  /**
   * Performs necessary throttling checks after a network request.
   * @param cacheManager
   * @param thumbprint
   * @param response
   */
  static postProcess(cacheManager, thumbprint, response) {
    if (_ThrottlingUtils.checkResponseStatus(response) || _ThrottlingUtils.checkResponseForRetryAfter(response)) {
      const thumbprintValue = {
        throttleTime: _ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
        error: response.body.error,
        errorCodes: response.body.error_codes,
        errorMessage: response.body.error_description,
        subError: response.body.suberror
      };
      cacheManager.setThrottlingCache(_ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue);
    }
  }
  /**
   * Checks a NetworkResponse object's status codes against 429 or 5xx
   * @param response
   */
  static checkResponseStatus(response) {
    return response.status === 429 || response.status >= 500 && response.status < 600;
  }
  /**
   * Checks a NetworkResponse object's RetryAfter header
   * @param response
   */
  static checkResponseForRetryAfter(response) {
    if (response.headers) {
      return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
    }
    return false;
  }
  /**
   * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
   * @param throttleTime
   */
  static calculateThrottleTime(throttleTime) {
    const time = throttleTime <= 0 ? 0 : throttleTime;
    const currentSeconds = Date.now() / 1e3;
    return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
  }
  static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
    const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
    const key = this.generateThrottlingStorageKey(thumbprint);
    cacheManager.removeItem(key);
  }
};

// node_modules/@azure/msal-common/dist/error/NetworkError.mjs
var NetworkError = class _NetworkError extends AuthError {
  constructor(error, httpStatus, responseHeaders) {
    super(error.errorCode, error.errorMessage, error.subError);
    Object.setPrototypeOf(this, _NetworkError.prototype);
    this.name = "NetworkError";
    this.error = error;
    this.httpStatus = httpStatus;
    this.responseHeaders = responseHeaders;
  }
};

// node_modules/@azure/msal-common/dist/client/BaseClient.mjs
var BaseClient = class {
  constructor(configuration, performanceClient) {
    this.config = buildClientConfiguration(configuration);
    this.logger = new Logger(this.config.loggerOptions, name, version);
    this.cryptoUtils = this.config.cryptoInterface;
    this.cacheManager = this.config.storageInterface;
    this.networkClient = this.config.networkInterface;
    this.serverTelemetryManager = this.config.serverTelemetryManager;
    this.authority = this.config.authOptions.authority;
    this.performanceClient = performanceClient;
  }
  /**
   * Creates default headers for requests to token endpoint
   */
  createTokenRequestHeaders(ccsCred) {
    const headers = {};
    headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
    if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
      switch (ccsCred.type) {
        case CcsCredentialType.HOME_ACCOUNT_ID:
          try {
            const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
            headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
          } catch (e) {
            this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
          }
          break;
        case CcsCredentialType.UPN:
          headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
          break;
      }
    }
    return headers;
  }
  /**
   * Http post to token endpoint
   * @param tokenEndpoint
   * @param queryString
   * @param headers
   * @param thumbprint
   */
  async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
    var _a;
    if (queuedEvent) {
      (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(queuedEvent, correlationId);
    }
    const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers }, correlationId);
    if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
      this.config.serverTelemetryManager.clearTelemetryCache();
    }
    return response;
  }
  /**
   * Wraps sendPostRequestAsync with necessary preflight and postflight logic
   * @param thumbprint - Request thumbprint for throttling
   * @param tokenEndpoint - Endpoint to make the POST to
   * @param options - Body and Headers to include on the POST request
   * @param correlationId - CorrelationId for telemetry
   */
  async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
    var _a, _b, _c;
    ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
    let response;
    try {
      response = await invokeAsync(this.networkClient.sendPostRequestAsync.bind(this.networkClient), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
      const responseHeaders = response.headers || {};
      (_b = this.performanceClient) == null ? void 0 : _b.addFields({
        refreshTokenSize: ((_a = response.body.refresh_token) == null ? void 0 : _a.length) || 0,
        httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
        requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || ""
      }, correlationId);
    } catch (e) {
      if (e instanceof NetworkError) {
        const responseHeaders = e.responseHeaders;
        if (responseHeaders) {
          (_c = this.performanceClient) == null ? void 0 : _c.addFields({
            httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
            requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
            contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] || void 0,
            contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] || void 0,
            httpStatus: e.httpStatus
          }, correlationId);
        }
        throw e.error;
      }
      if (e instanceof AuthError) {
        throw e;
      } else {
        throw createClientAuthError(networkError);
      }
    }
    ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
    return response;
  }
  /**
   * Updates the authority object of the client. Endpoint discovery must be completed.
   * @param updatedAuthority
   */
  async updateAuthority(cloudInstanceHostname, correlationId) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
    const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
    const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
    this.authority = cloudInstanceAuthority;
  }
  /**
   * Creates query string for the /token request
   * @param request
   */
  createTokenQueryParameters(request) {
    const parameters = /* @__PURE__ */ new Map();
    if (request.embeddedClientId) {
      addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
    }
    if (request.tokenQueryParameters) {
      addExtraQueryParameters(parameters, request.tokenQueryParameters);
    }
    addCorrelationId(parameters, request.correlationId);
    instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
    return mapToQueryString(parameters);
  }
};

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs
var noTokensFound = "no_tokens_found";
var nativeAccountUnavailable = "native_account_unavailable";
var refreshTokenExpired = "refresh_token_expired";
var interactionRequired = "interaction_required";
var consentRequired = "consent_required";
var loginRequired = "login_required";
var badToken = "bad_token";

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs
var InteractionRequiredServerErrorMessage = [
  interactionRequired,
  consentRequired,
  loginRequired,
  badToken
];
var InteractionRequiredAuthSubErrorMessage = [
  "message_only",
  "additional_action",
  "basic_action",
  "user_password_expired",
  "consent_required",
  "bad_token"
];
var InteractionRequiredAuthErrorMessages = {
  [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
  [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
  [refreshTokenExpired]: "Refresh token has expired.",
  [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve."
};
var InteractionRequiredAuthErrorMessage = {
  noTokensFoundError: {
    code: noTokensFound,
    desc: InteractionRequiredAuthErrorMessages[noTokensFound]
  },
  native_account_unavailable: {
    code: nativeAccountUnavailable,
    desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable]
  },
  bad_token: {
    code: badToken,
    desc: InteractionRequiredAuthErrorMessages[badToken]
  }
};
var InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
  constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {
    super(errorCode, errorMessage, subError);
    Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
    this.timestamp = timestamp || Constants.EMPTY_STRING;
    this.traceId = traceId || Constants.EMPTY_STRING;
    this.correlationId = correlationId || Constants.EMPTY_STRING;
    this.claims = claims || Constants.EMPTY_STRING;
    this.name = "InteractionRequiredAuthError";
    this.errorNo = errorNo;
  }
};
function isInteractionRequiredError(errorCode, errorString, subError) {
  const isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
  const isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
  const isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some((irErrorCode) => {
    return errorString.indexOf(irErrorCode) > -1;
  });
  return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
}
function createInteractionRequiredAuthError(errorCode) {
  return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
}

// node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs
var ProtocolUtils = class _ProtocolUtils {
  /**
   * Appends user state with random guid, or returns random guid.
   * @param userState
   * @param randomGuid
   */
  static setRequestState(cryptoObj, userState, meta) {
    const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
    return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;
  }
  /**
   * Generates the state value used by the common library.
   * @param randomGuid
   * @param cryptoObj
   */
  static generateLibraryState(cryptoObj, meta) {
    if (!cryptoObj) {
      throw createClientAuthError(noCryptoObject);
    }
    const stateObj = {
      id: cryptoObj.createNewGuid()
    };
    if (meta) {
      stateObj.meta = meta;
    }
    const stateString = JSON.stringify(stateObj);
    return cryptoObj.base64Encode(stateString);
  }
  /**
   * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
   * @param state
   * @param cryptoObj
   */
  static parseRequestState(cryptoObj, state) {
    if (!cryptoObj) {
      throw createClientAuthError(noCryptoObject);
    }
    if (!state) {
      throw createClientAuthError(invalidState);
    }
    try {
      const splitState = state.split(Constants.RESOURCE_DELIM);
      const libraryState = splitState[0];
      const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
      const libraryStateString = cryptoObj.base64Decode(libraryState);
      const libraryStateObj = JSON.parse(libraryStateString);
      return {
        userRequestState: userState || Constants.EMPTY_STRING,
        libraryState: libraryStateObj
      };
    } catch (e) {
      throw createClientAuthError(invalidState);
    }
  }
};

// node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs
var KeyLocation = {
  SW: "sw",
  UHW: "uhw"
};
var PopTokenGenerator = class {
  constructor(cryptoUtils, performanceClient) {
    this.cryptoUtils = cryptoUtils;
    this.performanceClient = performanceClient;
  }
  /**
   * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
   * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
   * @param request
   * @returns
   */
  async generateCnf(request, logger) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
    const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger, this.performanceClient, request.correlationId)(request);
    const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
    return {
      kid: reqCnf.kid,
      reqCnfString
    };
  }
  /**
   * Generates key_id for a SHR token request
   * @param request
   * @returns
   */
  async generateKid(request) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
    const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
    return {
      kid: kidThumbprint,
      xms_ksl: KeyLocation.SW
    };
  }
  /**
   * Signs the POP access_token with the local generated key-pair
   * @param accessToken
   * @param request
   * @returns
   */
  async signPopToken(accessToken, keyId, request) {
    return this.signPayload(accessToken, keyId, request);
  }
  /**
   * Utility function to generate the signed JWT for an access_token
   * @param payload
   * @param kid
   * @param request
   * @param claims
   * @returns
   */
  async signPayload(payload, keyId, request, claims) {
    const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } = request;
    const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
    const resourceUrlComponents = resourceUrlString == null ? void 0 : resourceUrlString.getUrlComponents();
    return this.cryptoUtils.signJwt({
      at: payload,
      ts: nowSeconds(),
      m: resourceRequestMethod == null ? void 0 : resourceRequestMethod.toUpperCase(),
      u: resourceUrlComponents == null ? void 0 : resourceUrlComponents.HostNameAndPort,
      nonce: shrNonce || this.cryptoUtils.createNewGuid(),
      p: resourceUrlComponents == null ? void 0 : resourceUrlComponents.AbsolutePath,
      q: (resourceUrlComponents == null ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : void 0,
      client_claims: shrClaims || void 0,
      ...claims
    }, keyId, shrOptions, request.correlationId);
  }
};

// node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs
var TokenCacheContext = class {
  constructor(tokenCache, hasChanged) {
    this.cache = tokenCache;
    this.hasChanged = hasChanged;
  }
  /**
   * boolean which indicates the changes in cache
   */
  get cacheHasChanged() {
    return this.hasChanged;
  }
  /**
   * function to retrieve the token cache
   */
  get tokenCache() {
    return this.cache;
  }
};

// node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs
var ResponseHandler = class _ResponseHandler {
  constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {
    this.clientId = clientId;
    this.cacheStorage = cacheStorage;
    this.cryptoObj = cryptoObj;
    this.logger = logger;
    this.serializableCache = serializableCache;
    this.persistencePlugin = persistencePlugin;
    this.performanceClient = performanceClient;
  }
  /**
   * Function which validates server authorization token response.
   * @param serverResponse
   * @param refreshAccessToken
   */
  validateTokenResponse(serverResponse, refreshAccessToken) {
    var _a;
    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
      const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
      const serverErrorNo = ((_a = serverResponse.error_codes) == null ? void 0 : _a.length) ? serverResponse.error_codes[0] : void 0;
      const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
      if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
        return;
      } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
        return;
      }
      if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);
      }
      throw serverError;
    }
  }
  /**
   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
   * @param serverTokenResponse
   * @param authority
   */
  async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
    let idTokenClaims;
    if (serverTokenResponse.id_token) {
      idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);
      if (authCodePayload && authCodePayload.nonce) {
        if (idTokenClaims.nonce !== authCodePayload.nonce) {
          throw createClientAuthError(nonceMismatch);
        }
      }
      if (request.maxAge || request.maxAge === 0) {
        const authTime = idTokenClaims.auth_time;
        if (!authTime) {
          throw createClientAuthError(authTimeNotFound);
        }
        checkMaxAge(authTime, request.maxAge);
      }
    }
    this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
    let requestStateObj;
    if (!!authCodePayload && !!authCodePayload.state) {
      requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
    }
    serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
    const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
    let cacheContext;
    try {
      if (this.persistencePlugin && this.serializableCache) {
        this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
        cacheContext = new TokenCacheContext(this.serializableCache, true);
        await this.persistencePlugin.beforeCacheAccess(cacheContext);
      }
      if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
        const key = cacheRecord.account.generateAccountKey();
        const account = this.cacheStorage.getAccount(key);
        if (!account) {
          this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
          return await _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, void 0, serverRequestId);
        }
      }
      await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, request.storeInCache);
    } finally {
      if (this.persistencePlugin && this.serializableCache && cacheContext) {
        this.logger.verbose("Persistence enabled, calling afterCacheAccess");
        await this.persistencePlugin.afterCacheAccess(cacheContext);
      }
    }
    return _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
  }
  /**
   * Generates CacheRecord
   * @param serverTokenResponse
   * @param idTokenObj
   * @param authority
   */
  generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
    const env = authority.getPreferredCache();
    if (!env) {
      throw createClientAuthError(invalidCacheEnvironment);
    }
    const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
    let cachedIdToken;
    let cachedAccount;
    if (serverTokenResponse.id_token && !!idTokenClaims) {
      cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
      cachedAccount = buildAccountToCache(
        this.cacheStorage,
        authority,
        this.homeAccountIdentifier,
        this.cryptoObj.base64Decode,
        idTokenClaims,
        serverTokenResponse.client_info,
        env,
        claimsTenantId,
        authCodePayload,
        void 0,
        // nativeAccountId
        this.logger
      );
    }
    let cachedAccessToken = null;
    if (serverTokenResponse.access_token) {
      const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
      const expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
      const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
      const refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
      const tokenExpirationSeconds = reqTimestamp + expiresIn;
      const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
      const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
      cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
    }
    let cachedRefreshToken = null;
    if (serverTokenResponse.refresh_token) {
      let rtExpiresOn;
      if (serverTokenResponse.refresh_token_expires_in) {
        const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === "string" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;
        rtExpiresOn = reqTimestamp + rtExpiresIn;
      }
      cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
    }
    let cachedAppMetadata = null;
    if (serverTokenResponse.foci) {
      cachedAppMetadata = {
        clientId: this.clientId,
        environment: env,
        familyId: serverTokenResponse.foci
      };
    }
    return {
      account: cachedAccount,
      idToken: cachedIdToken,
      accessToken: cachedAccessToken,
      refreshToken: cachedRefreshToken,
      appMetadata: cachedAppMetadata
    };
  }
  /**
   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
   *
   * Optionally takes a state string that is set as-is in the response.
   *
   * @param cacheRecord
   * @param idTokenObj
   * @param fromTokenCache
   * @param stateString
   */
  static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
    var _a, _b, _c, _d, _e;
    let accessToken = Constants.EMPTY_STRING;
    let responseScopes = [];
    let expiresOn = null;
    let extExpiresOn;
    let refreshOn;
    let familyId = Constants.EMPTY_STRING;
    if (cacheRecord.accessToken) {
      if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {
        const popTokenGenerator = new PopTokenGenerator(cryptoObj);
        const { secret, keyId } = cacheRecord.accessToken;
        if (!keyId) {
          throw createClientAuthError(keyIdMissing);
        }
        accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
      } else {
        accessToken = cacheRecord.accessToken.secret;
      }
      responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
      expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
      extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
      if (cacheRecord.accessToken.refreshOn) {
        refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
      }
    }
    if (cacheRecord.appMetadata) {
      familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : "";
    }
    const uid = (idTokenClaims == null ? void 0 : idTokenClaims.oid) || (idTokenClaims == null ? void 0 : idTokenClaims.sub) || "";
    const tid = (idTokenClaims == null ? void 0 : idTokenClaims.tid) || "";
    if ((serverTokenResponse == null ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {
      cacheRecord.account.nativeAccountId = serverTokenResponse == null ? void 0 : serverTokenResponse.spa_accountid;
    }
    const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(
      cacheRecord.account.getAccountInfo(),
      void 0,
      // tenantProfile optional
      idTokenClaims,
      (_a = cacheRecord.idToken) == null ? void 0 : _a.secret
    ) : null;
    return {
      authority: authority.canonicalAuthority,
      uniqueId: uid,
      tenantId: tid,
      scopes: responseScopes,
      account: accountInfo,
      idToken: ((_b = cacheRecord == null ? void 0 : cacheRecord.idToken) == null ? void 0 : _b.secret) || "",
      idTokenClaims: idTokenClaims || {},
      accessToken,
      fromCache: fromTokenCache,
      expiresOn,
      extExpiresOn,
      refreshOn,
      correlationId: request.correlationId,
      requestId: requestId || Constants.EMPTY_STRING,
      familyId,
      tokenType: ((_c = cacheRecord.accessToken) == null ? void 0 : _c.tokenType) || Constants.EMPTY_STRING,
      state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
      cloudGraphHostName: ((_d = cacheRecord.account) == null ? void 0 : _d.cloudGraphHostName) || Constants.EMPTY_STRING,
      msGraphHost: ((_e = cacheRecord.account) == null ? void 0 : _e.msGraphHost) || Constants.EMPTY_STRING,
      code: serverTokenResponse == null ? void 0 : serverTokenResponse.spa_code,
      fromNativeBroker: false
    };
  }
};
function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {
  logger == null ? void 0 : logger.verbose("setCachedAccount called");
  const accountKeys = cacheStorage.getAccountKeys();
  const baseAccountKey = accountKeys.find((accountKey) => {
    return accountKey.startsWith(homeAccountId);
  });
  let cachedAccount = null;
  if (baseAccountKey) {
    cachedAccount = cacheStorage.getAccount(baseAccountKey);
  }
  const baseAccount = cachedAccount || AccountEntity.createAccount({
    homeAccountId,
    idTokenClaims,
    clientInfo,
    environment,
    cloudGraphHostName: authCodePayload == null ? void 0 : authCodePayload.cloud_graph_host_name,
    msGraphHost: authCodePayload == null ? void 0 : authCodePayload.msgraph_host,
    nativeAccountId
  }, authority, base64Decode);
  const tenantProfiles = baseAccount.tenantProfiles || [];
  const tenantId = claimsTenantId || baseAccount.realm;
  if (tenantId && !tenantProfiles.find((tenantProfile) => {
    return tenantProfile.tenantId === tenantId;
  })) {
    const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
    tenantProfiles.push(newTenantProfile);
  }
  baseAccount.tenantProfiles = tenantProfiles;
  return baseAccount;
}

// node_modules/@azure/msal-common/dist/request/RequestValidator.mjs
var RequestValidator = class {
  /**
   * Utility to check if the `redirectUri` in the request is a non-null value
   * @param redirectUri
   */
  static validateRedirectUri(redirectUri) {
    if (!redirectUri) {
      throw createClientConfigurationError(redirectUriEmpty);
    }
  }
  /**
   * Utility to validate prompt sent by the user in the request
   * @param prompt
   */
  static validatePrompt(prompt) {
    const promptValues = [];
    for (const value in PromptValue) {
      promptValues.push(PromptValue[value]);
    }
    if (promptValues.indexOf(prompt) < 0) {
      throw createClientConfigurationError(invalidPromptValue);
    }
  }
  static validateClaims(claims) {
    try {
      JSON.parse(claims);
    } catch (e) {
      throw createClientConfigurationError(invalidClaims);
    }
  }
  /**
   * Utility to validate code_challenge and code_challenge_method
   * @param codeChallenge
   * @param codeChallengeMethod
   */
  static validateCodeChallengeParams(codeChallenge, codeChallengeMethod) {
    if (!codeChallenge || !codeChallengeMethod) {
      throw createClientConfigurationError(pkceParamsMissing);
    } else {
      this.validateCodeChallengeMethod(codeChallengeMethod);
    }
  }
  /**
   * Utility to validate code_challenge_method
   * @param codeChallengeMethod
   */
  static validateCodeChallengeMethod(codeChallengeMethod) {
    if ([
      CodeChallengeMethodValues.PLAIN,
      CodeChallengeMethodValues.S256
    ].indexOf(codeChallengeMethod) < 0) {
      throw createClientConfigurationError(invalidCodeChallengeMethod);
    }
  }
};

// node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs
async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
  if (typeof clientAssertion === "string") {
    return clientAssertion;
  } else {
    const config2 = {
      clientId,
      tokenEndpoint
    };
    return clientAssertion(config2);
  }
}

// node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs
var AuthorizationCodeClient = class extends BaseClient {
  constructor(configuration, performanceClient) {
    var _a;
    super(configuration, performanceClient);
    this.includeRedirectUri = true;
    this.oidcDefaultScopes = (_a = this.config.authOptions.authority.options.OIDCOptions) == null ? void 0 : _a.defaultScopes;
  }
  /**
   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
   * authorization_code_grant
   * @param request
   */
  async acquireToken(request, authCodePayload) {
    var _a, _b;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
    if (!request.code) {
      throw createClientAuthError(requestCannotBeMade);
    }
    const reqTimestamp = nowSeconds();
    const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
    const requestId = (_b = response.headers) == null ? void 0 : _b[HeaderNames.X_MS_REQUEST_ID];
    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
    responseHandler.validateTokenResponse(response.body);
    return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, void 0, void 0, void 0, requestId);
  }
  /**
   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
   * Default behaviour is to redirect the user to `window.location.href`.
   * @param authorityUri
   */
  getLogoutUri(logoutRequest) {
    if (!logoutRequest) {
      throw createClientConfigurationError(logoutRequestEmpty);
    }
    const queryString = this.createLogoutUrlQueryString(logoutRequest);
    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
  }
  /**
   * Executes POST request to token endpoint
   * @param authority
   * @param request
   */
  async executeTokenRequest(authority, request) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
    const queryParametersString = this.createTokenQueryParameters(request);
    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
    const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
    let ccsCredential = void 0;
    if (request.clientInfo) {
      try {
        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
        ccsCredential = {
          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
          type: CcsCredentialType.HOME_ACCOUNT_ID
        };
      } catch (e) {
        this.logger.verbose("Could not parse client info for CCS Header: " + e);
      }
    }
    const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
    const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
    return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
  }
  /**
   * Generates a map for all the params to be sent to the service
   * @param request
   */
  async createTokenRequestBody(request) {
    var _a, _b;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
    const parameters = /* @__PURE__ */ new Map();
    addClientId(parameters, request.embeddedClientId || ((_b = request.tokenBodyParameters) == null ? void 0 : _b[CLIENT_ID]) || this.config.authOptions.clientId);
    if (!this.includeRedirectUri) {
      RequestValidator.validateRedirectUri(request.redirectUri);
    } else {
      addRedirectUri(parameters, request.redirectUri);
    }
    addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
    addAuthorizationCode(parameters, request.code);
    addLibraryInfo(parameters, this.config.libraryInfo);
    addApplicationTelemetry(parameters, this.config.telemetry.application);
    addThrottling(parameters);
    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
      addServerTelemetry(parameters, this.serverTelemetryManager);
    }
    if (request.codeVerifier) {
      addCodeVerifier(parameters, request.codeVerifier);
    }
    if (this.config.clientCredentials.clientSecret) {
      addClientSecret(parameters, this.config.clientCredentials.clientSecret);
    }
    if (this.config.clientCredentials.clientAssertion) {
      const clientAssertion = this.config.clientCredentials.clientAssertion;
      addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
      addClientAssertionType(parameters, clientAssertion.assertionType);
    }
    addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
    addClientInfo(parameters);
    if (request.authenticationScheme === AuthenticationScheme.POP) {
      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
      let reqCnfData;
      if (!request.popKid) {
        const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
        reqCnfData = generatedReqCnfData.reqCnfString;
      } else {
        reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
      }
      addPopToken(parameters, reqCnfData);
    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
      if (request.sshJwk) {
        addSshJwk(parameters, request.sshJwk);
      } else {
        throw createClientConfigurationError(missingSshJwk);
      }
    }
    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
    }
    let ccsCred = void 0;
    if (request.clientInfo) {
      try {
        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
        ccsCred = {
          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
          type: CcsCredentialType.HOME_ACCOUNT_ID
        };
      } catch (e) {
        this.logger.verbose("Could not parse client info for CCS Header: " + e);
      }
    } else {
      ccsCred = request.ccsCredential;
    }
    if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
      switch (ccsCred.type) {
        case CcsCredentialType.HOME_ACCOUNT_ID:
          try {
            const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
            addCcsOid(parameters, clientInfo);
          } catch (e) {
            this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
          }
          break;
        case CcsCredentialType.UPN:
          addCcsUpn(parameters, ccsCred.credential);
          break;
      }
    }
    if (request.embeddedClientId) {
      addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
    }
    if (request.tokenBodyParameters) {
      addExtraQueryParameters(parameters, request.tokenBodyParameters);
    }
    if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {
      addExtraQueryParameters(parameters, {
        [RETURN_SPA_CODE]: "1"
      });
    }
    instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
    return mapToQueryString(parameters);
  }
  /**
   * This API validates the `EndSessionRequest` and creates a URL
   * @param request
   */
  createLogoutUrlQueryString(request) {
    const parameters = /* @__PURE__ */ new Map();
    if (request.postLogoutRedirectUri) {
      addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
    }
    if (request.correlationId) {
      addCorrelationId(parameters, request.correlationId);
    }
    if (request.idTokenHint) {
      addIdTokenHint(parameters, request.idTokenHint);
    }
    if (request.state) {
      addState(parameters, request.state);
    }
    if (request.logoutHint) {
      addLogoutHint(parameters, request.logoutHint);
    }
    if (request.extraQueryParameters) {
      addExtraQueryParameters(parameters, request.extraQueryParameters);
    }
    if (this.config.authOptions.instanceAware) {
      addInstanceAware(parameters);
    }
    return mapToQueryString(parameters);
  }
};

// node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs
var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
var RefreshTokenClient = class extends BaseClient {
  constructor(configuration, performanceClient) {
    super(configuration, performanceClient);
  }
  async acquireToken(request) {
    var _a, _b;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
    const reqTimestamp = nowSeconds();
    const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
    const requestId = (_b = response.headers) == null ? void 0 : _b[HeaderNames.X_MS_REQUEST_ID];
    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
    responseHandler.validateTokenResponse(response.body);
    return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, void 0, void 0, true, request.forceCache, requestId);
  }
  /**
   * Gets cached refresh token and attaches to request, then calls acquireToken API
   * @param request
   */
  async acquireTokenByRefreshToken(request) {
    var _a;
    if (!request) {
      throw createClientConfigurationError(tokenRequestEmpty);
    }
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
    if (!request.account) {
      throw createClientAuthError(noAccountInSilentRequest);
    }
    const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
    if (isFOCI) {
      try {
        return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);
      } catch (e) {
        const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
        const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
        if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
          return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
        } else {
          throw e;
        }
      }
    }
    return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
  }
  /**
   * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
   * @param request
   */
  async acquireTokenWithCachedRefreshToken(request, foci) {
    var _a, _b, _c;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
    const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, void 0, this.performanceClient, request.correlationId);
    if (!refreshToken) {
      throw createInteractionRequiredAuthError(noTokensFound);
    }
    if (refreshToken.expiresOn && isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {
      (_b = this.performanceClient) == null ? void 0 : _b.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
      throw createInteractionRequiredAuthError(refreshTokenExpired);
    }
    const refreshTokenRequest = {
      ...request,
      refreshToken: refreshToken.secret,
      authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
      ccsCredential: {
        credential: request.account.homeAccountId,
        type: CcsCredentialType.HOME_ACCOUNT_ID
      }
    };
    try {
      return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);
    } catch (e) {
      if (e instanceof InteractionRequiredAuthError) {
        (_c = this.performanceClient) == null ? void 0 : _c.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
        if (e.subError === badToken) {
          this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
          const badRefreshTokenKey = generateCredentialKey(refreshToken);
          this.cacheManager.removeRefreshToken(badRefreshTokenKey);
        }
      }
      throw e;
    }
  }
  /**
   * Constructs the network message and makes a NW call to the underlying secure token service
   * @param request
   * @param authority
   */
  async executeTokenRequest(request, authority) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
    const queryParametersString = this.createTokenQueryParameters(request);
    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
    const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
    const headers = this.createTokenRequestHeaders(request.ccsCredential);
    const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
    return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
  }
  /**
   * Helper function to create the token request body
   * @param request
   */
  async createTokenRequestBody(request) {
    var _a, _b, _c;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
    const parameters = /* @__PURE__ */ new Map();
    addClientId(parameters, request.embeddedClientId || ((_b = request.tokenBodyParameters) == null ? void 0 : _b[CLIENT_ID]) || this.config.authOptions.clientId);
    if (request.redirectUri) {
      addRedirectUri(parameters, request.redirectUri);
    }
    addScopes(parameters, request.scopes, true, (_c = this.config.authOptions.authority.options.OIDCOptions) == null ? void 0 : _c.defaultScopes);
    addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
    addClientInfo(parameters);
    addLibraryInfo(parameters, this.config.libraryInfo);
    addApplicationTelemetry(parameters, this.config.telemetry.application);
    addThrottling(parameters);
    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
      addServerTelemetry(parameters, this.serverTelemetryManager);
    }
    addRefreshToken(parameters, request.refreshToken);
    if (this.config.clientCredentials.clientSecret) {
      addClientSecret(parameters, this.config.clientCredentials.clientSecret);
    }
    if (this.config.clientCredentials.clientAssertion) {
      const clientAssertion = this.config.clientCredentials.clientAssertion;
      addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
      addClientAssertionType(parameters, clientAssertion.assertionType);
    }
    if (request.authenticationScheme === AuthenticationScheme.POP) {
      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
      let reqCnfData;
      if (!request.popKid) {
        const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
        reqCnfData = generatedReqCnfData.reqCnfString;
      } else {
        reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
      }
      addPopToken(parameters, reqCnfData);
    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
      if (request.sshJwk) {
        addSshJwk(parameters, request.sshJwk);
      } else {
        throw createClientConfigurationError(missingSshJwk);
      }
    }
    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
    }
    if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
      switch (request.ccsCredential.type) {
        case CcsCredentialType.HOME_ACCOUNT_ID:
          try {
            const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
            addCcsOid(parameters, clientInfo);
          } catch (e) {
            this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
          }
          break;
        case CcsCredentialType.UPN:
          addCcsUpn(parameters, request.ccsCredential.credential);
          break;
      }
    }
    if (request.embeddedClientId) {
      addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
    }
    if (request.tokenBodyParameters) {
      addExtraQueryParameters(parameters, request.tokenBodyParameters);
    }
    instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
    return mapToQueryString(parameters);
  }
};

// node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs
var SilentFlowClient = class extends BaseClient {
  constructor(configuration, performanceClient) {
    super(configuration, performanceClient);
  }
  /**
   * Retrieves token from cache or throws an error if it must be refreshed.
   * @param request
   */
  async acquireCachedToken(request) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
    let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
    if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {
      this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
      throw createClientAuthError(tokenRefreshRequired);
    }
    if (!request.account) {
      throw createClientAuthError(noAccountInSilentRequest);
    }
    const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);
    const tokenKeys = this.cacheManager.getTokenKeys();
    const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId, this.performanceClient, request.correlationId);
    if (!cachedAccessToken) {
      this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
      throw createClientAuthError(tokenRefreshRequired);
    } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
      this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
      throw createClientAuthError(tokenRefreshRequired);
    } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
      lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
    }
    const environment = request.authority || this.authority.getPreferredCache();
    const cacheRecord = {
      account: this.cacheManager.readAccountFromCache(request.account),
      accessToken: cachedAccessToken,
      idToken: this.cacheManager.getIdToken(request.account, tokenKeys, requestTenantId, this.performanceClient, request.correlationId),
      refreshToken: null,
      appMetadata: this.cacheManager.readAppMetadataFromCache(environment)
    };
    this.setCacheOutcome(lastCacheOutcome, request.correlationId);
    if (this.config.serverTelemetryManager) {
      this.config.serverTelemetryManager.incrementCacheHits();
    }
    return [
      await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
      lastCacheOutcome
    ];
  }
  setCacheOutcome(cacheOutcome, correlationId) {
    var _a, _b;
    (_a = this.serverTelemetryManager) == null ? void 0 : _a.setCacheOutcome(cacheOutcome);
    (_b = this.performanceClient) == null ? void 0 : _b.addFields({
      cacheOutcome
    }, correlationId);
    if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
      this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
    }
  }
  /**
   * Helper function to build response object from the CacheRecord
   * @param cacheRecord
   */
  async generateResultFromCacheRecord(cacheRecord, request) {
    var _a;
    (_a = this.performanceClient) == null ? void 0 : _a.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
    let idTokenClaims;
    if (cacheRecord.idToken) {
      idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
    }
    if (request.maxAge || request.maxAge === 0) {
      const authTime = idTokenClaims == null ? void 0 : idTokenClaims.auth_time;
      if (!authTime) {
        throw createClientAuthError(authTimeNotFound);
      }
      checkMaxAge(authTime, request.maxAge);
    }
    return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
  }
};

// node_modules/@azure/msal-common/dist/protocol/Authorize.mjs
var Authorize_exports = {};
__export(Authorize_exports, {
  getAuthorizationCodePayload: () => getAuthorizationCodePayload,
  getAuthorizeUrl: () => getAuthorizeUrl,
  getStandardAuthorizeRequestParameters: () => getStandardAuthorizeRequestParameters,
  validateAuthorizationResponse: () => validateAuthorizationResponse
});
function getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {
  var _a, _b;
  const correlationId = request.correlationId;
  const parameters = /* @__PURE__ */ new Map();
  addClientId(parameters, request.embeddedClientId || ((_a = request.extraQueryParameters) == null ? void 0 : _a[CLIENT_ID]) || authOptions.clientId);
  const requestScopes = [
    ...request.scopes || [],
    ...request.extraScopesToConsent || []
  ];
  addScopes(parameters, requestScopes, true, (_b = authOptions.authority.options.OIDCOptions) == null ? void 0 : _b.defaultScopes);
  addRedirectUri(parameters, request.redirectUri);
  addCorrelationId(parameters, correlationId);
  addResponseMode(parameters, request.responseMode);
  addClientInfo(parameters);
  if (request.prompt) {
    addPrompt(parameters, request.prompt);
    performanceClient == null ? void 0 : performanceClient.addFields({ prompt: request.prompt }, correlationId);
  }
  if (request.domainHint) {
    addDomainHint(parameters, request.domainHint);
    performanceClient == null ? void 0 : performanceClient.addFields({ domainHintFromRequest: true }, correlationId);
  }
  if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
    if (request.sid && request.prompt === PromptValue.NONE) {
      logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
      addSid(parameters, request.sid);
      performanceClient == null ? void 0 : performanceClient.addFields({ sidFromRequest: true }, correlationId);
    } else if (request.account) {
      const accountSid = extractAccountSid(request.account);
      let accountLoginHintClaim = extractLoginHint(request.account);
      if (accountLoginHintClaim && request.domainHint) {
        logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
        accountLoginHintClaim = null;
      }
      if (accountLoginHintClaim) {
        logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
        addLoginHint(parameters, accountLoginHintClaim);
        performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      } else if (accountSid && request.prompt === PromptValue.NONE) {
        logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
        addSid(parameters, accountSid);
        performanceClient == null ? void 0 : performanceClient.addFields({ sidFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      } else if (request.loginHint) {
        logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
        addLoginHint(parameters, request.loginHint);
        addCcsUpn(parameters, request.loginHint);
        performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromRequest: true }, correlationId);
      } else if (request.account.username) {
        logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
        addLoginHint(parameters, request.account.username);
        performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromUpn: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      }
    } else if (request.loginHint) {
      logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
      addLoginHint(parameters, request.loginHint);
      addCcsUpn(parameters, request.loginHint);
      performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromRequest: true }, correlationId);
    }
  } else {
    logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
  }
  if (request.nonce) {
    addNonce(parameters, request.nonce);
  }
  if (request.state) {
    addState(parameters, request.state);
  }
  if (request.claims || authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0) {
    addClaims(parameters, request.claims, authOptions.clientCapabilities);
  }
  if (request.embeddedClientId) {
    addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
  }
  if (authOptions.instanceAware && (!request.extraQueryParameters || !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
    addInstanceAware(parameters);
  }
  return parameters;
}
function getAuthorizeUrl(authority, requestParameters) {
  const queryString = mapToQueryString(requestParameters);
  return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
}
function getAuthorizationCodePayload(serverParams, cachedState) {
  validateAuthorizationResponse(serverParams, cachedState);
  if (!serverParams.code) {
    throw createClientAuthError(authorizationCodeMissingFromServerResponse);
  }
  return serverParams;
}
function validateAuthorizationResponse(serverResponse, requestState) {
  if (!serverResponse.state || !requestState) {
    throw serverResponse.state ? createClientAuthError(stateNotFound, "Cached State") : createClientAuthError(stateNotFound, "Server State");
  }
  let decodedServerResponseState;
  let decodedRequestState;
  try {
    decodedServerResponseState = decodeURIComponent(serverResponse.state);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  try {
    decodedRequestState = decodeURIComponent(requestState);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  if (decodedServerResponseState !== decodedRequestState) {
    throw createClientAuthError(stateMismatch);
  }
  if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
    const serverErrorNo = parseServerErrorNo(serverResponse);
    if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
      throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);
    }
    throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);
  }
}
function parseServerErrorNo(serverResponse) {
  var _a, _b;
  const errorCodePrefix = "code=";
  const errorCodePrefixIndex = (_a = serverResponse.error_uri) == null ? void 0 : _a.lastIndexOf(errorCodePrefix);
  return errorCodePrefixIndex && errorCodePrefixIndex >= 0 ? (_b = serverResponse.error_uri) == null ? void 0 : _b.substring(errorCodePrefixIndex + errorCodePrefix.length) : void 0;
}
function extractAccountSid(account) {
  var _a;
  return ((_a = account.idTokenClaims) == null ? void 0 : _a.sid) || null;
}
function extractLoginHint(account) {
  var _a;
  return ((_a = account.idTokenClaims) == null ? void 0 : _a.login_hint) || null;
}

// node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs
var skuGroupSeparator = ",";
var skuValueSeparator = "|";
function makeExtraSkuString(params) {
  const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
  const skuMap = /* @__PURE__ */ new Map([
    [0, [libraryName, libraryVersion]],
    [2, [extensionName, extensionVersion]]
  ]);
  let skuArr = [];
  if (skus == null ? void 0 : skus.length) {
    skuArr = skus.split(skuGroupSeparator);
    if (skuArr.length < 4) {
      return skus;
    }
  } else {
    skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
  }
  skuMap.forEach((value, key) => {
    var _a, _b;
    if (value.length === 2 && ((_a = value[0]) == null ? void 0 : _a.length) && ((_b = value[1]) == null ? void 0 : _b.length)) {
      setSku({
        skuArr,
        index: key,
        skuName: value[0],
        skuVersion: value[1]
      });
    }
  });
  return skuArr.join(skuGroupSeparator);
}
function setSku(params) {
  const { skuArr, index, skuName, skuVersion } = params;
  if (index >= skuArr.length) {
    return;
  }
  skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);
}
var ServerTelemetryManager = class _ServerTelemetryManager {
  constructor(telemetryRequest, cacheManager) {
    this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
    this.cacheManager = cacheManager;
    this.apiId = telemetryRequest.apiId;
    this.correlationId = telemetryRequest.correlationId;
    this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
    this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
    this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
  }
  /**
   * API to add MSER Telemetry to request
   */
  generateCurrentRequestHeaderValue() {
    const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
    const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
    const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
    if (nativeBrokerErrorCode == null ? void 0 : nativeBrokerErrorCode.length) {
      platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
    }
    const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    const regionDiscoveryFields = this.getRegionDiscoveryFields();
    const requestWithRegionDiscoveryFields = [
      request,
      regionDiscoveryFields
    ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    return [
      SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
      requestWithRegionDiscoveryFields,
      platformFields
    ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
  }
  /**
   * API to add MSER Telemetry for the last failed request
   */
  generateLastRequestHeaderValue() {
    const lastRequests = this.getLastRequests();
    const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
    const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    const errorCount = lastRequests.errors.length;
    const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
    const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    return [
      SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
      lastRequests.cacheHits,
      failedRequests,
      errors,
      platformFields
    ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
  }
  /**
   * API to cache token failures for MSER data capture
   * @param error
   */
  cacheFailedRequest(error) {
    const lastRequests = this.getLastRequests();
    if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
      lastRequests.failedRequests.shift();
      lastRequests.failedRequests.shift();
      lastRequests.errors.shift();
    }
    lastRequests.failedRequests.push(this.apiId, this.correlationId);
    if (error instanceof Error && !!error && error.toString()) {
      if (error instanceof AuthError) {
        if (error.subError) {
          lastRequests.errors.push(error.subError);
        } else if (error.errorCode) {
          lastRequests.errors.push(error.errorCode);
        } else {
          lastRequests.errors.push(error.toString());
        }
      } else {
        lastRequests.errors.push(error.toString());
      }
    } else {
      lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
    }
    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
    return;
  }
  /**
   * Update server telemetry cache entry by incrementing cache hit counter
   */
  incrementCacheHits() {
    const lastRequests = this.getLastRequests();
    lastRequests.cacheHits += 1;
    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
    return lastRequests.cacheHits;
  }
  /**
   * Get the server telemetry entity from cache or initialize a new one
   */
  getLastRequests() {
    const initialValue = {
      failedRequests: [],
      errors: [],
      cacheHits: 0
    };
    const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
    return lastRequests || initialValue;
  }
  /**
   * Remove server telemetry cache entry
   */
  clearTelemetryCache() {
    const lastRequests = this.getLastRequests();
    const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
    const errorCount = lastRequests.errors.length;
    if (numErrorsFlushed === errorCount) {
      this.cacheManager.removeItem(this.telemetryCacheKey);
    } else {
      const serverTelemEntity = {
        failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
        errors: lastRequests.errors.slice(numErrorsFlushed),
        cacheHits: 0
      };
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
    }
  }
  /**
   * Returns the maximum number of errors that can be flushed to the server in the next network request
   * @param serverTelemetryEntity
   */
  static maxErrorsToSend(serverTelemetryEntity) {
    let i;
    let maxErrors = 0;
    let dataSize = 0;
    const errorCount = serverTelemetryEntity.errors.length;
    for (i = 0; i < errorCount; i++) {
      const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
      const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
      const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
      dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
      if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
        maxErrors += 1;
      } else {
        break;
      }
    }
    return maxErrors;
  }
  /**
   * Get the region discovery fields
   *
   * @returns string
   */
  getRegionDiscoveryFields() {
    const regionDiscoveryFields = [];
    regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
    regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
    regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
    return regionDiscoveryFields.join(",");
  }
  /**
   * Update the region discovery metadata
   *
   * @param regionDiscoveryMetadata
   * @returns void
   */
  updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
    this.regionUsed = regionDiscoveryMetadata.region_used;
    this.regionSource = regionDiscoveryMetadata.region_source;
    this.regionOutcome = regionDiscoveryMetadata.region_outcome;
  }
  /**
   * Set cache outcome
   */
  setCacheOutcome(cacheOutcome) {
    this.cacheOutcome = cacheOutcome;
  }
  setNativeBrokerErrorCode(errorCode) {
    const lastRequests = this.getLastRequests();
    lastRequests.nativeBrokerErrorCode = errorCode;
    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
  }
  getNativeBrokerErrorCode() {
    return this.getLastRequests().nativeBrokerErrorCode;
  }
  clearNativeBrokerErrorCode() {
    const lastRequests = this.getLastRequests();
    delete lastRequests.nativeBrokerErrorCode;
    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
  }
  static makeExtraSkuString(params) {
    return makeExtraSkuString(params);
  }
};

// node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs
var Deserializer = class {
  /**
   * Parse the JSON blob in memory and deserialize the content
   * @param cachedJson - JSON blob cache
   */
  static deserializeJSONBlob(jsonFile) {
    const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);
    return deserializedCache;
  }
  /**
   * Deserializes accounts to AccountEntity objects
   * @param accounts - accounts of type SerializedAccountEntity
   */
  static deserializeAccounts(accounts) {
    const accountObjects = {};
    if (accounts) {
      Object.keys(accounts).map(function(key) {
        var _a;
        const serializedAcc = accounts[key];
        const mappedAcc = {
          homeAccountId: serializedAcc.home_account_id,
          environment: serializedAcc.environment,
          realm: serializedAcc.realm,
          localAccountId: serializedAcc.local_account_id,
          username: serializedAcc.username,
          authorityType: serializedAcc.authority_type,
          name: serializedAcc.name,
          clientInfo: serializedAcc.client_info,
          lastModificationTime: serializedAcc.last_modification_time,
          lastModificationApp: serializedAcc.last_modification_app,
          tenantProfiles: (_a = serializedAcc.tenantProfiles) == null ? void 0 : _a.map((serializedTenantProfile) => {
            return JSON.parse(serializedTenantProfile);
          })
        };
        const account = new AccountEntity();
        CacheManager.toObject(account, mappedAcc);
        accountObjects[key] = account;
      });
    }
    return accountObjects;
  }
  /**
   * Deserializes id tokens to IdTokenEntity objects
   * @param idTokens - credentials of type SerializedIdTokenEntity
   */
  static deserializeIdTokens(idTokens) {
    const idObjects = {};
    if (idTokens) {
      Object.keys(idTokens).map(function(key) {
        const serializedIdT = idTokens[key];
        const idToken = {
          homeAccountId: serializedIdT.home_account_id,
          environment: serializedIdT.environment,
          credentialType: serializedIdT.credential_type,
          clientId: serializedIdT.client_id,
          secret: serializedIdT.secret,
          realm: serializedIdT.realm
        };
        idObjects[key] = idToken;
      });
    }
    return idObjects;
  }
  /**
   * Deserializes access tokens to AccessTokenEntity objects
   * @param accessTokens - access tokens of type SerializedAccessTokenEntity
   */
  static deserializeAccessTokens(accessTokens) {
    const atObjects = {};
    if (accessTokens) {
      Object.keys(accessTokens).map(function(key) {
        const serializedAT = accessTokens[key];
        const accessToken = {
          homeAccountId: serializedAT.home_account_id,
          environment: serializedAT.environment,
          credentialType: serializedAT.credential_type,
          clientId: serializedAT.client_id,
          secret: serializedAT.secret,
          realm: serializedAT.realm,
          target: serializedAT.target,
          cachedAt: serializedAT.cached_at,
          expiresOn: serializedAT.expires_on,
          extendedExpiresOn: serializedAT.extended_expires_on,
          refreshOn: serializedAT.refresh_on,
          keyId: serializedAT.key_id,
          tokenType: serializedAT.token_type,
          requestedClaims: serializedAT.requestedClaims,
          requestedClaimsHash: serializedAT.requestedClaimsHash,
          userAssertionHash: serializedAT.userAssertionHash
        };
        atObjects[key] = accessToken;
      });
    }
    return atObjects;
  }
  /**
   * Deserializes refresh tokens to RefreshTokenEntity objects
   * @param refreshTokens - refresh tokens of type SerializedRefreshTokenEntity
   */
  static deserializeRefreshTokens(refreshTokens) {
    const rtObjects = {};
    if (refreshTokens) {
      Object.keys(refreshTokens).map(function(key) {
        const serializedRT = refreshTokens[key];
        const refreshToken = {
          homeAccountId: serializedRT.home_account_id,
          environment: serializedRT.environment,
          credentialType: serializedRT.credential_type,
          clientId: serializedRT.client_id,
          secret: serializedRT.secret,
          familyId: serializedRT.family_id,
          target: serializedRT.target,
          realm: serializedRT.realm
        };
        rtObjects[key] = refreshToken;
      });
    }
    return rtObjects;
  }
  /**
   * Deserializes appMetadata to AppMetaData objects
   * @param appMetadata - app metadata of type SerializedAppMetadataEntity
   */
  static deserializeAppMetadata(appMetadata) {
    const appMetadataObjects = {};
    if (appMetadata) {
      Object.keys(appMetadata).map(function(key) {
        const serializedAmdt = appMetadata[key];
        appMetadataObjects[key] = {
          clientId: serializedAmdt.client_id,
          environment: serializedAmdt.environment,
          familyId: serializedAmdt.family_id
        };
      });
    }
    return appMetadataObjects;
  }
  /**
   * Deserialize an inMemory Cache
   * @param jsonCache - JSON blob cache
   */
  static deserializeAllCache(jsonCache) {
    return {
      accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
      idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
      accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
      refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
      appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
    };
  }
};

// node_modules/@azure/msal-node/dist/utils/Constants.mjs
var MANAGED_IDENTITY_DEFAULT_TENANT = "managed_identity";
var DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = `https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`;
var ManagedIdentityEnvironmentVariableNames = {
  AZURE_POD_IDENTITY_AUTHORITY_HOST: "AZURE_POD_IDENTITY_AUTHORITY_HOST",
  IDENTITY_ENDPOINT: "IDENTITY_ENDPOINT",
  IDENTITY_HEADER: "IDENTITY_HEADER",
  IDENTITY_SERVER_THUMBPRINT: "IDENTITY_SERVER_THUMBPRINT",
  IMDS_ENDPOINT: "IMDS_ENDPOINT",
  MSI_ENDPOINT: "MSI_ENDPOINT",
  MSI_SECRET: "MSI_SECRET"
};
var ManagedIdentityIdType = {
  SYSTEM_ASSIGNED: "system-assigned",
  USER_ASSIGNED_CLIENT_ID: "user-assigned-client-id",
  USER_ASSIGNED_RESOURCE_ID: "user-assigned-resource-id",
  USER_ASSIGNED_OBJECT_ID: "user-assigned-object-id"
};
var HttpMethod = {
  GET: "get",
  POST: "post"
};
var ProxyStatus = {
  SUCCESS: HttpStatus.SUCCESS,
  SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,
  SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,
  SERVER_ERROR: HttpStatus.SERVER_ERROR
};
var REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
var MSAL_FORCE_REGION = "MSAL_FORCE_REGION";
var RANDOM_OCTET_SIZE = 32;
var Hash = {
  SHA256: "sha256"
};
var CharSet = {
  CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
};
var Constants2 = {
  MSAL_SKU: "msal.js.node",
  JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
  AUTHORIZATION_PENDING: "authorization_pending",
  HTTP_PROTOCOL: "http://",
  LOCALHOST: "localhost"
};
var ApiId = {
  acquireTokenSilent: 62,
  acquireTokenByUsernamePassword: 371,
  acquireTokenByDeviceCode: 671,
  acquireTokenByClientCredential: 771,
  acquireTokenByCode: 871,
  acquireTokenByRefreshToken: 872
};
var JwtConstants = {
  ALGORITHM: "alg",
  RSA_256: "RS256",
  PSS_256: "PS256",
  X5T_256: "x5t#S256",
  X5T: "x5t",
  X5C: "x5c",
  AUDIENCE: "aud",
  EXPIRATION_TIME: "exp",
  ISSUER: "iss",
  SUBJECT: "sub",
  NOT_BEFORE: "nbf",
  JWT_ID: "jti"
};
var MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON = [
  HttpStatus.NOT_FOUND,
  HttpStatus.REQUEST_TIMEOUT,
  HttpStatus.TOO_MANY_REQUESTS,
  HttpStatus.SERVER_ERROR,
  HttpStatus.SERVICE_UNAVAILABLE,
  HttpStatus.GATEWAY_TIMEOUT
];

// node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs
var NetworkUtils = class {
  static getNetworkResponse(headers, body, statusCode) {
    return {
      headers,
      body,
      status: statusCode
    };
  }
  /*
   * Utility function that converts a URL object into an ordinary options object as expected by the
   * http.request and https.request APIs.
   * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090
   */
  static urlToHttpOptions(url) {
    const options = {
      protocol: url.protocol,
      hostname: url.hostname && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
      hash: url.hash,
      search: url.search,
      pathname: url.pathname,
      path: `${url.pathname || ""}${url.search || ""}`,
      href: url.href
    };
    if (url.port !== "") {
      options.port = Number(url.port);
    }
    if (url.username || url.password) {
      options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;
    }
    return options;
  }
};

// node_modules/@azure/msal-node/dist/network/HttpClient.mjs
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var HttpClient = class {
  constructor(proxyUrl, customAgentOptions) {
    this.proxyUrl = proxyUrl || "";
    this.customAgentOptions = customAgentOptions || {};
  }
  /**
   * Http Get request
   * @param url
   * @param options
   */
  async sendGetRequestAsync(url, options, timeout) {
    if (this.proxyUrl) {
      return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.GET, options, this.customAgentOptions, timeout);
    } else {
      return networkRequestViaHttps(url, HttpMethod.GET, options, this.customAgentOptions, timeout);
    }
  }
  /**
   * Http Post request
   * @param url
   * @param options
   */
  async sendPostRequestAsync(url, options) {
    if (this.proxyUrl) {
      return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.POST, options, this.customAgentOptions);
    } else {
      return networkRequestViaHttps(url, HttpMethod.POST, options, this.customAgentOptions);
    }
  }
};
var networkRequestViaProxy = (destinationUrlString, proxyUrlString, httpMethod, options, agentOptions, timeout) => {
  const destinationUrl = new URL(destinationUrlString);
  const proxyUrl = new URL(proxyUrlString);
  const headers = (options == null ? void 0 : options.headers) || {};
  const tunnelRequestOptions = {
    host: proxyUrl.hostname,
    port: proxyUrl.port,
    method: "CONNECT",
    path: destinationUrl.hostname,
    headers
  };
  if (agentOptions && Object.keys(agentOptions).length) {
    tunnelRequestOptions.agent = new import_http.default.Agent(agentOptions);
  }
  let postRequestStringContent = "";
  if (httpMethod === HttpMethod.POST) {
    const body = (options == null ? void 0 : options.body) || "";
    postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
  } else {
    if (timeout) {
      tunnelRequestOptions.timeout = timeout;
    }
  }
  const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
  return new Promise((resolve, reject) => {
    const request = import_http.default.request(tunnelRequestOptions);
    if (timeout) {
      request.on("timeout", () => {
        request.destroy();
        reject(new Error("Request time out"));
      });
    }
    request.end();
    request.on("connect", (response, socket) => {
      const proxyStatusCode = (response == null ? void 0 : response.statusCode) || ProxyStatus.SERVER_ERROR;
      if (proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START || proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END) {
        request.destroy();
        socket.destroy();
        reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${(response == null ? void 0 : response.statusMessage) || "Unknown"}`));
      }
      socket.write(outgoingRequestString);
      const data = [];
      socket.on("data", (chunk) => {
        data.push(chunk);
      });
      socket.on("end", () => {
        const dataString = Buffer.concat([...data]).toString();
        const dataStringArray = dataString.split("\r\n");
        const httpStatusCode = parseInt(dataStringArray[0].split(" ")[1]);
        const statusMessage = dataStringArray[0].split(" ").slice(2).join(" ");
        const body = dataStringArray[dataStringArray.length - 1];
        const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
        const entries = /* @__PURE__ */ new Map();
        headersArray.forEach((header) => {
          const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
          const headerKey = headerKeyValue[0];
          let headerValue = headerKeyValue[1];
          try {
            const object = JSON.parse(headerValue);
            if (object && typeof object === "object") {
              headerValue = object;
            }
          } catch (e) {
          }
          entries.set(headerKey, headerValue);
        });
        const headers2 = Object.fromEntries(entries);
        const parsedHeaders = headers2;
        const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(httpStatusCode, statusMessage, parsedHeaders, body), httpStatusCode);
        if ((httpStatusCode < HttpStatus.SUCCESS_RANGE_START || httpStatusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
        networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
          request.destroy();
        }
        resolve(networkResponse);
      });
      socket.on("error", (chunk) => {
        request.destroy();
        socket.destroy();
        reject(new Error(chunk.toString()));
      });
    });
    request.on("error", (chunk) => {
      request.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};
var networkRequestViaHttps = (urlString, httpMethod, options, agentOptions, timeout) => {
  const isPostRequest = httpMethod === HttpMethod.POST;
  const body = (options == null ? void 0 : options.body) || "";
  const url = new URL(urlString);
  const headers = (options == null ? void 0 : options.headers) || {};
  const customOptions = {
    method: httpMethod,
    headers,
    ...NetworkUtils.urlToHttpOptions(url)
  };
  if (agentOptions && Object.keys(agentOptions).length) {
    customOptions.agent = new import_https.default.Agent(agentOptions);
  }
  if (isPostRequest) {
    customOptions.headers = {
      ...customOptions.headers,
      "Content-Length": body.length
    };
  } else {
    if (timeout) {
      customOptions.timeout = timeout;
    }
  }
  return new Promise((resolve, reject) => {
    let request;
    if (customOptions.protocol === "http:") {
      request = import_http.default.request(customOptions);
    } else {
      request = import_https.default.request(customOptions);
    }
    if (isPostRequest) {
      request.write(body);
    }
    if (timeout) {
      request.on("timeout", () => {
        request.destroy();
        reject(new Error("Request time out"));
      });
    }
    request.end();
    request.on("response", (response) => {
      const headers2 = response.headers;
      const statusCode = response.statusCode;
      const statusMessage = response.statusMessage;
      const data = [];
      response.on("data", (chunk) => {
        data.push(chunk);
      });
      response.on("end", () => {
        const body2 = Buffer.concat([...data]).toString();
        const parsedHeaders = headers2;
        const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(statusCode, statusMessage, parsedHeaders, body2), statusCode);
        if ((statusCode < HttpStatus.SUCCESS_RANGE_START || statusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
        networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
          request.destroy();
        }
        resolve(networkResponse);
      });
    });
    request.on("error", (chunk) => {
      request.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};
var parseBody = (statusCode, statusMessage, headers, body) => {
  let parsedBody;
  try {
    parsedBody = JSON.parse(body);
  } catch (error) {
    let errorType;
    let errorDescriptionHelper;
    if (statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START && statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END) {
      errorType = "client_error";
      errorDescriptionHelper = "A client";
    } else if (statusCode >= HttpStatus.SERVER_ERROR_RANGE_START && statusCode <= HttpStatus.SERVER_ERROR_RANGE_END) {
      errorType = "server_error";
      errorDescriptionHelper = "A server";
    } else {
      errorType = "unknown_error";
      errorDescriptionHelper = "An unknown";
    }
    parsedBody = {
      error: errorType,
      error_description: `${errorDescriptionHelper} error occured.
Http status code: ${statusCode}
Http status message: ${statusMessage || "Unknown"}
Headers: ${JSON.stringify(headers)}`
    };
  }
  return parsedBody;
};

// node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs
var invalidFileExtension = "invalid_file_extension";
var invalidFilePath = "invalid_file_path";
var invalidManagedIdentityIdType = "invalid_managed_identity_id_type";
var invalidSecret = "invalid_secret";
var missingId = "missing_client_id";
var networkUnavailable = "network_unavailable";
var platformNotSupported = "platform_not_supported";
var unableToCreateAzureArc = "unable_to_create_azure_arc";
var unableToCreateCloudShell = "unable_to_create_cloud_shell";
var unableToCreateSource = "unable_to_create_source";
var unableToReadSecretFile = "unable_to_read_secret_file";
var userAssignedNotAvailableAtRuntime = "user_assigned_not_available_at_runtime";
var wwwAuthenticateHeaderMissing = "www_authenticate_header_missing";
var wwwAuthenticateHeaderUnsupportedFormat = "www_authenticate_header_unsupported_format";
var MsiEnvironmentVariableUrlMalformedErrorCodes = {
  [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]: "azure_pod_identity_authority_host_url_malformed",
  [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]: "identity_endpoint_url_malformed",
  [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]: "imds_endpoint_url_malformed",
  [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]: "msi_endpoint_url_malformed"
};

// node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs
var ManagedIdentityErrorMessages = {
  [invalidFileExtension]: "The file path in the WWW-Authenticate header does not contain a .key file.",
  [invalidFilePath]: "The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.",
  [invalidManagedIdentityIdType]: "More than one ManagedIdentityIdType was provided.",
  [invalidSecret]: "The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.",
  [platformNotSupported]: "The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.",
  [missingId]: "A ManagedIdentityId id was not provided.",
  [MsiEnvironmentVariableUrlMalformedErrorCodes.AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}' environment variable is malformed.`,
  [MsiEnvironmentVariableUrlMalformedErrorCodes.IDENTITY_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variable is malformed.`,
  [MsiEnvironmentVariableUrlMalformedErrorCodes.IMDS_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' environment variable is malformed.`,
  [MsiEnvironmentVariableUrlMalformedErrorCodes.MSI_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' environment variable is malformed.`,
  [networkUnavailable]: "Authentication unavailable. The request to the managed identity endpoint timed out.",
  [unableToCreateAzureArc]: "Azure Arc Managed Identities can only be system assigned.",
  [unableToCreateCloudShell]: "Cloud Shell Managed Identities can only be system assigned.",
  [unableToCreateSource]: "Unable to create a Managed Identity source based on environment variables.",
  [unableToReadSecretFile]: "Unable to read the secret file.",
  [userAssignedNotAvailableAtRuntime]: "Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.",
  [wwwAuthenticateHeaderMissing]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.",
  [wwwAuthenticateHeaderUnsupportedFormat]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format."
};
var ManagedIdentityError = class _ManagedIdentityError extends AuthError {
  constructor(errorCode) {
    super(errorCode, ManagedIdentityErrorMessages[errorCode]);
    this.name = "ManagedIdentityError";
    Object.setPrototypeOf(this, _ManagedIdentityError.prototype);
  }
};
function createManagedIdentityError(errorCode) {
  return new ManagedIdentityError(errorCode);
}

// node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs
var NodeAuthErrorMessage = {
  invalidLoopbackAddressType: {
    code: "invalid_loopback_server_address_type",
    desc: "Loopback server address is not type string. This is unexpected."
  },
  unableToLoadRedirectUri: {
    code: "unable_to_load_redirectUrl",
    desc: "Loopback server callback was invoked without a url. This is unexpected."
  },
  noAuthCodeInResponse: {
    code: "no_auth_code_in_response",
    desc: "No auth code found in the server response. Please check your network trace to determine what happened."
  },
  noLoopbackServerExists: {
    code: "no_loopback_server_exists",
    desc: "No loopback server exists yet."
  },
  loopbackServerAlreadyExists: {
    code: "loopback_server_already_exists",
    desc: "Loopback server already exists. Cannot create another."
  },
  loopbackServerTimeout: {
    code: "loopback_server_timeout",
    desc: "Timed out waiting for auth code listener to be registered."
  },
  stateNotFoundError: {
    code: "state_not_found",
    desc: "State not found. Please verify that the request originated from msal."
  },
  thumbprintMissing: {
    code: "thumbprint_missing_from_client_certificate",
    desc: "Client certificate does not contain a SHA-1 or SHA-256 thumbprint."
  }
};
var NodeAuthError = class _NodeAuthError extends AuthError {
  constructor(errorCode, errorMessage) {
    super(errorCode, errorMessage);
    this.name = "NodeAuthError";
  }
  /**
   * Creates an error thrown if loopback server address is of type string.
   */
  static createInvalidLoopbackAddressTypeError() {
    return new _NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server is unable to get a url.
   */
  static createUnableToLoadRedirectUrlError() {
    return new _NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
  }
  /**
   * Creates an error thrown if the server response does not contain an auth code.
   */
  static createNoAuthCodeInResponseError() {
    return new _NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server has not been spun up yet.
   */
  static createNoLoopbackServerExistsError() {
    return new _NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
  }
  /**
   * Creates an error thrown if a loopback server already exists when attempting to create another one.
   */
  static createLoopbackServerAlreadyExistsError() {
    return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server times out registering the auth code listener.
   */
  static createLoopbackServerTimeoutError() {
    return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
  }
  /**
   * Creates an error thrown when the state is not present.
   */
  static createStateNotFoundError() {
    return new _NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
  }
  /**
   * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided
   */
  static createThumbprintMissingError() {
    return new _NodeAuthError(NodeAuthErrorMessage.thumbprintMissing.code, NodeAuthErrorMessage.thumbprintMissing.desc);
  }
};

// node_modules/@azure/msal-node/dist/config/Configuration.mjs
var DEFAULT_AUTH_OPTIONS = {
  clientId: Constants.EMPTY_STRING,
  authority: Constants.DEFAULT_AUTHORITY,
  clientSecret: Constants.EMPTY_STRING,
  clientAssertion: Constants.EMPTY_STRING,
  clientCertificate: {
    thumbprint: Constants.EMPTY_STRING,
    thumbprintSha256: Constants.EMPTY_STRING,
    privateKey: Constants.EMPTY_STRING,
    x5c: Constants.EMPTY_STRING
  },
  knownAuthorities: [],
  cloudDiscoveryMetadata: Constants.EMPTY_STRING,
  authorityMetadata: Constants.EMPTY_STRING,
  clientCapabilities: [],
  protocolMode: ProtocolMode.AAD,
  azureCloudOptions: {
    azureCloudInstance: AzureCloudInstance.None,
    tenant: Constants.EMPTY_STRING
  },
  skipAuthorityMetadataCache: false
};
var DEFAULT_CACHE_OPTIONS2 = {
  claimsBasedCachingEnabled: false
};
var DEFAULT_LOGGER_OPTIONS = {
  loggerCallback: () => {
  },
  piiLoggingEnabled: false,
  logLevel: LogLevel.Info
};
var DEFAULT_SYSTEM_OPTIONS2 = {
  loggerOptions: DEFAULT_LOGGER_OPTIONS,
  networkClient: new HttpClient(),
  proxyUrl: Constants.EMPTY_STRING,
  customAgentOptions: {},
  disableInternalRetries: false
};
var DEFAULT_TELEMETRY_OPTIONS2 = {
  application: {
    appName: Constants.EMPTY_STRING,
    appVersion: Constants.EMPTY_STRING
  }
};
function buildAppConfiguration({ auth, broker, cache, system, telemetry }) {
  const systemOptions = {
    ...DEFAULT_SYSTEM_OPTIONS2,
    networkClient: new HttpClient(system == null ? void 0 : system.proxyUrl, system == null ? void 0 : system.customAgentOptions),
    loggerOptions: (system == null ? void 0 : system.loggerOptions) || DEFAULT_LOGGER_OPTIONS,
    disableInternalRetries: (system == null ? void 0 : system.disableInternalRetries) || false
  };
  if (!!auth.clientCertificate && !!!auth.clientCertificate.thumbprint && !!!auth.clientCertificate.thumbprintSha256) {
    throw NodeAuthError.createStateNotFoundError();
  }
  return {
    auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },
    broker: { ...broker },
    cache: { ...DEFAULT_CACHE_OPTIONS2, ...cache },
    system: { ...systemOptions, ...system },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS2, ...telemetry }
  };
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs
var GuidGenerator = class {
  /**
   *
   * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
   * uuidv4 generates guids from cryprtographically-string random
   */
  generateGuid() {
    return v4_default();
  }
  /**
   * verifies if a string is  GUID
   * @param guid
   */
  isGuid(guid) {
    const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return regexGuid.test(guid);
  }
};

// node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs
var EncodingUtils = class _EncodingUtils {
  /**
   * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
   * 'base64': Base64 encoding.
   *
   * @param str text
   */
  static base64Encode(str, encoding) {
    return Buffer.from(str, encoding).toString("base64");
  }
  /**
   * encode a URL
   * @param str
   */
  static base64EncodeUrl(str, encoding) {
    return _EncodingUtils.base64Encode(str, encoding).replace(/=/g, Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
  }
  /**
   * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
   * 'base64': Base64 encoding.
   *
   * @param base64Str Base64 encoded text
   */
  static base64Decode(base64Str) {
    return Buffer.from(base64Str, "base64").toString("utf8");
  }
  /**
   * @param base64Str Base64 encoded Url
   */
  static base64DecodeUrl(base64Str) {
    let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
    while (str.length % 4) {
      str += "=";
    }
    return _EncodingUtils.base64Decode(str);
  }
};

// node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs
var import_crypto = __toESM(require("crypto"), 1);
var HashUtils = class {
  /**
   * generate 'SHA256' hash
   * @param buffer
   */
  sha256(buffer) {
    return import_crypto.default.createHash(Hash.SHA256).update(buffer).digest();
  }
};

// node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs
var import_crypto2 = __toESM(require("crypto"), 1);
var PkceGenerator = class {
  constructor() {
    this.hashUtils = new HashUtils();
  }
  /**
   * generates the codeVerfier and the challenge from the codeVerfier
   * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
   */
  async generatePkceCodes() {
    const verifier = this.generateCodeVerifier();
    const challenge = this.generateCodeChallengeFromVerifier(verifier);
    return { verifier, challenge };
  }
  /**
   * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
   */
  generateCodeVerifier() {
    const charArr = [];
    const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
    while (charArr.length <= RANDOM_OCTET_SIZE) {
      const byte = import_crypto2.default.randomBytes(1)[0];
      if (byte >= maxNumber) {
        continue;
      }
      const index = byte % CharSet.CV_CHARSET.length;
      charArr.push(CharSet.CV_CHARSET[index]);
    }
    const verifier = charArr.join(Constants.EMPTY_STRING);
    return EncodingUtils.base64EncodeUrl(verifier);
  }
  /**
   * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
   * @param codeVerifier
   */
  generateCodeChallengeFromVerifier(codeVerifier) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString("base64"), "base64");
  }
};

// node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs
var CryptoProvider = class {
  constructor() {
    this.pkceGenerator = new PkceGenerator();
    this.guidGenerator = new GuidGenerator();
    this.hashUtils = new HashUtils();
  }
  /**
   * base64 URL safe encoded string
   */
  base64UrlEncode() {
    throw new Error("Method not implemented.");
  }
  /**
   * Stringifies and base64Url encodes input public key
   * @param inputKid - public key id
   * @returns Base64Url encoded public key
   */
  encodeKid() {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a new random GUID - used to populate state and nonce.
   * @returns string (GUID)
   */
  createNewGuid() {
    return this.guidGenerator.generateGuid();
  }
  /**
   * Encodes input string to base64.
   * @param input - string to be encoded
   */
  base64Encode(input) {
    return EncodingUtils.base64Encode(input);
  }
  /**
   * Decodes input string from base64.
   * @param input - string to be decoded
   */
  base64Decode(input) {
    return EncodingUtils.base64Decode(input);
  }
  /**
   * Generates PKCE codes used in Authorization Code Flow.
   */
  generatePkceCodes() {
    return this.pkceGenerator.generatePkceCodes();
  }
  /**
   * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
   */
  getPublicKeyThumbprint() {
    throw new Error("Method not implemented.");
  }
  /**
   * Removes cryptographic keypair from key store matching the keyId passed in
   * @param kid - public key id
   */
  removeTokenBindingKey() {
    throw new Error("Method not implemented.");
  }
  /**
   * Removes all cryptographic keys from Keystore
   */
  clearKeystore() {
    throw new Error("Method not implemented.");
  }
  /**
   * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
   */
  signJwt() {
    throw new Error("Method not implemented.");
  }
  /**
   * Returns the SHA-256 hash of an input string
   */
  async hashString(plainText) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString("base64"), "base64");
  }
};

// node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs
var NodeStorage = class extends CacheManager {
  constructor(logger, clientId, cryptoImpl, staticAuthorityOptions) {
    super(clientId, cryptoImpl, logger, staticAuthorityOptions);
    this.cache = {};
    this.changeEmitters = [];
    this.logger = logger;
  }
  /**
   * Queue up callbacks
   * @param func - a callback function for cache change indication
   */
  registerChangeEmitter(func) {
    this.changeEmitters.push(func);
  }
  /**
   * Invoke the callback when cache changes
   */
  emitChange() {
    this.changeEmitters.forEach((func) => func.call(null));
  }
  /**
   * Converts cacheKVStore to InMemoryCache
   * @param cache - key value store
   */
  cacheToInMemoryCache(cache) {
    const inMemoryCache = {
      accounts: {},
      idTokens: {},
      accessTokens: {},
      refreshTokens: {},
      appMetadata: {}
    };
    for (const key in cache) {
      const value = cache[key];
      if (typeof value !== "object") {
        continue;
      }
      if (value instanceof AccountEntity) {
        inMemoryCache.accounts[key] = value;
      } else if (CacheHelpers_exports.isIdTokenEntity(value)) {
        inMemoryCache.idTokens[key] = value;
      } else if (CacheHelpers_exports.isAccessTokenEntity(value)) {
        inMemoryCache.accessTokens[key] = value;
      } else if (CacheHelpers_exports.isRefreshTokenEntity(value)) {
        inMemoryCache.refreshTokens[key] = value;
      } else if (CacheHelpers_exports.isAppMetadataEntity(key, value)) {
        inMemoryCache.appMetadata[key] = value;
      } else {
        continue;
      }
    }
    return inMemoryCache;
  }
  /**
   * converts inMemoryCache to CacheKVStore
   * @param inMemoryCache - kvstore map for inmemory
   */
  inMemoryCacheToCache(inMemoryCache) {
    let cache = this.getCache();
    cache = {
      ...cache,
      ...inMemoryCache.accounts,
      ...inMemoryCache.idTokens,
      ...inMemoryCache.accessTokens,
      ...inMemoryCache.refreshTokens,
      ...inMemoryCache.appMetadata
    };
    return cache;
  }
  /**
   * gets the current in memory cache for the client
   */
  getInMemoryCache() {
    this.logger.trace("Getting in-memory cache");
    const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
    return inMemoryCache;
  }
  /**
   * sets the current in memory cache for the client
   * @param inMemoryCache - key value map in memory
   */
  setInMemoryCache(inMemoryCache) {
    this.logger.trace("Setting in-memory cache");
    const cache = this.inMemoryCacheToCache(inMemoryCache);
    this.setCache(cache);
    this.emitChange();
  }
  /**
   * get the current cache key-value store
   */
  getCache() {
    this.logger.trace("Getting cache key-value store");
    return this.cache;
  }
  /**
   * sets the current cache (key value store)
   * @param cacheMap - key value map
   */
  setCache(cache) {
    this.logger.trace("Setting cache key value store");
    this.cache = cache;
    this.emitChange();
  }
  /**
   * Gets cache item with given key.
   * @param key - lookup key for the cache entry
   */
  getItem(key) {
    this.logger.tracePii(`Item key: ${key}`);
    const cache = this.getCache();
    return cache[key];
  }
  /**
   * Gets cache item with given key-value
   * @param key - lookup key for the cache entry
   * @param value - value of the cache entry
   */
  setItem(key, value) {
    this.logger.tracePii(`Item key: ${key}`);
    const cache = this.getCache();
    cache[key] = value;
    this.setCache(cache);
  }
  getAccountKeys() {
    const inMemoryCache = this.getInMemoryCache();
    const accountKeys = Object.keys(inMemoryCache.accounts);
    return accountKeys;
  }
  getTokenKeys() {
    const inMemoryCache = this.getInMemoryCache();
    const tokenKeys = {
      idToken: Object.keys(inMemoryCache.idTokens),
      accessToken: Object.keys(inMemoryCache.accessTokens),
      refreshToken: Object.keys(inMemoryCache.refreshTokens)
    };
    return tokenKeys;
  }
  /**
   * Reads account from cache, builds it into an account entity and returns it.
   * @param accountKey - lookup key to fetch cache type AccountEntity
   * @returns
   */
  getAccount(accountKey) {
    const cachedAccount = this.getItem(accountKey);
    return cachedAccount ? Object.assign(new AccountEntity(), this.getItem(accountKey)) : null;
  }
  /**
   * set account entity
   * @param account - cache value to be set of type AccountEntity
   */
  async setAccount(account) {
    const accountKey = account.generateAccountKey();
    this.setItem(accountKey, account);
  }
  /**
   * fetch the idToken credential
   * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
   */
  getIdTokenCredential(idTokenKey) {
    const idToken = this.getItem(idTokenKey);
    if (CacheHelpers_exports.isIdTokenEntity(idToken)) {
      return idToken;
    }
    return null;
  }
  /**
   * set idToken credential
   * @param idToken - cache value to be set of type IdTokenEntity
   */
  async setIdTokenCredential(idToken) {
    const idTokenKey = CacheHelpers_exports.generateCredentialKey(idToken);
    this.setItem(idTokenKey, idToken);
  }
  /**
   * fetch the accessToken credential
   * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
   */
  getAccessTokenCredential(accessTokenKey) {
    const accessToken = this.getItem(accessTokenKey);
    if (CacheHelpers_exports.isAccessTokenEntity(accessToken)) {
      return accessToken;
    }
    return null;
  }
  /**
   * set accessToken credential
   * @param accessToken -  cache value to be set of type AccessTokenEntity
   */
  async setAccessTokenCredential(accessToken) {
    const accessTokenKey = CacheHelpers_exports.generateCredentialKey(accessToken);
    this.setItem(accessTokenKey, accessToken);
  }
  /**
   * fetch the refreshToken credential
   * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
   */
  getRefreshTokenCredential(refreshTokenKey) {
    const refreshToken = this.getItem(refreshTokenKey);
    if (CacheHelpers_exports.isRefreshTokenEntity(refreshToken)) {
      return refreshToken;
    }
    return null;
  }
  /**
   * set refreshToken credential
   * @param refreshToken - cache value to be set of type RefreshTokenEntity
   */
  async setRefreshTokenCredential(refreshToken) {
    const refreshTokenKey = CacheHelpers_exports.generateCredentialKey(refreshToken);
    this.setItem(refreshTokenKey, refreshToken);
  }
  /**
   * fetch appMetadata entity from the platform cache
   * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
   */
  getAppMetadata(appMetadataKey) {
    const appMetadata = this.getItem(appMetadataKey);
    if (CacheHelpers_exports.isAppMetadataEntity(appMetadataKey, appMetadata)) {
      return appMetadata;
    }
    return null;
  }
  /**
   * set appMetadata entity to the platform cache
   * @param appMetadata - cache value to be set of type AppMetadataEntity
   */
  setAppMetadata(appMetadata) {
    const appMetadataKey = CacheHelpers_exports.generateAppMetadataKey(appMetadata);
    this.setItem(appMetadataKey, appMetadata);
  }
  /**
   * fetch server telemetry entity from the platform cache
   * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
   */
  getServerTelemetry(serverTelemetrykey) {
    const serverTelemetryEntity = this.getItem(serverTelemetrykey);
    if (serverTelemetryEntity && CacheHelpers_exports.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
      return serverTelemetryEntity;
    }
    return null;
  }
  /**
   * set server telemetry entity to the platform cache
   * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
   * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
   */
  setServerTelemetry(serverTelemetryKey, serverTelemetry) {
    this.setItem(serverTelemetryKey, serverTelemetry);
  }
  /**
   * fetch authority metadata entity from the platform cache
   * @param key - lookup key to fetch cache type AuthorityMetadataEntity
   */
  getAuthorityMetadata(key) {
    const authorityMetadataEntity = this.getItem(key);
    if (authorityMetadataEntity && CacheHelpers_exports.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
      return authorityMetadataEntity;
    }
    return null;
  }
  /**
   * Get all authority metadata keys
   */
  getAuthorityMetadataKeys() {
    return this.getKeys().filter((key) => {
      return this.isAuthorityMetadata(key);
    });
  }
  /**
   * set authority metadata entity to the platform cache
   * @param key - lookup key to fetch cache type AuthorityMetadataEntity
   * @param metadata - cache value to be set of type AuthorityMetadataEntity
   */
  setAuthorityMetadata(key, metadata) {
    this.setItem(key, metadata);
  }
  /**
   * fetch throttling entity from the platform cache
   * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
   */
  getThrottlingCache(throttlingCacheKey) {
    const throttlingCache = this.getItem(throttlingCacheKey);
    if (throttlingCache && CacheHelpers_exports.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
      return throttlingCache;
    }
    return null;
  }
  /**
   * set throttling entity to the platform cache
   * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
   * @param throttlingCache - cache value to be set of type ThrottlingEntity
   */
  setThrottlingCache(throttlingCacheKey, throttlingCache) {
    this.setItem(throttlingCacheKey, throttlingCache);
  }
  /**
   * Removes the cache item from memory with the given key.
   * @param key - lookup key to remove a cache entity
   * @param inMemory - key value map of the cache
   */
  removeItem(key) {
    this.logger.tracePii(`Item key: ${key}`);
    let result = false;
    const cache = this.getCache();
    if (!!cache[key]) {
      delete cache[key];
      result = true;
    }
    if (result) {
      this.setCache(cache);
      this.emitChange();
    }
    return result;
  }
  /**
   * Remove account entity from the platform cache if it's outdated
   * @param accountKey - lookup key to fetch cache type AccountEntity
   */
  removeOutdatedAccount(accountKey) {
    this.removeItem(accountKey);
  }
  /**
   * Checks whether key is in cache.
   * @param key - look up key for a cache entity
   */
  containsKey(key) {
    return this.getKeys().includes(key);
  }
  /**
   * Gets all keys in window.
   */
  getKeys() {
    this.logger.trace("Retrieving all cache keys");
    const cache = this.getCache();
    return [...Object.keys(cache)];
  }
  /**
   * Clears all cache entries created by MSAL (except tokens).
   */
  clear() {
    this.logger.trace("Clearing cache entries created by MSAL");
    const cacheKeys = this.getKeys();
    cacheKeys.forEach((key) => {
      this.removeItem(key);
    });
    this.emitChange();
  }
  /**
   * Initialize in memory cache from an exisiting cache vault
   * @param cache - blob formatted cache (JSON)
   */
  static generateInMemoryCache(cache) {
    return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
  }
  /**
   * retrieves the final JSON
   * @param inMemoryCache - itemised cache read from the JSON
   */
  static generateJsonCache(inMemoryCache) {
    return Serializer.serializeAllCache(inMemoryCache);
  }
  /**
   * Updates a credential's cache key if the current cache key is outdated
   */
  updateCredentialCacheKey(currentCacheKey, credential) {
    const updatedCacheKey = CacheHelpers_exports.generateCredentialKey(credential);
    if (currentCacheKey !== updatedCacheKey) {
      const cacheItem = this.getItem(currentCacheKey);
      if (cacheItem) {
        this.removeItem(currentCacheKey);
        this.setItem(updatedCacheKey, cacheItem);
        this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
        return updatedCacheKey;
      } else {
        this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
      }
    }
    return currentCacheKey;
  }
};

// node_modules/@azure/msal-node/dist/cache/TokenCache.mjs
var defaultSerializedCache = {
  Account: {},
  IdToken: {},
  AccessToken: {},
  RefreshToken: {},
  AppMetadata: {}
};
var TokenCache = class {
  constructor(storage, logger, cachePlugin) {
    this.cacheHasChanged = false;
    this.storage = storage;
    this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
    if (cachePlugin) {
      this.persistence = cachePlugin;
    }
    this.logger = logger;
  }
  /**
   * Set to true if cache state has changed since last time serialize or writeToPersistence was called
   */
  hasChanged() {
    return this.cacheHasChanged;
  }
  /**
   * Serializes in memory cache to JSON
   */
  serialize() {
    this.logger.trace("Serializing in-memory cache");
    let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
    if (this.cacheSnapshot) {
      this.logger.trace("Reading cache snapshot from disk");
      finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
    } else {
      this.logger.trace("No cache snapshot to merge");
    }
    this.cacheHasChanged = false;
    return JSON.stringify(finalState);
  }
  /**
   * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
   * @param cache - blob formatted cache
   */
  deserialize(cache) {
    this.logger.trace("Deserializing JSON to in-memory cache");
    this.cacheSnapshot = cache;
    if (this.cacheSnapshot) {
      this.logger.trace("Reading cache snapshot from disk");
      const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
      this.storage.setInMemoryCache(deserializedCache);
    } else {
      this.logger.trace("No cache snapshot to deserialize");
    }
  }
  /**
   * Fetches the cache key-value map
   */
  getKVStore() {
    return this.storage.getCache();
  }
  /**
   * Gets cache snapshot in CacheKVStore format
   */
  getCacheSnapshot() {
    const deserializedPersistentStorage = NodeStorage.generateInMemoryCache(this.cacheSnapshot);
    return this.storage.inMemoryCacheToCache(deserializedPersistentStorage);
  }
  /**
   * API that retrieves all accounts currently in cache to the user
   */
  async getAllAccounts() {
    this.logger.trace("getAllAccounts called");
    let cacheContext;
    try {
      if (this.persistence) {
        cacheContext = new TokenCacheContext(this, false);
        await this.persistence.beforeCacheAccess(cacheContext);
      }
      return this.storage.getAllAccounts();
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  /**
   * Returns the signed in account matching homeAccountId.
   * (the account object is created at the time of successful login)
   * or null when no matching account is found
   * @param homeAccountId - unique identifier for an account (uid.utid)
   */
  async getAccountByHomeId(homeAccountId) {
    const allAccounts = await this.getAllAccounts();
    if (homeAccountId && allAccounts && allAccounts.length) {
      return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
    } else {
      return null;
    }
  }
  /**
   * Returns the signed in account matching localAccountId.
   * (the account object is created at the time of successful login)
   * or null when no matching account is found
   * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
   */
  async getAccountByLocalId(localAccountId) {
    const allAccounts = await this.getAllAccounts();
    if (localAccountId && allAccounts && allAccounts.length) {
      return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
    } else {
      return null;
    }
  }
  /**
   * API to remove a specific account and the relevant data from cache
   * @param account - AccountInfo passed by the user
   */
  async removeAccount(account) {
    this.logger.trace("removeAccount called");
    let cacheContext;
    try {
      if (this.persistence) {
        cacheContext = new TokenCacheContext(this, true);
        await this.persistence.beforeCacheAccess(cacheContext);
      }
      await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  /**
   * Overwrites in-memory cache with persistent cache
   */
  async overwriteCache() {
    if (!this.persistence) {
      this.logger.info("No persistence layer specified, cache cannot be overwritten");
      return;
    }
    this.logger.info("Overwriting in-memory cache with persistent cache");
    this.storage.clear();
    const cacheContext = new TokenCacheContext(this, false);
    await this.persistence.beforeCacheAccess(cacheContext);
    const cacheSnapshot = this.getCacheSnapshot();
    this.storage.setCache(cacheSnapshot);
    await this.persistence.afterCacheAccess(cacheContext);
  }
  /**
   * Called when the cache has changed state.
   */
  handleChangeEvent() {
    this.cacheHasChanged = true;
  }
  /**
   * Merge in memory cache with the cache snapshot.
   * @param oldState - cache before changes
   * @param currentState - current cache state in the library
   */
  mergeState(oldState, currentState) {
    this.logger.trace("Merging in-memory cache with cache snapshot");
    const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
    return this.mergeUpdates(stateAfterRemoval, currentState);
  }
  /**
   * Deep update of oldState based on newState values
   * @param oldState - cache before changes
   * @param newState - updated cache
   */
  mergeUpdates(oldState, newState) {
    Object.keys(newState).forEach((newKey) => {
      const newValue = newState[newKey];
      if (!oldState.hasOwnProperty(newKey)) {
        if (newValue !== null) {
          oldState[newKey] = newValue;
        }
      } else {
        const newValueNotNull = newValue !== null;
        const newValueIsObject = typeof newValue === "object";
        const newValueIsNotArray = !Array.isArray(newValue);
        const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
        if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
          this.mergeUpdates(oldState[newKey], newValue);
        } else {
          oldState[newKey] = newValue;
        }
      }
    });
    return oldState;
  }
  /**
   * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
   * oldState that are not recognized, they are left untouched.
   * @param oldState - cache before changes
   * @param newState - updated cache
   */
  mergeRemovals(oldState, newState) {
    this.logger.trace("Remove updated entries in cache");
    const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
    const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
    const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
    const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
    const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
    return {
      ...oldState,
      Account: accounts,
      AccessToken: accessTokens,
      RefreshToken: refreshTokens,
      IdToken: idTokens,
      AppMetadata: appMetadata
    };
  }
  /**
   * Helper to merge new cache with the old one
   * @param oldState - cache before changes
   * @param newState - updated cache
   */
  mergeRemovalsDict(oldState, newState) {
    const finalState = { ...oldState };
    Object.keys(oldState).forEach((oldKey) => {
      if (!newState || !newState.hasOwnProperty(oldKey)) {
        delete finalState[oldKey];
      }
    });
    return finalState;
  }
  /**
   * Helper to overlay as a part of cache merge
   * @param passedInCache - cache read from the blob
   */
  overlayDefaults(passedInCache) {
    this.logger.trace("Overlaying input cache with the default cache");
    return {
      Account: {
        ...defaultSerializedCache.Account,
        ...passedInCache.Account
      },
      IdToken: {
        ...defaultSerializedCache.IdToken,
        ...passedInCache.IdToken
      },
      AccessToken: {
        ...defaultSerializedCache.AccessToken,
        ...passedInCache.AccessToken
      },
      RefreshToken: {
        ...defaultSerializedCache.RefreshToken,
        ...passedInCache.RefreshToken
      },
      AppMetadata: {
        ...defaultSerializedCache.AppMetadata,
        ...passedInCache.AppMetadata
      }
    };
  }
};

// node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
var ClientAssertion = class _ClientAssertion {
  /**
   * Initialize the ClientAssertion class from the clientAssertion passed by the user
   * @param assertion - refer https://tools.ietf.org/html/rfc7521
   */
  static fromAssertion(assertion) {
    const clientAssertion = new _ClientAssertion();
    clientAssertion.jwt = assertion;
    return clientAssertion;
  }
  /**
   * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint
   * Initialize the ClientAssertion class from the certificate passed by the user
   * @param thumbprint - identifier of a certificate
   * @param privateKey - secret key
   * @param publicCertificate - electronic document provided to prove the ownership of the public key
   */
  static fromCertificate(thumbprint, privateKey, publicCertificate) {
    const clientAssertion = new _ClientAssertion();
    clientAssertion.privateKey = privateKey;
    clientAssertion.thumbprint = thumbprint;
    clientAssertion.useSha256 = false;
    if (publicCertificate) {
      clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
    }
    return clientAssertion;
  }
  /**
   * Initialize the ClientAssertion class from the certificate passed by the user
   * @param thumbprint - identifier of a certificate
   * @param privateKey - secret key
   * @param publicCertificate - electronic document provided to prove the ownership of the public key
   */
  static fromCertificateWithSha256Thumbprint(thumbprint, privateKey, publicCertificate) {
    const clientAssertion = new _ClientAssertion();
    clientAssertion.privateKey = privateKey;
    clientAssertion.thumbprint = thumbprint;
    clientAssertion.useSha256 = true;
    if (publicCertificate) {
      clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
    }
    return clientAssertion;
  }
  /**
   * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
   * @param cryptoProvider - library's crypto helper
   * @param issuer - iss claim
   * @param jwtAudience - aud claim
   */
  getJwt(cryptoProvider, issuer, jwtAudience) {
    if (this.privateKey && this.thumbprint) {
      if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
        return this.jwt;
      }
      return this.createJwt(cryptoProvider, issuer, jwtAudience);
    }
    if (this.jwt) {
      return this.jwt;
    }
    throw createClientAuthError(ClientAuthErrorCodes_exports.invalidAssertion);
  }
  /**
   * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
   */
  createJwt(cryptoProvider, issuer, jwtAudience) {
    this.issuer = issuer;
    this.jwtAudience = jwtAudience;
    const issuedAt = TimeUtils_exports.nowSeconds();
    this.expirationTime = issuedAt + 600;
    const algorithm = this.useSha256 ? JwtConstants.PSS_256 : JwtConstants.RSA_256;
    const header = {
      alg: algorithm
    };
    const thumbprintHeader = this.useSha256 ? JwtConstants.X5T_256 : JwtConstants.X5T;
    Object.assign(header, {
      [thumbprintHeader]: EncodingUtils.base64EncodeUrl(this.thumbprint, "hex")
    });
    if (this.publicCertificate) {
      Object.assign(header, {
        [JwtConstants.X5C]: this.publicCertificate
      });
    }
    const payload = {
      [JwtConstants.AUDIENCE]: this.jwtAudience,
      [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
      [JwtConstants.ISSUER]: this.issuer,
      [JwtConstants.SUBJECT]: this.issuer,
      [JwtConstants.NOT_BEFORE]: issuedAt,
      [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
    };
    this.jwt = import_jsonwebtoken.default.sign(payload, this.privateKey, { header });
    return this.jwt;
  }
  /**
   * Utility API to check expiration
   */
  isExpired() {
    return this.expirationTime < TimeUtils_exports.nowSeconds();
  }
  /**
   * Extracts the raw certs from a given certificate string and returns them in an array.
   * @param publicCertificate - electronic document provided to prove the ownership of the public key
   */
  static parseCertificate(publicCertificate) {
    const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
    const certs = [];
    let matches;
    while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
      certs.push(matches[1].replace(/\r*\n/g, Constants.EMPTY_STRING));
    }
    return certs;
  }
};

// node_modules/@azure/msal-node/dist/packageMetadata.mjs
var name2 = "@azure/msal-node";
var version2 = "3.4.1";

// node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs
var UsernamePasswordClient = class extends BaseClient {
  constructor(configuration) {
    super(configuration);
  }
  /**
   * API to acquire a token by passing the username and password to the service in exchage of credentials
   * password_grant
   * @param request - CommonUsernamePasswordRequest
   */
  async acquireToken(request) {
    this.logger.info("in acquireToken call in username-password client");
    const reqTimestamp = TimeUtils_exports.nowSeconds();
    const response = await this.executeTokenRequest(this.authority, request);
    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
    responseHandler.validateTokenResponse(response.body);
    const tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request);
    return tokenResponse;
  }
  /**
   * Executes POST request to token endpoint
   * @param authority - authority object
   * @param request - CommonUsernamePasswordRequest provided by the developer
   */
  async executeTokenRequest(authority, request) {
    const queryParametersString = this.createTokenQueryParameters(request);
    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
    const requestBody = await this.createTokenRequestBody(request);
    const headers = this.createTokenRequestHeaders({
      credential: request.username,
      type: CcsCredentialType.UPN
    });
    const thumbprint = {
      clientId: this.config.authOptions.clientId,
      authority: authority.canonicalAuthority,
      scopes: request.scopes,
      claims: request.claims,
      authenticationScheme: request.authenticationScheme,
      resourceRequestMethod: request.resourceRequestMethod,
      resourceRequestUri: request.resourceRequestUri,
      shrClaims: request.shrClaims,
      sshKid: request.sshKid
    };
    return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
  }
  /**
   * Generates a map for all the params to be sent to the service
   * @param request - CommonUsernamePasswordRequest provided by the developer
   */
  async createTokenRequestBody(request) {
    const parameters = /* @__PURE__ */ new Map();
    RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
    RequestParameterBuilder_exports.addUsername(parameters, request.username);
    RequestParameterBuilder_exports.addPassword(parameters, request.password);
    RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
    RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.IDTOKEN_TOKEN);
    RequestParameterBuilder_exports.addGrantType(parameters, GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
    RequestParameterBuilder_exports.addClientInfo(parameters);
    RequestParameterBuilder_exports.addLibraryInfo(parameters, this.config.libraryInfo);
    RequestParameterBuilder_exports.addApplicationTelemetry(parameters, this.config.telemetry.application);
    RequestParameterBuilder_exports.addThrottling(parameters);
    if (this.serverTelemetryManager) {
      RequestParameterBuilder_exports.addServerTelemetry(parameters, this.serverTelemetryManager);
    }
    const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
    RequestParameterBuilder_exports.addCorrelationId(parameters, correlationId);
    if (this.config.clientCredentials.clientSecret) {
      RequestParameterBuilder_exports.addClientSecret(parameters, this.config.clientCredentials.clientSecret);
    }
    const clientAssertion = this.config.clientCredentials.clientAssertion;
    if (clientAssertion) {
      RequestParameterBuilder_exports.addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
      RequestParameterBuilder_exports.addClientAssertionType(parameters, clientAssertion.assertionType);
    }
    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      RequestParameterBuilder_exports.addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
    }
    if (this.config.systemOptions.preventCorsPreflight && request.username) {
      RequestParameterBuilder_exports.addCcsUpn(parameters, request.username);
    }
    return UrlUtils_exports.mapToQueryString(parameters);
  }
};

// node_modules/@azure/msal-node/dist/protocol/Authorize.mjs
function getAuthCodeRequestUrl(config2, authority, request, logger) {
  const parameters = Authorize_exports.getStandardAuthorizeRequestParameters({
    ...config2.auth,
    authority,
    redirectUri: request.redirectUri || ""
  }, request, logger);
  RequestParameterBuilder_exports.addLibraryInfo(parameters, {
    sku: Constants2.MSAL_SKU,
    version: version2,
    cpu: process.arch || "",
    os: process.platform || ""
  });
  if (config2.auth.protocolMode !== ProtocolMode.OIDC) {
    RequestParameterBuilder_exports.addApplicationTelemetry(parameters, config2.telemetry.application);
  }
  RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.CODE);
  if (request.codeChallenge && request.codeChallengeMethod) {
    RequestParameterBuilder_exports.addCodeChallengeParams(parameters, request.codeChallenge, request.codeChallengeMethod);
  }
  RequestParameterBuilder_exports.addExtraQueryParameters(parameters, request.extraQueryParameters || {});
  return Authorize_exports.getAuthorizeUrl(authority, parameters);
}

// node_modules/@azure/msal-node/dist/client/ClientApplication.mjs
var ClientApplication = class {
  /**
   * Constructor for the ClientApplication
   */
  constructor(configuration) {
    this.config = buildAppConfiguration(configuration);
    this.cryptoProvider = new CryptoProvider();
    this.logger = new Logger(this.config.system.loggerOptions, name2, version2);
    this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider, buildStaticAuthorityOptions(this.config.auth));
    this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
  }
  /**
   * Creates the URL of the authorization request, letting the user input credentials and consent to the
   * application. The URL targets the /authorize endpoint of the authority configured in the
   * application object.
   *
   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
   * `acquireTokenByCode(AuthorizationCodeRequest)`.
   */
  async getAuthCodeUrl(request) {
    this.logger.info("getAuthCodeUrl called", request.correlationId);
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      responseMode: request.responseMode || ResponseMode.QUERY,
      authenticationScheme: AuthenticationScheme.BEARER,
      state: request.state || "",
      nonce: request.nonce || ""
    };
    const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
    return getAuthCodeRequestUrl(this.config, discoveredAuthority, validRequest, this.logger);
  }
  /**
   * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
   * Authorization Code flow.
   *
   * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
   * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
   * AuthorizationCodeRequest are the same.
   */
  async acquireTokenByCode(request, authCodePayLoad) {
    this.logger.info("acquireTokenByCode called");
    if (request.state && authCodePayLoad) {
      this.logger.info("acquireTokenByCode - validating state");
      this.validateState(request.state, authCodePayLoad.state || "");
      authCodePayLoad = { ...authCodePayLoad, state: "" };
    }
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
    try {
      const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
      const authClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri, serverTelemetryManager);
      const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
      this.logger.verbose("Auth code client created", validRequest.correlationId);
      return await authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token by exchanging the refresh token provided for a new set of tokens.
   *
   * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
   * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
   * handle the caching and refreshing of tokens automatically.
   */
  async acquireTokenByRefreshToken(request) {
    this.logger.info("acquireTokenByRefreshToken called", request.correlationId);
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
    try {
      const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
      const refreshTokenClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
      const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
      this.logger.verbose("Refresh token client created", validRequest.correlationId);
      return await refreshTokenClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token silently when a user specifies the account the token is requested for.
   *
   * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
   * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
   * In case the refresh_token is expired or not found, an error is thrown
   * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
   */
  async acquireTokenSilent(request) {
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      forceRefresh: request.forceRefresh || false
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
    try {
      const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
      const clientConfiguration = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
      const silentFlowClient = new SilentFlowClient(clientConfiguration);
      this.logger.verbose("Silent flow client created", validRequest.correlationId);
      try {
        await this.tokenCache.overwriteCache();
        return await this.acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration);
      } catch (error) {
        if (error instanceof ClientAuthError && error.errorCode === ClientAuthErrorCodes_exports.tokenRefreshRequired) {
          const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
          return refreshTokenClient.acquireTokenByRefreshToken(validRequest);
        }
        throw error;
      }
    } catch (error) {
      if (error instanceof AuthError) {
        error.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(error);
      throw error;
    }
  }
  async acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration) {
    var _a;
    const [authResponse, cacheOutcome] = await silentFlowClient.acquireCachedToken({
      ...validRequest,
      scopes: ((_a = validRequest.scopes) == null ? void 0 : _a.length) ? validRequest.scopes : [...OIDC_DEFAULT_SCOPES]
    });
    if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
      this.logger.info("ClientApplication:acquireCachedTokenSilent - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
      const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
      try {
        await refreshTokenClient.acquireTokenByRefreshToken(validRequest);
      } catch (e) {
      }
    }
    return authResponse;
  }
  /**
   * Acquires tokens with password grant by exchanging client applications username and password for credentials
   *
   * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
   * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
   * Microsoft's documentation and recommendations are at:
   * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
   *
   * @param request - UsenamePasswordRequest
   * @deprecated - Use a more secure flow instead
   */
  async acquireTokenByUsernamePassword(request) {
    this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request)
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
    try {
      const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
      const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
      const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
      this.logger.verbose("Username password client created", validRequest.correlationId);
      return await usernamePasswordClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Gets the token cache for the application.
   */
  getTokenCache() {
    this.logger.info("getTokenCache called");
    return this.tokenCache;
  }
  /**
   * Validates OIDC state by comparing the user cached state with the state received from the server.
   *
   * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
   * CSRF attacks.
   * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
   * @param state - Unique GUID generated by the user that is cached by the user and sent to the server during the first leg of the flow
   * @param cachedState - This string is sent back by the server with the authorization code
   */
  validateState(state, cachedState) {
    if (!state) {
      throw NodeAuthError.createStateNotFoundError();
    }
    if (state !== cachedState) {
      throw createClientAuthError(ClientAuthErrorCodes_exports.stateMismatch);
    }
  }
  /**
   * Returns the logger instance
   */
  getLogger() {
    return this.logger;
  }
  /**
   * Replaces the default logger set in configurations with new Logger with new configurations
   * @param logger - Logger instance
   */
  setLogger(logger) {
    this.logger = logger;
  }
  /**
   * Builds the common configuration to be passed to the common component based on the platform configurarion
   * @param authority - user passed authority in configuration
   * @param serverTelemetryManager - initializes servertelemetry if passed
   */
  async buildOauthClientConfiguration(discoveredAuthority, requestCorrelationId, redirectUri, serverTelemetryManager) {
    this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
    this.logger.info(`Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`, requestCorrelationId);
    serverTelemetryManager == null ? void 0 : serverTelemetryManager.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
    const clientConfiguration = {
      authOptions: {
        clientId: this.config.auth.clientId,
        authority: discoveredAuthority,
        clientCapabilities: this.config.auth.clientCapabilities,
        redirectUri
      },
      loggerOptions: {
        logLevel: this.config.system.loggerOptions.logLevel,
        loggerCallback: this.config.system.loggerOptions.loggerCallback,
        piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
        correlationId: requestCorrelationId
      },
      cacheOptions: {
        claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
      },
      cryptoInterface: this.cryptoProvider,
      networkInterface: this.config.system.networkClient,
      storageInterface: this.storage,
      serverTelemetryManager,
      clientCredentials: {
        clientSecret: this.clientSecret,
        clientAssertion: await this.getClientAssertion(discoveredAuthority)
      },
      libraryInfo: {
        sku: Constants2.MSAL_SKU,
        version: version2,
        cpu: process.arch || Constants.EMPTY_STRING,
        os: process.platform || Constants.EMPTY_STRING
      },
      telemetry: this.config.telemetry,
      persistencePlugin: this.config.cache.cachePlugin,
      serializableCache: this.tokenCache
    };
    return clientConfiguration;
  }
  async getClientAssertion(authority) {
    if (this.developerProvidedClientAssertion) {
      this.clientAssertion = ClientAssertion.fromAssertion(await getClientAssertion(this.developerProvidedClientAssertion, this.config.auth.clientId, authority.tokenEndpoint));
    }
    return this.clientAssertion && {
      assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
      assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
    };
  }
  /**
   * Generates a request with the default scopes & generates a correlationId.
   * @param authRequest - BaseAuthRequest for initialization
   */
  async initializeBaseRequest(authRequest) {
    this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
    if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {
      this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
    }
    authRequest.authenticationScheme = AuthenticationScheme.BEARER;
    if (this.config.cache.claimsBasedCachingEnabled && authRequest.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
    !StringUtils.isEmptyObj(authRequest.claims)) {
      authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
    }
    return {
      ...authRequest,
      scopes: [
        ...authRequest && authRequest.scopes || [],
        ...OIDC_DEFAULT_SCOPES
      ],
      correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
      authority: authRequest.authority || this.config.auth.authority
    };
  }
  /**
   * Initializes the server telemetry payload
   * @param apiId - Id for a specific request
   * @param correlationId - GUID
   * @param forceRefresh - boolean to indicate network call
   */
  initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
    const telemetryPayload = {
      clientId: this.config.auth.clientId,
      correlationId,
      apiId,
      forceRefresh: forceRefresh || false
    };
    return new ServerTelemetryManager(telemetryPayload, this.storage);
  }
  /**
   * Create authority instance. If authority not passed in request, default to authority set on the application
   * object. If no authority set in application object, then default to common authority.
   * @param authorityString - authority from user configuration
   */
  async createAuthority(authorityString, requestCorrelationId, azureRegionConfiguration, azureCloudOptions) {
    this.logger.verbose("createAuthority called", requestCorrelationId);
    const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions || this.config.auth.azureCloudOptions);
    const authorityOptions = {
      protocolMode: this.config.auth.protocolMode,
      knownAuthorities: this.config.auth.knownAuthorities,
      cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
      authorityMetadata: this.config.auth.authorityMetadata,
      azureRegionConfiguration,
      skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
    };
    return AuthorityFactory_exports.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, requestCorrelationId);
  }
  /**
   * Clear the cache
   */
  clearCache() {
    this.storage.clear();
  }
};

// node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs
var import_http2 = __toESM(require("http"), 1);

// node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs
var ClientCredentialClient = class extends BaseClient {
  constructor(configuration, appTokenProvider) {
    super(configuration);
    this.appTokenProvider = appTokenProvider;
  }
  /**
   * Public API to acquire a token with ClientCredential Flow for Confidential clients
   * @param request - CommonClientCredentialRequest provided by the developer
   */
  async acquireToken(request) {
    if (request.skipCache || request.claims) {
      return this.executeTokenRequest(request, this.authority);
    }
    const [cachedAuthenticationResult, lastCacheOutcome] = await this.getCachedAuthenticationResult(request, this.config, this.cryptoUtils, this.authority, this.cacheManager, this.serverTelemetryManager);
    if (cachedAuthenticationResult) {
      if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
        this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
        const refreshAccessToken = true;
        await this.executeTokenRequest(request, this.authority, refreshAccessToken);
      }
      return cachedAuthenticationResult;
    } else {
      return this.executeTokenRequest(request, this.authority);
    }
  }
  /**
   * looks up cache if the tokens are cached already
   */
  async getCachedAuthenticationResult(request, config2, cryptoUtils, authority, cacheManager, serverTelemetryManager) {
    var _a, _b;
    const clientConfiguration = config2;
    const managedIdentityConfiguration = config2;
    let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
    let cacheContext;
    if (clientConfiguration.serializableCache && clientConfiguration.persistencePlugin) {
      cacheContext = new TokenCacheContext(clientConfiguration.serializableCache, false);
      await clientConfiguration.persistencePlugin.beforeCacheAccess(cacheContext);
    }
    const cachedAccessToken = this.readAccessTokenFromCache(authority, ((_a = managedIdentityConfiguration.managedIdentityId) == null ? void 0 : _a.id) || clientConfiguration.authOptions.clientId, new ScopeSet(request.scopes || []), cacheManager);
    if (clientConfiguration.serializableCache && clientConfiguration.persistencePlugin && cacheContext) {
      await clientConfiguration.persistencePlugin.afterCacheAccess(cacheContext);
    }
    if (!cachedAccessToken) {
      serverTelemetryManager == null ? void 0 : serverTelemetryManager.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
      return [null, CacheOutcome.NO_CACHED_ACCESS_TOKEN];
    }
    if (TimeUtils_exports.isTokenExpired(cachedAccessToken.expiresOn, ((_b = clientConfiguration.systemOptions) == null ? void 0 : _b.tokenRenewalOffsetSeconds) || DEFAULT_TOKEN_RENEWAL_OFFSET_SEC)) {
      serverTelemetryManager == null ? void 0 : serverTelemetryManager.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
      return [null, CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED];
    }
    if (cachedAccessToken.refreshOn && TimeUtils_exports.isTokenExpired(cachedAccessToken.refreshOn.toString(), 0)) {
      lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
      serverTelemetryManager == null ? void 0 : serverTelemetryManager.setCacheOutcome(CacheOutcome.PROACTIVELY_REFRESHED);
    }
    return [
      await ResponseHandler.generateAuthenticationResult(cryptoUtils, authority, {
        account: null,
        idToken: null,
        accessToken: cachedAccessToken,
        refreshToken: null,
        appMetadata: null
      }, true, request),
      lastCacheOutcome
    ];
  }
  /**
   * Reads access token from the cache
   */
  readAccessTokenFromCache(authority, id, scopeSet, cacheManager) {
    const accessTokenFilter = {
      homeAccountId: Constants.EMPTY_STRING,
      environment: authority.canonicalAuthorityUrlComponents.HostNameAndPort,
      credentialType: CredentialType.ACCESS_TOKEN,
      clientId: id,
      realm: authority.tenant,
      target: ScopeSet.createSearchScopes(scopeSet.asArray())
    };
    const accessTokens = cacheManager.getAccessTokensByFilter(accessTokenFilter);
    if (accessTokens.length < 1) {
      return null;
    } else if (accessTokens.length > 1) {
      throw createClientAuthError(ClientAuthErrorCodes_exports.multipleMatchingTokens);
    }
    return accessTokens[0];
  }
  /**
   * Makes a network call to request the token from the service
   * @param request - CommonClientCredentialRequest provided by the developer
   * @param authority - authority object
   */
  async executeTokenRequest(request, authority, refreshAccessToken) {
    let serverTokenResponse;
    let reqTimestamp;
    if (this.appTokenProvider) {
      this.logger.info("Using appTokenProvider extensibility.");
      const appTokenPropviderParameters = {
        correlationId: request.correlationId,
        tenantId: this.config.authOptions.authority.tenant,
        scopes: request.scopes,
        claims: request.claims
      };
      reqTimestamp = TimeUtils_exports.nowSeconds();
      const appTokenProviderResult = await this.appTokenProvider(appTokenPropviderParameters);
      serverTokenResponse = {
        access_token: appTokenProviderResult.accessToken,
        expires_in: appTokenProviderResult.expiresInSeconds,
        refresh_in: appTokenProviderResult.refreshInSeconds,
        token_type: AuthenticationScheme.BEARER
      };
    } else {
      const queryParametersString = this.createTokenQueryParameters(request);
      const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
      const requestBody = await this.createTokenRequestBody(request);
      const headers = this.createTokenRequestHeaders();
      const thumbprint = {
        clientId: this.config.authOptions.clientId,
        authority: request.authority,
        scopes: request.scopes,
        claims: request.claims,
        authenticationScheme: request.authenticationScheme,
        resourceRequestMethod: request.resourceRequestMethod,
        resourceRequestUri: request.resourceRequestUri,
        shrClaims: request.shrClaims,
        sshKid: request.sshKid
      };
      this.logger.info("Sending token request to endpoint: " + authority.tokenEndpoint);
      reqTimestamp = TimeUtils_exports.nowSeconds();
      const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
      serverTokenResponse = response.body;
      serverTokenResponse.status = response.status;
    }
    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
    responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
    const tokenResponse = await responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request);
    return tokenResponse;
  }
  /**
   * generate the request to the server in the acceptable format
   * @param request - CommonClientCredentialRequest provided by the developer
   */
  async createTokenRequestBody(request) {
    const parameters = /* @__PURE__ */ new Map();
    RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
    RequestParameterBuilder_exports.addScopes(parameters, request.scopes, false);
    RequestParameterBuilder_exports.addGrantType(parameters, GrantType.CLIENT_CREDENTIALS_GRANT);
    RequestParameterBuilder_exports.addLibraryInfo(parameters, this.config.libraryInfo);
    RequestParameterBuilder_exports.addApplicationTelemetry(parameters, this.config.telemetry.application);
    RequestParameterBuilder_exports.addThrottling(parameters);
    if (this.serverTelemetryManager) {
      RequestParameterBuilder_exports.addServerTelemetry(parameters, this.serverTelemetryManager);
    }
    const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
    RequestParameterBuilder_exports.addCorrelationId(parameters, correlationId);
    if (this.config.clientCredentials.clientSecret) {
      RequestParameterBuilder_exports.addClientSecret(parameters, this.config.clientCredentials.clientSecret);
    }
    const clientAssertion = request.clientAssertion || this.config.clientCredentials.clientAssertion;
    if (clientAssertion) {
      RequestParameterBuilder_exports.addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
      RequestParameterBuilder_exports.addClientAssertionType(parameters, clientAssertion.assertionType);
    }
    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      RequestParameterBuilder_exports.addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
    }
    return UrlUtils_exports.mapToQueryString(parameters);
  }
};

// node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs
var OnBehalfOfClient = class extends BaseClient {
  constructor(configuration) {
    super(configuration);
  }
  /**
   * Public API to acquire tokens with on behalf of flow
   * @param request - developer provided CommonOnBehalfOfRequest
   */
  async acquireToken(request) {
    this.scopeSet = new ScopeSet(request.scopes || []);
    this.userAssertionHash = await this.cryptoUtils.hashString(request.oboAssertion);
    if (request.skipCache || request.claims) {
      return this.executeTokenRequest(request, this.authority, this.userAssertionHash);
    }
    try {
      return await this.getCachedAuthenticationResult(request);
    } catch (e) {
      return await this.executeTokenRequest(request, this.authority, this.userAssertionHash);
    }
  }
  /**
   * look up cache for tokens
   * Find idtoken in the cache
   * Find accessToken based on user assertion and account info in the cache
   * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires
   * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session
   * @param request - developer provided CommonOnBehalfOfRequest
   */
  async getCachedAuthenticationResult(request) {
    var _a, _b;
    const cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);
    if (!cachedAccessToken) {
      (_a = this.serverTelemetryManager) == null ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
      this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
      throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
    } else if (TimeUtils_exports.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
      (_b = this.serverTelemetryManager) == null ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
      this.logger.info(`OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);
      throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
    }
    const cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId);
    let idTokenClaims;
    let cachedAccount = null;
    if (cachedIdToken) {
      idTokenClaims = AuthToken_exports.extractTokenClaims(cachedIdToken.secret, EncodingUtils.base64Decode);
      const localAccountId = idTokenClaims.oid || idTokenClaims.sub;
      const accountInfo = {
        homeAccountId: cachedIdToken.homeAccountId,
        environment: cachedIdToken.environment,
        tenantId: cachedIdToken.realm,
        username: Constants.EMPTY_STRING,
        localAccountId: localAccountId || Constants.EMPTY_STRING
      };
      cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);
    }
    if (this.config.serverTelemetryManager) {
      this.config.serverTelemetryManager.incrementCacheHits();
    }
    return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
      account: cachedAccount,
      accessToken: cachedAccessToken,
      idToken: cachedIdToken,
      refreshToken: null,
      appMetadata: null
    }, true, request, idTokenClaims);
  }
  /**
   * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager
   * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service
   * @param atHomeAccountId - account id
   */
  readIdTokenFromCacheForOBO(atHomeAccountId) {
    const idTokenFilter = {
      homeAccountId: atHomeAccountId,
      environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
      credentialType: CredentialType.ID_TOKEN,
      clientId: this.config.authOptions.clientId,
      realm: this.authority.tenant
    };
    const idTokenMap = this.cacheManager.getIdTokensByFilter(idTokenFilter);
    if (Object.values(idTokenMap).length < 1) {
      return null;
    }
    return Object.values(idTokenMap)[0];
  }
  /**
   * Fetches the cached access token based on incoming assertion
   * @param clientId - client id
   * @param request - developer provided CommonOnBehalfOfRequest
   */
  readAccessTokenFromCacheForOBO(clientId, request) {
    const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
    const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
    const accessTokenFilter = {
      credentialType,
      clientId,
      target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),
      tokenType: authScheme,
      keyId: request.sshKid,
      requestedClaimsHash: request.requestedClaimsHash,
      userAssertionHash: this.userAssertionHash
    };
    const accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter);
    const numAccessTokens = accessTokens.length;
    if (numAccessTokens < 1) {
      return null;
    } else if (numAccessTokens > 1) {
      throw createClientAuthError(ClientAuthErrorCodes_exports.multipleMatchingTokens);
    }
    return accessTokens[0];
  }
  /**
   * Make a network call to the server requesting credentials
   * @param request - developer provided CommonOnBehalfOfRequest
   * @param authority - authority object
   */
  async executeTokenRequest(request, authority, userAssertionHash) {
    const queryParametersString = this.createTokenQueryParameters(request);
    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
    const requestBody = await this.createTokenRequestBody(request);
    const headers = this.createTokenRequestHeaders();
    const thumbprint = {
      clientId: this.config.authOptions.clientId,
      authority: request.authority,
      scopes: request.scopes,
      claims: request.claims,
      authenticationScheme: request.authenticationScheme,
      resourceRequestMethod: request.resourceRequestMethod,
      resourceRequestUri: request.resourceRequestUri,
      shrClaims: request.shrClaims,
      sshKid: request.sshKid
    };
    const reqTimestamp = TimeUtils_exports.nowSeconds();
    const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
    responseHandler.validateTokenResponse(response.body);
    const tokenResponse = await responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, void 0, userAssertionHash);
    return tokenResponse;
  }
  /**
   * generate a server request in accepable format
   * @param request - developer provided CommonOnBehalfOfRequest
   */
  async createTokenRequestBody(request) {
    const parameters = /* @__PURE__ */ new Map();
    RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
    RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
    RequestParameterBuilder_exports.addGrantType(parameters, GrantType.JWT_BEARER);
    RequestParameterBuilder_exports.addClientInfo(parameters);
    RequestParameterBuilder_exports.addLibraryInfo(parameters, this.config.libraryInfo);
    RequestParameterBuilder_exports.addApplicationTelemetry(parameters, this.config.telemetry.application);
    RequestParameterBuilder_exports.addThrottling(parameters);
    if (this.serverTelemetryManager) {
      RequestParameterBuilder_exports.addServerTelemetry(parameters, this.serverTelemetryManager);
    }
    const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
    RequestParameterBuilder_exports.addCorrelationId(parameters, correlationId);
    RequestParameterBuilder_exports.addRequestTokenUse(parameters, AADServerParamKeys_exports.ON_BEHALF_OF);
    RequestParameterBuilder_exports.addOboAssertion(parameters, request.oboAssertion);
    if (this.config.clientCredentials.clientSecret) {
      RequestParameterBuilder_exports.addClientSecret(parameters, this.config.clientCredentials.clientSecret);
    }
    const clientAssertion = this.config.clientCredentials.clientAssertion;
    if (clientAssertion) {
      RequestParameterBuilder_exports.addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
      RequestParameterBuilder_exports.addClientAssertionType(parameters, clientAssertion.assertionType);
    }
    if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      RequestParameterBuilder_exports.addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
    }
    return UrlUtils_exports.mapToQueryString(parameters);
  }
};

// node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs
var ConfidentialClientApplication = class extends ClientApplication {
  /**
   * Constructor for the ConfidentialClientApplication
   *
   * Required attributes in the Configuration object are:
   * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal
   * - authority: the authority URL for your application.
   * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.
   *
   * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
   * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
   * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
   * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
   *
   * In Azure B2C, authority is of the form https://\{instance\}/tfp/\{tenant\}/\{policyName\}/
   * Full B2C functionality will be available in this library in future versions.
   *
   * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance
   */
  constructor(configuration) {
    var _a, _b, _c;
    super(configuration);
    const clientSecretNotEmpty = !!this.config.auth.clientSecret;
    const clientAssertionNotEmpty = !!this.config.auth.clientAssertion;
    const certificateNotEmpty = (!!((_a = this.config.auth.clientCertificate) == null ? void 0 : _a.thumbprint) || !!((_b = this.config.auth.clientCertificate) == null ? void 0 : _b.thumbprintSha256)) && !!((_c = this.config.auth.clientCertificate) == null ? void 0 : _c.privateKey);
    if (this.appTokenProvider) {
      return;
    }
    if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {
      throw createClientAuthError(ClientAuthErrorCodes_exports.invalidClientCredential);
    }
    if (this.config.auth.clientSecret) {
      this.clientSecret = this.config.auth.clientSecret;
      return;
    }
    if (this.config.auth.clientAssertion) {
      this.developerProvidedClientAssertion = this.config.auth.clientAssertion;
      return;
    }
    if (!certificateNotEmpty) {
      throw createClientAuthError(ClientAuthErrorCodes_exports.invalidClientCredential);
    } else {
      this.clientAssertion = !!this.config.auth.clientCertificate.thumbprintSha256 ? ClientAssertion.fromCertificateWithSha256Thumbprint(this.config.auth.clientCertificate.thumbprintSha256, this.config.auth.clientCertificate.privateKey, this.config.auth.clientCertificate.x5c) : ClientAssertion.fromCertificate(
        // guaranteed to be a string, due to prior error checking in this function
        this.config.auth.clientCertificate.thumbprint,
        this.config.auth.clientCertificate.privateKey,
        this.config.auth.clientCertificate.x5c
      );
    }
    this.appTokenProvider = void 0;
  }
  /**
   * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and
   * is meant for Azure SDK to enhance Managed Identity support.
   *
   * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.
   */
  SetAppTokenProvider(provider) {
    this.appTokenProvider = provider;
  }
  /**
   * Acquires tokens from the authority for the application (not for an end user).
   */
  async acquireTokenByClientCredential(request) {
    this.logger.info("acquireTokenByClientCredential called", request.correlationId);
    let clientAssertion;
    if (request.clientAssertion) {
      clientAssertion = {
        assertion: await getClientAssertion(
          request.clientAssertion,
          this.config.auth.clientId
          // tokenEndpoint will be undefined. resourceRequestUri is omitted in ClientCredentialRequest
        ),
        assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
      };
    }
    const baseRequest = await this.initializeBaseRequest(request);
    const validBaseRequest = {
      ...baseRequest,
      scopes: baseRequest.scopes.filter((scope) => !OIDC_DEFAULT_SCOPES.includes(scope))
    };
    const validRequest = {
      ...request,
      ...validBaseRequest,
      clientAssertion
    };
    const authority = new UrlString(validRequest.authority);
    const tenantId = authority.getUrlComponents().PathSegments[0];
    if (Object.values(AADAuthorityConstants).includes(tenantId)) {
      throw createClientAuthError(ClientAuthErrorCodes_exports.missingTenantIdError);
    }
    const ENV_MSAL_FORCE_REGION = process.env[MSAL_FORCE_REGION];
    let region;
    if (validRequest.azureRegion !== "DisableMsalForceRegion") {
      if (!validRequest.azureRegion && ENV_MSAL_FORCE_REGION) {
        region = ENV_MSAL_FORCE_REGION;
      } else {
        region = validRequest.azureRegion;
      }
    }
    const azureRegionConfiguration = {
      azureRegion: region,
      environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);
    try {
      const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, azureRegionConfiguration, request.azureCloudOptions);
      const clientCredentialConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
      const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
      this.logger.verbose("Client credential client created", validRequest.correlationId);
      return await clientCredentialClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires tokens from the authority for the application.
   *
   * Used in scenarios where the current app is a middle-tier service which was called with a token
   * representing an end user. The current app can use the token (oboAssertion) to request another
   * token to access downstream web API, on behalf of that user.
   *
   * The current middle-tier app has no user interaction to obtain consent.
   * See how to gain consent upfront for your middle-tier app from this article.
   * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application
   */
  async acquireTokenOnBehalfOf(request) {
    this.logger.info("acquireTokenOnBehalfOf called", request.correlationId);
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request)
    };
    try {
      const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
      const onBehalfOfConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", void 0);
      const oboClient = new OnBehalfOfClient(onBehalfOfConfig);
      this.logger.verbose("On behalf of client created", validRequest.correlationId);
      return await oboClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      throw e;
    }
  }
};

// node_modules/@azure/msal-node/dist/utils/TimeUtils.mjs
function isIso8601(dateString) {
  if (typeof dateString !== "string") {
    return false;
  }
  const date = new Date(dateString);
  return !isNaN(date.getTime()) && date.toISOString() === dateString;
}

// node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs
var HttpClientWithRetries = class {
  constructor(httpClientNoRetries, retryPolicy) {
    this.httpClientNoRetries = httpClientNoRetries;
    this.retryPolicy = retryPolicy;
  }
  async sendNetworkRequestAsyncHelper(httpMethod, url, options) {
    if (httpMethod === HttpMethod.GET) {
      return this.httpClientNoRetries.sendGetRequestAsync(url, options);
    } else {
      return this.httpClientNoRetries.sendPostRequestAsync(url, options);
    }
  }
  async sendNetworkRequestAsync(httpMethod, url, options) {
    let response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
    let currentRetry = 0;
    while (await this.retryPolicy.pauseForRetry(response.status, currentRetry, response.headers[HeaderNames.RETRY_AFTER])) {
      response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
      currentRetry++;
    }
    return response;
  }
  async sendGetRequestAsync(url, options) {
    return this.sendNetworkRequestAsync(HttpMethod.GET, url, options);
  }
  async sendPostRequestAsync(url, options) {
    return this.sendNetworkRequestAsync(HttpMethod.POST, url, options);
  }
};

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs
var ManagedIdentityUserAssignedIdQueryParameterNames = {
  MANAGED_IDENTITY_CLIENT_ID: "client_id",
  MANAGED_IDENTITY_OBJECT_ID: "object_id",
  MANAGED_IDENTITY_RESOURCE_ID_IMDS: "msi_res_id",
  MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS: "mi_res_id"
};
var BaseManagedIdentitySource = class {
  constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
    this.logger = logger;
    this.nodeStorage = nodeStorage;
    this.networkClient = networkClient;
    this.cryptoProvider = cryptoProvider;
    this.disableInternalRetries = disableInternalRetries;
  }
  async getServerTokenResponseAsync(response, _networkClient, _networkRequest, _networkRequestOptions) {
    return this.getServerTokenResponse(response);
  }
  getServerTokenResponse(response) {
    var _a, _b;
    let refreshIn, expiresIn;
    if (response.body.expires_on) {
      if (isIso8601(response.body.expires_on)) {
        response.body.expires_on = new Date(response.body.expires_on).getTime() / 1e3;
      }
      expiresIn = response.body.expires_on - TimeUtils_exports.nowSeconds();
      if (expiresIn > 2 * 3600) {
        refreshIn = expiresIn / 2;
      }
    }
    const serverTokenResponse = {
      status: response.status,
      // success
      access_token: response.body.access_token,
      expires_in: expiresIn,
      scope: response.body.resource,
      token_type: response.body.token_type,
      refresh_in: refreshIn,
      // error
      correlation_id: response.body.correlation_id || response.body.correlationId,
      error: typeof response.body.error === "string" ? response.body.error : (_a = response.body.error) == null ? void 0 : _a.code,
      error_description: response.body.message || (typeof response.body.error === "string" ? response.body.error_description : (_b = response.body.error) == null ? void 0 : _b.message),
      error_codes: response.body.error_codes,
      timestamp: response.body.timestamp,
      trace_id: response.body.trace_id
    };
    return serverTokenResponse;
  }
  async acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
    const networkRequest = this.createRequest(managedIdentityRequest.resource, managedIdentityId);
    const headers = networkRequest.headers;
    headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
    const networkRequestOptions = { headers };
    if (Object.keys(networkRequest.bodyParameters).length) {
      networkRequestOptions.body = networkRequest.computeParametersBodyString();
    }
    const networkClientHelper = this.disableInternalRetries ? this.networkClient : new HttpClientWithRetries(this.networkClient, networkRequest.retryPolicy);
    const reqTimestamp = TimeUtils_exports.nowSeconds();
    let response;
    try {
      if (networkRequest.httpMethod === HttpMethod.POST) {
        response = await networkClientHelper.sendPostRequestAsync(networkRequest.computeUri(), networkRequestOptions);
      } else {
        response = await networkClientHelper.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
      }
    } catch (error) {
      if (error instanceof AuthError) {
        throw error;
      } else {
        throw createClientAuthError(ClientAuthErrorCodes_exports.networkError);
      }
    }
    const responseHandler = new ResponseHandler(managedIdentityId.id, this.nodeStorage, this.cryptoProvider, this.logger, null, null);
    const serverTokenResponse = await this.getServerTokenResponseAsync(response, networkClientHelper, networkRequest, networkRequestOptions);
    responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
    return responseHandler.handleServerTokenResponse(serverTokenResponse, fakeAuthority, reqTimestamp, managedIdentityRequest);
  }
  getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityIdType, imds) {
    switch (managedIdentityIdType) {
      case ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:
        this.logger.info("[Managed Identity] Adding user assigned client id to the request.");
        return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;
      case ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:
        this.logger.info("[Managed Identity] Adding user assigned resource id to the request.");
        return imds ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_IMDS : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS;
      case ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:
        this.logger.info("[Managed Identity] Adding user assigned object id to the request.");
        return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;
      default:
        throw createManagedIdentityError(invalidManagedIdentityIdType);
    }
  }
};
BaseManagedIdentitySource.getValidatedEnvVariableUrlString = (envVariableStringName, envVariable, sourceName, logger) => {
  try {
    return new UrlString(envVariable).urlString;
  } catch (error) {
    logger.info(`[Managed Identity] ${sourceName} managed identity is unavailable because the '${envVariableStringName}' environment variable is malformed.`);
    throw createManagedIdentityError(MsiEnvironmentVariableUrlMalformedErrorCodes[envVariableStringName]);
  }
};

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs
var import_fs = require("fs");
var import_path = __toESM(require("path"), 1);
var SUPPORTED_AZURE_ARC_PLATFORMS = {
  win32: `${process.env["ProgramData"]}\\AzureConnectedMachineAgent\\Tokens\\`,
  linux: "/var/opt/azcmagent/tokens/"
};
var AZURE_ARC_FILE_DETECTION = {
  win32: `${process.env["ProgramFiles"]}\\AzureConnectedMachineAgent\\himds.exe`,
  linux: "/opt/azcmagent/bin/himds"
};

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs
var IMDS_TOKEN_PATH = "/metadata/identity/oauth2/token";
var DEFAULT_IMDS_ENDPOINT = `http://169.254.169.254${IMDS_TOKEN_PATH}`;

// src/auth.ts
var import_remote = __toESM(require_renderer2());
var fs = __toESM(require("fs"));
var AUTHORITY = "https://login.microsoftonline.com/consumers";
var REDIRECT_URI2 = "http://localhost:5000";
var SCOPES = ["Tasks.ReadWrite", "offline_access"];
var AuthManager = class {
  /**
   * Creates an instance of AuthManager.
   * @param clientId - The client ID of your Azure AD application.
   * @param clientSecret - The client secret of your Azure AD application.
   * @param redirectUrl - The redirect URL registered in your Azure AD app.
   * @param tokenFilePath - Path to the file where the token cache will be stored.
   */
  constructor(clientId, clientSecret, redirectUrl, tokenFilePath) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectUrl = redirectUrl;
    this.tokenFilePath = tokenFilePath;
    this.initClient();
  }
  /**
   * Initializes the MSAL client with the given configuration.
   */
  initClient() {
    const config2 = {
      auth: {
        clientId: this.clientId,
        authority: AUTHORITY,
        clientSecret: this.clientSecret
      }
    };
    this.cca = new ConfidentialClientApplication(config2);
  }
  /**
   * Saves the current token cache to disk.
   */
  saveTokenCache() {
    const tokenCacheSerialized = this.cca.getTokenCache().serialize();
    fs.writeFileSync(this.tokenFilePath, tokenCacheSerialized);
  }
  /**
   * Performs an interactive login to acquire an access token.
   * Opens a BrowserWindow to let the user sign in.
   * @returns A promise that resolves with an object containing a valid access token.
   */
  async getAccessToken() {
    return new Promise((resolve, reject) => {
      const authUrl = `${AUTHORITY}/oauth2/v2.0/authorize?client_id=${this.clientId}&response_type=code&redirect_uri=${encodeURIComponent(REDIRECT_URI2)}&response_mode=query&scope=${encodeURIComponent(SCOPES.join(" "))}&prompt=consent`;
      const authWindow = new import_remote.BrowserWindow({
        width: 600,
        height: 700,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true
        }
      });
      authWindow.loadURL(authUrl);
      authWindow.webContents.on("will-redirect", async (event, url) => {
        try {
          const redirectURL = new URL(url);
          const error = redirectURL.searchParams.get("error");
          if (error) throw new Error("OAuth error: " + error);
          const authCode = redirectURL.searchParams.get("code");
          if (!authCode) return;
          event.preventDefault();
          authWindow.close();
          const tokenRequest = {
            code: authCode,
            scopes: SCOPES,
            redirectUri: REDIRECT_URI2
          };
          const tokenResponse = await this.cca.acquireTokenByCode(tokenRequest);
          if (!tokenResponse)
            throw new Error("No token response received.");
          this.saveTokenCache();
          resolve({ accessToken: tokenResponse.accessToken });
        } catch (err) {
          if (!authWindow.isDestroyed()) authWindow.close();
          reject(err);
        }
      });
    });
  }
  /**
   * Refreshes the access token using the refresh token stored in the token cache.
   * @returns A promise that resolves with an object containing a new access token.
   */
  async refreshAccessTokenWithCCA() {
    if (!fs.existsSync(this.tokenFilePath)) {
      throw new Error("No token cache found. Please login first.");
    }
    const cacheData = fs.readFileSync(this.tokenFilePath, "utf8");
    this.cca.getTokenCache().deserialize(cacheData);
    const tokenCacheSerialized = this.cca.getTokenCache().serialize();
    const parsedCache = JSON.parse(tokenCacheSerialized);
    if (!parsedCache.RefreshToken) {
      throw new Error("No refresh token found in the cache.");
    }
    const refreshTokenObject = parsedCache.RefreshToken;
    const refreshTokenKey = Object.keys(refreshTokenObject)[0];
    const refreshToken = refreshTokenObject[refreshTokenKey].secret;
    const tokenRequest = {
      refreshToken,
      scopes: SCOPES,
      redirectUri: REDIRECT_URI2
    };
    try {
      const tokenResponse = await this.cca.acquireTokenByRefreshToken(tokenRequest);
      if (!tokenResponse)
        throw new Error("No token response received from refresh.");
      this.saveTokenCache();
      return { accessToken: tokenResponse.accessToken };
    } catch (error) {
      throw error;
    }
  }
  /**
   * Returns a valid access token by checking the token cache.
   * If a token is available, it refreshes it; otherwise, it performs an interactive login.
   * @returns A promise that resolves with an object containing a valid access token.
   */
  async getToken() {
    if (fs.existsSync(this.tokenFilePath)) {
      return this.refreshAccessTokenWithCCA();
    } else {
      return this.getAccessToken();
    }
  }
};

// src/task-title-modal.ts
var import_obsidian5 = require("obsidian");
var TaskTitleModal = class extends import_obsidian5.Modal {
  /**
   * Constructs the modal.
   * @param app - The Obsidian app instance.
   * @param onSubmit - A callback that receives the entered task title.
   */
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  /**
   * Called when the modal is opened. Renders the input UI and centers it.
   */
  onOpen() {
    const { contentEl } = this;
    contentEl.style.display = "flex";
    contentEl.style.flexDirection = "column";
    contentEl.style.alignItems = "center";
    contentEl.style.justifyContent = "center";
    contentEl.style.gap = "10px";
    contentEl.style.minHeight = "100px";
    contentEl.createEl("h2", { text: "Enter Task Title" });
    const inputEl = contentEl.createEl("input", {
      type: "text",
      placeholder: "Task Title"
    });
    inputEl.style.width = "100%";
    inputEl.focus();
    inputEl.onkeydown = (e) => {
      if (e.key === "Enter") {
        this.result = inputEl.value;
        this.close();
        this.onSubmit(this.result);
      }
    };
  }
  /**
   * Called when the modal is closed. Clears the content.
   */
  onClose() {
    this.contentEl.empty();
  }
};

// src/select-modal.ts
var import_obsidian6 = require("obsidian");
var GenericSelectModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, items, getText, onSelect) {
    super(app);
    this.items = items;
    this.getText = getText;
    this.onSelect = onSelect;
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    return this.getText(item);
  }
  async onChooseItem(item) {
    await this.onSelect(item);
  }
};

// src/main.ts
var TaskSyncerPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.sidebarView = null;
    this.taskCache = null;
  }
  /**
   * Called when the plugin is activated.
   * Loads environment variables, settings, registers views and commands, and initializes authentication.
   */
  async onload() {
    const basePath = this.app.vault.adapter.basePath;
    const pluginPath = path2.join(
      basePath,
      ".obsidian/plugins/sync-obsidian-todo-plugin"
    );
    dotenv.config({ path: path2.join(pluginPath, ".env"), override: true });
    await this.loadSettings();
    this.addSettingTab(new MyTodoSettingTab(this.app, this));
    this.registerView(VIEW_TYPE_TODO_SIDEBAR, (leaf) => {
      const view = new TaskSidebarView(leaf, this);
      this.sidebarView = view;
      return view;
    });
    this.initializeCommand();
    this.tokenFilePath = `${pluginPath}/token_cache.json`;
    if (this.settings.clientId && this.settings.clientSecret) {
      this.authManager = new AuthManager(
        this.settings.clientId,
        this.settings.clientSecret,
        this.settings.redirectUrl,
        this.tokenFilePath
      );
    }
    if (fs2.existsSync(this.tokenFilePath)) {
      const cacheData = fs2.readFileSync(this.tokenFilePath, "utf8");
      this.authManager.cca.getTokenCache().deserialize(cacheData);
      console.log("Token cache loaded from file.");
    }
    this.injectStyles();
    notify("Microsoft To-Do Plugin Loaded!", "info");
  }
  /**
   * Initializes the MSAL client and registers commands/ribbon icons.
   */
  initializeCommand() {
    this.addCommand({
      id: "open-microsoft-todo-sidebar",
      name: "Open Microsoft To-Do Sidebar",
      callback: async () => {
        this.activateSidebar();
      }
    });
    this.addCommand({
      id: "login-microsoft-todo",
      name: "Login to Microsoft To-Do (Interactive)",
      callback: async () => {
        try {
          notify("Logging in...");
          await this.authManager.getAccessToken();
          notify("Logged in successfully!", "success");
        } catch (error) {
          console.error("Authentication error:", error);
          notify(
            "Error logining in! Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "refresh-microsoft-todo-token",
      name: "Refresh Microsoft To-Do Token",
      callback: async () => {
        try {
          const tokenData = await this.authManager.refreshAccessTokenWithCCA();
          notify("Token refreshed successfully!", "success");
          console.log("New Access Token:", tokenData.accessToken);
        } catch (error) {
          console.error("Error refreshing token:", error);
          notify(
            "Error refreshing token. Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "get-tasks-from-selected-list",
      name: "Get Tasks from Selected List",
      callback: async () => {
        try {
          notify("Fetching tasks...");
          await this.getTasksFromSelectedList();
          notify("Tasks fetched successfully!", "success");
        } catch (error) {
          console.error(
            "Error fetching tasks from selected list:",
            error
          );
          notify(
            "Error fetching tasks. Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "push-all-tasks-from-note",
      name: "Push All Tasks from Note to Microsoft To-Do",
      callback: async () => {
        try {
          notify("Syncing tasks to Microsoft To-Do...");
          const tasksCount = await this.pushTasksFromNote();
          notify(
            `Tasks synced successfully! ${tasksCount} new tasks added.`,
            "success"
          );
          await this.refreshViewAndCache();
        } catch (error) {
          console.error("Error pushing tasks:", error);
          notify(
            "Error pushing tasks. Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "push-one-task",
      name: "Create and push Task",
      callback: async () => {
        new TaskTitleModal(this.app, async (taskTitle) => {
          try {
            notify("Pushing tasks to Microsoft To-Do...");
            await this.pushOneTask(taskTitle);
            notify(`Tasks pushed successfully!`, "success");
          } catch (error) {
            console.error("Error pushing tasks:", error);
            notify(
              "Error pushing tasks. Check the console for details.",
              "error"
            );
          }
        }).open();
      }
    });
    this.addCommand({
      id: "show-not-started-tasks",
      name: "Show Tasks List",
      callback: async () => {
        try {
          await this.openTaskCompleteModal();
        } catch (error) {
          console.error("Error completing task:", error);
          notify(
            "Error completing task. Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "select-task-list",
      name: "Select Task List",
      callback: async () => {
        try {
          notify("Selecting task list...");
          await this.openTaskListsModal();
          notify("Task list selected successfully!", "success");
        } catch (error) {
          console.error("Error selecting task list:", error);
          notify(
            "Error selecting task list. Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "organize-tasks",
      name: "Organize Tasks from All Notes",
      callback: async () => {
        try {
          await this.gatherTasks();
          notify("Tasks organized successfully!", "success");
        } catch (error) {
          console.error("Error organizing tasks:", error);
          notify(
            "Error organizing tasks. Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "delete-completed-tasks",
      name: "Delete Completed Tasks",
      callback: async () => {
        try {
          notify("Deleting completed tasks...");
          const deletedCount = await this.deleteAllCompletedTasks();
          notify(
            `${deletedCount} completed tasks deleted successfully!`,
            "success"
          );
        } catch (error) {
          console.error("Error deleting completed tasks:", error);
          notify(
            "Error deleting tasks. Check the console for details.",
            "error"
          );
        }
      }
    });
    this.addCommand({
      id: "testing",
      name: "Testing",
      callback: async () => {
        try {
          console.log("Testing");
          notify("Testing...", "success");
        } catch (error) {
          console.error("Error testing:", error);
        }
      }
    });
  }
  /**
   * Injects custom CSS styles into the document.
   */
  injectStyles() {
    const style = document.createElement("style");
    style.textContent = `
		.task-line {
			display: flex;
			align-items: center;
			gap: 8px;
			padding: 2px 0;
		}

		.task-line input[type="checkbox"] {
			margin: 0;
			transform: scale(1.1);
		}

		.task-line span {
			font-size: 14px;
		}
	`;
    document.head.appendChild(style);
  }
  /**
   * Activates the sidebar view.
   */
  async activateSidebar() {
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    if (!rightLeaf) {
      console.warn("No right leaf available.");
      return;
    }
    await rightLeaf.setViewState({
      type: VIEW_TYPE_TODO_SIDEBAR,
      active: true
    });
    this.app.workspace.revealLeaf(rightLeaf);
  }
  /**
   * Loads plugin settings from the Obsidian vault.
   */
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  /**
   * Saves plugin settings to the Obsidian vault.
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async getAccessToken() {
    try {
      const tokenData = await this.authManager.getToken();
      return tokenData.accessToken;
    } catch (error) {
      console.error("Error fetching access token:", error);
      throw error;
    }
  }
  /**
   * Fetches available Microsoft To-Do task lists and updates the plugin settings.
   */
  async loadAvailableTaskLists() {
    notify("Loading task lists...");
    try {
      const accessToken = await this.getAccessToken();
      const listArray = await fetchTaskLists(accessToken);
      console.log("Fetched Task Lists:", listArray);
      this.settings.taskLists = listArray.map((list) => ({
        id: list.id,
        title: list.title
      }));
      notify("Task lists loaded successfully!", "success");
    } catch (err) {
      console.error("Error loading task lists:", err);
      notify(
        "Error loading task lists. Check the console for details.",
        "error"
      );
    }
  }
  /**
   * Get task lists using access token with fetchTaskLists api function.
   * @returns A TaskList interface with fetched task lists.
   * */
  async getTaskLists() {
    try {
      const accessToken = await this.getAccessToken();
      const taskLists = await fetchTaskLists(accessToken);
      return taskLists;
    } catch (error) {
      console.error("Error fetching task lists:", error);
      throw error;
    }
  }
  /**
   * Fetches tasks from the selected Microsoft ToDo list.
   * @returns A map of task title to an object containing task details.
   */
  async getTasksFromSelectedList() {
    if (!this.settings.selectedTaskListId) {
      throw new Error(
        "No task list selected. Please choose one in settings."
      );
    }
    if (this.taskCache && this.taskCache.tasks) {
      console.log("Using cached tasks:", this.taskCache.tasks);
      return new Map(this.taskCache.tasks);
    }
    try {
      console.log("No cached tasks found, refreshing task cache.");
      return await this.refreshTaskCache();
    } catch (error) {
      console.error("Error fetching tasks:", error);
      throw error;
    }
  }
  /**
   * Pushes tasks from the active note to Microsoft ToDo.
   * @returns The number of new tasks created.
   */
  async pushTasksFromNote() {
    if (!this.settings.selectedTaskListId) {
      throw new Error(
        "No task list selected. Please choose one in settings."
      );
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      throw new Error("No active file found.");
    }
    const fileContent = await this.app.vault.read(activeFile);
    const taskRegex = /^-\s*\[( |x)\]\s+(.+)$/gm;
    const noteTasks = [];
    let match;
    while ((match = taskRegex.exec(fileContent)) !== null) {
      const complete = match[1] === "x";
      const title = match[2].trim();
      noteTasks.push({ title, complete });
    }
    if (noteTasks.length === 0) {
      throw new Error("No tasks found in the active note.");
    }
    try {
      const accessToken = await this.getAccessToken();
      const existingTasks = await fetchTasks(this.settings, accessToken);
      let newTasksCount = 0;
      for (const task of noteTasks) {
        const existingTask = existingTasks.get(task.title);
        if (existingTask) {
          if (task.complete && existingTask.status !== "completed") {
            await updateTask(
              this.settings,
              accessToken,
              existingTask.id,
              true
            );
          } else {
            console.log(`Task already exists: ${task.title}`);
          }
          continue;
        }
        const initialStatus = task.complete ? "completed" : "notStarted";
        await createTask(
          this.settings,
          accessToken,
          task.title,
          initialStatus
        );
        newTasksCount++;
      }
      console.log("Synced Tasks:", noteTasks);
      return newTasksCount;
    } catch (error) {
      console.error("Error syncing tasks:", error);
      throw error;
    }
  }
  /**
   * Pushes a single task to selected list in Microsoft ToDo.
   * @param task - The task title text to push.
   */
  async pushOneTask(task) {
    if (!this.settings.selectedTaskListId) {
      throw new Error(
        "No task list selected. Please choose one in settings."
      );
    }
    try {
      const accessToken = await this.getAccessToken();
      const existingTasks = await fetchTasks(this.settings, accessToken);
      const existingTask = existingTasks.get(task);
      if (existingTask) {
        console.log(`Task already exists: ${task}`);
      }
      await createTask(this.settings, accessToken, task);
      await this.refreshViewAndCache();
      console.log("Synced Tasks:", task);
    } catch (error) {
      console.error("Error syncing tasks:", error);
      throw error;
    }
  }
  /**
   * Gathers tasks from all markdown files in the vault and updates (or creates) a consolidated note.
   * @returns A map of task text to its current state.
   */
  async gatherTasks() {
    const noteName = "Tasks List.md";
    const markdownFiles = this.app.vault.getMarkdownFiles();
    const tasksMap = /* @__PURE__ */ new Map();
    const taskRegex = /^\s*-\s*\[( |x)\]\s+(.*)$/gm;
    for (const file of markdownFiles) {
      const content = await this.app.vault.read(file);
      let match;
      while ((match = taskRegex.exec(content)) !== null) {
        const currentState = match[1] === "x" ? "[x]" : "[ ]";
        const taskText = match[2].trim();
        if (tasksMap.has(taskText)) {
          if (currentState === "[x]") {
            tasksMap.set(taskText, "[x]");
          }
        } else {
          tasksMap.set(taskText, currentState);
        }
      }
    }
    const finalTasks = Array.from(tasksMap.entries()).map(
      ([taskText, state]) => `- ${state} ${taskText}`
    );
    const newContent = finalTasks.join("\n");
    const targetFile = this.app.vault.getAbstractFileByPath(noteName);
    if (!targetFile) {
      await this.app.vault.create(noteName, newContent);
    } else if (targetFile instanceof import_obsidian7.TFile) {
      await this.app.vault.modify(targetFile, newContent);
    } else {
      throw new Error("Unexpected file type for Tasks List");
    }
    return tasksMap;
  }
  /**
   * Open a interactive window for the user to interact and select a target task list.
   */
  async openTaskListsModal() {
    const tasksLists = this.settings.taskLists;
    console.log("Task Lists:", tasksLists);
    new GenericSelectModal(
      this.app,
      tasksLists,
      (taskList) => taskList.title,
      async (taskList) => {
        this.settings.selectedTaskListId = taskList.id;
        await this.saveSettings();
        await this.refreshViewAndCache();
      }
    ).open();
  }
  /**
   * Open a interactive window for the user to interact and select to complete task items.
   */
  async openTaskCompleteModal() {
    const tasksMap = await this.getTasksFromSelectedList();
    const notStartedTasks = Array.from(tasksMap.values()).filter(
      (task) => task.status !== "completed"
    );
    new GenericSelectModal(
      this.app,
      notStartedTasks,
      (task) => task.status !== "completed" ? task.title : "",
      async (task) => {
        const accessToken = await this.getAccessToken();
        await updateTask(this.settings, accessToken, task.id, true);
        notify(
          `Task "${task.title}" marked as complete and synced.`,
          "success"
        );
        await this.refreshViewAndCache();
      }
    ).open();
  }
  /**
   * Fetch task using api function and store in the cache for quick access.
   */
  async refreshTaskCache() {
    if (!this.settings.selectedTaskListId) {
      throw new Error(
        "No task list selected. Please choose one in settings."
      );
    }
    try {
      const accessToken = await this.getAccessToken();
      const tasks = await fetchTasks(this.settings, accessToken);
      console.log("Fetched Tasks:", tasks);
      const currentData = await this.loadData() || {};
      currentData.tasks = Array.from(tasks.entries());
      this.taskCache = currentData;
      await this.saveData(currentData);
      return tasks;
    } catch (error) {
      console.error("Error fetching tasks:", error);
      throw error;
    }
  }
  /**
   * Use the deleteTask api function to delete all completed task in the targeted task list.
   * @returns Amount of deleted tasks.
   */
  async deleteAllCompletedTasks() {
    if (!this.settings.selectedTaskListId) {
      throw new Error(
        "No task list selected. Please choose one in settings."
      );
    }
    let deletedTasksCount = 0;
    try {
      const accessToken = await this.getAccessToken();
      const tasks = await this.getTasksFromSelectedList();
      const completedTasks = Array.from(tasks.values()).filter(
        (task) => task.status === "completed"
      );
      for (const task of completedTasks) {
        console.log("Deleting Task:", task);
        await deleteTask(this.settings, accessToken, task.id);
        deletedTasksCount++;
      }
      this.refreshViewAndCache();
      return deletedTasksCount;
    } catch (error) {
      console.error("Error deleting tasks:", error);
      return deletedTasksCount;
    }
  }
  /**
   * Refreshes the sidebar view and task cache to display the latest tasks.
   */
  async refreshViewAndCache() {
    const tasks = await this.refreshTaskCache();
    if (this.sidebarView) {
      await this.sidebarView.render(tasks);
    } else {
      console.warn("Sidebar view is not active.");
    }
  }
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@azure/msal-node/dist/cache/serializer/Serializer.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-common/dist/utils/Constants.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/AuthErrorCodes.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/AuthError.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/ClientAuthError.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/crypto/ICrypto.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/logger/Logger.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/packageMetadata.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/AuthorityOptions.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/account/AuthToken.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/utils/TimeUtils.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/cache/utils/CacheHelpers.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/ClientConfigurationError.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/utils/StringUtils.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/request/ScopeSet.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/account/ClientInfo.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/account/AccountInfo.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/AuthorityType.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/account/TokenClaims.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/ProtocolMode.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/cache/entities/AccountEntity.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/utils/UrlUtils.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/url/UrlString.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/AuthorityMetadata.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/CacheErrorCodes.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/CacheError.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/cache/CacheManager.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/config/ClientConfiguration.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/account/CcsCredential.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/constants/AADServerParamKeys.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/request/RequestParameterBuilder.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/utils/FunctionWrappers.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/RegionDiscovery.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/Authority.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/authority/AuthorityFactory.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/ServerError.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/network/RequestThumbprint.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/network/ThrottlingUtils.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/NetworkError.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/client/BaseClient.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/utils/ProtocolUtils.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/crypto/PopTokenGenerator.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/response/ResponseHandler.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/request/RequestValidator.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/utils/ClientAssertionUtils.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/client/AuthorizationCodeClient.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/client/RefreshTokenClient.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/client/SilentFlowClient.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/protocol/Authorize.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-common/dist/index-node.mjs:
  (*! @azure/msal-common v15.4.0 2025-03-25 *)

@azure/msal-node/dist/cache/serializer/Deserializer.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/internals.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/utils/Constants.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/utils/NetworkUtils.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/network/HttpClient.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/error/ManagedIdentityError.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/config/ManagedIdentityId.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/error/NodeAuthError.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/config/Configuration.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/crypto/GuidGenerator.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/utils/EncodingUtils.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/crypto/HashUtils.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/crypto/PkceGenerator.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/crypto/CryptoProvider.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/cache/NodeStorage.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/cache/TokenCache.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ClientAssertion.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/packageMetadata.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/UsernamePasswordClient.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/protocol/Authorize.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ClientApplication.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/network/LoopbackClient.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/DeviceCodeClient.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/PublicClientApplication.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ClientCredentialClient.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/OnBehalfOfClient.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ConfidentialClientApplication.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/utils/TimeUtils.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/network/HttpClientWithRetries.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/retry/LinearRetryPolicy.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentityClient.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/client/ManagedIdentityApplication.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)

@azure/msal-node/dist/index.mjs:
  (*! @azure/msal-node v3.4.1 2025-03-25 *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2RvdGVudi9wYWNrYWdlLmpzb24iLCAibm9kZV9tb2R1bGVzL2RvdGVudi9saWIvbWFpbi5qcyIsICJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2p3cy9saWIvZGF0YS1zdHJlYW0uanMiLCAibm9kZV9tb2R1bGVzL2J1ZmZlci1lcXVhbC1jb25zdGFudC10aW1lL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lY2RzYS1zaWctZm9ybWF0dGVyL3NyYy9wYXJhbS1ieXRlcy1mb3ItYWxnLmpzIiwgIm5vZGVfbW9kdWxlcy9lY2RzYS1zaWctZm9ybWF0dGVyL3NyYy9lY2RzYS1zaWctZm9ybWF0dGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9qd2EvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2p3cy9saWIvdG9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL2p3cy9saWIvc2lnbi1zdHJlYW0uanMiLCAibm9kZV9tb2R1bGVzL2p3cy9saWIvdmVyaWZ5LXN0cmVhbS5qcyIsICJub2RlX21vZHVsZXMvandzL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9qc29ud2VidG9rZW4vZGVjb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9qc29ud2VidG9rZW4vbGliL0pzb25XZWJUb2tlbkVycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9qc29ud2VidG9rZW4vbGliL05vdEJlZm9yZUVycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9qc29ud2VidG9rZW4vbGliL1Rva2VuRXhwaXJlZEVycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvanNvbndlYnRva2VuL2xpYi90aW1lc3Bhbi5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXRjaC5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcmNvbXBhcmUuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3QuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHQuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvZXJjZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2xydWNhY2hlLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWF4LXNhdGlzZnlpbmcuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXNhdGlzZnlpbmcuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbHRyLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc3Vic2V0LmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9saWIvYXN5bW1ldHJpY0tleURldGFpbHNTdXBwb3J0ZWQuanMiLCAibm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9saWIvcnNhUHNzS2V5RGV0YWlsc1N1cHBvcnRlZC5qcyIsICJub2RlX21vZHVsZXMvanNvbndlYnRva2VuL2xpYi92YWxpZGF0ZUFzeW1tZXRyaWNLZXkuanMiLCAibm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9saWIvcHNTdXBwb3J0ZWQuanMiLCAibm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi92ZXJpZnkuanMiLCAibm9kZV9tb2R1bGVzL2xvZGFzaC5pbmNsdWRlcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbG9kYXNoLmlzYm9vbGVhbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbG9kYXNoLmlzaW50ZWdlci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbG9kYXNoLmlzbnVtYmVyL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9sb2Rhc2guaXNwbGFpbm9iamVjdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbG9kYXNoLmlzc3RyaW5nL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9sb2Rhc2gub25jZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvanNvbndlYnRva2VuL3NpZ24uanMiLCAibm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGVsZWN0cm9uL3JlbW90ZS9kaXN0L3NyYy9yZW5kZXJlci9jYWxsYmFja3MtcmVnaXN0cnkuanMiLCAibm9kZV9tb2R1bGVzL0BlbGVjdHJvbi9yZW1vdGUvZGlzdC9zcmMvY29tbW9uL3R5cGUtdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL0BlbGVjdHJvbi9yZW1vdGUvZGlzdC9zcmMvY29tbW9uL2dldC1lbGVjdHJvbi1iaW5kaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9AZWxlY3Ryb24vcmVtb3RlL2Rpc3Qvc3JjL2NvbW1vbi9tb2R1bGUtbmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL0BlbGVjdHJvbi9yZW1vdGUvZGlzdC9zcmMvcmVuZGVyZXIvcmVtb3RlLmpzIiwgIm5vZGVfbW9kdWxlcy9AZWxlY3Ryb24vcmVtb3RlL2Rpc3Qvc3JjL3JlbmRlcmVyL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZWxlY3Ryb24vcmVtb3RlL3JlbmRlcmVyL2luZGV4LmpzIiwgInNyYy9tYWluLnRzIiwgInNyYy9zZXR0aW5nLnRzIiwgInNyYy9yaWdodC1zaWRlYmFyLXZpZXcudHMiLCAic3JjL3V0aWxzLnRzIiwgInNyYy9hcGkudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvc3JjL2NhY2hlL3NlcmlhbGl6ZXIvU2VyaWFsaXplci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy91dGlscy9Db25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvZXJyb3IvQXV0aEVycm9yQ29kZXMudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvZXJyb3IvQXV0aEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2Vycm9yL0NsaWVudEF1dGhFcnJvckNvZGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2Vycm9yL0NsaWVudEF1dGhFcnJvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9jcnlwdG8vSUNyeXB0by50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9sb2dnZXIvTG9nZ2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL3BhY2thZ2VNZXRhZGF0YS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9hdXRob3JpdHkvQXV0aG9yaXR5T3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9hY2NvdW50L0F1dGhUb2tlbi50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy91dGlscy9UaW1lVXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvY2FjaGUvdXRpbHMvQ2FjaGVIZWxwZXJzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy91dGlscy9TdHJpbmdVdGlscy50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9yZXF1ZXN0L1Njb3BlU2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2FjY291bnQvQ2xpZW50SW5mby50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9hY2NvdW50L0FjY291bnRJbmZvLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2F1dGhvcml0eS9BdXRob3JpdHlUeXBlLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2FjY291bnQvVG9rZW5DbGFpbXMudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvYXV0aG9yaXR5L1Byb3RvY29sTW9kZS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9jYWNoZS9lbnRpdGllcy9BY2NvdW50RW50aXR5LnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL3V0aWxzL1VybFV0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL3VybC9VcmxTdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvYXV0aG9yaXR5L0F1dGhvcml0eU1ldGFkYXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2Vycm9yL0NhY2hlRXJyb3JDb2Rlcy50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9lcnJvci9DYWNoZUVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2NhY2hlL0NhY2hlTWFuYWdlci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9jb25maWcvQ2xpZW50Q29uZmlndXJhdGlvbi50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9hY2NvdW50L0Njc0NyZWRlbnRpYWwudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvY29uc3RhbnRzL0FBRFNlcnZlclBhcmFtS2V5cy50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9yZXF1ZXN0L1JlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2F1dGhvcml0eS9PcGVuSWRDb25maWdSZXNwb25zZS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9hdXRob3JpdHkvQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2F1dGhvcml0eS9DbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy91dGlscy9GdW5jdGlvbldyYXBwZXJzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2F1dGhvcml0eS9SZWdpb25EaXNjb3ZlcnkudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvYXV0aG9yaXR5L0F1dGhvcml0eS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9hdXRob3JpdHkvQXV0aG9yaXR5RmFjdG9yeS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9lcnJvci9TZXJ2ZXJFcnJvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9uZXR3b3JrL1JlcXVlc3RUaHVtYnByaW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL25ldHdvcmsvVGhyb3R0bGluZ1V0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2Vycm9yL05ldHdvcmtFcnJvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9jbGllbnQvQmFzZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9lcnJvci9JbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvZXJyb3IvSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy91dGlscy9Qcm90b2NvbFV0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2NyeXB0by9Qb3BUb2tlbkdlbmVyYXRvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9jYWNoZS9wZXJzaXN0ZW5jZS9Ub2tlbkNhY2hlQ29udGV4dC50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9yZXNwb25zZS9SZXNwb25zZUhhbmRsZXIudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9zcmMvcmVxdWVzdC9SZXF1ZXN0VmFsaWRhdG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL3V0aWxzL0NsaWVudEFzc2VydGlvblV0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2NsaWVudC9BdXRob3JpemF0aW9uQ29kZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy9jbGllbnQvUmVmcmVzaFRva2VuQ2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL2NsaWVudC9TaWxlbnRGbG93Q2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vc3JjL3Byb3RvY29sL0F1dGhvcml6ZS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL3NyYy90ZWxlbWV0cnkvc2VydmVyL1NlcnZlclRlbGVtZXRyeU1hbmFnZXIudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvc3JjL2NhY2hlL3NlcmlhbGl6ZXIvRGVzZXJpYWxpemVyLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy91dGlscy9Db25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvc3JjL3V0aWxzL05ldHdvcmtVdGlscy50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvbmV0d29yay9IdHRwQ2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9lcnJvci9NYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9lcnJvci9NYW5hZ2VkSWRlbnRpdHlFcnJvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvZXJyb3IvTm9kZUF1dGhFcnJvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvY29uZmlnL0NvbmZpZ3VyYXRpb24udHMiLCAibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiLCAibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsICJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvc3JjL2NyeXB0by9HdWlkR2VuZXJhdG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy91dGlscy9FbmNvZGluZ1V0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jcnlwdG8vSGFzaFV0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jcnlwdG8vUGtjZUdlbmVyYXRvci50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvY3J5cHRvL0NyeXB0b1Byb3ZpZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jYWNoZS9Ob2RlU3RvcmFnZS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvY2FjaGUvVG9rZW5DYWNoZS50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvY2xpZW50L0NsaWVudEFzc2VydGlvbi50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvcGFja2FnZU1ldGFkYXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jbGllbnQvVXNlcm5hbWVQYXNzd29yZENsaWVudC50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvcHJvdG9jb2wvQXV0aG9yaXplLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jbGllbnQvQ2xpZW50QXBwbGljYXRpb24udHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvc3JjL2NsaWVudC9DbGllbnRDcmVkZW50aWFsQ2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jbGllbnQvT25CZWhhbGZPZkNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvY2xpZW50L0NvbmZpZGVudGlhbENsaWVudEFwcGxpY2F0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy91dGlscy9UaW1lVXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvc3JjL25ldHdvcmsvSHR0cENsaWVudFdpdGhSZXRyaWVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jbGllbnQvTWFuYWdlZElkZW50aXR5U291cmNlcy9CYXNlTWFuYWdlZElkZW50aXR5U291cmNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL3NyYy9jbGllbnQvTWFuYWdlZElkZW50aXR5U291cmNlcy9BenVyZUFyYy50cyIsICJub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9zcmMvY2xpZW50L01hbmFnZWRJZGVudGl0eVNvdXJjZXMvSW1kcy50cyIsICJzcmMvYXV0aC50cyIsICJzcmMvdGFzay10aXRsZS1tb2RhbC50cyIsICJzcmMvc2VsZWN0LW1vZGFsLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJ7XG4gIFwibmFtZVwiOiBcImRvdGVudlwiLFxuICBcInZlcnNpb25cIjogXCIxNi40LjdcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkxvYWRzIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIC5lbnYgZmlsZVwiLFxuICBcIm1haW5cIjogXCJsaWIvbWFpbi5qc1wiLFxuICBcInR5cGVzXCI6IFwibGliL21haW4uZC50c1wiLFxuICBcImV4cG9ydHNcIjoge1xuICAgIFwiLlwiOiB7XG4gICAgICBcInR5cGVzXCI6IFwiLi9saWIvbWFpbi5kLnRzXCIsXG4gICAgICBcInJlcXVpcmVcIjogXCIuL2xpYi9tYWluLmpzXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIuL2xpYi9tYWluLmpzXCJcbiAgICB9LFxuICAgIFwiLi9jb25maWdcIjogXCIuL2NvbmZpZy5qc1wiLFxuICAgIFwiLi9jb25maWcuanNcIjogXCIuL2NvbmZpZy5qc1wiLFxuICAgIFwiLi9saWIvZW52LW9wdGlvbnNcIjogXCIuL2xpYi9lbnYtb3B0aW9ucy5qc1wiLFxuICAgIFwiLi9saWIvZW52LW9wdGlvbnMuanNcIjogXCIuL2xpYi9lbnYtb3B0aW9ucy5qc1wiLFxuICAgIFwiLi9saWIvY2xpLW9wdGlvbnNcIjogXCIuL2xpYi9jbGktb3B0aW9ucy5qc1wiLFxuICAgIFwiLi9saWIvY2xpLW9wdGlvbnMuanNcIjogXCIuL2xpYi9jbGktb3B0aW9ucy5qc1wiLFxuICAgIFwiLi9wYWNrYWdlLmpzb25cIjogXCIuL3BhY2thZ2UuanNvblwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJkdHMtY2hlY2tcIjogXCJ0c2MgLS1wcm9qZWN0IHRlc3RzL3R5cGVzL3RzY29uZmlnLmpzb25cIixcbiAgICBcImxpbnRcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwicHJldGVzdFwiOiBcIm5wbSBydW4gbGludCAmJiBucG0gcnVuIGR0cy1jaGVja1wiLFxuICAgIFwidGVzdFwiOiBcInRhcCBydW4gLS1hbGxvdy1lbXB0eS1jb3ZlcmFnZSAtLWRpc2FibGUtY292ZXJhZ2UgLS10aW1lb3V0PTYwMDAwXCIsXG4gICAgXCJ0ZXN0OmNvdmVyYWdlXCI6IFwidGFwIHJ1biAtLXNob3ctZnVsbC1jb3ZlcmFnZSAtLXRpbWVvdXQ9NjAwMDAgLS1jb3ZlcmFnZS1yZXBvcnQ9bGNvdlwiLFxuICAgIFwicHJlcmVsZWFzZVwiOiBcIm5wbSB0ZXN0XCIsXG4gICAgXCJyZWxlYXNlXCI6IFwic3RhbmRhcmQtdmVyc2lvblwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL21vdGRvdGxhL2RvdGVudi5naXRcIlxuICB9LFxuICBcImZ1bmRpbmdcIjogXCJodHRwczovL2RvdGVudnguY29tXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZG90ZW52XCIsXG4gICAgXCJlbnZcIixcbiAgICBcIi5lbnZcIixcbiAgICBcImVudmlyb25tZW50XCIsXG4gICAgXCJ2YXJpYWJsZXNcIixcbiAgICBcImNvbmZpZ1wiLFxuICAgIFwic2V0dGluZ3NcIlxuICBdLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwiUkVBRE1FLm1kXCIsXG4gIFwibGljZW5zZVwiOiBcIkJTRC0yLUNsYXVzZVwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdHlwZXMvbm9kZVwiOiBcIl4xOC4xMS4zXCIsXG4gICAgXCJkZWNhY2hlXCI6IFwiXjQuNi4yXCIsXG4gICAgXCJzaW5vblwiOiBcIl4xNC4wLjFcIixcbiAgICBcInN0YW5kYXJkXCI6IFwiXjE3LjAuMFwiLFxuICAgIFwic3RhbmRhcmQtdmVyc2lvblwiOiBcIl45LjUuMFwiLFxuICAgIFwidGFwXCI6IFwiXjE5LjIuMFwiLFxuICAgIFwidHlwZXNjcmlwdFwiOiBcIl40LjguNFwiXG4gIH0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0xMlwiXG4gIH0sXG4gIFwiYnJvd3NlclwiOiB7XG4gICAgXCJmc1wiOiBmYWxzZVxuICB9XG59XG4iLCAiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG5jb25zdCBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG5cbmNvbnN0IHZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbmNvbnN0IExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZ1xuXG4vLyBQYXJzZSBzcmMgaW50byBhbiBPYmplY3RcbmZ1bmN0aW9uIHBhcnNlIChzcmMpIHtcbiAgY29uc3Qgb2JqID0ge31cblxuICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBzdHJpbmdcbiAgbGV0IGxpbmVzID0gc3JjLnRvU3RyaW5nKClcblxuICAvLyBDb252ZXJ0IGxpbmUgYnJlYWtzIHRvIHNhbWUgZm9ybWF0XG4gIGxpbmVzID0gbGluZXMucmVwbGFjZSgvXFxyXFxuPy9tZywgJ1xcbicpXG5cbiAgbGV0IG1hdGNoXG4gIHdoaWxlICgobWF0Y2ggPSBMSU5FLmV4ZWMobGluZXMpKSAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5ID0gbWF0Y2hbMV1cblxuICAgIC8vIERlZmF1bHQgdW5kZWZpbmVkIG9yIG51bGwgdG8gZW1wdHkgc3RyaW5nXG4gICAgbGV0IHZhbHVlID0gKG1hdGNoWzJdIHx8ICcnKVxuXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgLy8gQ2hlY2sgaWYgZG91YmxlIHF1b3RlZFxuICAgIGNvbnN0IG1heWJlUXVvdGUgPSB2YWx1ZVswXVxuXG4gICAgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3Rlc1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihbJ1wiYF0pKFtcXHNcXFNdKilcXDEkL21nLCAnJDInKVxuXG4gICAgLy8gRXhwYW5kIG5ld2xpbmVzIGlmIGRvdWJsZSBxdW90ZWRcbiAgICBpZiAobWF5YmVRdW90ZSA9PT0gJ1wiJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpXG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIG9iamVjdFxuICAgIG9ialtrZXldID0gdmFsdWVcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gX3BhcnNlVmF1bHQgKG9wdGlvbnMpIHtcbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIFBhcnNlIC5lbnYudmF1bHRcbiAgY29uc3QgcmVzdWx0ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudih7IHBhdGg6IHZhdWx0UGF0aCB9KVxuICBpZiAoIXJlc3VsdC5wYXJzZWQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE1JU1NJTkdfREFUQTogQ2Fubm90IHBhcnNlICR7dmF1bHRQYXRofSBmb3IgYW4gdW5rbm93biByZWFzb25gKVxuICAgIGVyci5jb2RlID0gJ01JU1NJTkdfREFUQSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIGhhbmRsZSBzY2VuYXJpbyBmb3IgY29tbWEgc2VwYXJhdGVkIGtleXMgLSBmb3IgdXNlIHdpdGgga2V5IHJvdGF0aW9uXG4gIC8vIGV4YW1wbGU6IERPVEVOVl9LRVk9XCJkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kLGRvdGVudjovLzprZXlfNzg5MEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PXByb2RcIlxuICBjb25zdCBrZXlzID0gX2RvdGVudktleShvcHRpb25zKS5zcGxpdCgnLCcpXG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cbiAgbGV0IGRlY3J5cHRlZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBmdWxsIGtleVxuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXS50cmltKClcblxuICAgICAgLy8gR2V0IGluc3RydWN0aW9ucyBmb3IgZGVjcnlwdFxuICAgICAgY29uc3QgYXR0cnMgPSBfaW5zdHJ1Y3Rpb25zKHJlc3VsdCwga2V5KVxuXG4gICAgICAvLyBEZWNyeXB0XG4gICAgICBkZWNyeXB0ZWQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdChhdHRycy5jaXBoZXJ0ZXh0LCBhdHRycy5rZXkpXG5cbiAgICAgIGJyZWFrXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGxhc3Qga2V5XG4gICAgICBpZiAoaSArIDEgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICAvLyB0cnkgbmV4dCBrZXlcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBkZWNyeXB0ZWQgLmVudiBzdHJpbmdcbiAgcmV0dXJuIERvdGVudk1vZHVsZS5wYXJzZShkZWNyeXB0ZWQpXG59XG5cbmZ1bmN0aW9uIF9sb2cgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bSU5GT10gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF93YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW1dBUk5dICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZGVidWcgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bREVCVUddICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZG90ZW52S2V5IChvcHRpb25zKSB7XG4gIC8vIHByaW9yaXRpemUgZGV2ZWxvcGVyIGRpcmVjdGx5IHNldHRpbmcgb3B0aW9ucy5ET1RFTlZfS0VZXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuRE9URU5WX0tFWSAmJiBvcHRpb25zLkRPVEVOVl9LRVkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBvcHRpb25zLkRPVEVOVl9LRVlcbiAgfVxuXG4gIC8vIHNlY29uZGFyeSBpbmZyYSBhbHJlYWR5IGNvbnRhaW5zIGEgRE9URU5WX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICBpZiAocHJvY2Vzcy5lbnYuRE9URU5WX0tFWSAmJiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuRE9URU5WX0tFWVxuICB9XG5cbiAgLy8gZmFsbGJhY2sgdG8gZW1wdHkgc3RyaW5nXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBfaW5zdHJ1Y3Rpb25zIChyZXN1bHQsIGRvdGVudktleSkge1xuICAvLyBQYXJzZSBET1RFTlZfS0VZLiBGb3JtYXQgaXMgYSBVUklcbiAgbGV0IHVyaVxuICB0cnkge1xuICAgIHVyaSA9IG5ldyBVUkwoZG90ZW52S2V5KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5jb2RlID09PSAnRVJSX0lOVkFMSURfVVJMJykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IFdyb25nIGZvcm1hdC4gTXVzdCBiZSBpbiB2YWxpZCB1cmkgZm9ybWF0IGxpa2UgZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9ZGV2ZWxvcG1lbnQnKVxuICAgICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIC8vIEdldCBkZWNyeXB0IGtleVxuICBjb25zdCBrZXkgPSB1cmkucGFzc3dvcmRcbiAgaWYgKCFrZXkpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBrZXkgcGFydCcpXG4gICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gR2V0IGVudmlyb25tZW50XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXJpLnNlYXJjaFBhcmFtcy5nZXQoJ2Vudmlyb25tZW50JylcbiAgaWYgKCFlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGVudmlyb25tZW50IHBhcnQnKVxuICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIEdldCBjaXBoZXJ0ZXh0IHBheWxvYWRcbiAgY29uc3QgZW52aXJvbm1lbnRLZXkgPSBgRE9URU5WX1ZBVUxUXyR7ZW52aXJvbm1lbnQudG9VcHBlckNhc2UoKX1gXG4gIGNvbnN0IGNpcGhlcnRleHQgPSByZXN1bHQucGFyc2VkW2Vudmlyb25tZW50S2V5XSAvLyBET1RFTlZfVkFVTFRfUFJPRFVDVElPTlxuICBpZiAoIWNpcGhlcnRleHQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE5PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlQ6IENhbm5vdCBsb2NhdGUgZW52aXJvbm1lbnQgJHtlbnZpcm9ubWVudEtleX0gaW4geW91ciAuZW52LnZhdWx0IGZpbGUuYClcbiAgICBlcnIuY29kZSA9ICdOT1RfRk9VTkRfRE9URU5WX0VOVklST05NRU5UJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgcmV0dXJuIHsgY2lwaGVydGV4dCwga2V5IH1cbn1cblxuZnVuY3Rpb24gX3ZhdWx0UGF0aCAob3B0aW9ucykge1xuICBsZXQgcG9zc2libGVWYXVsdFBhdGggPSBudWxsXG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkge1xuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XG4gICAgICAgICAgcG9zc2libGVWYXVsdFBhdGggPSBmaWxlcGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBmaWxlcGF0aCA6IGAke2ZpbGVwYXRofS52YXVsdGBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBvcHRpb25zLnBhdGggOiBgJHtvcHRpb25zLnBhdGh9LnZhdWx0YFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudi52YXVsdCcpXG4gIH1cblxuICBpZiAoZnMuZXhpc3RzU3luYyhwb3NzaWJsZVZhdWx0UGF0aCkpIHtcbiAgICByZXR1cm4gcG9zc2libGVWYXVsdFBhdGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlSG9tZSAoZW52UGF0aCkge1xuICByZXR1cm4gZW52UGF0aFswXSA9PT0gJ34nID8gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgZW52UGF0aC5zbGljZSgxKSkgOiBlbnZQYXRoXG59XG5cbmZ1bmN0aW9uIF9jb25maWdWYXVsdCAob3B0aW9ucykge1xuICBfbG9nKCdMb2FkaW5nIGVudiBmcm9tIGVuY3J5cHRlZCAuZW52LnZhdWx0JylcblxuICBjb25zdCBwYXJzZWQgPSBEb3RlbnZNb2R1bGUuX3BhcnNlVmF1bHQob3B0aW9ucylcblxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHByb2Nlc3NFbnYsIHBhcnNlZCwgb3B0aW9ucylcblxuICByZXR1cm4geyBwYXJzZWQgfVxufVxuXG5mdW5jdGlvbiBjb25maWdEb3RlbnYgKG9wdGlvbnMpIHtcbiAgY29uc3QgZG90ZW52UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudicpXG4gIGxldCBlbmNvZGluZyA9ICd1dGY4J1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIF9kZWJ1ZygnTm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkLiBVVEYtOCBpcyB1c2VkIGJ5IGRlZmF1bHQnKVxuICAgIH1cbiAgfVxuXG4gIGxldCBvcHRpb25QYXRocyA9IFtkb3RlbnZQYXRoXSAvLyBkZWZhdWx0LCBsb29rIGZvciAuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBvcHRpb25QYXRocyA9IFtfcmVzb2x2ZUhvbWUob3B0aW9ucy5wYXRoKV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbXSAvLyByZXNldCBkZWZhdWx0XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIG9wdGlvbnMucGF0aCkge1xuICAgICAgICBvcHRpb25QYXRocy5wdXNoKF9yZXNvbHZlSG9tZShmaWxlcGF0aCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHBhcnNlZCBkYXRhIGluIGEgdGVtcG9yYXJ5IG9iamVjdCAoYmVjYXVzZSB3ZSBuZWVkIHRvIHJldHVybiBpdCkuICBPbmNlIHdlIGhhdmUgdGhlIGZpbmFsXG4gIC8vIHBhcnNlZCBkYXRhLCB3ZSB3aWxsIGNvbWJpbmUgaXQgd2l0aCBwcm9jZXNzLmVudiAob3Igb3B0aW9ucy5wcm9jZXNzRW52IGlmIHByb3ZpZGVkKS5cbiAgbGV0IGxhc3RFcnJvclxuICBjb25zdCBwYXJzZWRBbGwgPSB7fVxuICBmb3IgKGNvbnN0IHBhdGggb2Ygb3B0aW9uUGF0aHMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3BlY2lmeWluZyBhbiBlbmNvZGluZyByZXR1cm5zIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBidWZmZXJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZyB9KSlcblxuICAgICAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHBhcnNlZEFsbCwgcGFyc2VkLCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBfZGVidWcoYEZhaWxlZCB0byBsb2FkICR7cGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICAgIGxhc3RFcnJvciA9IGVcbiAgICB9XG4gIH1cblxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHByb2Nlc3NFbnYsIHBhcnNlZEFsbCwgb3B0aW9ucylcblxuICBpZiAobGFzdEVycm9yKSB7XG4gICAgcmV0dXJuIHsgcGFyc2VkOiBwYXJzZWRBbGwsIGVycm9yOiBsYXN0RXJyb3IgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsIH1cbiAgfVxufVxuXG4vLyBQb3B1bGF0ZXMgcHJvY2Vzcy5lbnYgZnJvbSAuZW52IGZpbGVcbmZ1bmN0aW9uIGNvbmZpZyAob3B0aW9ucykge1xuICAvLyBmYWxsYmFjayB0byBvcmlnaW5hbCBkb3RlbnYgaWYgRE9URU5WX0tFWSBpcyBub3Qgc2V0XG4gIGlmIChfZG90ZW52S2V5KG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCB2YXVsdFBhdGggPSBfdmF1bHRQYXRoKG9wdGlvbnMpXG5cbiAgLy8gZG90ZW52S2V5IGV4aXN0cyBidXQgLmVudi52YXVsdCBmaWxlIGRvZXMgbm90IGV4aXN0XG4gIGlmICghdmF1bHRQYXRoKSB7XG4gICAgX3dhcm4oYFlvdSBzZXQgRE9URU5WX0tFWSBidXQgeW91IGFyZSBtaXNzaW5nIGEgLmVudi52YXVsdCBmaWxlIGF0ICR7dmF1bHRQYXRofS4gRGlkIHlvdSBmb3JnZXQgdG8gYnVpbGQgaXQ/YClcblxuICAgIHJldHVybiBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gRG90ZW52TW9kdWxlLl9jb25maWdWYXVsdChvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBkZWNyeXB0IChlbmNyeXB0ZWQsIGtleVN0cikge1xuICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShrZXlTdHIuc2xpY2UoLTY0KSwgJ2hleCcpXG4gIGxldCBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkLCAnYmFzZTY0JylcblxuICBjb25zdCBub25jZSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgMTIpXG4gIGNvbnN0IGF1dGhUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC0xNilcbiAgY2lwaGVydGV4dCA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMTIsIC0xNilcblxuICB0cnkge1xuICAgIGNvbnN0IGFlc2djbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMjU2LWdjbScsIGtleSwgbm9uY2UpXG4gICAgYWVzZ2NtLnNldEF1dGhUYWcoYXV0aFRhZylcbiAgICByZXR1cm4gYCR7YWVzZ2NtLnVwZGF0ZShjaXBoZXJ0ZXh0KX0ke2Flc2djbS5maW5hbCgpfWBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpc1JhbmdlID0gZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yXG4gICAgY29uc3QgaW52YWxpZEtleUxlbmd0aCA9IGVycm9yLm1lc3NhZ2UgPT09ICdJbnZhbGlkIGtleSBsZW5ndGgnXG4gICAgY29uc3QgZGVjcnlwdGlvbkZhaWxlZCA9IGVycm9yLm1lc3NhZ2UgPT09ICdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnXG5cbiAgICBpZiAoaXNSYW5nZSB8fCBpbnZhbGlkS2V5TGVuZ3RoKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogSXQgbXVzdCBiZSA2NCBjaGFyYWN0ZXJzIGxvbmcgKG9yIG1vcmUpJylcbiAgICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSBpZiAoZGVjcnlwdGlvbkZhaWxlZCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdERUNSWVBUSU9OX0ZBSUxFRDogUGxlYXNlIGNoZWNrIHlvdXIgRE9URU5WX0tFWScpXG4gICAgICBlcnIuY29kZSA9ICdERUNSWVBUSU9OX0ZBSUxFRCdcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuXG4vLyBQb3B1bGF0ZSBwcm9jZXNzLmVudiB3aXRoIHBhcnNlZCB2YWx1ZXNcbmZ1bmN0aW9uIHBvcHVsYXRlIChwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuICBjb25zdCBvdmVycmlkZSA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJyaWRlKVxuXG4gIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignT0JKRUNUX1JFUVVJUkVEOiBQbGVhc2UgY2hlY2sgdGhlIHByb2Nlc3NFbnYgYXJndW1lbnQgYmVpbmcgcGFzc2VkIHRvIHBvcHVsYXRlJylcbiAgICBlcnIuY29kZSA9ICdPQkpFQ1RfUkVRVUlSRUQnXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBTZXQgcHJvY2Vzcy5lbnZcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyc2VkKSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzc0Vudiwga2V5KSkge1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgIHByb2Nlc3NFbnZba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgICB9XG5cbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCBXQVMgb3ZlcndyaXR0ZW5gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9kZWJ1ZyhgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIHdhcyBOT1Qgb3ZlcndyaXR0ZW5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NFbnZba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IERvdGVudk1vZHVsZSA9IHtcbiAgY29uZmlnRG90ZW52LFxuICBfY29uZmlnVmF1bHQsXG4gIF9wYXJzZVZhdWx0LFxuICBjb25maWcsXG4gIGRlY3J5cHQsXG4gIHBhcnNlLFxuICBwb3B1bGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25maWdEb3RlbnYgPSBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52XG5tb2R1bGUuZXhwb3J0cy5fY29uZmlnVmF1bHQgPSBEb3RlbnZNb2R1bGUuX2NvbmZpZ1ZhdWx0XG5tb2R1bGUuZXhwb3J0cy5fcGFyc2VWYXVsdCA9IERvdGVudk1vZHVsZS5fcGFyc2VWYXVsdFxubW9kdWxlLmV4cG9ydHMuY29uZmlnID0gRG90ZW52TW9kdWxlLmNvbmZpZ1xubW9kdWxlLmV4cG9ydHMuZGVjcnlwdCA9IERvdGVudk1vZHVsZS5kZWNyeXB0XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IERvdGVudk1vZHVsZS5wYXJzZVxubW9kdWxlLmV4cG9ydHMucG9wdWxhdGUgPSBEb3RlbnZNb2R1bGUucG9wdWxhdGVcblxubW9kdWxlLmV4cG9ydHMgPSBEb3RlbnZNb2R1bGVcbiIsICIvKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwgIi8qZ2xvYmFsIG1vZHVsZSwgcHJvY2VzcyovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gRGF0YVN0cmVhbShkYXRhKSB7XG4gIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIE5vIGlucHV0XG4gIGlmICghZGF0YSkge1xuICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gU3RyZWFtXG4gIGlmICh0eXBlb2YgZGF0YS5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgZGF0YS5waXBlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQnVmZmVyIG9yIFN0cmluZ1xuICAvLyBvciBPYmplY3QgKGFzc3VtZWRseSBhIHBhc3N3b3JkZWQga2V5KVxuICBpZiAoZGF0YS5sZW5ndGggfHwgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy5idWZmZXIgPSBkYXRhO1xuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW1pdCgnZW5kJywgZGF0YSk7XG4gICAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgZGF0YSB0eXBlICgnKyB0eXBlb2YgZGF0YSArICcpJyk7XG59XG51dGlsLmluaGVyaXRzKERhdGFTdHJlYW0sIFN0cmVhbSk7XG5cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoZGF0YSkge1xuICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmZmVyLCBCdWZmZXIuZnJvbShkYXRhKV0pO1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbn07XG5cbkRhdGFTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChkYXRhKSB7XG4gIGlmIChkYXRhKVxuICAgIHRoaXMud3JpdGUoZGF0YSk7XG4gIHRoaXMuZW1pdCgnZW5kJywgZGF0YSk7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTdHJlYW07XG4iLCAiLypqc2hpbnQgbm9kZTp0cnVlICovXG4ndXNlIHN0cmljdCc7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyOyAvLyBicm93c2VyaWZ5XG52YXIgU2xvd0J1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLlNsb3dCdWZmZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyRXE7XG5cbmZ1bmN0aW9uIGJ1ZmZlckVxKGEsIGIpIHtcblxuICAvLyBzaG9ydGN1dHRpbmcgb24gdHlwZSBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3RuZXNzXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBidWZmZXIgc2l6ZXMgc2hvdWxkIGJlIHdlbGwta25vd24gaW5mb3JtYXRpb24sIHNvIGRlc3BpdGUgdGhpc1xuICAvLyBzaG9ydGN1dHRpbmcsIGl0IGRvZXNuJ3QgbGVhayBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlICpjb250ZW50cyogb2YgdGhlXG4gIC8vIGJ1ZmZlcnMuXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIC8qanNoaW50IGJpdHdpc2U6ZmFsc2UgKi9cbiAgICBjIHw9IGFbaV0gXiBiW2ldOyAvLyBYT1JcbiAgfVxuICByZXR1cm4gYyA9PT0gMDtcbn1cblxuYnVmZmVyRXEuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXIucHJvdG90eXBlLmVxdWFsID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbCh0aGF0KSB7XG4gICAgcmV0dXJuIGJ1ZmZlckVxKHRoaXMsIHRoYXQpO1xuICB9O1xufTtcblxudmFyIG9yaWdCdWZFcXVhbCA9IEJ1ZmZlci5wcm90b3R5cGUuZXF1YWw7XG52YXIgb3JpZ1Nsb3dCdWZFcXVhbCA9IFNsb3dCdWZmZXIucHJvdG90eXBlLmVxdWFsO1xuYnVmZmVyRXEucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXIucHJvdG90eXBlLmVxdWFsID0gb3JpZ0J1ZkVxdWFsO1xuICBTbG93QnVmZmVyLnByb3RvdHlwZS5lcXVhbCA9IG9yaWdTbG93QnVmRXF1YWw7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0UGFyYW1TaXplKGtleVNpemUpIHtcblx0dmFyIHJlc3VsdCA9ICgoa2V5U2l6ZSAvIDgpIHwgMCkgKyAoa2V5U2l6ZSAlIDggPT09IDAgPyAwIDogMSk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwYXJhbUJ5dGVzRm9yQWxnID0ge1xuXHRFUzI1NjogZ2V0UGFyYW1TaXplKDI1NiksXG5cdEVTMzg0OiBnZXRQYXJhbVNpemUoMzg0KSxcblx0RVM1MTI6IGdldFBhcmFtU2l6ZSg1MjEpXG59O1xuXG5mdW5jdGlvbiBnZXRQYXJhbUJ5dGVzRm9yQWxnKGFsZykge1xuXHR2YXIgcGFyYW1CeXRlcyA9IHBhcmFtQnl0ZXNGb3JBbGdbYWxnXTtcblx0aWYgKHBhcmFtQnl0ZXMpIHtcblx0XHRyZXR1cm4gcGFyYW1CeXRlcztcblx0fVxuXG5cdHRocm93IG5ldyBFcnJvcignVW5rbm93biBhbGdvcml0aG0gXCInICsgYWxnICsgJ1wiJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UGFyYW1CeXRlc0ZvckFsZztcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGdldFBhcmFtQnl0ZXNGb3JBbGcgPSByZXF1aXJlKCcuL3BhcmFtLWJ5dGVzLWZvci1hbGcnKTtcblxudmFyIE1BWF9PQ1RFVCA9IDB4ODAsXG5cdENMQVNTX1VOSVZFUlNBTCA9IDAsXG5cdFBSSU1JVElWRV9CSVQgPSAweDIwLFxuXHRUQUdfU0VRID0gMHgxMCxcblx0VEFHX0lOVCA9IDB4MDIsXG5cdEVOQ09ERURfVEFHX1NFUSA9IChUQUdfU0VRIHwgUFJJTUlUSVZFX0JJVCkgfCAoQ0xBU1NfVU5JVkVSU0FMIDw8IDYpLFxuXHRFTkNPREVEX1RBR19JTlQgPSBUQUdfSU5UIHwgKENMQVNTX1VOSVZFUlNBTCA8PCA2KTtcblxuZnVuY3Rpb24gYmFzZTY0VXJsKGJhc2U2NCkge1xuXHRyZXR1cm4gYmFzZTY0XG5cdFx0LnJlcGxhY2UoLz0vZywgJycpXG5cdFx0LnJlcGxhY2UoL1xcKy9nLCAnLScpXG5cdFx0LnJlcGxhY2UoL1xcLy9nLCAnXycpO1xufVxuXG5mdW5jdGlvbiBzaWduYXR1cmVBc0J1ZmZlcihzaWduYXR1cmUpIHtcblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihzaWduYXR1cmUpKSB7XG5cdFx0cmV0dXJuIHNpZ25hdHVyZTtcblx0fSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHNpZ25hdHVyZSkge1xuXHRcdHJldHVybiBCdWZmZXIuZnJvbShzaWduYXR1cmUsICdiYXNlNjQnKTtcblx0fVxuXG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VDRFNBIHNpZ25hdHVyZSBtdXN0IGJlIGEgQmFzZTY0IHN0cmluZyBvciBhIEJ1ZmZlcicpO1xufVxuXG5mdW5jdGlvbiBkZXJUb0pvc2Uoc2lnbmF0dXJlLCBhbGcpIHtcblx0c2lnbmF0dXJlID0gc2lnbmF0dXJlQXNCdWZmZXIoc2lnbmF0dXJlKTtcblx0dmFyIHBhcmFtQnl0ZXMgPSBnZXRQYXJhbUJ5dGVzRm9yQWxnKGFsZyk7XG5cblx0Ly8gdGhlIERFUiBlbmNvZGVkIHBhcmFtIHNob3VsZCBhdCBtb3N0IGJlIHRoZSBwYXJhbSBzaXplLCBwbHVzIGEgcGFkZGluZ1xuXHQvLyB6ZXJvLCBzaW5jZSBkdWUgdG8gYmVpbmcgYSBzaWduZWQgaW50ZWdlclxuXHR2YXIgbWF4RW5jb2RlZFBhcmFtTGVuZ3RoID0gcGFyYW1CeXRlcyArIDE7XG5cblx0dmFyIGlucHV0TGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcblxuXHR2YXIgb2Zmc2V0ID0gMDtcblx0aWYgKHNpZ25hdHVyZVtvZmZzZXQrK10gIT09IEVOQ09ERURfVEFHX1NFUSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgZXhwZWN0ZWQgXCJzZXFcIicpO1xuXHR9XG5cblx0dmFyIHNlcUxlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG5cdGlmIChzZXFMZW5ndGggPT09IChNQVhfT0NURVQgfCAxKSkge1xuXHRcdHNlcUxlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG5cdH1cblxuXHRpZiAoaW5wdXRMZW5ndGggLSBvZmZzZXQgPCBzZXFMZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wic2VxXCIgc3BlY2lmaWVkIGxlbmd0aCBvZiBcIicgKyBzZXFMZW5ndGggKyAnXCIsIG9ubHkgXCInICsgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0KSArICdcIiByZW1haW5pbmcnKTtcblx0fVxuXG5cdGlmIChzaWduYXR1cmVbb2Zmc2V0KytdICE9PSBFTkNPREVEX1RBR19JTlQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFwiaW50XCIgZm9yIFwiclwiJyk7XG5cdH1cblxuXHR2YXIgckxlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG5cblx0aWYgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0IC0gMiA8IHJMZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wiclwiIHNwZWNpZmllZCBsZW5ndGggb2YgXCInICsgckxlbmd0aCArICdcIiwgb25seSBcIicgKyAoaW5wdXRMZW5ndGggLSBvZmZzZXQgLSAyKSArICdcIiBhdmFpbGFibGUnKTtcblx0fVxuXG5cdGlmIChtYXhFbmNvZGVkUGFyYW1MZW5ndGggPCByTGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdcInJcIiBzcGVjaWZpZWQgbGVuZ3RoIG9mIFwiJyArIHJMZW5ndGggKyAnXCIsIG1heCBvZiBcIicgKyBtYXhFbmNvZGVkUGFyYW1MZW5ndGggKyAnXCIgaXMgYWNjZXB0YWJsZScpO1xuXHR9XG5cblx0dmFyIHJPZmZzZXQgPSBvZmZzZXQ7XG5cdG9mZnNldCArPSByTGVuZ3RoO1xuXG5cdGlmIChzaWduYXR1cmVbb2Zmc2V0KytdICE9PSBFTkNPREVEX1RBR19JTlQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFwiaW50XCIgZm9yIFwic1wiJyk7XG5cdH1cblxuXHR2YXIgc0xlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG5cblx0aWYgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0ICE9PSBzTGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdcInNcIiBzcGVjaWZpZWQgbGVuZ3RoIG9mIFwiJyArIHNMZW5ndGggKyAnXCIsIGV4cGVjdGVkIFwiJyArIChpbnB1dExlbmd0aCAtIG9mZnNldCkgKyAnXCInKTtcblx0fVxuXG5cdGlmIChtYXhFbmNvZGVkUGFyYW1MZW5ndGggPCBzTGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdcInNcIiBzcGVjaWZpZWQgbGVuZ3RoIG9mIFwiJyArIHNMZW5ndGggKyAnXCIsIG1heCBvZiBcIicgKyBtYXhFbmNvZGVkUGFyYW1MZW5ndGggKyAnXCIgaXMgYWNjZXB0YWJsZScpO1xuXHR9XG5cblx0dmFyIHNPZmZzZXQgPSBvZmZzZXQ7XG5cdG9mZnNldCArPSBzTGVuZ3RoO1xuXG5cdGlmIChvZmZzZXQgIT09IGlucHV0TGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBjb25zdW1lIGVudGlyZSBidWZmZXIsIGJ1dCBcIicgKyAoaW5wdXRMZW5ndGggLSBvZmZzZXQpICsgJ1wiIGJ5dGVzIHJlbWFpbicpO1xuXHR9XG5cblx0dmFyIHJQYWRkaW5nID0gcGFyYW1CeXRlcyAtIHJMZW5ndGgsXG5cdFx0c1BhZGRpbmcgPSBwYXJhbUJ5dGVzIC0gc0xlbmd0aDtcblxuXHR2YXIgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHJQYWRkaW5nICsgckxlbmd0aCArIHNQYWRkaW5nICsgc0xlbmd0aCk7XG5cblx0Zm9yIChvZmZzZXQgPSAwOyBvZmZzZXQgPCByUGFkZGluZzsgKytvZmZzZXQpIHtcblx0XHRkc3Rbb2Zmc2V0XSA9IDA7XG5cdH1cblx0c2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHJPZmZzZXQgKyBNYXRoLm1heCgtclBhZGRpbmcsIDApLCByT2Zmc2V0ICsgckxlbmd0aCk7XG5cblx0b2Zmc2V0ID0gcGFyYW1CeXRlcztcblxuXHRmb3IgKHZhciBvID0gb2Zmc2V0OyBvZmZzZXQgPCBvICsgc1BhZGRpbmc7ICsrb2Zmc2V0KSB7XG5cdFx0ZHN0W29mZnNldF0gPSAwO1xuXHR9XG5cdHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCBzT2Zmc2V0ICsgTWF0aC5tYXgoLXNQYWRkaW5nLCAwKSwgc09mZnNldCArIHNMZW5ndGgpO1xuXG5cdGRzdCA9IGRzdC50b1N0cmluZygnYmFzZTY0Jyk7XG5cdGRzdCA9IGJhc2U2NFVybChkc3QpO1xuXG5cdHJldHVybiBkc3Q7XG59XG5cbmZ1bmN0aW9uIGNvdW50UGFkZGluZyhidWYsIHN0YXJ0LCBzdG9wKSB7XG5cdHZhciBwYWRkaW5nID0gMDtcblx0d2hpbGUgKHN0YXJ0ICsgcGFkZGluZyA8IHN0b3AgJiYgYnVmW3N0YXJ0ICsgcGFkZGluZ10gPT09IDApIHtcblx0XHQrK3BhZGRpbmc7XG5cdH1cblxuXHR2YXIgbmVlZHNTaWduID0gYnVmW3N0YXJ0ICsgcGFkZGluZ10gPj0gTUFYX09DVEVUO1xuXHRpZiAobmVlZHNTaWduKSB7XG5cdFx0LS1wYWRkaW5nO1xuXHR9XG5cblx0cmV0dXJuIHBhZGRpbmc7XG59XG5cbmZ1bmN0aW9uIGpvc2VUb0RlcihzaWduYXR1cmUsIGFsZykge1xuXHRzaWduYXR1cmUgPSBzaWduYXR1cmVBc0J1ZmZlcihzaWduYXR1cmUpO1xuXHR2YXIgcGFyYW1CeXRlcyA9IGdldFBhcmFtQnl0ZXNGb3JBbGcoYWxnKTtcblxuXHR2YXIgc2lnbmF0dXJlQnl0ZXMgPSBzaWduYXR1cmUubGVuZ3RoO1xuXHRpZiAoc2lnbmF0dXJlQnl0ZXMgIT09IHBhcmFtQnl0ZXMgKiAyKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignXCInICsgYWxnICsgJ1wiIHNpZ25hdHVyZXMgbXVzdCBiZSBcIicgKyBwYXJhbUJ5dGVzICogMiArICdcIiBieXRlcywgc2F3IFwiJyArIHNpZ25hdHVyZUJ5dGVzICsgJ1wiJyk7XG5cdH1cblxuXHR2YXIgclBhZGRpbmcgPSBjb3VudFBhZGRpbmcoc2lnbmF0dXJlLCAwLCBwYXJhbUJ5dGVzKTtcblx0dmFyIHNQYWRkaW5nID0gY291bnRQYWRkaW5nKHNpZ25hdHVyZSwgcGFyYW1CeXRlcywgc2lnbmF0dXJlLmxlbmd0aCk7XG5cdHZhciByTGVuZ3RoID0gcGFyYW1CeXRlcyAtIHJQYWRkaW5nO1xuXHR2YXIgc0xlbmd0aCA9IHBhcmFtQnl0ZXMgLSBzUGFkZGluZztcblxuXHR2YXIgcnNCeXRlcyA9IDEgKyAxICsgckxlbmd0aCArIDEgKyAxICsgc0xlbmd0aDtcblxuXHR2YXIgc2hvcnRMZW5ndGggPSByc0J5dGVzIDwgTUFYX09DVEVUO1xuXG5cdHZhciBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUoKHNob3J0TGVuZ3RoID8gMiA6IDMpICsgcnNCeXRlcyk7XG5cblx0dmFyIG9mZnNldCA9IDA7XG5cdGRzdFtvZmZzZXQrK10gPSBFTkNPREVEX1RBR19TRVE7XG5cdGlmIChzaG9ydExlbmd0aCkge1xuXHRcdC8vIEJpdCA4IGhhcyB2YWx1ZSBcIjBcIlxuXHRcdC8vIGJpdHMgNy0xIGdpdmUgdGhlIGxlbmd0aC5cblx0XHRkc3Rbb2Zmc2V0KytdID0gcnNCeXRlcztcblx0fSBlbHNlIHtcblx0XHQvLyBCaXQgOCBvZiBmaXJzdCBvY3RldCBoYXMgdmFsdWUgXCIxXCJcblx0XHQvLyBiaXRzIDctMSBnaXZlIHRoZSBudW1iZXIgb2YgYWRkaXRpb25hbCBsZW5ndGggb2N0ZXRzLlxuXHRcdGRzdFtvZmZzZXQrK10gPSBNQVhfT0NURVRcdHwgMTtcblx0XHQvLyBsZW5ndGgsIGJhc2UgMjU2XG5cdFx0ZHN0W29mZnNldCsrXSA9IHJzQnl0ZXMgJiAweGZmO1xuXHR9XG5cdGRzdFtvZmZzZXQrK10gPSBFTkNPREVEX1RBR19JTlQ7XG5cdGRzdFtvZmZzZXQrK10gPSByTGVuZ3RoO1xuXHRpZiAoclBhZGRpbmcgPCAwKSB7XG5cdFx0ZHN0W29mZnNldCsrXSA9IDA7XG5cdFx0b2Zmc2V0ICs9IHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCAwLCBwYXJhbUJ5dGVzKTtcblx0fSBlbHNlIHtcblx0XHRvZmZzZXQgKz0gc2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHJQYWRkaW5nLCBwYXJhbUJ5dGVzKTtcblx0fVxuXHRkc3Rbb2Zmc2V0KytdID0gRU5DT0RFRF9UQUdfSU5UO1xuXHRkc3Rbb2Zmc2V0KytdID0gc0xlbmd0aDtcblx0aWYgKHNQYWRkaW5nIDwgMCkge1xuXHRcdGRzdFtvZmZzZXQrK10gPSAwO1xuXHRcdHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCBwYXJhbUJ5dGVzKTtcblx0fSBlbHNlIHtcblx0XHRzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgcGFyYW1CeXRlcyArIHNQYWRkaW5nKTtcblx0fVxuXG5cdHJldHVybiBkc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRkZXJUb0pvc2U6IGRlclRvSm9zZSxcblx0am9zZVRvRGVyOiBqb3NlVG9EZXJcbn07XG4iLCAidmFyIGJ1ZmZlckVxdWFsID0gcmVxdWlyZSgnYnVmZmVyLWVxdWFsLWNvbnN0YW50LXRpbWUnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBmb3JtYXRFY2RzYSA9IHJlcXVpcmUoJ2VjZHNhLXNpZy1mb3JtYXR0ZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgTVNHX0lOVkFMSURfQUxHT1JJVEhNID0gJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCBhbGdvcml0aG0uXFxuICBTdXBwb3J0ZWQgYWxnb3JpdGhtcyBhcmU6XFxuICBcIkhTMjU2XCIsIFwiSFMzODRcIiwgXCJIUzUxMlwiLCBcIlJTMjU2XCIsIFwiUlMzODRcIiwgXCJSUzUxMlwiLCBcIlBTMjU2XCIsIFwiUFMzODRcIiwgXCJQUzUxMlwiLCBcIkVTMjU2XCIsIFwiRVMzODRcIiwgXCJFUzUxMlwiIGFuZCBcIm5vbmVcIi4nXG52YXIgTVNHX0lOVkFMSURfU0VDUkVUID0gJ3NlY3JldCBtdXN0IGJlIGEgc3RyaW5nIG9yIGJ1ZmZlcic7XG52YXIgTVNHX0lOVkFMSURfVkVSSUZJRVJfS0VZID0gJ2tleSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJztcbnZhciBNU0dfSU5WQUxJRF9TSUdORVJfS0VZID0gJ2tleSBtdXN0IGJlIGEgc3RyaW5nLCBhIGJ1ZmZlciBvciBhbiBvYmplY3QnO1xuXG52YXIgc3VwcG9ydHNLZXlPYmplY3RzID0gdHlwZW9mIGNyeXB0by5jcmVhdGVQdWJsaWNLZXkgPT09ICdmdW5jdGlvbic7XG5pZiAoc3VwcG9ydHNLZXlPYmplY3RzKSB7XG4gIE1TR19JTlZBTElEX1ZFUklGSUVSX0tFWSArPSAnIG9yIGEgS2V5T2JqZWN0JztcbiAgTVNHX0lOVkFMSURfU0VDUkVUICs9ICdvciBhIEtleU9iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQdWJsaWNLZXkoa2V5KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghc3VwcG9ydHNLZXlPYmplY3RzKSB7XG4gICAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1ZFUklGSUVSX0tFWSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfVkVSSUZJRVJfS0VZKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1ZFUklGSUVSX0tFWSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleS5hc3ltbWV0cmljS2V5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfVkVSSUZJRVJfS0VZKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5LmV4cG9ydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IHR5cGVFcnJvcihNU0dfSU5WQUxJRF9WRVJJRklFUl9LRVkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja0lzUHJpdmF0ZUtleShrZXkpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1NJR05FUl9LRVkpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tJc1NlY3JldEtleShrZXkpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIGlmICghc3VwcG9ydHNLZXlPYmplY3RzKSB7XG4gICAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1NFQ1JFVCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfU0VDUkVUKTtcbiAgfVxuXG4gIGlmIChrZXkudHlwZSAhPT0gJ3NlY3JldCcpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfU0VDUkVUKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5LmV4cG9ydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IHR5cGVFcnJvcihNU0dfSU5WQUxJRF9TRUNSRVQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gIHJldHVybiBiYXNlNjRcbiAgICAucmVwbGFjZSgvPS9nLCAnJylcbiAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5cbmZ1bmN0aW9uIHRvQmFzZTY0KGJhc2U2NHVybCkge1xuICBiYXNlNjR1cmwgPSBiYXNlNjR1cmwudG9TdHJpbmcoKTtcblxuICB2YXIgcGFkZGluZyA9IDQgLSBiYXNlNjR1cmwubGVuZ3RoICUgNDtcbiAgaWYgKHBhZGRpbmcgIT09IDQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGRpbmc7ICsraSkge1xuICAgICAgYmFzZTY0dXJsICs9ICc9JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTY0dXJsXG4gICAgLnJlcGxhY2UoL1xcLS9nLCAnKycpXG4gICAgLnJlcGxhY2UoL18vZywgJy8nKTtcbn1cblxuZnVuY3Rpb24gdHlwZUVycm9yKHRlbXBsYXRlKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgZXJyTXNnID0gdXRpbC5mb3JtYXQuYmluZCh1dGlsLCB0ZW1wbGF0ZSkuYXBwbHkobnVsbCwgYXJncyk7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGVyck1zZyk7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlck9yU3RyaW5nKG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0KHRoaW5nKSB7XG4gIGlmICghYnVmZmVyT3JTdHJpbmcodGhpbmcpKVxuICAgIHRoaW5nID0gSlNPTi5zdHJpbmdpZnkodGhpbmcpO1xuICByZXR1cm4gdGhpbmc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhtYWNTaWduZXIoYml0cykge1xuICByZXR1cm4gZnVuY3Rpb24gc2lnbih0aGluZywgc2VjcmV0KSB7XG4gICAgY2hlY2tJc1NlY3JldEtleShzZWNyZXQpO1xuICAgIHRoaW5nID0gbm9ybWFsaXplSW5wdXQodGhpbmcpO1xuICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYScgKyBiaXRzLCBzZWNyZXQpO1xuICAgIHZhciBzaWcgPSAoaG1hYy51cGRhdGUodGhpbmcpLCBobWFjLmRpZ2VzdCgnYmFzZTY0JykpXG4gICAgcmV0dXJuIGZyb21CYXNlNjQoc2lnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIbWFjVmVyaWZpZXIoYml0cykge1xuICByZXR1cm4gZnVuY3Rpb24gdmVyaWZ5KHRoaW5nLCBzaWduYXR1cmUsIHNlY3JldCkge1xuICAgIHZhciBjb21wdXRlZFNpZyA9IGNyZWF0ZUhtYWNTaWduZXIoYml0cykodGhpbmcsIHNlY3JldCk7XG4gICAgcmV0dXJuIGJ1ZmZlckVxdWFsKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSksIEJ1ZmZlci5mcm9tKGNvbXB1dGVkU2lnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5U2lnbmVyKGJpdHMpIHtcbiByZXR1cm4gZnVuY3Rpb24gc2lnbih0aGluZywgcHJpdmF0ZUtleSkge1xuICAgIGNoZWNrSXNQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgIHRoaW5nID0gbm9ybWFsaXplSW5wdXQodGhpbmcpO1xuICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGFyZSBzcGVjaWZ5aW5nIFwiUlNBXCIgaGVyZSwgdGhpcyB3b3JrcyB3aXRoIEVDRFNBXG4gICAgLy8ga2V5cyBhcyB3ZWxsLlxuICAgIHZhciBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbignUlNBLVNIQScgKyBiaXRzKTtcbiAgICB2YXIgc2lnID0gKHNpZ25lci51cGRhdGUodGhpbmcpLCBzaWduZXIuc2lnbihwcml2YXRlS2V5LCAnYmFzZTY0JykpO1xuICAgIHJldHVybiBmcm9tQmFzZTY0KHNpZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VmVyaWZpZXIoYml0cykge1xuICByZXR1cm4gZnVuY3Rpb24gdmVyaWZ5KHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIGNoZWNrSXNQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB0aGluZyA9IG5vcm1hbGl6ZUlucHV0KHRoaW5nKTtcbiAgICBzaWduYXR1cmUgPSB0b0Jhc2U2NChzaWduYXR1cmUpO1xuICAgIHZhciB2ZXJpZmllciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ1JTQS1TSEEnICsgYml0cyk7XG4gICAgdmVyaWZpZXIudXBkYXRlKHRoaW5nKTtcbiAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHB1YmxpY0tleSwgc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUFNTS2V5U2lnbmVyKGJpdHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNpZ24odGhpbmcsIHByaXZhdGVLZXkpIHtcbiAgICBjaGVja0lzUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICB0aGluZyA9IG5vcm1hbGl6ZUlucHV0KHRoaW5nKTtcbiAgICB2YXIgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24oJ1JTQS1TSEEnICsgYml0cyk7XG4gICAgdmFyIHNpZyA9IChzaWduZXIudXBkYXRlKHRoaW5nKSwgc2lnbmVyLnNpZ24oe1xuICAgICAga2V5OiBwcml2YXRlS2V5LFxuICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkcsXG4gICAgICBzYWx0TGVuZ3RoOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QU1NfU0FMVExFTl9ESUdFU1RcbiAgICB9LCAnYmFzZTY0JykpO1xuICAgIHJldHVybiBmcm9tQmFzZTY0KHNpZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUFNTS2V5VmVyaWZpZXIoYml0cykge1xuICByZXR1cm4gZnVuY3Rpb24gdmVyaWZ5KHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIGNoZWNrSXNQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB0aGluZyA9IG5vcm1hbGl6ZUlucHV0KHRoaW5nKTtcbiAgICBzaWduYXR1cmUgPSB0b0Jhc2U2NChzaWduYXR1cmUpO1xuICAgIHZhciB2ZXJpZmllciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ1JTQS1TSEEnICsgYml0cyk7XG4gICAgdmVyaWZpZXIudXBkYXRlKHRoaW5nKTtcbiAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHtcbiAgICAgIGtleTogcHVibGljS2V5LFxuICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkcsXG4gICAgICBzYWx0TGVuZ3RoOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QU1NfU0FMVExFTl9ESUdFU1RcbiAgICB9LCBzaWduYXR1cmUsICdiYXNlNjQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFQ0RTQVNpZ25lcihiaXRzKSB7XG4gIHZhciBpbm5lciA9IGNyZWF0ZUtleVNpZ25lcihiaXRzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IGlubmVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgc2lnbmF0dXJlID0gZm9ybWF0RWNkc2EuZGVyVG9Kb3NlKHNpZ25hdHVyZSwgJ0VTJyArIGJpdHMpO1xuICAgIHJldHVybiBzaWduYXR1cmU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVDRFNBVmVyaWZlcihiaXRzKSB7XG4gIHZhciBpbm5lciA9IGNyZWF0ZUtleVZlcmlmaWVyKGJpdHMpO1xuICByZXR1cm4gZnVuY3Rpb24gdmVyaWZ5KHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIHNpZ25hdHVyZSA9IGZvcm1hdEVjZHNhLmpvc2VUb0RlcihzaWduYXR1cmUsICdFUycgKyBiaXRzKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgdmFyIHJlc3VsdCA9IGlubmVyKHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9uZVNpZ25lcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vbmVWZXJpZmllcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHZlcmlmeSh0aGluZywgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZSA9PT0gJyc7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBqd2EoYWxnb3JpdGhtKSB7XG4gIHZhciBzaWduZXJGYWN0b3JpZXMgPSB7XG4gICAgaHM6IGNyZWF0ZUhtYWNTaWduZXIsXG4gICAgcnM6IGNyZWF0ZUtleVNpZ25lcixcbiAgICBwczogY3JlYXRlUFNTS2V5U2lnbmVyLFxuICAgIGVzOiBjcmVhdGVFQ0RTQVNpZ25lcixcbiAgICBub25lOiBjcmVhdGVOb25lU2lnbmVyLFxuICB9XG4gIHZhciB2ZXJpZmllckZhY3RvcmllcyA9IHtcbiAgICBoczogY3JlYXRlSG1hY1ZlcmlmaWVyLFxuICAgIHJzOiBjcmVhdGVLZXlWZXJpZmllcixcbiAgICBwczogY3JlYXRlUFNTS2V5VmVyaWZpZXIsXG4gICAgZXM6IGNyZWF0ZUVDRFNBVmVyaWZlcixcbiAgICBub25lOiBjcmVhdGVOb25lVmVyaWZpZXIsXG4gIH1cbiAgdmFyIG1hdGNoID0gYWxnb3JpdGhtLm1hdGNoKC9eKFJTfFBTfEVTfEhTKSgyNTZ8Mzg0fDUxMikkfF4obm9uZSkkL2kpO1xuICBpZiAoIW1hdGNoKVxuICAgIHRocm93IHR5cGVFcnJvcihNU0dfSU5WQUxJRF9BTEdPUklUSE0sIGFsZ29yaXRobSk7XG4gIHZhciBhbGdvID0gKG1hdGNoWzFdIHx8IG1hdGNoWzNdKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYml0cyA9IG1hdGNoWzJdO1xuXG4gIHJldHVybiB7XG4gICAgc2lnbjogc2lnbmVyRmFjdG9yaWVzW2FsZ29dKGJpdHMpLFxuICAgIHZlcmlmeTogdmVyaWZpZXJGYWN0b3JpZXNbYWxnb10oYml0cyksXG4gIH1cbn07XG4iLCAiLypnbG9iYWwgbW9kdWxlKi9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9TdHJpbmcob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICByZXR1cm4gb2JqO1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgQnVmZmVyLmlzQnVmZmVyKG9iaikpXG4gICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbn07XG4iLCAiLypnbG9iYWwgbW9kdWxlKi9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBEYXRhU3RyZWFtID0gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbScpO1xudmFyIGp3YSA9IHJlcXVpcmUoJ2p3YScpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b3N0cmluZycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGJhc2U2NHVybChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIHJldHVybiBCdWZmZXJcbiAgICAuZnJvbShzdHJpbmcsIGVuY29kaW5nKVxuICAgIC50b1N0cmluZygnYmFzZTY0JylcbiAgICAucmVwbGFjZSgvPS9nLCAnJylcbiAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5cbmZ1bmN0aW9uIGp3c1NlY3VyZWRJbnB1dChoZWFkZXIsIHBheWxvYWQsIGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuICB2YXIgZW5jb2RlZEhlYWRlciA9IGJhc2U2NHVybCh0b1N0cmluZyhoZWFkZXIpLCAnYmluYXJ5Jyk7XG4gIHZhciBlbmNvZGVkUGF5bG9hZCA9IGJhc2U2NHVybCh0b1N0cmluZyhwYXlsb2FkKSwgZW5jb2RpbmcpO1xuICByZXR1cm4gdXRpbC5mb3JtYXQoJyVzLiVzJywgZW5jb2RlZEhlYWRlciwgZW5jb2RlZFBheWxvYWQpO1xufVxuXG5mdW5jdGlvbiBqd3NTaWduKG9wdHMpIHtcbiAgdmFyIGhlYWRlciA9IG9wdHMuaGVhZGVyO1xuICB2YXIgcGF5bG9hZCA9IG9wdHMucGF5bG9hZDtcbiAgdmFyIHNlY3JldE9yS2V5ID0gb3B0cy5zZWNyZXQgfHwgb3B0cy5wcml2YXRlS2V5O1xuICB2YXIgZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nO1xuICB2YXIgYWxnbyA9IGp3YShoZWFkZXIuYWxnKTtcbiAgdmFyIHNlY3VyZWRJbnB1dCA9IGp3c1NlY3VyZWRJbnB1dChoZWFkZXIsIHBheWxvYWQsIGVuY29kaW5nKTtcbiAgdmFyIHNpZ25hdHVyZSA9IGFsZ28uc2lnbihzZWN1cmVkSW5wdXQsIHNlY3JldE9yS2V5KTtcbiAgcmV0dXJuIHV0aWwuZm9ybWF0KCclcy4lcycsIHNlY3VyZWRJbnB1dCwgc2lnbmF0dXJlKTtcbn1cblxuZnVuY3Rpb24gU2lnblN0cmVhbShvcHRzKSB7XG4gIHZhciBzZWNyZXQgPSBvcHRzLnNlY3JldHx8b3B0cy5wcml2YXRlS2V5fHxvcHRzLmtleTtcbiAgdmFyIHNlY3JldFN0cmVhbSA9IG5ldyBEYXRhU3RyZWFtKHNlY3JldCk7XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICB0aGlzLmhlYWRlciA9IG9wdHMuaGVhZGVyO1xuICB0aGlzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZztcbiAgdGhpcy5zZWNyZXQgPSB0aGlzLnByaXZhdGVLZXkgPSB0aGlzLmtleSA9IHNlY3JldFN0cmVhbTtcbiAgdGhpcy5wYXlsb2FkID0gbmV3IERhdGFTdHJlYW0ob3B0cy5wYXlsb2FkKTtcbiAgdGhpcy5zZWNyZXQub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnBheWxvYWQud3JpdGFibGUgJiYgdGhpcy5yZWFkYWJsZSlcbiAgICAgIHRoaXMuc2lnbigpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIHRoaXMucGF5bG9hZC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuc2VjcmV0LndyaXRhYmxlICYmIHRoaXMucmVhZGFibGUpXG4gICAgICB0aGlzLnNpZ24oKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn1cbnV0aWwuaW5oZXJpdHMoU2lnblN0cmVhbSwgU3RyZWFtKTtcblxuU2lnblN0cmVhbS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IGp3c1NpZ24oe1xuICAgICAgaGVhZGVyOiB0aGlzLmhlYWRlcixcbiAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZC5idWZmZXIsXG4gICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LmJ1ZmZlcixcbiAgICAgIGVuY29kaW5nOiB0aGlzLmVuY29kaW5nXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCdkb25lJywgc2lnbmF0dXJlKTtcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBzaWduYXR1cmUpO1xuICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJldHVybiBzaWduYXR1cmU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgfVxufTtcblxuU2lnblN0cmVhbS5zaWduID0gandzU2lnbjtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduU3RyZWFtO1xuIiwgIi8qZ2xvYmFsIG1vZHVsZSovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgRGF0YVN0cmVhbSA9IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0nKTtcbnZhciBqd2EgPSByZXF1aXJlKCdqd2EnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9zdHJpbmcnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEpXU19SRUdFWCA9IC9eW2EtekEtWjAtOVxcLV9dKz9cXC5bYS16QS1aMC05XFwtX10rP1xcLihbYS16QS1aMC05XFwtX10rKT8kLztcblxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGluZykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBzYWZlSnNvblBhcnNlKHRoaW5nKSB7XG4gIGlmIChpc09iamVjdCh0aGluZykpXG4gICAgcmV0dXJuIHRoaW5nO1xuICB0cnkgeyByZXR1cm4gSlNPTi5wYXJzZSh0aGluZyk7IH1cbiAgY2F0Y2ggKGUpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxufVxuXG5mdW5jdGlvbiBoZWFkZXJGcm9tSldTKGp3c1NpZykge1xuICB2YXIgZW5jb2RlZEhlYWRlciA9IGp3c1NpZy5zcGxpdCgnLicsIDEpWzBdO1xuICByZXR1cm4gc2FmZUpzb25QYXJzZShCdWZmZXIuZnJvbShlbmNvZGVkSGVhZGVyLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpKTtcbn1cblxuZnVuY3Rpb24gc2VjdXJlZElucHV0RnJvbUpXUyhqd3NTaWcpIHtcbiAgcmV0dXJuIGp3c1NpZy5zcGxpdCgnLicsIDIpLmpvaW4oJy4nKTtcbn1cblxuZnVuY3Rpb24gc2lnbmF0dXJlRnJvbUpXUyhqd3NTaWcpIHtcbiAgcmV0dXJuIGp3c1NpZy5zcGxpdCgnLicpWzJdO1xufVxuXG5mdW5jdGlvbiBwYXlsb2FkRnJvbUpXUyhqd3NTaWcsIGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuICB2YXIgcGF5bG9hZCA9IGp3c1NpZy5zcGxpdCgnLicpWzFdO1xuICByZXR1cm4gQnVmZmVyLmZyb20ocGF5bG9hZCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEp3cyhzdHJpbmcpIHtcbiAgcmV0dXJuIEpXU19SRUdFWC50ZXN0KHN0cmluZykgJiYgISFoZWFkZXJGcm9tSldTKHN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIGp3c1ZlcmlmeShqd3NTaWcsIGFsZ29yaXRobSwgc2VjcmV0T3JLZXkpIHtcbiAgaWYgKCFhbGdvcml0aG0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiTWlzc2luZyBhbGdvcml0aG0gcGFyYW1ldGVyIGZvciBqd3MudmVyaWZ5XCIpO1xuICAgIGVyci5jb2RlID0gXCJNSVNTSU5HX0FMR09SSVRITVwiO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBqd3NTaWcgPSB0b1N0cmluZyhqd3NTaWcpO1xuICB2YXIgc2lnbmF0dXJlID0gc2lnbmF0dXJlRnJvbUpXUyhqd3NTaWcpO1xuICB2YXIgc2VjdXJlZElucHV0ID0gc2VjdXJlZElucHV0RnJvbUpXUyhqd3NTaWcpO1xuICB2YXIgYWxnbyA9IGp3YShhbGdvcml0aG0pO1xuICByZXR1cm4gYWxnby52ZXJpZnkoc2VjdXJlZElucHV0LCBzaWduYXR1cmUsIHNlY3JldE9yS2V5KTtcbn1cblxuZnVuY3Rpb24gandzRGVjb2RlKGp3c1NpZywgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgandzU2lnID0gdG9TdHJpbmcoandzU2lnKTtcblxuICBpZiAoIWlzVmFsaWRKd3MoandzU2lnKSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgaGVhZGVyID0gaGVhZGVyRnJvbUpXUyhqd3NTaWcpO1xuXG4gIGlmICghaGVhZGVyKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBwYXlsb2FkID0gcGF5bG9hZEZyb21KV1MoandzU2lnKTtcbiAgaWYgKGhlYWRlci50eXAgPT09ICdKV1QnIHx8IG9wdHMuanNvbilcbiAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShwYXlsb2FkLCBvcHRzLmVuY29kaW5nKTtcblxuICByZXR1cm4ge1xuICAgIGhlYWRlcjogaGVhZGVyLFxuICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgc2lnbmF0dXJlOiBzaWduYXR1cmVGcm9tSldTKGp3c1NpZylcbiAgfTtcbn1cblxuZnVuY3Rpb24gVmVyaWZ5U3RyZWFtKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBzZWNyZXRPcktleSA9IG9wdHMuc2VjcmV0fHxvcHRzLnB1YmxpY0tleXx8b3B0cy5rZXk7XG4gIHZhciBzZWNyZXRTdHJlYW0gPSBuZXcgRGF0YVN0cmVhbShzZWNyZXRPcktleSk7XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICB0aGlzLmFsZ29yaXRobSA9IG9wdHMuYWxnb3JpdGhtO1xuICB0aGlzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZztcbiAgdGhpcy5zZWNyZXQgPSB0aGlzLnB1YmxpY0tleSA9IHRoaXMua2V5ID0gc2VjcmV0U3RyZWFtO1xuICB0aGlzLnNpZ25hdHVyZSA9IG5ldyBEYXRhU3RyZWFtKG9wdHMuc2lnbmF0dXJlKTtcbiAgdGhpcy5zZWNyZXQub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnNpZ25hdHVyZS53cml0YWJsZSAmJiB0aGlzLnJlYWRhYmxlKVxuICAgICAgdGhpcy52ZXJpZnkoKTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICB0aGlzLnNpZ25hdHVyZS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuc2VjcmV0LndyaXRhYmxlICYmIHRoaXMucmVhZGFibGUpXG4gICAgICB0aGlzLnZlcmlmeSgpO1xuICB9LmJpbmQodGhpcykpO1xufVxudXRpbC5pbmhlcml0cyhWZXJpZnlTdHJlYW0sIFN0cmVhbSk7XG5WZXJpZnlTdHJlYW0ucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeSgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmFsaWQgPSBqd3NWZXJpZnkodGhpcy5zaWduYXR1cmUuYnVmZmVyLCB0aGlzLmFsZ29yaXRobSwgdGhpcy5rZXkuYnVmZmVyKTtcbiAgICB2YXIgb2JqID0gandzRGVjb2RlKHRoaXMuc2lnbmF0dXJlLmJ1ZmZlciwgdGhpcy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbWl0KCdkb25lJywgdmFsaWQsIG9iaik7XG4gICAgdGhpcy5lbWl0KCdkYXRhJywgdmFsaWQpO1xuICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJldHVybiB2YWxpZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICB9XG59O1xuXG5WZXJpZnlTdHJlYW0uZGVjb2RlID0gandzRGVjb2RlO1xuVmVyaWZ5U3RyZWFtLmlzVmFsaWQgPSBpc1ZhbGlkSndzO1xuVmVyaWZ5U3RyZWFtLnZlcmlmeSA9IGp3c1ZlcmlmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZXJpZnlTdHJlYW07XG4iLCAiLypnbG9iYWwgZXhwb3J0cyovXG52YXIgU2lnblN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3NpZ24tc3RyZWFtJyk7XG52YXIgVmVyaWZ5U3RyZWFtID0gcmVxdWlyZSgnLi9saWIvdmVyaWZ5LXN0cmVhbScpO1xuXG52YXIgQUxHT1JJVEhNUyA9IFtcbiAgJ0hTMjU2JywgJ0hTMzg0JywgJ0hTNTEyJyxcbiAgJ1JTMjU2JywgJ1JTMzg0JywgJ1JTNTEyJyxcbiAgJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJyxcbiAgJ0VTMjU2JywgJ0VTMzg0JywgJ0VTNTEyJ1xuXTtcblxuZXhwb3J0cy5BTEdPUklUSE1TID0gQUxHT1JJVEhNUztcbmV4cG9ydHMuc2lnbiA9IFNpZ25TdHJlYW0uc2lnbjtcbmV4cG9ydHMudmVyaWZ5ID0gVmVyaWZ5U3RyZWFtLnZlcmlmeTtcbmV4cG9ydHMuZGVjb2RlID0gVmVyaWZ5U3RyZWFtLmRlY29kZTtcbmV4cG9ydHMuaXNWYWxpZCA9IFZlcmlmeVN0cmVhbS5pc1ZhbGlkO1xuZXhwb3J0cy5jcmVhdGVTaWduID0gZnVuY3Rpb24gY3JlYXRlU2lnbihvcHRzKSB7XG4gIHJldHVybiBuZXcgU2lnblN0cmVhbShvcHRzKTtcbn07XG5leHBvcnRzLmNyZWF0ZVZlcmlmeSA9IGZ1bmN0aW9uIGNyZWF0ZVZlcmlmeShvcHRzKSB7XG4gIHJldHVybiBuZXcgVmVyaWZ5U3RyZWFtKG9wdHMpO1xufTtcbiIsICJ2YXIgandzID0gcmVxdWlyZSgnandzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGp3dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGRlY29kZWQgPSBqd3MuZGVjb2RlKGp3dCwgb3B0aW9ucyk7XG4gIGlmICghZGVjb2RlZCkgeyByZXR1cm4gbnVsbDsgfVxuICB2YXIgcGF5bG9hZCA9IGRlY29kZWQucGF5bG9hZDtcblxuICAvL3RyeSBwYXJzZSB0aGUgcGF5bG9hZFxuICBpZih0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgICBpZihvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcGF5bG9hZCA9IG9iajtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxuXG4gIC8vcmV0dXJuIGhlYWRlciBpZiBgY29tcGxldGVgIG9wdGlvbiBpcyBlbmFibGVkLiAgaGVhZGVyIGluY2x1ZGVzIGNsYWltc1xuICAvL3N1Y2ggYXMgYGtpZGAgYW5kIGBhbGdgIHVzZWQgdG8gc2VsZWN0IHRoZSBrZXkgd2l0aGluIGEgSldLUyBuZWVkZWQgdG9cbiAgLy92ZXJpZnkgdGhlIHNpZ25hdHVyZVxuICBpZiAob3B0aW9ucy5jb21wbGV0ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXI6IGRlY29kZWQuaGVhZGVyLFxuICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgIHNpZ25hdHVyZTogZGVjb2RlZC5zaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXlsb2FkO1xufTtcbiIsICJ2YXIgSnNvbldlYlRva2VuRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3IpIHtcbiAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgaWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxuICB0aGlzLm5hbWUgPSAnSnNvbldlYlRva2VuRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICBpZiAoZXJyb3IpIHRoaXMuaW5uZXIgPSBlcnJvcjtcbn07XG5cbkpzb25XZWJUb2tlbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkpzb25XZWJUb2tlbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpzb25XZWJUb2tlbkVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25XZWJUb2tlbkVycm9yO1xuIiwgInZhciBKc29uV2ViVG9rZW5FcnJvciA9IHJlcXVpcmUoJy4vSnNvbldlYlRva2VuRXJyb3InKTtcblxudmFyIE5vdEJlZm9yZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGUpIHtcbiAgSnNvbldlYlRva2VuRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgdGhpcy5uYW1lID0gJ05vdEJlZm9yZUVycm9yJztcbiAgdGhpcy5kYXRlID0gZGF0ZTtcbn07XG5cbk5vdEJlZm9yZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSnNvbldlYlRva2VuRXJyb3IucHJvdG90eXBlKTtcblxuTm90QmVmb3JlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm90QmVmb3JlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gTm90QmVmb3JlRXJyb3I7IiwgInZhciBKc29uV2ViVG9rZW5FcnJvciA9IHJlcXVpcmUoJy4vSnNvbldlYlRva2VuRXJyb3InKTtcblxudmFyIFRva2VuRXhwaXJlZEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGV4cGlyZWRBdCkge1xuICBKc29uV2ViVG9rZW5FcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICB0aGlzLm5hbWUgPSAnVG9rZW5FeHBpcmVkRXJyb3InO1xuICB0aGlzLmV4cGlyZWRBdCA9IGV4cGlyZWRBdDtcbn07XG5cblRva2VuRXhwaXJlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSnNvbldlYlRva2VuRXJyb3IucHJvdG90eXBlKTtcblxuVG9rZW5FeHBpcmVkRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9rZW5FeHBpcmVkRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gVG9rZW5FeHBpcmVkRXJyb3I7IiwgIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsICJ2YXIgbXMgPSByZXF1aXJlKCdtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aW1lLCBpYXQpIHtcbiAgdmFyIHRpbWVzdGFtcCA9IGlhdCB8fCBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcblxuICBpZiAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1zKHRpbWUpO1xuICAgIGlmICh0eXBlb2YgbWlsbGlzZWNvbmRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aW1lc3RhbXAgKyBtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdGltZXN0YW1wICsgdGltZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cblxufTsiLCAiLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG4vLyBNYXggc2FmZSBsZW5ndGggZm9yIGEgYnVpbGQgaWRlbnRpZmllci4gVGhlIG1heCBsZW5ndGggbWludXMgNiBjaGFyYWN0ZXJzIGZvclxuLy8gdGhlIHNob3J0ZXN0IHZlcnNpb24gd2l0aCBhIGJ1aWxkIDAuMC4wK0JVSUxELlxuY29uc3QgTUFYX1NBRkVfQlVJTERfTEVOR1RIID0gTUFYX0xFTkdUSCAtIDZcblxuY29uc3QgUkVMRUFTRV9UWVBFUyA9IFtcbiAgJ21ham9yJyxcbiAgJ3ByZW1ham9yJyxcbiAgJ21pbm9yJyxcbiAgJ3ByZW1pbm9yJyxcbiAgJ3BhdGNoJyxcbiAgJ3ByZXBhdGNoJyxcbiAgJ3ByZXJlbGVhc2UnLFxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfQlVJTERfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBSRUxFQVNFX1RZUEVTLFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRTogMGIwMDEsXG4gIEZMQUdfTE9PU0U6IDBiMDEwLFxufVxuIiwgImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsICJjb25zdCB7XG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsXG4gIE1BWF9TQUZFX0JVSUxEX0xFTkdUSCxcbiAgTUFYX0xFTkdUSCxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzYWZlUmUgPSBleHBvcnRzLnNhZmVSZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCBzYWZlU3JjID0gZXhwb3J0cy5zYWZlU3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IExFVFRFUkRBU0hOVU1CRVIgPSAnW2EtekEtWjAtOS1dJ1xuXG4vLyBSZXBsYWNlIHNvbWUgZ3JlZWR5IHJlZ2V4IHRva2VucyB0byBwcmV2ZW50IHJlZ2V4IGRvcyBpc3N1ZXMuIFRoZXNlIHJlZ2V4IGFyZVxuLy8gdXNlZCBpbnRlcm5hbGx5IHZpYSB0aGUgc2FmZVJlIG9iamVjdCBzaW5jZSBhbGwgaW5wdXRzIGluIHRoaXMgbGlicmFyeSBnZXRcbi8vIG5vcm1hbGl6ZWQgZmlyc3QgdG8gdHJpbSBhbmQgY29sbGFwc2UgYWxsIGV4dHJhIHdoaXRlc3BhY2UuIFRoZSBvcmlnaW5hbFxuLy8gcmVnZXhlcyBhcmUgZXhwb3J0ZWQgZm9yIHVzZXJsYW5kIGNvbnN1bXB0aW9uIGFuZCBsb3dlciBsZXZlbCB1c2FnZS4gQVxuLy8gZnV0dXJlIGJyZWFraW5nIGNoYW5nZSBjb3VsZCBleHBvcnQgdGhlIHNhZmVyIHJlZ2V4IG9ubHkgd2l0aCBhIG5vdGUgdGhhdFxuLy8gYWxsIGlucHV0IHNob3VsZCBoYXZlIGV4dHJhIHdoaXRlc3BhY2UgcmVtb3ZlZC5cbmNvbnN0IHNhZmVSZWdleFJlcGxhY2VtZW50cyA9IFtcbiAgWydcXFxccycsIDFdLFxuICBbJ1xcXFxkJywgTUFYX0xFTkdUSF0sXG4gIFtMRVRURVJEQVNITlVNQkVSLCBNQVhfU0FGRV9CVUlMRF9MRU5HVEhdLFxuXVxuXG5jb25zdCBtYWtlU2FmZVJlZ2V4ID0gKHZhbHVlKSA9PiB7XG4gIGZvciAoY29uc3QgW3Rva2VuLCBtYXhdIG9mIHNhZmVSZWdleFJlcGxhY2VtZW50cykge1xuICAgIHZhbHVlID0gdmFsdWVcbiAgICAgIC5zcGxpdChgJHt0b2tlbn0qYCkuam9pbihgJHt0b2tlbn17MCwke21heH19YClcbiAgICAgIC5zcGxpdChgJHt0b2tlbn0rYCkuam9pbihgJHt0b2tlbn17MSwke21heH19YClcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IHNhZmUgPSBtYWtlU2FmZVJlZ2V4KHZhbHVlKVxuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhuYW1lLCBpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgc2FmZVNyY1tpbmRleF0gPSBzYWZlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxuICBzYWZlUmVbaW5kZXhdID0gbmV3IFJlZ0V4cChzYWZlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnXFxcXGQrJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgYFxcXFxkKlthLXpBLVotXSR7TEVUVEVSREFTSE5VTUJFUn0qYClcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsIGAke0xFVFRFUkRBU0hOVU1CRVJ9K2ApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0VQTEFJTicsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YClcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHtzcmNbdC5DT0VSQ0VQTEFJTl19KD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRUZVTEwnLCBzcmNbdC5DT0VSQ0VQTEFJTl0gK1xuICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pP2AgK1xuICAgICAgICAgICAgICBgKD86JHtzcmNbdC5CVUlMRF19KT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTEZVTEwnLCBzcmNbdC5DT0VSQ0VGVUxMXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMC0wXFxcXHMqJCcpXG4iLCAiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dFxuY29uc3QgbG9vc2VPcHRpb24gPSBPYmplY3QuZnJlZXplKHsgbG9vc2U6IHRydWUgfSlcbmNvbnN0IGVtcHR5T3B0cyA9IE9iamVjdC5mcmVlemUoeyB9KVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBlbXB0eU9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbG9vc2VPcHRpb25cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwgImNvbnN0IG51bWVyaWMgPSAvXlswLTldKyQvXG5jb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIGNvbnN0IGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iLCAiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHNhZmVTcmM6IHNyYywgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgY29tcGFyZUlkZW50aWZpZXJzIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jbGFzcyBTZW1WZXIge1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZlcnNpb24uIE11c3QgYmUgYSBzdHJpbmcuIEdvdCB0eXBlIFwiJHt0eXBlb2YgdmVyc2lvbn1cIi5gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygnYnVpbGQgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBpZiAocmVsZWFzZS5zdGFydHNXaXRoKCdwcmUnKSkge1xuICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiBpZGVudGlmaWVyIGlzIGVtcHR5JylcbiAgICAgIH1cbiAgICAgIC8vIEF2b2lkIGFuIGludmFsaWQgc2VtdmVyIHJlc3VsdHNcbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgUmVnRXhwKGBeJHt0aGlzLm9wdGlvbnMubG9vc2UgPyBzcmNbdC5QUkVSRUxFQVNFTE9PU0VdIDogc3JjW3QuUFJFUkVMRUFTRV19JGApXG4gICAgICAgIGNvbnN0IG1hdGNoID0gYC0ke2lkZW50aWZpZXJ9YC5tYXRjaChyKVxuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdICE9PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlkZW50aWZpZXI6ICR7aWRlbnRpZmllcn1gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2ZXJzaW9uICR7dGhpcy5yYXd9IGlzIG5vdCBhIHByZXJlbGVhc2VgKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLnJhdyA9IHRoaXMuZm9ybWF0KClcbiAgICBpZiAodGhpcy5idWlsZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmF3ICs9IGArJHt0aGlzLmJ1aWxkLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsICJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zLCB0aHJvd0Vycm9ycyA9IGZhbHNlKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKCF0aHJvd0Vycm9ycykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhyb3cgZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG4iLCAiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFxuIiwgImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgaW5jID0gKHZlcnNpb24sIHJlbGVhc2UsIG9wdGlvbnMsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXJCYXNlID0gaWRlbnRpZmllclxuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcihcbiAgICAgIHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIgPyB2ZXJzaW9uLnZlcnNpb24gOiB2ZXJzaW9uLFxuICAgICAgb3B0aW9uc1xuICAgICkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNcbiIsICJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xLCBudWxsLCB0cnVlKVxuICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yLCBudWxsLCB0cnVlKVxuICBjb25zdCBjb21wYXJpc29uID0gdjEuY29tcGFyZSh2MilcblxuICBpZiAoY29tcGFyaXNvbiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB2MUhpZ2hlciA9IGNvbXBhcmlzb24gPiAwXG4gIGNvbnN0IGhpZ2hWZXJzaW9uID0gdjFIaWdoZXIgPyB2MSA6IHYyXG4gIGNvbnN0IGxvd1ZlcnNpb24gPSB2MUhpZ2hlciA/IHYyIDogdjFcbiAgY29uc3QgaGlnaEhhc1ByZSA9ICEhaGlnaFZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGhcbiAgY29uc3QgbG93SGFzUHJlID0gISFsb3dWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG5cbiAgaWYgKGxvd0hhc1ByZSAmJiAhaGlnaEhhc1ByZSkge1xuICAgIC8vIEdvaW5nIGZyb20gcHJlcmVsZWFzZSAtPiBubyBwcmVyZWxlYXNlIHJlcXVpcmVzIHNvbWUgc3BlY2lhbCBjYXNpbmdcblxuICAgIC8vIElmIHRoZSBsb3cgdmVyc2lvbiBoYXMgb25seSBhIG1ham9yLCB0aGVuIGl0IHdpbGwgYWx3YXlzIGJlIGEgbWFqb3JcbiAgICAvLyBTb21lIGV4YW1wbGVzOlxuICAgIC8vIDEuMC4wLTEgLT4gMS4wLjBcbiAgICAvLyAxLjAuMC0xIC0+IDEuMS4xXG4gICAgLy8gMS4wLjAtMSAtPiAyLjAuMFxuICAgIGlmICghbG93VmVyc2lvbi5wYXRjaCAmJiAhbG93VmVyc2lvbi5taW5vcikge1xuICAgICAgcmV0dXJuICdtYWpvcidcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbWFpbiBwYXJ0IGhhcyBubyBkaWZmZXJlbmNlXG4gICAgaWYgKGxvd1ZlcnNpb24uY29tcGFyZU1haW4oaGlnaFZlcnNpb24pID09PSAwKSB7XG4gICAgICBpZiAobG93VmVyc2lvbi5taW5vciAmJiAhbG93VmVyc2lvbi5wYXRjaCkge1xuICAgICAgICByZXR1cm4gJ21pbm9yJ1xuICAgICAgfVxuICAgICAgcmV0dXJuICdwYXRjaCdcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBoaWdoIGFuZCBsb3cgYXJlIHByZWxlYXNlc1xuICByZXR1cm4gJ3ByZXJlbGVhc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1pbm9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vclxubW9kdWxlLmV4cG9ydHMgPSBtaW5vclxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwgImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iLCAiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCAiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsICJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCAiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwgImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iLCAiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwgImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3B9YClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBjbXBcbiIsICJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRUZVTExdIDogcmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy8gV2l0aCBpbmNsdWRlUHJlcmVsZWFzZSBvcHRpb24gc2V0LCAnMS4yLjMuNC1yYycgd2FudHMgdG8gY29lcmNlICcyLjMuNC1yYycsIG5vdCAnMi4zLjQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBjb25zdCBjb2VyY2VSdGxSZWdleCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRVJUTEZVTExdIDogcmVbdC5DT0VSQ0VSVExdXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSBjb2VyY2VSdGxSZWdleC5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICBjb2VyY2VSdGxSZWdleC5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgY29lcmNlUnRsUmVnZXgubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtYWpvciA9IG1hdGNoWzJdXG4gIGNvbnN0IG1pbm9yID0gbWF0Y2hbM10gfHwgJzAnXG4gIGNvbnN0IHBhdGNoID0gbWF0Y2hbNF0gfHwgJzAnXG4gIGNvbnN0IHByZXJlbGVhc2UgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIG1hdGNoWzVdID8gYC0ke21hdGNoWzVdfWAgOiAnJ1xuICBjb25zdCBidWlsZCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgbWF0Y2hbNl0gPyBgKyR7bWF0Y2hbNl19YCA6ICcnXG5cbiAgcmV0dXJuIHBhcnNlKGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSR7cHJlcmVsZWFzZX0ke2J1aWxkfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwgImNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWF4ID0gMTAwMFxuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KGtleSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGtleSBmcm9tIHRoZSBtYXAgYW5kIGFkZCBpdCB0byB0aGUgZW5kXG4gICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cblxuICBkZWxldGUgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuZGVsZXRlKGtleSlcblxuICAgIGlmICghZGVsZXRlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiBjYWNoZSBpcyBmdWxsLCBkZWxldGUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbVxuICAgICAgaWYgKHRoaXMubWFwLnNpemUgPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLm1hcC5rZXlzKCkubmV4dCgpLnZhbHVlXG4gICAgICAgIHRoaXMuZGVsZXRlKGZpcnN0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsICJjb25zdCBTUEFDRV9DSEFSQUNURVJTID0gL1xccysvZ1xuXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QgcmVkdWNlIGFsbCB3aGl0ZXNwYWNlIGFzIG11Y2ggYXMgcG9zc2libGUgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVseVxuICAgIC8vIG9uIHBvdGVudGlhbGx5IHNsb3cgcmVnZXhlcyBsaWtlIFxccyouIFRoaXMgaXMgdGhlbiBzdG9yZWQgYW5kIHVzZWQgZm9yXG4gICAgLy8gZnV0dXJlIGVycm9yIG1lc3NhZ2VzIGFzIHdlbGwuXG4gICAgdGhpcy5yYXcgPSByYW5nZS50cmltKCkucmVwbGFjZShTUEFDRV9DSEFSQUNURVJTLCAnICcpXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgb24gfHxcbiAgICB0aGlzLnNldCA9IHRoaXMucmF3XG4gICAgICAuc3BsaXQoJ3x8JylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyID0+IHRoaXMucGFyc2VSYW5nZShyLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHt0aGlzLnJhd31gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXR0ZWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCByYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0dGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJ3x8J1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy5zZXRbaV1cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb21wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJyAnXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkICs9IGNvbXBzW2tdLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSkgfFxuICAgICAgKHRoaXMub3B0aW9ucy5sb29zZSAmJiBGTEFHX0xPT1NFKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArICc6JyArIHJhbmdlXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygndGlsZGUgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY2FyZXQgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgbGV0IHJhbmdlTGlzdCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJyAnKVxuICAgICAgLm1hcChjb21wID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIGlmIChsb29zZSkge1xuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIHJhbmdlTGlzdCA9IHJhbmdlTGlzdC5maWx0ZXIoY29tcCA9PiB7XG4gICAgICAgIGRlYnVnKCdsb29zZSBpbnZhbGlkIGZpbHRlcicsIGNvbXAsIHRoaXMub3B0aW9ucylcbiAgICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChyZVt0LkNPTVBBUkFUT1JMT09TRV0pXG4gICAgICB9KVxuICAgIH1cbiAgICBkZWJ1ZygncmFuZ2UgbGlzdCcsIHJhbmdlTGlzdClcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCByYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2VMaXN0Lm1hcChjb21wID0+IG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKSB7XG4gICAgICAgIHJldHVybiBbY29tcF1cbiAgICAgIH1cbiAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKVxuICAgIH1cbiAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSkge1xuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV1cbiAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGludGVyc2VjdHMgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICByYW5nZS5zZXQuc29tZSgocmFuZ2VDb21wYXJhdG9ycykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2xydWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSgpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgc2FmZVJlOiByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlLFxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IHsgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UsIEZMQUdfTE9PU0UgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MC4wLjEgLS0+ID49MC4wLjEgPDAuMS4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VUaWxkZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tPiA+PTAuMC4xIDwwLjAuMi0wXG4vLyBeMC4xLjAgLS0+ID49MC4xLjAgPDAuMi4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VDYXJldChjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpKVxuICAgIC5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIHByID0gJy0wJ1xuICAgICAgfVxuXG4gICAgICByZXQgPSBgJHtndGx0ICsgTX0uJHttfS4ke3B9JHtwcn1gXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3ByfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuY29uc3QgcmVwbGFjZVN0YXJzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuY29uc3QgcmVwbGFjZUdURTAgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZUdURTAnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVtvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gdC5HVEUwUFJFIDogdC5HVEUwXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG4vLyBUT0RPIGJ1aWxkP1xuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwcikgPT4ge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4ke2ZtfS4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX1gXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX0ke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9IGA8JHsrdE0gKyAxfS4wLjAtMGBcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7K3RtICsgMX0uMC0wYFxuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gYDw9JHt0TX0uJHt0bX0uJHt0cH0tJHt0cHJ9YFxuICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7dG19LiR7K3RwICsgMX0tMGBcbiAgfSBlbHNlIHtcbiAgICB0byA9IGA8PSR7dG99YFxuICB9XG5cbiAgcmV0dXJuIGAke2Zyb219ICR7dG99YC50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiY29uc3QgQU5ZID0gU3ltYm9sKCdTZW1WZXIgQU5ZJylcbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBDb21wYXJhdG9yIHtcbiAgc3RhdGljIGdldCBBTlkgKCkge1xuICAgIHJldHVybiBBTllcbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXAgPSBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIFNwZWNpYWwgY2FzZXMgd2hlcmUgbm90aGluZyBjYW4gcG9zc2libHkgYmUgbG93ZXJcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUgPT09ICc8MC4wLjAtMCcgfHwgY29tcC52YWx1ZSA9PT0gJzwwLjAuMC0wJykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICAgICh0aGlzLnZhbHVlLnN0YXJ0c1dpdGgoJzwwLjAuMCcpIHx8IGNvbXAudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBpbmNyZWFzaW5nICg+IG9yID49KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gU2FtZSBkaXJlY3Rpb24gZGVjcmVhc2luZyAoPCBvciA8PSlcbiAgICBpZiAodGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIHNhbWUgU2VtVmVyIGFuZCBib3RoIHNpZGVzIGFyZSBpbmNsdXNpdmUgKDw9IG9yID49KVxuICAgIGlmIChcbiAgICAgICh0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5pbmNsdWRlcygnPScpICYmIGNvbXAub3BlcmF0b3IuaW5jbHVkZXMoJz0nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBsZXNzIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIG9wcG9zaXRlIGRpcmVjdGlvbnMgZ3JlYXRlciB0aGFuXG4gICAgaWYgKGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgIHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwgImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsICJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCAiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsICJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IG1pblNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cbm1vZHVsZS5leHBvcnRzID0gbWluU2F0aXNmeWluZ1xuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSkge1xuICAgICAgbWludmVyID0gc2V0TWluXG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCAiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCAiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsICIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsICJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwgImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCAiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsICJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKV1cbmNvbnN0IG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgICB9XG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiIsICIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBpZGVudGlmaWVycyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpXG5jb25zdCB2YWxpZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJylcbmNvbnN0IGNsZWFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKVxuY29uc3QgaW5jID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJylcbmNvbnN0IGRpZmYgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJylcbmNvbnN0IG1ham9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKVxuY29uc3QgbWlub3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpXG5jb25zdCBwYXRjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJylcbmNvbnN0IHByZXJlbGVhc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JylcbmNvbnN0IHJzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGNvZXJjZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblZlcnNpb24gPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpXG5jb25zdCB2YWxpZFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKVxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKVxuY29uc3QgZ3RyID0gcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJylcbmNvbnN0IGx0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpXG5jb25zdCBpbnRlcnNlY3RzID0gcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpXG5jb25zdCBzaW1wbGlmeVJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKVxuY29uc3Qgc3Vic2V0ID0gcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0Jylcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZSxcbiAgdmFsaWQsXG4gIGNsZWFuLFxuICBpbmMsXG4gIGRpZmYsXG4gIG1ham9yLFxuICBtaW5vcixcbiAgcGF0Y2gsXG4gIHByZXJlbGVhc2UsXG4gIGNvbXBhcmUsXG4gIHJjb21wYXJlLFxuICBjb21wYXJlTG9vc2UsXG4gIGNvbXBhcmVCdWlsZCxcbiAgc29ydCxcbiAgcnNvcnQsXG4gIGd0LFxuICBsdCxcbiAgZXEsXG4gIG5lcSxcbiAgZ3RlLFxuICBsdGUsXG4gIGNtcCxcbiAgY29lcmNlLFxuICBDb21wYXJhdG9yLFxuICBSYW5nZSxcbiAgc2F0aXNmaWVzLFxuICB0b0NvbXBhcmF0b3JzLFxuICBtYXhTYXRpc2Z5aW5nLFxuICBtaW5TYXRpc2Z5aW5nLFxuICBtaW5WZXJzaW9uLFxuICB2YWxpZFJhbmdlLFxuICBvdXRzaWRlLFxuICBndHIsXG4gIGx0cixcbiAgaW50ZXJzZWN0cyxcbiAgc2ltcGxpZnlSYW5nZSxcbiAgc3Vic2V0LFxuICBTZW1WZXIsXG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogY29uc3RhbnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFJFTEVBU0VfVFlQRVM6IGNvbnN0YW50cy5SRUxFQVNFX1RZUEVTLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMucmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsICJjb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZW12ZXIuc2F0aXNmaWVzKHByb2Nlc3MudmVyc2lvbiwgJz49MTUuNy4wJyk7XG4iLCAiY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2VtdmVyLnNhdGlzZmllcyhwcm9jZXNzLnZlcnNpb24sICc+PTE2LjkuMCcpO1xuIiwgImNvbnN0IEFTWU1NRVRSSUNfS0VZX0RFVEFJTFNfU1VQUE9SVEVEID0gcmVxdWlyZSgnLi9hc3ltbWV0cmljS2V5RGV0YWlsc1N1cHBvcnRlZCcpO1xuY29uc3QgUlNBX1BTU19LRVlfREVUQUlMU19TVVBQT1JURUQgPSByZXF1aXJlKCcuL3JzYVBzc0tleURldGFpbHNTdXBwb3J0ZWQnKTtcblxuY29uc3QgYWxsb3dlZEFsZ29yaXRobXNGb3JLZXlzID0ge1xuICAnZWMnOiBbJ0VTMjU2JywgJ0VTMzg0JywgJ0VTNTEyJ10sXG4gICdyc2EnOiBbJ1JTMjU2JywgJ1BTMjU2JywgJ1JTMzg0JywgJ1BTMzg0JywgJ1JTNTEyJywgJ1BTNTEyJ10sXG4gICdyc2EtcHNzJzogWydQUzI1NicsICdQUzM4NCcsICdQUzUxMiddXG59O1xuXG5jb25zdCBhbGxvd2VkQ3VydmVzID0ge1xuICBFUzI1NjogJ3ByaW1lMjU2djEnLFxuICBFUzM4NDogJ3NlY3AzODRyMScsXG4gIEVTNTEyOiAnc2VjcDUyMXIxJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgaWYgKCFhbGdvcml0aG0gfHwgIWtleSkgcmV0dXJuO1xuXG4gIGNvbnN0IGtleVR5cGUgPSBrZXkuYXN5bW1ldHJpY0tleVR5cGU7XG4gIGlmICgha2V5VHlwZSkgcmV0dXJuO1xuXG4gIGNvbnN0IGFsbG93ZWRBbGdvcml0aG1zID0gYWxsb3dlZEFsZ29yaXRobXNGb3JLZXlzW2tleVR5cGVdO1xuXG4gIGlmICghYWxsb3dlZEFsZ29yaXRobXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24ga2V5IHR5cGUgXCIke2tleVR5cGV9XCIuYCk7XG4gIH1cblxuICBpZiAoIWFsbG93ZWRBbGdvcml0aG1zLmluY2x1ZGVzKGFsZ29yaXRobSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiYWxnXCIgcGFyYW1ldGVyIGZvciBcIiR7a2V5VHlwZX1cIiBrZXkgdHlwZSBtdXN0IGJlIG9uZSBvZjogJHthbGxvd2VkQWxnb3JpdGhtcy5qb2luKCcsICcpfS5gKVxuICB9XG5cbiAgLypcbiAgICogSWdub3JlIHRoZSBuZXh0IGJsb2NrIGZyb20gdGVzdCBjb3ZlcmFnZSBiZWNhdXNlIGl0IGdldHMgZXhlY3V0ZWRcbiAgICogY29uZGl0aW9uYWxseSBkZXBlbmRpbmcgb24gdGhlIE5vZGUgdmVyc2lvbi4gTm90IGlnbm9yaW5nIGl0IHdvdWxkXG4gICAqIHByZXZlbnQgdXMgZnJvbSByZWFjaGluZyB0aGUgdGFyZ2V0ICUgb2YgY292ZXJhZ2UgZm9yIHZlcnNpb25zIG9mXG4gICAqIE5vZGUgdW5kZXIgMTUuNy4wLlxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKEFTWU1NRVRSSUNfS0VZX0RFVEFJTFNfU1VQUE9SVEVEKSB7XG4gICAgc3dpdGNoIChrZXlUeXBlKSB7XG4gICAgY2FzZSAnZWMnOlxuICAgICAgY29uc3Qga2V5Q3VydmUgPSBrZXkuYXN5bW1ldHJpY0tleURldGFpbHMubmFtZWRDdXJ2ZTtcbiAgICAgIGNvbnN0IGFsbG93ZWRDdXJ2ZSA9IGFsbG93ZWRDdXJ2ZXNbYWxnb3JpdGhtXTtcblxuICAgICAgaWYgKGtleUN1cnZlICE9PSBhbGxvd2VkQ3VydmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcImFsZ1wiIHBhcmFtZXRlciBcIiR7YWxnb3JpdGhtfVwiIHJlcXVpcmVzIGN1cnZlIFwiJHthbGxvd2VkQ3VydmV9XCIuYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JzYS1wc3MnOlxuICAgICAgaWYgKFJTQV9QU1NfS0VZX0RFVEFJTFNfU1VQUE9SVEVEKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGFsZ29yaXRobS5zbGljZSgtMyksIDEwKTtcbiAgICAgICAgY29uc3QgeyBoYXNoQWxnb3JpdGhtLCBtZ2YxSGFzaEFsZ29yaXRobSwgc2FsdExlbmd0aCB9ID0ga2V5LmFzeW1tZXRyaWNLZXlEZXRhaWxzO1xuXG4gICAgICAgIGlmIChoYXNoQWxnb3JpdGhtICE9PSBgc2hhJHtsZW5ndGh9YCB8fCBtZ2YxSGFzaEFsZ29yaXRobSAhPT0gaGFzaEFsZ29yaXRobSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXkgZm9yIHRoaXMgb3BlcmF0aW9uLCBpdHMgUlNBLVBTUyBwYXJhbWV0ZXJzIGRvIG5vdCBtZWV0IHRoZSByZXF1aXJlbWVudHMgb2YgXCJhbGdcIiAke2FsZ29yaXRobX0uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHNhbHRMZW5ndGggPiBsZW5ndGggPj4gMykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXkgZm9yIHRoaXMgb3BlcmF0aW9uLCBpdHMgUlNBLVBTUyBwYXJhbWV0ZXIgc2FsdExlbmd0aCBkb2VzIG5vdCBtZWV0IHRoZSByZXF1aXJlbWVudHMgb2YgXCJhbGdcIiAke2FsZ29yaXRobX0uYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCAidmFyIHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbXZlci5zYXRpc2ZpZXMocHJvY2Vzcy52ZXJzaW9uLCAnXjYuMTIuMCB8fCA+PTguMC4wJyk7XG4iLCAiY29uc3QgSnNvbldlYlRva2VuRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9Kc29uV2ViVG9rZW5FcnJvcicpO1xuY29uc3QgTm90QmVmb3JlRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9Ob3RCZWZvcmVFcnJvcicpO1xuY29uc3QgVG9rZW5FeHBpcmVkRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9Ub2tlbkV4cGlyZWRFcnJvcicpO1xuY29uc3QgZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmNvbnN0IHRpbWVzcGFuID0gcmVxdWlyZSgnLi9saWIvdGltZXNwYW4nKTtcbmNvbnN0IHZhbGlkYXRlQXN5bW1ldHJpY0tleSA9IHJlcXVpcmUoJy4vbGliL3ZhbGlkYXRlQXN5bW1ldHJpY0tleScpO1xuY29uc3QgUFNfU1VQUE9SVEVEID0gcmVxdWlyZSgnLi9saWIvcHNTdXBwb3J0ZWQnKTtcbmNvbnN0IGp3cyA9IHJlcXVpcmUoJ2p3cycpO1xuY29uc3Qge0tleU9iamVjdCwgY3JlYXRlU2VjcmV0S2V5LCBjcmVhdGVQdWJsaWNLZXl9ID0gcmVxdWlyZShcImNyeXB0b1wiKTtcblxuY29uc3QgUFVCX0tFWV9BTEdTID0gWydSUzI1NicsICdSUzM4NCcsICdSUzUxMiddO1xuY29uc3QgRUNfS0VZX0FMR1MgPSBbJ0VTMjU2JywgJ0VTMzg0JywgJ0VTNTEyJ107XG5jb25zdCBSU0FfS0VZX0FMR1MgPSBbJ1JTMjU2JywgJ1JTMzg0JywgJ1JTNTEyJ107XG5jb25zdCBIU19BTEdTID0gWydIUzI1NicsICdIUzM4NCcsICdIUzUxMiddO1xuXG5pZiAoUFNfU1VQUE9SVEVEKSB7XG4gIFBVQl9LRVlfQUxHUy5zcGxpY2UoUFVCX0tFWV9BTEdTLmxlbmd0aCwgMCwgJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJyk7XG4gIFJTQV9LRVlfQUxHUy5zcGxpY2UoUlNBX0tFWV9BTEdTLmxlbmd0aCwgMCwgJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGp3dFN0cmluZywgc2VjcmV0T3JQdWJsaWNLZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICAvL2Nsb25lIHRoaXMgb2JqZWN0IHNpbmNlIHdlIGFyZSBnb2luZyB0byBtdXRhdGUgaXQuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICBsZXQgZG9uZTtcblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBkb25lID0gY2FsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmNsb2NrVGltZXN0YW1wICYmIHR5cGVvZiBvcHRpb25zLmNsb2NrVGltZXN0YW1wICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignY2xvY2tUaW1lc3RhbXAgbXVzdCBiZSBhIG51bWJlcicpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm5vbmNlICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRpb25zLm5vbmNlICE9PSAnc3RyaW5nJyB8fCBvcHRpb25zLm5vbmNlLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdub25jZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFsbG93SW52YWxpZEFzeW1tZXRyaWNLZXlUeXBlcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmFsbG93SW52YWxpZEFzeW1tZXRyaWNLZXlUeXBlcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdhbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXMgbXVzdCBiZSBhIGJvb2xlYW4nKSk7XG4gIH1cblxuICBjb25zdCBjbG9ja1RpbWVzdGFtcCA9IG9wdGlvbnMuY2xvY2tUaW1lc3RhbXAgfHwgTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG5cbiAgaWYgKCFqd3RTdHJpbmcpe1xuICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignand0IG11c3QgYmUgcHJvdmlkZWQnKSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGp3dFN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBtdXN0IGJlIGEgc3RyaW5nJykpO1xuICB9XG5cbiAgY29uc3QgcGFydHMgPSBqd3RTdHJpbmcuc3BsaXQoJy4nKTtcblxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKXtcbiAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKSk7XG4gIH1cblxuICBsZXQgZGVjb2RlZFRva2VuO1xuXG4gIHRyeSB7XG4gICAgZGVjb2RlZFRva2VuID0gZGVjb2RlKGp3dFN0cmluZywgeyBjb21wbGV0ZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaChlcnIpIHtcbiAgICByZXR1cm4gZG9uZShlcnIpO1xuICB9XG5cbiAgaWYgKCFkZWNvZGVkVG9rZW4pIHtcbiAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2ludmFsaWQgdG9rZW4nKSk7XG4gIH1cblxuICBjb25zdCBoZWFkZXIgPSBkZWNvZGVkVG9rZW4uaGVhZGVyO1xuICBsZXQgZ2V0U2VjcmV0O1xuXG4gIGlmKHR5cGVvZiBzZWNyZXRPclB1YmxpY0tleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCd2ZXJpZnkgbXVzdCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzIGlmIHNlY3JldCBvciBwdWJsaWMga2V5IGlzIHByb3ZpZGVkIGFzIGEgY2FsbGJhY2snKSk7XG4gICAgfVxuXG4gICAgZ2V0U2VjcmV0ID0gc2VjcmV0T3JQdWJsaWNLZXk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZ2V0U2VjcmV0ID0gZnVuY3Rpb24oaGVhZGVyLCBzZWNyZXRDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNlY3JldENhbGxiYWNrKG51bGwsIHNlY3JldE9yUHVibGljS2V5KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGdldFNlY3JldChoZWFkZXIsIGZ1bmN0aW9uKGVyciwgc2VjcmV0T3JQdWJsaWNLZXkpIHtcbiAgICBpZihlcnIpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignZXJyb3IgaW4gc2VjcmV0IG9yIHB1YmxpYyBrZXkgY2FsbGJhY2s6ICcgKyBlcnIubWVzc2FnZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc1NpZ25hdHVyZSA9IHBhcnRzWzJdLnRyaW0oKSAhPT0gJyc7XG5cbiAgICBpZiAoIWhhc1NpZ25hdHVyZSAmJiBzZWNyZXRPclB1YmxpY0tleSl7XG4gICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBzaWduYXR1cmUgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1NpZ25hdHVyZSAmJiAhc2VjcmV0T3JQdWJsaWNLZXkpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignc2VjcmV0IG9yIHB1YmxpYyBrZXkgbXVzdCBiZSBwcm92aWRlZCcpKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1NpZ25hdHVyZSAmJiAhb3B0aW9ucy5hbGdvcml0aG1zKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ3BsZWFzZSBzcGVjaWZ5IFwibm9uZVwiIGluIFwiYWxnb3JpdGhtc1wiIHRvIHZlcmlmeSB1bnNpZ25lZCB0b2tlbnMnKSk7XG4gICAgfVxuXG4gICAgaWYgKHNlY3JldE9yUHVibGljS2V5ICE9IG51bGwgJiYgIShzZWNyZXRPclB1YmxpY0tleSBpbnN0YW5jZW9mIEtleU9iamVjdCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlY3JldE9yUHVibGljS2V5ID0gY3JlYXRlUHVibGljS2V5KHNlY3JldE9yUHVibGljS2V5KTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZWNyZXRPclB1YmxpY0tleSA9IGNyZWF0ZVNlY3JldEtleSh0eXBlb2Ygc2VjcmV0T3JQdWJsaWNLZXkgPT09ICdzdHJpbmcnID8gQnVmZmVyLmZyb20oc2VjcmV0T3JQdWJsaWNLZXkpIDogc2VjcmV0T3JQdWJsaWNLZXkpO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdzZWNyZXRPclB1YmxpY0tleSBpcyBub3QgdmFsaWQga2V5IG1hdGVyaWFsJykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuYWxnb3JpdGhtcykge1xuICAgICAgaWYgKHNlY3JldE9yUHVibGljS2V5LnR5cGUgPT09ICdzZWNyZXQnKSB7XG4gICAgICAgIG9wdGlvbnMuYWxnb3JpdGhtcyA9IEhTX0FMR1M7XG4gICAgICB9IGVsc2UgaWYgKFsncnNhJywgJ3JzYS1wc3MnXS5pbmNsdWRlcyhzZWNyZXRPclB1YmxpY0tleS5hc3ltbWV0cmljS2V5VHlwZSkpIHtcbiAgICAgICAgb3B0aW9ucy5hbGdvcml0aG1zID0gUlNBX0tFWV9BTEdTXG4gICAgICB9IGVsc2UgaWYgKHNlY3JldE9yUHVibGljS2V5LmFzeW1tZXRyaWNLZXlUeXBlID09PSAnZWMnKSB7XG4gICAgICAgIG9wdGlvbnMuYWxnb3JpdGhtcyA9IEVDX0tFWV9BTEdTXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLmFsZ29yaXRobXMgPSBQVUJfS0VZX0FMR1NcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGdvcml0aG1zLmluZGV4T2YoZGVjb2RlZFRva2VuLmhlYWRlci5hbGcpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdpbnZhbGlkIGFsZ29yaXRobScpKTtcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpICYmIHNlY3JldE9yUHVibGljS2V5LnR5cGUgIT09ICdzZWNyZXQnKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoKGBzZWNyZXRPclB1YmxpY0tleSBtdXN0IGJlIGEgc3ltbWV0cmljIGtleSB3aGVuIHVzaW5nICR7aGVhZGVyLmFsZ31gKSkpXG4gICAgfSBlbHNlIGlmICgvXig/OlJTfFBTfEVTKS8udGVzdChoZWFkZXIuYWxnKSAmJiBzZWNyZXRPclB1YmxpY0tleS50eXBlICE9PSAncHVibGljJykge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKChgc2VjcmV0T3JQdWJsaWNLZXkgbXVzdCBiZSBhbiBhc3ltbWV0cmljIGtleSB3aGVuIHVzaW5nICR7aGVhZGVyLmFsZ31gKSkpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmFsbG93SW52YWxpZEFzeW1tZXRyaWNLZXlUeXBlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsaWRhdGVBc3ltbWV0cmljS2V5KGhlYWRlci5hbGcsIHNlY3JldE9yUHVibGljS2V5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkID0gandzLnZlcmlmeShqd3RTdHJpbmcsIGRlY29kZWRUb2tlbi5oZWFkZXIuYWxnLCBzZWNyZXRPclB1YmxpY0tleSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGRvbmUoZSk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZScpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXlsb2FkID0gZGVjb2RlZFRva2VuLnBheWxvYWQ7XG5cbiAgICBpZiAodHlwZW9mIHBheWxvYWQubmJmICE9PSAndW5kZWZpbmVkJyAmJiAhb3B0aW9ucy5pZ25vcmVOb3RCZWZvcmUpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5uYmYgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignaW52YWxpZCBuYmYgdmFsdWUnKSk7XG4gICAgICB9XG4gICAgICBpZiAocGF5bG9hZC5uYmYgPiBjbG9ja1RpbWVzdGFtcCArIChvcHRpb25zLmNsb2NrVG9sZXJhbmNlIHx8IDApKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBOb3RCZWZvcmVFcnJvcignand0IG5vdCBhY3RpdmUnLCBuZXcgRGF0ZShwYXlsb2FkLm5iZiAqIDEwMDApKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLmV4cCAhPT0gJ3VuZGVmaW5lZCcgJiYgIW9wdGlvbnMuaWdub3JlRXhwaXJhdGlvbikge1xuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLmV4cCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdpbnZhbGlkIGV4cCB2YWx1ZScpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9ja1RpbWVzdGFtcCA+PSBwYXlsb2FkLmV4cCArIChvcHRpb25zLmNsb2NrVG9sZXJhbmNlIHx8IDApKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBUb2tlbkV4cGlyZWRFcnJvcignand0IGV4cGlyZWQnLCBuZXcgRGF0ZShwYXlsb2FkLmV4cCAqIDEwMDApKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXVkaWVuY2UpIHtcbiAgICAgIGNvbnN0IGF1ZGllbmNlcyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5hdWRpZW5jZSkgPyBvcHRpb25zLmF1ZGllbmNlIDogW29wdGlvbnMuYXVkaWVuY2VdO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gQXJyYXkuaXNBcnJheShwYXlsb2FkLmF1ZCkgPyBwYXlsb2FkLmF1ZCA6IFtwYXlsb2FkLmF1ZF07XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gdGFyZ2V0LnNvbWUoZnVuY3Rpb24gKHRhcmdldEF1ZGllbmNlKSB7XG4gICAgICAgIHJldHVybiBhdWRpZW5jZXMuc29tZShmdW5jdGlvbiAoYXVkaWVuY2UpIHtcbiAgICAgICAgICByZXR1cm4gYXVkaWVuY2UgaW5zdGFuY2VvZiBSZWdFeHAgPyBhdWRpZW5jZS50ZXN0KHRhcmdldEF1ZGllbmNlKSA6IGF1ZGllbmNlID09PSB0YXJnZXRBdWRpZW5jZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBhdWRpZW5jZSBpbnZhbGlkLiBleHBlY3RlZDogJyArIGF1ZGllbmNlcy5qb2luKCcgb3IgJykpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pc3N1ZXIpIHtcbiAgICAgIGNvbnN0IGludmFsaWRfaXNzdWVyID1cbiAgICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zLmlzc3VlciA9PT0gJ3N0cmluZycgJiYgcGF5bG9hZC5pc3MgIT09IG9wdGlvbnMuaXNzdWVyKSB8fFxuICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShvcHRpb25zLmlzc3VlcikgJiYgb3B0aW9ucy5pc3N1ZXIuaW5kZXhPZihwYXlsb2FkLmlzcykgPT09IC0xKTtcblxuICAgICAgaWYgKGludmFsaWRfaXNzdWVyKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignand0IGlzc3VlciBpbnZhbGlkLiBleHBlY3RlZDogJyArIG9wdGlvbnMuaXNzdWVyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3ViamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuc3ViICE9PSBvcHRpb25zLnN1YmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdqd3Qgc3ViamVjdCBpbnZhbGlkLiBleHBlY3RlZDogJyArIG9wdGlvbnMuc3ViamVjdCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmp3dGlkKSB7XG4gICAgICBpZiAocGF5bG9hZC5qdGkgIT09IG9wdGlvbnMuand0aWQpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdqd3Qgand0aWQgaW52YWxpZC4gZXhwZWN0ZWQ6ICcgKyBvcHRpb25zLmp3dGlkKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9uY2UpIHtcbiAgICAgIGlmIChwYXlsb2FkLm5vbmNlICE9PSBvcHRpb25zLm5vbmNlKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignand0IG5vbmNlIGludmFsaWQuIGV4cGVjdGVkOiAnICsgb3B0aW9ucy5ub25jZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1heEFnZSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLmlhdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdpYXQgcmVxdWlyZWQgd2hlbiBtYXhBZ2UgaXMgc3BlY2lmaWVkJykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXhBZ2VUaW1lc3RhbXAgPSB0aW1lc3BhbihvcHRpb25zLm1heEFnZSwgcGF5bG9hZC5pYXQpO1xuICAgICAgaWYgKHR5cGVvZiBtYXhBZ2VUaW1lc3RhbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignXCJtYXhBZ2VcIiBzaG91bGQgYmUgYSBudW1iZXIgb2Ygc2Vjb25kcyBvciBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdGltZXNwYW4gZWc6IFwiMWRcIiwgXCIyMGhcIiwgNjAnKSk7XG4gICAgICB9XG4gICAgICBpZiAoY2xvY2tUaW1lc3RhbXAgPj0gbWF4QWdlVGltZXN0YW1wICsgKG9wdGlvbnMuY2xvY2tUb2xlcmFuY2UgfHwgMCkpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IFRva2VuRXhwaXJlZEVycm9yKCdtYXhBZ2UgZXhjZWVkZWQnLCBuZXcgRGF0ZShtYXhBZ2VUaW1lc3RhbXAgKiAxMDAwKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNvbXBsZXRlID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBkZWNvZGVkVG9rZW4uc2lnbmF0dXJlO1xuXG4gICAgICByZXR1cm4gZG9uZShudWxsLCB7XG4gICAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbmUobnVsbCwgcGF5bG9hZCk7XG4gIH0pO1xufTtcbiIsICIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgdmFyIHJlc3VsdCA9IChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpXG4gICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXG4gICAgOiBbXTtcblxuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPyBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluY2x1ZGVzO1xuIiwgIi8qKlxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCb29sZWFuKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQm9vbGVhbjtcbiIsICIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0ludGVnZXIoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0ludGVnZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwgIi8qKlxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlIGNsYXNzaWZpZWRcbiAqIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bWJlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwgIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxuICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT0gb2JqZWN0VGFnIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsICIvKipcbiAqIGxvZGFzaCA0LjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwgIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICovXG5mdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBuID0gdG9JbnRlZ2VyKG4pO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tbiA+IDApIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKG4gPD0gMSkge1xuICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAqIGluaXRpYWxpemUoKTtcbiAqIGluaXRpYWxpemUoKTtcbiAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gKi9cbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9uY2U7XG4iLCAiY29uc3QgdGltZXNwYW4gPSByZXF1aXJlKCcuL2xpYi90aW1lc3BhbicpO1xuY29uc3QgUFNfU1VQUE9SVEVEID0gcmVxdWlyZSgnLi9saWIvcHNTdXBwb3J0ZWQnKTtcbmNvbnN0IHZhbGlkYXRlQXN5bW1ldHJpY0tleSA9IHJlcXVpcmUoJy4vbGliL3ZhbGlkYXRlQXN5bW1ldHJpY0tleScpO1xuY29uc3QgandzID0gcmVxdWlyZSgnandzJyk7XG5jb25zdCBpbmNsdWRlcyA9IHJlcXVpcmUoJ2xvZGFzaC5pbmNsdWRlcycpO1xuY29uc3QgaXNCb29sZWFuID0gcmVxdWlyZSgnbG9kYXNoLmlzYm9vbGVhbicpO1xuY29uc3QgaXNJbnRlZ2VyID0gcmVxdWlyZSgnbG9kYXNoLmlzaW50ZWdlcicpO1xuY29uc3QgaXNOdW1iZXIgPSByZXF1aXJlKCdsb2Rhc2guaXNudW1iZXInKTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2guaXNwbGFpbm9iamVjdCcpO1xuY29uc3QgaXNTdHJpbmcgPSByZXF1aXJlKCdsb2Rhc2guaXNzdHJpbmcnKTtcbmNvbnN0IG9uY2UgPSByZXF1aXJlKCdsb2Rhc2gub25jZScpO1xuY29uc3QgeyBLZXlPYmplY3QsIGNyZWF0ZVNlY3JldEtleSwgY3JlYXRlUHJpdmF0ZUtleSB9ID0gcmVxdWlyZSgnY3J5cHRvJylcblxuY29uc3QgU1VQUE9SVEVEX0FMR1MgPSBbJ1JTMjU2JywgJ1JTMzg0JywgJ1JTNTEyJywgJ0VTMjU2JywgJ0VTMzg0JywgJ0VTNTEyJywgJ0hTMjU2JywgJ0hTMzg0JywgJ0hTNTEyJywgJ25vbmUnXTtcbmlmIChQU19TVVBQT1JURUQpIHtcbiAgU1VQUE9SVEVEX0FMR1Muc3BsaWNlKDMsIDAsICdQUzI1NicsICdQUzM4NCcsICdQUzUxMicpO1xufVxuXG5jb25zdCBzaWduX29wdGlvbnNfc2NoZW1hID0ge1xuICBleHBpcmVzSW46IHsgaXNWYWxpZDogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgfHwgKGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSk7IH0sIG1lc3NhZ2U6ICdcImV4cGlyZXNJblwiIHNob3VsZCBiZSBhIG51bWJlciBvZiBzZWNvbmRzIG9yIHN0cmluZyByZXByZXNlbnRpbmcgYSB0aW1lc3BhbicgfSxcbiAgbm90QmVmb3JlOiB7IGlzVmFsaWQ6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBpc0ludGVnZXIodmFsdWUpIHx8IChpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUpOyB9LCBtZXNzYWdlOiAnXCJub3RCZWZvcmVcIiBzaG91bGQgYmUgYSBudW1iZXIgb2Ygc2Vjb25kcyBvciBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdGltZXNwYW4nIH0sXG4gIGF1ZGllbmNlOiB7IGlzVmFsaWQ6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBpc1N0cmluZyh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSk7IH0sIG1lc3NhZ2U6ICdcImF1ZGllbmNlXCIgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheScgfSxcbiAgYWxnb3JpdGhtOiB7IGlzVmFsaWQ6IGluY2x1ZGVzLmJpbmQobnVsbCwgU1VQUE9SVEVEX0FMR1MpLCBtZXNzYWdlOiAnXCJhbGdvcml0aG1cIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVudW0gdmFsdWUnIH0sXG4gIGhlYWRlcjogeyBpc1ZhbGlkOiBpc1BsYWluT2JqZWN0LCBtZXNzYWdlOiAnXCJoZWFkZXJcIiBtdXN0IGJlIGFuIG9iamVjdCcgfSxcbiAgZW5jb2Rpbmc6IHsgaXNWYWxpZDogaXNTdHJpbmcsIG1lc3NhZ2U6ICdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHN0cmluZycgfSxcbiAgaXNzdWVyOiB7IGlzVmFsaWQ6IGlzU3RyaW5nLCBtZXNzYWdlOiAnXCJpc3N1ZXJcIiBtdXN0IGJlIGEgc3RyaW5nJyB9LFxuICBzdWJqZWN0OiB7IGlzVmFsaWQ6IGlzU3RyaW5nLCBtZXNzYWdlOiAnXCJzdWJqZWN0XCIgbXVzdCBiZSBhIHN0cmluZycgfSxcbiAgand0aWQ6IHsgaXNWYWxpZDogaXNTdHJpbmcsIG1lc3NhZ2U6ICdcImp3dGlkXCIgbXVzdCBiZSBhIHN0cmluZycgfSxcbiAgbm9UaW1lc3RhbXA6IHsgaXNWYWxpZDogaXNCb29sZWFuLCBtZXNzYWdlOiAnXCJub1RpbWVzdGFtcFwiIG11c3QgYmUgYSBib29sZWFuJyB9LFxuICBrZXlpZDogeyBpc1ZhbGlkOiBpc1N0cmluZywgbWVzc2FnZTogJ1wia2V5aWRcIiBtdXN0IGJlIGEgc3RyaW5nJyB9LFxuICBtdXRhdGVQYXlsb2FkOiB7IGlzVmFsaWQ6IGlzQm9vbGVhbiwgbWVzc2FnZTogJ1wibXV0YXRlUGF5bG9hZFwiIG11c3QgYmUgYSBib29sZWFuJyB9LFxuICBhbGxvd0luc2VjdXJlS2V5U2l6ZXM6IHsgaXNWYWxpZDogaXNCb29sZWFuLCBtZXNzYWdlOiAnXCJhbGxvd0luc2VjdXJlS2V5U2l6ZXNcIiBtdXN0IGJlIGEgYm9vbGVhbid9LFxuICBhbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXM6IHsgaXNWYWxpZDogaXNCb29sZWFuLCBtZXNzYWdlOiAnXCJhbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXNcIiBtdXN0IGJlIGEgYm9vbGVhbid9XG59O1xuXG5jb25zdCByZWdpc3RlcmVkX2NsYWltc19zY2hlbWEgPSB7XG4gIGlhdDogeyBpc1ZhbGlkOiBpc051bWJlciwgbWVzc2FnZTogJ1wiaWF0XCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMnIH0sXG4gIGV4cDogeyBpc1ZhbGlkOiBpc051bWJlciwgbWVzc2FnZTogJ1wiZXhwXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMnIH0sXG4gIG5iZjogeyBpc1ZhbGlkOiBpc051bWJlciwgbWVzc2FnZTogJ1wibmJmXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMnIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHNjaGVtYSwgYWxsb3dVbmtub3duLCBvYmplY3QsIHBhcmFtZXRlck5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHBhcmFtZXRlck5hbWUgKyAnXCIgdG8gYmUgYSBwbGFpbiBvYmplY3QuJyk7XG4gIH1cbiAgT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoIXZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIWFsbG93VW5rbm93bikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsga2V5ICsgJ1wiIGlzIG5vdCBhbGxvd2VkIGluIFwiJyArIHBhcmFtZXRlck5hbWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkYXRvci5pc1ZhbGlkKG9iamVjdFtrZXldKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdG9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gdmFsaWRhdGUoc2lnbl9vcHRpb25zX3NjaGVtYSwgZmFsc2UsIG9wdGlvbnMsICdvcHRpb25zJyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gIHJldHVybiB2YWxpZGF0ZShyZWdpc3RlcmVkX2NsYWltc19zY2hlbWEsIHRydWUsIHBheWxvYWQsICdwYXlsb2FkJyk7XG59XG5cbmNvbnN0IG9wdGlvbnNfdG9fcGF5bG9hZCA9IHtcbiAgJ2F1ZGllbmNlJzogJ2F1ZCcsXG4gICdpc3N1ZXInOiAnaXNzJyxcbiAgJ3N1YmplY3QnOiAnc3ViJyxcbiAgJ2p3dGlkJzogJ2p0aSdcbn07XG5cbmNvbnN0IG9wdGlvbnNfZm9yX29iamVjdHMgPSBbXG4gICdleHBpcmVzSW4nLFxuICAnbm90QmVmb3JlJyxcbiAgJ25vVGltZXN0YW1wJyxcbiAgJ2F1ZGllbmNlJyxcbiAgJ2lzc3VlcicsXG4gICdzdWJqZWN0JyxcbiAgJ2p3dGlkJyxcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBheWxvYWQsIHNlY3JldE9yUHJpdmF0ZUtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuXG4gIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKTtcblxuICBjb25zdCBoZWFkZXIgPSBPYmplY3QuYXNzaWduKHtcbiAgICBhbGc6IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdIUzI1NicsXG4gICAgdHlwOiBpc09iamVjdFBheWxvYWQgPyAnSldUJyA6IHVuZGVmaW5lZCxcbiAgICBraWQ6IG9wdGlvbnMua2V5aWRcbiAgfSwgb3B0aW9ucy5oZWFkZXIpO1xuXG4gIGZ1bmN0aW9uIGZhaWx1cmUoZXJyKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgaWYgKCFzZWNyZXRPclByaXZhdGVLZXkgJiYgb3B0aW9ucy5hbGdvcml0aG0gIT09ICdub25lJykge1xuICAgIHJldHVybiBmYWlsdXJlKG5ldyBFcnJvcignc2VjcmV0T3JQcml2YXRlS2V5IG11c3QgaGF2ZSBhIHZhbHVlJykpO1xuICB9XG5cbiAgaWYgKHNlY3JldE9yUHJpdmF0ZUtleSAhPSBudWxsICYmICEoc2VjcmV0T3JQcml2YXRlS2V5IGluc3RhbmNlb2YgS2V5T2JqZWN0KSkge1xuICAgIHRyeSB7XG4gICAgICBzZWNyZXRPclByaXZhdGVLZXkgPSBjcmVhdGVQcml2YXRlS2V5KHNlY3JldE9yUHJpdmF0ZUtleSlcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWNyZXRPclByaXZhdGVLZXkgPSBjcmVhdGVTZWNyZXRLZXkodHlwZW9mIHNlY3JldE9yUHJpdmF0ZUtleSA9PT0gJ3N0cmluZycgPyBCdWZmZXIuZnJvbShzZWNyZXRPclByaXZhdGVLZXkpIDogc2VjcmV0T3JQcml2YXRlS2V5KVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoJ3NlY3JldE9yUHJpdmF0ZUtleSBpcyBub3QgdmFsaWQga2V5IG1hdGVyaWFsJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoZWFkZXIuYWxnLnN0YXJ0c1dpdGgoJ0hTJykgJiYgc2VjcmV0T3JQcml2YXRlS2V5LnR5cGUgIT09ICdzZWNyZXQnKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKChgc2VjcmV0T3JQcml2YXRlS2V5IG11c3QgYmUgYSBzeW1tZXRyaWMga2V5IHdoZW4gdXNpbmcgJHtoZWFkZXIuYWxnfWApKSlcbiAgfSBlbHNlIGlmICgvXig/OlJTfFBTfEVTKS8udGVzdChoZWFkZXIuYWxnKSkge1xuICAgIGlmIChzZWNyZXRPclByaXZhdGVLZXkudHlwZSAhPT0gJ3ByaXZhdGUnKSB7XG4gICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoKGBzZWNyZXRPclByaXZhdGVLZXkgbXVzdCBiZSBhbiBhc3ltbWV0cmljIGtleSB3aGVuIHVzaW5nICR7aGVhZGVyLmFsZ31gKSkpXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd0luc2VjdXJlS2V5U2l6ZXMgJiZcbiAgICAgICFoZWFkZXIuYWxnLnN0YXJ0c1dpdGgoJ0VTJykgJiZcbiAgICAgIHNlY3JldE9yUHJpdmF0ZUtleS5hc3ltbWV0cmljS2V5RGV0YWlscyAhPT0gdW5kZWZpbmVkICYmIC8vS2V5T2JqZWN0LmFzeW1tZXRyaWNLZXlEZXRhaWxzIGlzIHN1cHBvcnRlZCBpbiBOb2RlIDE1K1xuICAgICAgc2VjcmV0T3JQcml2YXRlS2V5LmFzeW1tZXRyaWNLZXlEZXRhaWxzLm1vZHVsdXNMZW5ndGggPCAyMDQ4KSB7XG4gICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoYHNlY3JldE9yUHJpdmF0ZUtleSBoYXMgYSBtaW5pbXVtIGtleSBzaXplIG9mIDIwNDggYml0cyBmb3IgJHtoZWFkZXIuYWxnfWApKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKCdwYXlsb2FkIGlzIHJlcXVpcmVkJykpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMubXV0YXRlUGF5bG9hZCkge1xuICAgICAgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30scGF5bG9hZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGludmFsaWRfb3B0aW9ucyA9IG9wdGlvbnNfZm9yX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9uc1tvcHRdICE9PSAndW5kZWZpbmVkJztcbiAgICB9KTtcblxuICAgIGlmIChpbnZhbGlkX29wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKCdpbnZhbGlkICcgKyBpbnZhbGlkX29wdGlvbnMuam9pbignLCcpICsgJyBvcHRpb24gZm9yICcgKyAodHlwZW9mIHBheWxvYWQgKSArICcgcGF5bG9hZCcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQuZXhwICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0aW9ucy5leHBpcmVzSW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKCdCYWQgXCJvcHRpb25zLmV4cGlyZXNJblwiIG9wdGlvbiB0aGUgcGF5bG9hZCBhbHJlYWR5IGhhcyBhbiBcImV4cFwiIHByb3BlcnR5LicpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZC5uYmYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRpb25zLm5vdEJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoJ0JhZCBcIm9wdGlvbnMubm90QmVmb3JlXCIgb3B0aW9uIHRoZSBwYXlsb2FkIGFscmVhZHkgaGFzIGFuIFwibmJmXCIgcHJvcGVydHkuJykpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUoZXJyb3IpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmFsbG93SW52YWxpZEFzeW1tZXRyaWNLZXlUeXBlcykge1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0ZUFzeW1tZXRyaWNLZXkoaGVhZGVyLmFsZywgc2VjcmV0T3JQcml2YXRlS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IHBheWxvYWQuaWF0IHx8IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gIGlmIChvcHRpb25zLm5vVGltZXN0YW1wKSB7XG4gICAgZGVsZXRlIHBheWxvYWQuaWF0O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgIHBheWxvYWQuaWF0ID0gdGltZXN0YW1wO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm5vdEJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgcGF5bG9hZC5uYmYgPSB0aW1lc3BhbihvcHRpb25zLm5vdEJlZm9yZSwgdGltZXN0YW1wKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoZXJyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLm5iZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWlsdXJlKG5ldyBFcnJvcignXCJub3RCZWZvcmVcIiBzaG91bGQgYmUgYSBudW1iZXIgb2Ygc2Vjb25kcyBvciBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdGltZXNwYW4gZWc6IFwiMWRcIiwgXCIyMGhcIiwgNjAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXNJbiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQuZXhwID0gdGltZXNwYW4ob3B0aW9ucy5leHBpcmVzSW4sIHRpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWlsdXJlKGVycik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF5bG9hZC5leHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoJ1wiZXhwaXJlc0luXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMgb3Igc3RyaW5nIHJlcHJlc2VudGluZyBhIHRpbWVzcGFuIGVnOiBcIjFkXCIsIFwiMjBoXCIsIDYwJykpO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnNfdG9fcGF5bG9hZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29uc3QgY2xhaW0gPSBvcHRpb25zX3RvX3BheWxvYWRba2V5XTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZFtjbGFpbV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWlsdXJlKG5ldyBFcnJvcignQmFkIFwib3B0aW9ucy4nICsga2V5ICsgJ1wiIG9wdGlvbi4gVGhlIHBheWxvYWQgYWxyZWFkeSBoYXMgYW4gXCInICsgY2xhaW0gKyAnXCIgcHJvcGVydHkuJykpO1xuICAgICAgfVxuICAgICAgcGF5bG9hZFtjbGFpbV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIG9uY2UoY2FsbGJhY2spO1xuXG4gICAgandzLmNyZWF0ZVNpZ24oe1xuICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICBwcml2YXRlS2V5OiBzZWNyZXRPclByaXZhdGVLZXksXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nXG4gICAgfSkub25jZSgnZXJyb3InLCBjYWxsYmFjaylcbiAgICAgIC5vbmNlKCdkb25lJywgZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgaW4gZmF2b3Igb2YgdGhlIG1vZHVsdXMgbGVuZ3RoIGNoZWNrIGJlZm9yZSBzaWduaW5nIG9uY2Ugbm9kZSAxNSsgaXMgdGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb25cbiAgICAgICAgaWYoIW9wdGlvbnMuYWxsb3dJbnNlY3VyZUtleVNpemVzICYmIC9eKD86UlN8UFMpLy50ZXN0KGhlYWRlci5hbGcpICYmIHNpZ25hdHVyZS5sZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKGBzZWNyZXRPclByaXZhdGVLZXkgaGFzIGEgbWluaW11bSBrZXkgc2l6ZSBvZiAyMDQ4IGJpdHMgZm9yICR7aGVhZGVyLmFsZ31gKSlcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBzaWduYXR1cmUpO1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHNpZ25hdHVyZSA9IGp3cy5zaWduKHtoZWFkZXI6IGhlYWRlciwgcGF5bG9hZDogcGF5bG9hZCwgc2VjcmV0OiBzZWNyZXRPclByaXZhdGVLZXksIGVuY29kaW5nOiBlbmNvZGluZ30pO1xuICAgIC8vIFRPRE86IFJlbW92ZSBpbiBmYXZvciBvZiB0aGUgbW9kdWx1cyBsZW5ndGggY2hlY2sgYmVmb3JlIHNpZ25pbmcgb25jZSBub2RlIDE1KyBpcyB0aGUgbWluaW11bSBzdXBwb3J0ZWQgdmVyc2lvblxuICAgIGlmKCFvcHRpb25zLmFsbG93SW5zZWN1cmVLZXlTaXplcyAmJiAvXig/OlJTfFBTKS8udGVzdChoZWFkZXIuYWxnKSAmJiBzaWduYXR1cmUubGVuZ3RoIDwgMjU2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNlY3JldE9yUHJpdmF0ZUtleSBoYXMgYSBtaW5pbXVtIGtleSBzaXplIG9mIDIwNDggYml0cyBmb3IgJHtoZWFkZXIuYWxnfWApXG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmVcbiAgfVxufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZScpLFxuICB2ZXJpZnk6IHJlcXVpcmUoJy4vdmVyaWZ5JyksXG4gIHNpZ246IHJlcXVpcmUoJy4vc2lnbicpLFxuICBKc29uV2ViVG9rZW5FcnJvcjogcmVxdWlyZSgnLi9saWIvSnNvbldlYlRva2VuRXJyb3InKSxcbiAgTm90QmVmb3JlRXJyb3I6IHJlcXVpcmUoJy4vbGliL05vdEJlZm9yZUVycm9yJyksXG4gIFRva2VuRXhwaXJlZEVycm9yOiByZXF1aXJlKCcuL2xpYi9Ub2tlbkV4cGlyZWRFcnJvcicpLFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbGJhY2tzUmVnaXN0cnkgPSB2b2lkIDA7XG5jbGFzcyBDYWxsYmFja3NSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmV4dElkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0lkcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb25JbmZvID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgYWRkKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayBpcyBhbHJlYWR5IGFkZGVkLlxuICAgICAgICBsZXQgaWQgPSB0aGlzLmNhbGxiYWNrSWRzLmdldChjYWxsYmFjayk7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICBpZCA9IHRoaXMubmV4dElkICs9IDE7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmNhbGxiYWNrSWRzLnNldChjYWxsYmFjaywgaWQpO1xuICAgICAgICAvLyBDYXB0dXJlIHRoZSBsb2NhdGlvbiBvZiB0aGUgZnVuY3Rpb24gYW5kIHB1dCBpdCBpbiB0aGUgSUQgc3RyaW5nLFxuICAgICAgICAvLyBzbyB0aGF0IHJlbGVhc2UgZXJyb3JzIGNhbiBiZSB0cmFja2VkIGRvd24gZWFzaWx5LlxuICAgICAgICBjb25zdCByZWdleHAgPSAvYXQgKC4qKS9naTtcbiAgICAgICAgY29uc3Qgc3RhY2tTdHJpbmcgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgICAgICBpZiAoIXN0YWNrU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICBsZXQgZmlsZW5hbWVBbmRMaW5lO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleHAuZXhlYyhzdGFja1N0cmluZykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uLmluY2x1ZGVzKCcobmF0aXZlKScpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uLmluY2x1ZGVzKCcoPGFub255bW91cz4pJykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24uaW5jbHVkZXMoJ2NhbGxiYWNrcy1yZWdpc3RyeS5qcycpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uLmluY2x1ZGVzKCdyZW1vdGUuanMnKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbi5pbmNsdWRlcygnQGVsZWN0cm9uL3JlbW90ZS9kaXN0JykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCByZWYgPSAvKFteL14pXSopXFwpPyQvZ2kuZXhlYyhsb2NhdGlvbik7XG4gICAgICAgICAgICBpZiAocmVmKVxuICAgICAgICAgICAgICAgIGZpbGVuYW1lQW5kTGluZSA9IHJlZlsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYXRpb25JbmZvLnNldChjYWxsYmFjaywgZmlsZW5hbWVBbmRMaW5lKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBnZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tzW2lkXSB8fCBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIGdldExvY2F0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uSW5mby5nZXQoY2FsbGJhY2spO1xuICAgIH1cbiAgICBhcHBseShpZCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoaWQpLmFwcGx5KGdsb2JhbCwgLi4uYXJncyk7XG4gICAgfVxuICAgIHJlbW92ZShpZCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2lkXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrSWRzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbaWRdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsYmFja3NSZWdpc3RyeSA9IENhbGxiYWNrc1JlZ2lzdHJ5O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5pc1NlcmlhbGl6YWJsZU9iamVjdCA9IGV4cG9ydHMuaXNQcm9taXNlID0gdm9pZCAwO1xuY29uc3QgZWxlY3Ryb25fMSA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKTtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgICByZXR1cm4gKHZhbCAmJlxuICAgICAgICB2YWwudGhlbiAmJlxuICAgICAgICB2YWwudGhlbiBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmXG4gICAgICAgIHZhbC5jb25zdHJ1Y3RvciAmJlxuICAgICAgICB2YWwuY29uc3RydWN0b3IucmVqZWN0ICYmXG4gICAgICAgIHZhbC5jb25zdHJ1Y3Rvci5yZWplY3QgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJlxuICAgICAgICB2YWwuY29uc3RydWN0b3IucmVzb2x2ZSAmJlxuICAgICAgICB2YWwuY29uc3RydWN0b3IucmVzb2x2ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuY29uc3Qgc2VyaWFsaXphYmxlVHlwZXMgPSBbXG4gICAgQm9vbGVhbixcbiAgICBOdW1iZXIsXG4gICAgU3RyaW5nLFxuICAgIERhdGUsXG4gICAgRXJyb3IsXG4gICAgUmVnRXhwLFxuICAgIEFycmF5QnVmZmVyXG5dO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSNTdXBwb3J0ZWRfdHlwZXNcbmZ1bmN0aW9uIGlzU2VyaWFsaXphYmxlT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHwgc2VyaWFsaXphYmxlVHlwZXMuc29tZSh0eXBlID0+IHZhbHVlIGluc3RhbmNlb2YgdHlwZSk7XG59XG5leHBvcnRzLmlzU2VyaWFsaXphYmxlT2JqZWN0ID0gaXNTZXJpYWxpemFibGVPYmplY3Q7XG5jb25zdCBvYmplY3RNYXAgPSBmdW5jdGlvbiAoc291cmNlLCBtYXBwZXIpIHtcbiAgICBjb25zdCBzb3VyY2VFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc291cmNlKTtcbiAgICBjb25zdCB0YXJnZXRFbnRyaWVzID0gc291cmNlRW50cmllcy5tYXAoKFtrZXksIHZhbF0pID0+IFtrZXksIG1hcHBlcih2YWwpXSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0YXJnZXRFbnRyaWVzKTtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVOYXRpdmVJbWFnZShpbWFnZSkge1xuICAgIGNvbnN0IHJlcHJlc2VudGF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9ycyA9IGltYWdlLmdldFNjYWxlRmFjdG9ycygpO1xuICAgIC8vIFVzZSBCdWZmZXIgd2hlbiB0aGVyZSdzIG9ubHkgb25lIHJlcHJlc2VudGF0aW9uIGZvciBiZXR0ZXIgcGVyZi5cbiAgICAvLyBUaGlzIGF2b2lkcyBjb21wcmVzc2luZyB0by9mcm9tIFBORyB3aGVyZSBpdCdzIG5vdCBuZWNlc3NhcnkgdG9cbiAgICAvLyBlbnN1cmUgdW5pcXVlbmVzcyBvZiBkYXRhVVJMcyAoc2luY2UgdGhlcmUncyBvbmx5IG9uZSkuXG4gICAgaWYgKHNjYWxlRmFjdG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcnNbMF07XG4gICAgICAgIGNvbnN0IHNpemUgPSBpbWFnZS5nZXRTaXplKHNjYWxlRmFjdG9yKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gaW1hZ2UudG9CaXRtYXAoeyBzY2FsZUZhY3RvciB9KTtcbiAgICAgICAgcmVwcmVzZW50YXRpb25zLnB1c2goeyBzY2FsZUZhY3Rvciwgc2l6ZSwgYnVmZmVyIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gZGF0YVVSTHMgdG8gZW5zdXJlIHRoYXQgdGhleSBhcmUgbm90IGxvc3QgaW4gY3JlYXRpb24uXG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVGYWN0b3Igb2Ygc2NhbGVGYWN0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gaW1hZ2UuZ2V0U2l6ZShzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgICBjb25zdCBkYXRhVVJMID0gaW1hZ2UudG9EYXRhVVJMKHsgc2NhbGVGYWN0b3IgfSk7XG4gICAgICAgICAgICByZXByZXNlbnRhdGlvbnMucHVzaCh7IHNjYWxlRmFjdG9yLCBzaXplLCBkYXRhVVJMIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IF9fRUxFQ1RST05fU0VSSUFMSVpFRF9OYXRpdmVJbWFnZV9fOiB0cnVlLCByZXByZXNlbnRhdGlvbnMgfTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplTmF0aXZlSW1hZ2UodmFsdWUpIHtcbiAgICBjb25zdCBpbWFnZSA9IGVsZWN0cm9uXzEubmF0aXZlSW1hZ2UuY3JlYXRlRW1wdHkoKTtcbiAgICAvLyBVc2UgQnVmZmVyIHdoZW4gdGhlcmUncyBvbmx5IG9uZSByZXByZXNlbnRhdGlvbiBmb3IgYmV0dGVyIHBlcmYuXG4gICAgLy8gVGhpcyBhdm9pZHMgY29tcHJlc3NpbmcgdG8vZnJvbSBQTkcgd2hlcmUgaXQncyBub3QgbmVjZXNzYXJ5IHRvXG4gICAgLy8gZW5zdXJlIHVuaXF1ZW5lc3Mgb2YgZGF0YVVSTHMgKHNpbmNlIHRoZXJlJ3Mgb25seSBvbmUpLlxuICAgIGlmICh2YWx1ZS5yZXByZXNlbnRhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBzaXplLCBzY2FsZUZhY3RvciB9ID0gdmFsdWUucmVwcmVzZW50YXRpb25zWzBdO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNpemU7XG4gICAgICAgIGltYWdlLmFkZFJlcHJlc2VudGF0aW9uKHsgYnVmZmVyLCBzY2FsZUZhY3Rvciwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCBmcm9tIGRhdGFVUkxzIHRvIGVuc3VyZSB0aGF0IHRoZXkgYXJlIG5vdCBsb3N0IGluIGNyZWF0aW9uLlxuICAgICAgICBmb3IgKGNvbnN0IHJlcCBvZiB2YWx1ZS5yZXByZXNlbnRhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YVVSTCwgc2l6ZSwgc2NhbGVGYWN0b3IgfSA9IHJlcDtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2l6ZTtcbiAgICAgICAgICAgIGltYWdlLmFkZFJlcHJlc2VudGF0aW9uKHsgZGF0YVVSTCwgc2NhbGVGYWN0b3IsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdOYXRpdmVJbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU5hdGl2ZUltYWdlKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoc2VyaWFsaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZXJpYWxpemFibGVPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdE1hcCh2YWx1ZSwgc2VyaWFsaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLl9fRUxFQ1RST05fU0VSSUFMSVpFRF9OYXRpdmVJbWFnZV9fKSB7XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZU5hdGl2ZUltYWdlKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChkZXNlcmlhbGl6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2VyaWFsaXphYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3RNYXAodmFsdWUsIGRlc2VyaWFsaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVsZWN0cm9uQmluZGluZyA9IHZvaWQgMDtcbmNvbnN0IGdldEVsZWN0cm9uQmluZGluZyA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuX2xpbmtlZEJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuX2xpbmtlZEJpbmRpbmcoJ2VsZWN0cm9uX2NvbW1vbl8nICsgbmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZWxlY3Ryb25CaW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVsZWN0cm9uQmluZGluZyhuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLmdldEVsZWN0cm9uQmluZGluZyA9IGdldEVsZWN0cm9uQmluZGluZztcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfYSwgX2I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJyb3dzZXJNb2R1bGVOYW1lcyA9IGV4cG9ydHMuY29tbW9uTW9kdWxlTmFtZXMgPSB2b2lkIDA7XG5jb25zdCBnZXRfZWxlY3Ryb25fYmluZGluZ18xID0gcmVxdWlyZShcIi4vZ2V0LWVsZWN0cm9uLWJpbmRpbmdcIik7XG5leHBvcnRzLmNvbW1vbk1vZHVsZU5hbWVzID0gW1xuICAgICdjbGlwYm9hcmQnLFxuICAgICduYXRpdmVJbWFnZScsXG4gICAgJ3NoZWxsJyxcbl07XG5leHBvcnRzLmJyb3dzZXJNb2R1bGVOYW1lcyA9IFtcbiAgICAnYXBwJyxcbiAgICAnYXV0b1VwZGF0ZXInLFxuICAgICdCYXNlV2luZG93JyxcbiAgICAnQnJvd3NlclZpZXcnLFxuICAgICdCcm93c2VyV2luZG93JyxcbiAgICAnY29udGVudFRyYWNpbmcnLFxuICAgICdjcmFzaFJlcG9ydGVyJyxcbiAgICAnZGlhbG9nJyxcbiAgICAnZ2xvYmFsU2hvcnRjdXQnLFxuICAgICdpcGNNYWluJyxcbiAgICAnaW5BcHBQdXJjaGFzZScsXG4gICAgJ01lbnUnLFxuICAgICdNZW51SXRlbScsXG4gICAgJ25hdGl2ZVRoZW1lJyxcbiAgICAnbmV0JyxcbiAgICAnbmV0TG9nJyxcbiAgICAnTWVzc2FnZUNoYW5uZWxNYWluJyxcbiAgICAnTm90aWZpY2F0aW9uJyxcbiAgICAncG93ZXJNb25pdG9yJyxcbiAgICAncG93ZXJTYXZlQmxvY2tlcicsXG4gICAgJ3Byb3RvY29sJyxcbiAgICAncHVzaE5vdGlmaWNhdGlvbnMnLFxuICAgICdzYWZlU3RvcmFnZScsXG4gICAgJ3NjcmVlbicsXG4gICAgJ3Nlc3Npb24nLFxuICAgICdTaGFyZU1lbnUnLFxuICAgICdzeXN0ZW1QcmVmZXJlbmNlcycsXG4gICAgJ1RvcExldmVsV2luZG93JyxcbiAgICAnVG91Y2hCYXInLFxuICAgICdUcmF5JyxcbiAgICAndXRpbGl0eVByb2Nlc3MnLFxuICAgICdWaWV3JyxcbiAgICAnd2ViQ29udGVudHMnLFxuICAgICdXZWJDb250ZW50c1ZpZXcnLFxuICAgICd3ZWJGcmFtZU1haW4nLFxuXS5jb25jYXQoZXhwb3J0cy5jb21tb25Nb2R1bGVOYW1lcyk7XG5jb25zdCBmZWF0dXJlcyA9IGdldF9lbGVjdHJvbl9iaW5kaW5nXzEuZ2V0RWxlY3Ryb25CaW5kaW5nKCdmZWF0dXJlcycpO1xuaWYgKCgoX2EgPSBmZWF0dXJlcyA9PT0gbnVsbCB8fCBmZWF0dXJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVhdHVyZXMuaXNEZXNrdG9wQ2FwdHVyZXJFbmFibGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChmZWF0dXJlcykpICE9PSBmYWxzZSkge1xuICAgIGV4cG9ydHMuYnJvd3Nlck1vZHVsZU5hbWVzLnB1c2goJ2Rlc2t0b3BDYXB0dXJlcicpO1xufVxuaWYgKCgoX2IgPSBmZWF0dXJlcyA9PT0gbnVsbCB8fCBmZWF0dXJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVhdHVyZXMuaXNWaWV3QXBpRW5hYmxlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoZmVhdHVyZXMpKSAhPT0gZmFsc2UpIHtcbiAgICBleHBvcnRzLmJyb3dzZXJNb2R1bGVOYW1lcy5wdXNoKCdJbWFnZVZpZXcnKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRnVuY3Rpb25XaXRoUmV0dXJuVmFsdWUgPSBleHBvcnRzLmdldEdsb2JhbCA9IGV4cG9ydHMuZ2V0Q3VycmVudFdlYkNvbnRlbnRzID0gZXhwb3J0cy5nZXRDdXJyZW50V2luZG93ID0gZXhwb3J0cy5nZXRCdWlsdGluID0gdm9pZCAwO1xuY29uc3QgY2FsbGJhY2tzX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9jYWxsYmFja3MtcmVnaXN0cnlcIik7XG5jb25zdCB0eXBlX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3R5cGUtdXRpbHNcIik7XG5jb25zdCBlbGVjdHJvbl8xID0gcmVxdWlyZShcImVsZWN0cm9uXCIpO1xuY29uc3QgbW9kdWxlX25hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL21vZHVsZS1uYW1lc1wiKTtcbmNvbnN0IGdldF9lbGVjdHJvbl9iaW5kaW5nXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dldC1lbGVjdHJvbi1iaW5kaW5nXCIpO1xuY29uc3QgeyBQcm9taXNlIH0gPSBnbG9iYWw7XG5jb25zdCBjYWxsYmFja3NSZWdpc3RyeSA9IG5ldyBjYWxsYmFja3NfcmVnaXN0cnlfMS5DYWxsYmFja3NSZWdpc3RyeSgpO1xuY29uc3QgcmVtb3RlT2JqZWN0Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBmaW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoaWQpID0+IHtcbiAgICBjb25zdCByZWYgPSByZW1vdGVPYmplY3RDYWNoZS5nZXQoaWQpO1xuICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCAmJiByZWYuZGVyZWYoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbW90ZU9iamVjdENhY2hlLmRlbGV0ZShpZCk7XG4gICAgICAgIGVsZWN0cm9uXzEuaXBjUmVuZGVyZXIuc2VuZChcIlJFTU9URV9CUk9XU0VSX0RFUkVGRVJFTkNFXCIgLyogQlJPV1NFUl9ERVJFRkVSRU5DRSAqLywgY29udGV4dElkLCBpZCwgMCk7XG4gICAgfVxufSk7XG5jb25zdCBlbGVjdHJvbklkcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpc1JldHVyblZhbHVlID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGdldENhY2hlZFJlbW90ZU9iamVjdChpZCkge1xuICAgIGNvbnN0IHJlZiA9IHJlbW90ZU9iamVjdENhY2hlLmdldChpZCk7XG4gICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlcmVmID0gcmVmLmRlcmVmKCk7XG4gICAgICAgIGlmIChkZXJlZiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRlcmVmO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldENhY2hlZFJlbW90ZU9iamVjdChpZCwgdmFsdWUpIHtcbiAgICBjb25zdCB3ciA9IG5ldyBXZWFrUmVmKHZhbHVlKTtcbiAgICByZW1vdGVPYmplY3RDYWNoZS5zZXQoaWQsIHdyKTtcbiAgICBmaW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3Rlcih2YWx1ZSwgaWQpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHRJZCgpIHtcbiAgICBjb25zdCB2OFV0aWwgPSBnZXRfZWxlY3Ryb25fYmluZGluZ18xLmdldEVsZWN0cm9uQmluZGluZygndjhfdXRpbCcpO1xuICAgIGlmICh2OFV0aWwpIHtcbiAgICAgICAgcmV0dXJuIHY4VXRpbC5nZXRIaWRkZW5WYWx1ZShnbG9iYWwsICdjb250ZXh0SWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlY3Ryb24gPj12MTMuMC4wLWJldGEuNiByZXF1aXJlZCB0byBzdXBwb3J0IHNhbmRib3hlZCByZW5kZXJlcnMnKTtcbiAgICB9XG59XG4vLyBBbiB1bmlxdWUgSUQgdGhhdCBjYW4gcmVwcmVzZW50IGN1cnJlbnQgY29udGV4dC5cbmNvbnN0IGNvbnRleHRJZCA9IHByb2Nlc3MuY29udGV4dElkIHx8IGdldENvbnRleHRJZCgpO1xuLy8gTm90aWZ5IHRoZSBtYWluIHByb2Nlc3Mgd2hlbiBjdXJyZW50IGNvbnRleHQgaXMgZ29pbmcgdG8gYmUgcmVsZWFzZWQuXG4vLyBOb3RlIHRoYXQgd2hlbiB0aGUgcmVuZGVyZXIgcHJvY2VzcyBpcyBkZXN0cm95ZWQsIHRoZSBtZXNzYWdlIG1heSBub3QgYmVcbi8vIHNlbnQsIHdlIGFsc28gbGlzdGVuIHRvIHRoZSBcInJlbmRlci12aWV3LWRlbGV0ZWRcIiBldmVudCBpbiB0aGUgbWFpbiBwcm9jZXNzXG4vLyB0byBndWFyZCB0aGF0IHNpdHVhdGlvbi5cbnByb2Nlc3Mub24oJ2V4aXQnLCAoKSA9PiB7XG4gICAgY29uc3QgY29tbWFuZCA9IFwiUkVNT1RFX0JST1dTRVJfQ09OVEVYVF9SRUxFQVNFXCIgLyogQlJPV1NFUl9DT05URVhUX1JFTEVBU0UgKi87XG4gICAgZWxlY3Ryb25fMS5pcGNSZW5kZXJlci5zZW5kKGNvbW1hbmQsIGNvbnRleHRJZCk7XG59KTtcbmNvbnN0IElTX1JFTU9URV9QUk9YWSA9IFN5bWJvbCgnaXMtcmVtb3RlLXByb3h5Jyk7XG4vLyBDb252ZXJ0IHRoZSBhcmd1bWVudHMgb2JqZWN0IGludG8gYW4gYXJyYXkgb2YgbWV0YSBkYXRhLlxuZnVuY3Rpb24gd3JhcEFyZ3MoYXJncywgdmlzaXRlZCA9IG5ldyBTZXQoKSkge1xuICAgIGNvbnN0IHZhbHVlVG9NZXRhID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2UuXG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gJ05hdGl2ZUltYWdlJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZWltYWdlJywgdmFsdWU6IHR5cGVfdXRpbHNfMS5zZXJpYWxpemUodmFsdWUpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogd3JhcEFyZ3ModmFsdWUsIHZpc2l0ZWQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmlzaXRlZC5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2J1ZmZlcicsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZV91dGlsc18xLmlzU2VyaWFsaXphYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlX3V0aWxzXzEuaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwcm9taXNlJyxcbiAgICAgICAgICAgICAgICAgICAgdGhlbjogdmFsdWVUb01ldGEoZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlY3Ryb25JZHMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZW1vdGUtb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGVsZWN0cm9uSWRzLmdldCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBuYW1lOiB2YWx1ZS5jb25zdHJ1Y3RvciA/IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgOiAnJyxcbiAgICAgICAgICAgICAgICBtZW1iZXJzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB2YWx1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgICAgIG1ldGEubWVtYmVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVG9NZXRhKHZhbHVlW3Byb3BdKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlzaXRlZC5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIGlzUmV0dXJuVmFsdWUuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24td2l0aC1yZXR1cm4tdmFsdWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVRvTWV0YSh2YWx1ZSgpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBpZDogY2FsbGJhY2tzUmVnaXN0cnkuYWRkKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogY2FsbGJhY2tzUmVnaXN0cnkuZ2V0TG9jYXRpb24odmFsdWUpLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXJncy5tYXAodmFsdWVUb01ldGEpO1xufVxuLy8gUG9wdWxhdGUgb2JqZWN0J3MgbWVtYmVycyBmcm9tIGRlc2NyaXB0b3JzLlxuLy8gVGhlIHxyZWZ8IHdpbGwgYmUga2VwdCByZWZlcmVuY2VkIGJ5IHxtZW1iZXJzfC5cbi8vIFRoaXMgbWF0Y2hlcyB8Z2V0T2JqZWN0TWVtZWJlcnN8IGluIHJwYy1zZXJ2ZXIuXG5mdW5jdGlvbiBzZXRPYmplY3RNZW1iZXJzKHJlZiwgb2JqZWN0LCBtZXRhSWQsIG1lbWJlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVtYmVycykpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBtZW1iZXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBtZW1iZXIubmFtZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogbWVtYmVyLmVudW1lcmFibGUgfTtcbiAgICAgICAgaWYgKG1lbWJlci50eXBlID09PSAnbWV0aG9kJykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlTWVtYmVyRnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMuY29uc3RydWN0b3IgPT09IHJlbW90ZU1lbWJlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBcIlJFTU9URV9CUk9XU0VSX01FTUJFUl9DT05TVFJVQ1RPUlwiIC8qIEJST1dTRVJfTUVNQkVSX0NPTlNUUlVDVE9SICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IFwiUkVNT1RFX0JST1dTRVJfTUVNQkVSX0NBTExcIiAvKiBCUk9XU0VSX01FTUJFUl9DQUxMICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBlbGVjdHJvbl8xLmlwY1JlbmRlcmVyLnNlbmRTeW5jKGNvbW1hbmQsIGNvbnRleHRJZCwgbWV0YUlkLCBtZW1iZXIubmFtZSwgd3JhcEFyZ3MoYXJncykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhVG9WYWx1ZShyZXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkZXNjcmlwdG9yRnVuY3Rpb24gPSBwcm94eUZ1bmN0aW9uUHJvcGVydGllcyhyZW1vdGVNZW1iZXJGdW5jdGlvbiwgbWV0YUlkLCBtZW1iZXIubmFtZSk7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yRnVuY3Rpb24ucmVmID0gcmVmOyAvLyBUaGUgbWVtYmVyIHNob3VsZCByZWZlcmVuY2UgaXRzIG9iamVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvckZ1bmN0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBtb25rZXktcGF0Y2ggdGhlIG1ldGhvZFxuICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yRnVuY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lbWJlci50eXBlID09PSAnZ2V0Jykge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IFwiUkVNT1RFX0JST1dTRVJfTUVNQkVSX0dFVFwiIC8qIEJST1dTRVJfTUVNQkVSX0dFVCAqLztcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gZWxlY3Ryb25fMS5pcGNSZW5kZXJlci5zZW5kU3luYyhjb21tYW5kLCBjb250ZXh0SWQsIG1ldGFJZCwgbWVtYmVyLm5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhVG9WYWx1ZShtZXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobWVtYmVyLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHdyYXBBcmdzKFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kID0gXCJSRU1PVEVfQlJPV1NFUl9NRU1CRVJfU0VUXCIgLyogQlJPV1NFUl9NRU1CRVJfU0VUICovO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gZWxlY3Ryb25fMS5pcGNSZW5kZXJlci5zZW5kU3luYyhjb21tYW5kLCBjb250ZXh0SWQsIG1ldGFJZCwgbWVtYmVyLm5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVRvVmFsdWUobWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG1lbWJlci5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG4vLyBQb3B1bGF0ZSBvYmplY3QncyBwcm90b3R5cGUgZnJvbSBkZXNjcmlwdG9yLlxuLy8gVGhpcyBtYXRjaGVzIHxnZXRPYmplY3RQcm90b3R5cGV8IGluIHJwYy1zZXJ2ZXIuXG5mdW5jdGlvbiBzZXRPYmplY3RQcm90b3R5cGUocmVmLCBvYmplY3QsIG1ldGFJZCwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcHJvdG8gPSB7fTtcbiAgICBzZXRPYmplY3RNZW1iZXJzKHJlZiwgcHJvdG8sIG1ldGFJZCwgZGVzY3JpcHRvci5tZW1iZXJzKTtcbiAgICBzZXRPYmplY3RQcm90b3R5cGUocmVmLCBwcm90bywgbWV0YUlkLCBkZXNjcmlwdG9yLnByb3RvKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqZWN0LCBwcm90byk7XG59XG4vLyBXcmFwIGZ1bmN0aW9uIGluIFByb3h5IGZvciBhY2Nlc3NpbmcgcmVtb3RlIHByb3BlcnRpZXNcbmZ1bmN0aW9uIHByb3h5RnVuY3Rpb25Qcm9wZXJ0aWVzKHJlbW90ZU1lbWJlckZ1bmN0aW9uLCBtZXRhSWQsIG5hbWUpIHtcbiAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgLy8gTGF6aWx5IGxvYWQgZnVuY3Rpb24gcHJvcGVydGllc1xuICAgIGNvbnN0IGxvYWRSZW1vdGVQcm9wZXJ0aWVzID0gKCkgPT4ge1xuICAgICAgICBpZiAobG9hZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBjb21tYW5kID0gXCJSRU1PVEVfQlJPV1NFUl9NRU1CRVJfR0VUXCIgLyogQlJPV1NFUl9NRU1CRVJfR0VUICovO1xuICAgICAgICBjb25zdCBtZXRhID0gZWxlY3Ryb25fMS5pcGNSZW5kZXJlci5zZW5kU3luYyhjb21tYW5kLCBjb250ZXh0SWQsIG1ldGFJZCwgbmFtZSk7XG4gICAgICAgIHNldE9iamVjdE1lbWJlcnMocmVtb3RlTWVtYmVyRnVuY3Rpb24sIHJlbW90ZU1lbWJlckZ1bmN0aW9uLCBtZXRhLmlkLCBtZXRhLm1lbWJlcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm94eShyZW1vdGVNZW1iZXJGdW5jdGlvbiwge1xuICAgICAgICBzZXQ6ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAncmVmJylcbiAgICAgICAgICAgICAgICBsb2FkUmVtb3RlUHJvcGVydGllcygpO1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogKHRhcmdldCwgcHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gSVNfUkVNT1RFX1BST1hZKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wZXJ0eSkpXG4gICAgICAgICAgICAgICAgbG9hZFJlbW90ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3RvU3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBsb2FkUmVtb3RlUHJvcGVydGllcygpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogKHRhcmdldCwgcHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICBsb2FkUmVtb3RlUHJvcGVydGllcygpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIENvbnZlcnQgbWV0YSBkYXRhIGZyb20gYnJvd3NlciBpbnRvIHJlYWwgdmFsdWUuXG5mdW5jdGlvbiBtZXRhVG9WYWx1ZShtZXRhKSB7XG4gICAgaWYgKCFtZXRhKVxuICAgICAgICByZXR1cm4ge307XG4gICAgaWYgKG1ldGEudHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICByZXR1cm4gbWV0YS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBtZXRhLm1lbWJlcnMubWFwKChtZW1iZXIpID0+IG1ldGFUb1ZhbHVlKG1lbWJlcikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXRhLnR5cGUgPT09ICduYXRpdmVpbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVfdXRpbHNfMS5kZXNlcmlhbGl6ZShtZXRhLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS50eXBlID09PSAnYnVmZmVyJykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obWV0YS52YWx1ZS5idWZmZXIsIG1ldGEudmFsdWUuYnl0ZU9mZnNldCwgbWV0YS52YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS50eXBlID09PSAncHJvbWlzZScpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHRoZW46IG1ldGFUb1ZhbHVlKG1ldGEudGhlbikgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICByZXR1cm4gbWV0YVRvRXJyb3IobWV0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEudHlwZSA9PT0gJ2V4Y2VwdGlvbicpIHtcbiAgICAgICAgaWYgKG1ldGEudmFsdWUudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgbWV0YVRvRXJyb3IobWV0YS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBpbiBleGNlcHRpb246ICR7bWV0YS52YWx1ZS50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBpZiAoJ2lkJyBpbiBtZXRhKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBnZXRDYWNoZWRSZW1vdGVPYmplY3QobWV0YS5pZCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEEgc2hhZG93IGNsYXNzIHRvIHJlcHJlc2VudCB0aGUgcmVtb3RlIGZ1bmN0aW9uIG9iamVjdC5cbiAgICAgICAgaWYgKG1ldGEudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlRnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMuY29uc3RydWN0b3IgPT09IHJlbW90ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBcIlJFTU9URV9CUk9XU0VSX0NPTlNUUlVDVE9SXCIgLyogQlJPV1NFUl9DT05TVFJVQ1RPUiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBcIlJFTU9URV9CUk9XU0VSX0ZVTkNUSU9OX0NBTExcIiAvKiBCUk9XU0VSX0ZVTkNUSU9OX0NBTEwgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IGVsZWN0cm9uXzEuaXBjUmVuZGVyZXIuc2VuZFN5bmMoY29tbWFuZCwgY29udGV4dElkLCBtZXRhLmlkLCB3cmFwQXJncyhhcmdzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFUb1ZhbHVlKG9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0ID0gcmVtb3RlRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBzZXRPYmplY3RNZW1iZXJzKHJldCwgcmV0LCBtZXRhLmlkLCBtZXRhLm1lbWJlcnMpO1xuICAgICAgICBzZXRPYmplY3RQcm90b3R5cGUocmV0LCByZXQsIG1ldGEuaWQsIG1ldGEucHJvdG8pO1xuICAgICAgICBpZiAocmV0LmNvbnN0cnVjdG9yICYmIHJldC5jb25zdHJ1Y3RvcltJU19SRU1PVEVfUFJPWFldKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LmNvbnN0cnVjdG9yLCAnbmFtZScsIHsgdmFsdWU6IG1ldGEubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFjayBkZWxlZ2F0ZSBvYmoncyBsaWZldGltZSAmIHRlbGwgYnJvd3NlciB0byBjbGVhbiB1cCB3aGVuIG9iamVjdCBpcyBHQ2VkLlxuICAgICAgICBlbGVjdHJvbklkcy5zZXQocmV0LCBtZXRhLmlkKTtcbiAgICAgICAgc2V0Q2FjaGVkUmVtb3RlT2JqZWN0KG1ldGEuaWQsIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbWV0YVRvRXJyb3IobWV0YSkge1xuICAgIGNvbnN0IG9iaiA9IG1ldGEudmFsdWU7XG4gICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgbWV0YS5tZW1iZXJzKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IG1ldGFUb1ZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGhhc1NlbmRlcklkKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dC5zZW5kZXJJZCA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoY2hhbm5lbCwgaGFuZGxlcikge1xuICAgIGVsZWN0cm9uXzEuaXBjUmVuZGVyZXIub24oY2hhbm5lbCwgKGV2ZW50LCBwYXNzZWRDb250ZXh0SWQsIGlkLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChoYXNTZW5kZXJJZChldmVudCkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zZW5kZXJJZCAhPT0gMCAmJiBldmVudC5zZW5kZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTWVzc2FnZSAke2NoYW5uZWx9IHNlbnQgYnkgdW5leHBlY3RlZCBXZWJDb250ZW50cyAoJHtldmVudC5zZW5kZXJJZH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXNzZWRDb250ZXh0SWQgPT09IGNvbnRleHRJZCkge1xuICAgICAgICAgICAgaGFuZGxlcihpZCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNZXNzYWdlIHNlbnQgdG8gYW4gdW4tZXhpc3QgY29udGV4dCwgbm90aWZ5IHRoZSBlcnJvciB0byBtYWluIHByb2Nlc3MuXG4gICAgICAgICAgICBlbGVjdHJvbl8xLmlwY1JlbmRlcmVyLnNlbmQoXCJSRU1PVEVfQlJPV1NFUl9XUk9OR19DT05URVhUX0VSUk9SXCIgLyogQlJPV1NFUl9XUk9OR19DT05URVhUX0VSUk9SICovLCBjb250ZXh0SWQsIHBhc3NlZENvbnRleHRJZCwgaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBlbmFibGVTdGFja3MgPSBwcm9jZXNzLmFyZ3YuaW5jbHVkZXMoJy0tZW5hYmxlLWFwaS1maWx0ZXJpbmctbG9nZ2luZycpO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFN0YWNrKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHsgc3RhY2s6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChlbmFibGVTdGFja3MpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBnZXRDdXJyZW50U3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LnN0YWNrO1xufVxuLy8gQnJvd3NlciBjYWxscyBhIGNhbGxiYWNrIGluIHJlbmRlcmVyLlxuaGFuZGxlTWVzc2FnZShcIlJFTU9URV9SRU5ERVJFUl9DQUxMQkFDS1wiIC8qIFJFTkRFUkVSX0NBTExCQUNLICovLCAoaWQsIGFyZ3MpID0+IHtcbiAgICBjYWxsYmFja3NSZWdpc3RyeS5hcHBseShpZCwgbWV0YVRvVmFsdWUoYXJncykpO1xufSk7XG4vLyBBIGNhbGxiYWNrIGluIGJyb3dzZXIgaXMgcmVsZWFzZWQuXG5oYW5kbGVNZXNzYWdlKFwiUkVNT1RFX1JFTkRFUkVSX1JFTEVBU0VfQ0FMTEJBQ0tcIiAvKiBSRU5ERVJFUl9SRUxFQVNFX0NBTExCQUNLICovLCAoaWQpID0+IHtcbiAgICBjYWxsYmFja3NSZWdpc3RyeS5yZW1vdmUoaWQpO1xufSk7XG5leHBvcnRzLnJlcXVpcmUgPSAobW9kdWxlKSA9PiB7XG4gICAgY29uc3QgY29tbWFuZCA9IFwiUkVNT1RFX0JST1dTRVJfUkVRVUlSRVwiIC8qIEJST1dTRVJfUkVRVUlSRSAqLztcbiAgICBjb25zdCBtZXRhID0gZWxlY3Ryb25fMS5pcGNSZW5kZXJlci5zZW5kU3luYyhjb21tYW5kLCBjb250ZXh0SWQsIG1vZHVsZSwgZ2V0Q3VycmVudFN0YWNrKCkpO1xuICAgIHJldHVybiBtZXRhVG9WYWx1ZShtZXRhKTtcbn07XG4vLyBBbGlhcyB0byByZW1vdGUucmVxdWlyZSgnZWxlY3Ryb24nKS54eHguXG5mdW5jdGlvbiBnZXRCdWlsdGluKG1vZHVsZSkge1xuICAgIGNvbnN0IGNvbW1hbmQgPSBcIlJFTU9URV9CUk9XU0VSX0dFVF9CVUlMVElOXCIgLyogQlJPV1NFUl9HRVRfQlVJTFRJTiAqLztcbiAgICBjb25zdCBtZXRhID0gZWxlY3Ryb25fMS5pcGNSZW5kZXJlci5zZW5kU3luYyhjb21tYW5kLCBjb250ZXh0SWQsIG1vZHVsZSwgZ2V0Q3VycmVudFN0YWNrKCkpO1xuICAgIHJldHVybiBtZXRhVG9WYWx1ZShtZXRhKTtcbn1cbmV4cG9ydHMuZ2V0QnVpbHRpbiA9IGdldEJ1aWx0aW47XG5mdW5jdGlvbiBnZXRDdXJyZW50V2luZG93KCkge1xuICAgIGNvbnN0IGNvbW1hbmQgPSBcIlJFTU9URV9CUk9XU0VSX0dFVF9DVVJSRU5UX1dJTkRPV1wiIC8qIEJST1dTRVJfR0VUX0NVUlJFTlRfV0lORE9XICovO1xuICAgIGNvbnN0IG1ldGEgPSBlbGVjdHJvbl8xLmlwY1JlbmRlcmVyLnNlbmRTeW5jKGNvbW1hbmQsIGNvbnRleHRJZCwgZ2V0Q3VycmVudFN0YWNrKCkpO1xuICAgIHJldHVybiBtZXRhVG9WYWx1ZShtZXRhKTtcbn1cbmV4cG9ydHMuZ2V0Q3VycmVudFdpbmRvdyA9IGdldEN1cnJlbnRXaW5kb3c7XG4vLyBHZXQgY3VycmVudCBXZWJDb250ZW50cyBvYmplY3QuXG5mdW5jdGlvbiBnZXRDdXJyZW50V2ViQ29udGVudHMoKSB7XG4gICAgY29uc3QgY29tbWFuZCA9IFwiUkVNT1RFX0JST1dTRVJfR0VUX0NVUlJFTlRfV0VCX0NPTlRFTlRTXCIgLyogQlJPV1NFUl9HRVRfQ1VSUkVOVF9XRUJfQ09OVEVOVFMgKi87XG4gICAgY29uc3QgbWV0YSA9IGVsZWN0cm9uXzEuaXBjUmVuZGVyZXIuc2VuZFN5bmMoY29tbWFuZCwgY29udGV4dElkLCBnZXRDdXJyZW50U3RhY2soKSk7XG4gICAgcmV0dXJuIG1ldGFUb1ZhbHVlKG1ldGEpO1xufVxuZXhwb3J0cy5nZXRDdXJyZW50V2ViQ29udGVudHMgPSBnZXRDdXJyZW50V2ViQ29udGVudHM7XG4vLyBHZXQgYSBnbG9iYWwgb2JqZWN0IGluIGJyb3dzZXIuXG5mdW5jdGlvbiBnZXRHbG9iYWwobmFtZSkge1xuICAgIGNvbnN0IGNvbW1hbmQgPSBcIlJFTU9URV9CUk9XU0VSX0dFVF9HTE9CQUxcIiAvKiBCUk9XU0VSX0dFVF9HTE9CQUwgKi87XG4gICAgY29uc3QgbWV0YSA9IGVsZWN0cm9uXzEuaXBjUmVuZGVyZXIuc2VuZFN5bmMoY29tbWFuZCwgY29udGV4dElkLCBuYW1lLCBnZXRDdXJyZW50U3RhY2soKSk7XG4gICAgcmV0dXJuIG1ldGFUb1ZhbHVlKG1ldGEpO1xufVxuZXhwb3J0cy5nZXRHbG9iYWwgPSBnZXRHbG9iYWw7XG4vLyBHZXQgdGhlIHByb2Nlc3Mgb2JqZWN0IGluIGJyb3dzZXIuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3Byb2Nlc3MnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6ICgpID0+IGV4cG9ydHMuZ2V0R2xvYmFsKCdwcm9jZXNzJylcbn0pO1xuLy8gQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdoZW4gY2FsbGVkIGluIGJyb3dzZXIuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbldpdGhSZXR1cm5WYWx1ZShyZXR1cm5WYWx1ZSkge1xuICAgIGNvbnN0IGZ1bmMgPSAoKSA9PiByZXR1cm5WYWx1ZTtcbiAgICBpc1JldHVyblZhbHVlLmFkZChmdW5jKTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmV4cG9ydHMuY3JlYXRlRnVuY3Rpb25XaXRoUmV0dXJuVmFsdWUgPSBjcmVhdGVGdW5jdGlvbldpdGhSZXR1cm5WYWx1ZTtcbmNvbnN0IGFkZEJ1aWx0aW5Qcm9wZXJ0eSA9IChuYW1lKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBleHBvcnRzLmdldEJ1aWx0aW4obmFtZSlcbiAgICB9KTtcbn07XG5tb2R1bGVfbmFtZXNfMS5icm93c2VyTW9kdWxlTmFtZXNcbiAgICAuZm9yRWFjaChhZGRCdWlsdGluUHJvcGVydHkpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5pZiAocHJvY2Vzcy50eXBlID09PSAnYnJvd3NlcicpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIkBlbGVjdHJvbi9yZW1vdGVcIiBjYW5ub3QgYmUgcmVxdWlyZWQgaW4gdGhlIGJyb3dzZXIgcHJvY2Vzcy4gSW5zdGVhZCByZXF1aXJlKFwiQGVsZWN0cm9uL3JlbW90ZS9tYWluXCIpLmApO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlbW90ZVwiKSwgZXhwb3J0cyk7XG4iLCAibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3NyYy9yZW5kZXJlcicpXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBkb3RlbnYgZnJvbSBcImRvdGVudlwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHtcblx0TXlUb2RvU2V0dGluZ1RhYixcblx0REVGQVVMVF9TRVRUSU5HUyxcblx0TXlUb2RvU2V0dGluZ3MsXG59IGZyb20gXCJzcmMvc2V0dGluZ1wiO1xuaW1wb3J0IHtcblx0VklFV19UWVBFX1RPRE9fU0lERUJBUixcblx0VGFza1NpZGViYXJWaWV3LFxufSBmcm9tIFwic3JjL3JpZ2h0LXNpZGViYXItdmlld1wiO1xuaW1wb3J0IHtcblx0ZmV0Y2hUYXNrcyxcblx0Y3JlYXRlVGFzayxcblx0dXBkYXRlVGFzayxcblx0ZmV0Y2hUYXNrTGlzdHMsXG5cdGRlbGV0ZVRhc2ssXG59IGZyb20gXCJzcmMvYXBpXCI7XG5pbXBvcnQgeyBBdXRoTWFuYWdlciB9IGZyb20gXCJzcmMvYXV0aFwiO1xuaW1wb3J0IHsgVGFza1RpdGxlTW9kYWwgfSBmcm9tIFwic3JjL3Rhc2stdGl0bGUtbW9kYWxcIjtcbmltcG9ydCB7IEdlbmVyaWNTZWxlY3RNb2RhbCB9IGZyb20gXCJzcmMvc2VsZWN0LW1vZGFsXCI7XG5pbXBvcnQgeyBub3RpZnkgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIHRhc2sgY2FjaGUuXG4gKi9cbmludGVyZmFjZSBUYXNrQ2FjaGUge1xuXHR0YXNrczogQXJyYXk8W3N0cmluZywgeyB0aXRsZTogc3RyaW5nOyBzdGF0dXM6IHN0cmluZzsgaWQ6IHN0cmluZyB9XT47XG5cdGxhc3RVcGRhdGVkOiBudW1iZXI7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0YXNrIGl0ZW0uXG4gKi9cbmludGVyZmFjZSBUYXNrSXRlbSB7XG5cdHRpdGxlOiBzdHJpbmc7XG5cdHN0YXR1czogc3RyaW5nO1xuXHRpZDogc3RyaW5nO1xufVxuXG4vKipcbiAqICBJbnRlcmZhY2UgZm9yIHRhc2sgbGlzdHMuXG4gKi9cbmludGVyZmFjZSBUYXNrTGlzdCB7XG5cdHRpdGxlOiBzdHJpbmc7XG5cdGlkOiBzdHJpbmc7XG59XG5cbi8qKlxuICogTWFpbiBwbHVnaW4gY2xhc3MgZm9yIHN5bmNpbmcgdGFza3MgYmV0d2VlbiBPYnNpZGlhbiBhbmQgTWljcm9zb2Z0IFRvXHUyMDExRG8uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tTeW5jZXJQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogTXlUb2RvU2V0dGluZ3M7XG5cdHNpZGViYXJWaWV3OiBUYXNrU2lkZWJhclZpZXcgfCBudWxsID0gbnVsbDtcblx0dG9rZW5GaWxlUGF0aDogc3RyaW5nO1xuXHRhdXRoTWFuYWdlcjogQXV0aE1hbmFnZXI7XG5cdHRhc2tDYWNoZTogVGFza0NhY2hlIHwgbnVsbCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBwbHVnaW4gaXMgYWN0aXZhdGVkLlxuXHQgKiBMb2FkcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHNldHRpbmdzLCByZWdpc3RlcnMgdmlld3MgYW5kIGNvbW1hbmRzLCBhbmQgaW5pdGlhbGl6ZXMgYXV0aGVudGljYXRpb24uXG5cdCAqL1xuXHRhc3luYyBvbmxvYWQoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Ly8gMC4gTG9hZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgcGx1Z2luJ3MgLmVudiBmaWxlLlxuXHRcdGNvbnN0IGJhc2VQYXRoID0gKHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgYW55KS5iYXNlUGF0aDtcblx0XHRjb25zdCBwbHVnaW5QYXRoID0gcGF0aC5qb2luKFxuXHRcdFx0YmFzZVBhdGgsXG5cdFx0XHRcIi5vYnNpZGlhbi9wbHVnaW5zL3N5bmMtb2JzaWRpYW4tdG9kby1wbHVnaW5cIixcblx0XHQpO1xuXHRcdGRvdGVudi5jb25maWcoeyBwYXRoOiBwYXRoLmpvaW4ocGx1Z2luUGF0aCwgXCIuZW52XCIpLCBvdmVycmlkZTogdHJ1ZSB9KTtcblxuXHRcdC8vIDEuIExvYWQgc3RvcmVkIHNldHRpbmdzIChvciBkZWZhdWx0IHNldHRpbmdzIGlmIG5vbmUgZXhpc3QpLlxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHQvLyAyLiBBZGQgdGhlIHNldHRpbmdzIHRhYi5cblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IE15VG9kb1NldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuXHRcdC8vIDMuIFJlZ2lzdGVyIHRoZSBzaWRlYmFyIHZpZXcuXG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoVklFV19UWVBFX1RPRE9fU0lERUJBUiwgKGxlYWYpID0+IHtcblx0XHRcdGNvbnN0IHZpZXcgPSBuZXcgVGFza1NpZGViYXJWaWV3KGxlYWYsIHRoaXMpO1xuXHRcdFx0dGhpcy5zaWRlYmFyVmlldyA9IHZpZXc7XG5cdFx0XHRyZXR1cm4gdmlldztcblx0XHR9KTtcblxuXHRcdC8vIDQuIEluaXRpYWxpemUgY29yZSBjb21wb25lbnRzIChNU0FMIGNsaWVudCwgY29tbWFuZHMsIGV0Yy4pLlxuXHRcdHRoaXMuaW5pdGlhbGl6ZUNvbW1hbmQoKTtcblxuXHRcdC8vIDUuIEluaXRpYWxpemUgdGhlIE1TQUwgY2xpZW50XG5cdFx0dGhpcy50b2tlbkZpbGVQYXRoID0gYCR7cGx1Z2luUGF0aH0vdG9rZW5fY2FjaGUuanNvbmA7XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuY2xpZW50SWQgJiYgdGhpcy5zZXR0aW5ncy5jbGllbnRTZWNyZXQpIHtcblx0XHRcdHRoaXMuYXV0aE1hbmFnZXIgPSBuZXcgQXV0aE1hbmFnZXIoXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2xpZW50SWQsXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2xpZW50U2VjcmV0LFxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnJlZGlyZWN0VXJsLFxuXHRcdFx0XHR0aGlzLnRva2VuRmlsZVBhdGgsXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIDYuIFNldCB1cCB0aGUgdG9rZW4gY2FjaGUuXG5cdFx0aWYgKGZzLmV4aXN0c1N5bmModGhpcy50b2tlbkZpbGVQYXRoKSkge1xuXHRcdFx0Y29uc3QgY2FjaGVEYXRhID0gZnMucmVhZEZpbGVTeW5jKHRoaXMudG9rZW5GaWxlUGF0aCwgXCJ1dGY4XCIpO1xuXHRcdFx0dGhpcy5hdXRoTWFuYWdlci5jY2EuZ2V0VG9rZW5DYWNoZSgpLmRlc2VyaWFsaXplKGNhY2hlRGF0YSk7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlRva2VuIGNhY2hlIGxvYWRlZCBmcm9tIGZpbGUuXCIpO1xuXHRcdH1cblxuXHRcdC8vIDcuIFJlZ2lzdGVyIHN0eWxlc1xuXHRcdC8vIHRoaXMucmVnaXN0ZXJTdHlsZXMocGx1Z2luUGF0aCk7XG5cdFx0dGhpcy5pbmplY3RTdHlsZXMoKTtcblx0XHRub3RpZnkoXCJNaWNyb3NvZnQgVG8tRG8gUGx1Z2luIExvYWRlZCFcIiwgXCJpbmZvXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBNU0FMIGNsaWVudCBhbmQgcmVnaXN0ZXJzIGNvbW1hbmRzL3JpYmJvbiBpY29ucy5cblx0ICovXG5cdGluaXRpYWxpemVDb21tYW5kKCk6IHZvaWQge1xuXHRcdC8vIFJlZ2lzdGVyIGNvbW1hbmQgdG8gb3BlbiB0aGUgc2lkZWJhci5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1taWNyb3NvZnQtdG9kby1zaWRlYmFyXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gTWljcm9zb2Z0IFRvLURvIFNpZGViYXJcIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuYWN0aXZhdGVTaWRlYmFyKCk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0Ly8gUmVnaXN0ZXIgaW50ZXJhY3RpdmUgbG9naW4gY29tbWFuZC5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwibG9naW4tbWljcm9zb2Z0LXRvZG9cIixcblx0XHRcdG5hbWU6IFwiTG9naW4gdG8gTWljcm9zb2Z0IFRvLURvIChJbnRlcmFjdGl2ZSlcIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0bm90aWZ5KFwiTG9nZ2luZyBpbi4uLlwiKTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmF1dGhNYW5hZ2VyLmdldEFjY2Vzc1Rva2VuKCk7XG5cdFx0XHRcdFx0bm90aWZ5KFwiTG9nZ2VkIGluIHN1Y2Nlc3NmdWxseSFcIiwgXCJzdWNjZXNzXCIpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJBdXRoZW50aWNhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuXHRcdFx0XHRcdG5vdGlmeShcblx0XHRcdFx0XHRcdFwiRXJyb3IgbG9naW5pbmcgaW4hIENoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLlwiLFxuXHRcdFx0XHRcdFx0XCJlcnJvclwiLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHQvLyBSZWdpc3RlciB0b2tlbiByZWZyZXNoIGNvbW1hbmQuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlZnJlc2gtbWljcm9zb2Z0LXRvZG8tdG9rZW5cIixcblx0XHRcdG5hbWU6IFwiUmVmcmVzaCBNaWNyb3NvZnQgVG8tRG8gVG9rZW5cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgdG9rZW5EYXRhID1cblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXV0aE1hbmFnZXIucmVmcmVzaEFjY2Vzc1Rva2VuV2l0aENDQSgpO1xuXHRcdFx0XHRcdG5vdGlmeShcIlRva2VuIHJlZnJlc2hlZCBzdWNjZXNzZnVsbHkhXCIsIFwic3VjY2Vzc1wiKTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIk5ldyBBY2Nlc3MgVG9rZW46XCIsIHRva2VuRGF0YS5hY2Nlc3NUb2tlbik7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIHJlZnJlc2hpbmcgdG9rZW46XCIsIGVycm9yKTtcblx0XHRcdFx0XHRub3RpZnkoXG5cdFx0XHRcdFx0XHRcIkVycm9yIHJlZnJlc2hpbmcgdG9rZW4uIENoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLlwiLFxuXHRcdFx0XHRcdFx0XCJlcnJvclwiLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHQvLyBSZWdpc3RlciBjb21tYW5kIHRvIGZldGNoIHRhc2sgZnJvbSBzZWxlY3RlZCBsaXN0LlxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJnZXQtdGFza3MtZnJvbS1zZWxlY3RlZC1saXN0XCIsXG5cdFx0XHRuYW1lOiBcIkdldCBUYXNrcyBmcm9tIFNlbGVjdGVkIExpc3RcIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0bm90aWZ5KFwiRmV0Y2hpbmcgdGFza3MuLi5cIik7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5nZXRUYXNrc0Zyb21TZWxlY3RlZExpc3QoKTtcblx0XHRcdFx0XHRub3RpZnkoXCJUYXNrcyBmZXRjaGVkIHN1Y2Nlc3NmdWxseSFcIiwgXCJzdWNjZXNzXCIpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdFx0XHRcIkVycm9yIGZldGNoaW5nIHRhc2tzIGZyb20gc2VsZWN0ZWQgbGlzdDpcIixcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0bm90aWZ5KFxuXHRcdFx0XHRcdFx0XCJFcnJvciBmZXRjaGluZyB0YXNrcy4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIGRldGFpbHMuXCIsXG5cdFx0XHRcdFx0XHRcImVycm9yXCIsXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdC8vIFJlZ2lzdGVyIGNvbW1hbmQgdG8gc3luYyB0YXNrIGxpc3RzIGZvciB0aGUgY3VycmVudCBub3RlLlxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJwdXNoLWFsbC10YXNrcy1mcm9tLW5vdGVcIixcblx0XHRcdG5hbWU6IFwiUHVzaCBBbGwgVGFza3MgZnJvbSBOb3RlIHRvIE1pY3Jvc29mdCBUby1Eb1wiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRub3RpZnkoXCJTeW5jaW5nIHRhc2tzIHRvIE1pY3Jvc29mdCBUby1Eby4uLlwiKTtcblx0XHRcdFx0XHRjb25zdCB0YXNrc0NvdW50ID0gYXdhaXQgdGhpcy5wdXNoVGFza3NGcm9tTm90ZSgpO1xuXHRcdFx0XHRcdG5vdGlmeShcblx0XHRcdFx0XHRcdGBUYXNrcyBzeW5jZWQgc3VjY2Vzc2Z1bGx5ISAke3Rhc2tzQ291bnR9IG5ldyB0YXNrcyBhZGRlZC5gLFxuXHRcdFx0XHRcdFx0XCJzdWNjZXNzXCIsXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlZnJlc2hWaWV3QW5kQ2FjaGUoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgcHVzaGluZyB0YXNrczpcIiwgZXJyb3IpO1xuXHRcdFx0XHRcdG5vdGlmeShcblx0XHRcdFx0XHRcdFwiRXJyb3IgcHVzaGluZyB0YXNrcy4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIGRldGFpbHMuXCIsXG5cdFx0XHRcdFx0XHRcImVycm9yXCIsXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJwdXNoLW9uZS10YXNrXCIsXG5cdFx0XHRuYW1lOiBcIkNyZWF0ZSBhbmQgcHVzaCBUYXNrXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRuZXcgVGFza1RpdGxlTW9kYWwodGhpcy5hcHAsIGFzeW5jICh0YXNrVGl0bGU6IHN0cmluZykgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRub3RpZnkoXCJQdXNoaW5nIHRhc2tzIHRvIE1pY3Jvc29mdCBUby1Eby4uLlwiKTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucHVzaE9uZVRhc2sodGFza1RpdGxlKTtcblx0XHRcdFx0XHRcdG5vdGlmeShgVGFza3MgcHVzaGVkIHN1Y2Nlc3NmdWxseSFgLCBcInN1Y2Nlc3NcIik7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwdXNoaW5nIHRhc2tzOlwiLCBlcnJvcik7XG5cdFx0XHRcdFx0XHRub3RpZnkoXG5cdFx0XHRcdFx0XHRcdFwiRXJyb3IgcHVzaGluZyB0YXNrcy4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIGRldGFpbHMuXCIsXG5cdFx0XHRcdFx0XHRcdFwiZXJyb3JcIixcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KS5vcGVuKCk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInNob3ctbm90LXN0YXJ0ZWQtdGFza3NcIixcblx0XHRcdG5hbWU6IFwiU2hvdyBUYXNrcyBMaXN0XCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMub3BlblRhc2tDb21wbGV0ZU1vZGFsKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGNvbXBsZXRpbmcgdGFzazpcIiwgZXJyb3IpO1xuXHRcdFx0XHRcdG5vdGlmeShcblx0XHRcdFx0XHRcdFwiRXJyb3IgY29tcGxldGluZyB0YXNrLiBDaGVjayB0aGUgY29uc29sZSBmb3IgZGV0YWlscy5cIixcblx0XHRcdFx0XHRcdFwiZXJyb3JcIixcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInNlbGVjdC10YXNrLWxpc3RcIixcblx0XHRcdG5hbWU6IFwiU2VsZWN0IFRhc2sgTGlzdFwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRub3RpZnkoXCJTZWxlY3RpbmcgdGFzayBsaXN0Li4uXCIpO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMub3BlblRhc2tMaXN0c01vZGFsKCk7XG5cdFx0XHRcdFx0bm90aWZ5KFwiVGFzayBsaXN0IHNlbGVjdGVkIHN1Y2Nlc3NmdWxseSFcIiwgXCJzdWNjZXNzXCIpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZWxlY3RpbmcgdGFzayBsaXN0OlwiLCBlcnJvcik7XG5cdFx0XHRcdFx0bm90aWZ5KFxuXHRcdFx0XHRcdFx0XCJFcnJvciBzZWxlY3RpbmcgdGFzayBsaXN0LiBDaGVjayB0aGUgY29uc29sZSBmb3IgZGV0YWlscy5cIixcblx0XHRcdFx0XHRcdFwiZXJyb3JcIixcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9yZ2FuaXplLXRhc2tzXCIsXG5cdFx0XHRuYW1lOiBcIk9yZ2FuaXplIFRhc2tzIGZyb20gQWxsIE5vdGVzXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuZ2F0aGVyVGFza3MoKTtcblx0XHRcdFx0XHRub3RpZnkoXCJUYXNrcyBvcmdhbml6ZWQgc3VjY2Vzc2Z1bGx5IVwiLCBcInN1Y2Nlc3NcIik7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIG9yZ2FuaXppbmcgdGFza3M6XCIsIGVycm9yKTtcblx0XHRcdFx0XHRub3RpZnkoXG5cdFx0XHRcdFx0XHRcIkVycm9yIG9yZ2FuaXppbmcgdGFza3MuIENoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLlwiLFxuXHRcdFx0XHRcdFx0XCJlcnJvclwiLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZGVsZXRlLWNvbXBsZXRlZC10YXNrc1wiLFxuXHRcdFx0bmFtZTogXCJEZWxldGUgQ29tcGxldGVkIFRhc2tzXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG5vdGlmeShcIkRlbGV0aW5nIGNvbXBsZXRlZCB0YXNrcy4uLlwiKTtcblx0XHRcdFx0XHRjb25zdCBkZWxldGVkQ291bnQgPSBhd2FpdCB0aGlzLmRlbGV0ZUFsbENvbXBsZXRlZFRhc2tzKCk7XG5cdFx0XHRcdFx0bm90aWZ5KFxuXHRcdFx0XHRcdFx0YCR7ZGVsZXRlZENvdW50fSBjb21wbGV0ZWQgdGFza3MgZGVsZXRlZCBzdWNjZXNzZnVsbHkhYCxcblx0XHRcdFx0XHRcdFwic3VjY2Vzc1wiLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGRlbGV0aW5nIGNvbXBsZXRlZCB0YXNrczpcIiwgZXJyb3IpO1xuXHRcdFx0XHRcdG5vdGlmeShcblx0XHRcdFx0XHRcdFwiRXJyb3IgZGVsZXRpbmcgdGFza3MuIENoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLlwiLFxuXHRcdFx0XHRcdFx0XCJlcnJvclwiLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGVzdGluZ1wiLFxuXHRcdFx0bmFtZTogXCJUZXN0aW5nXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiVGVzdGluZ1wiKTtcblx0XHRcdFx0XHRub3RpZnkoXCJUZXN0aW5nLi4uXCIsIFwic3VjY2Vzc1wiKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgdGVzdGluZzpcIiwgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluamVjdHMgY3VzdG9tIENTUyBzdHlsZXMgaW50byB0aGUgZG9jdW1lbnQuXG5cdCAqL1xuXHRpbmplY3RTdHlsZXMoKSB7XG5cdFx0Y29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdFx0c3R5bGUudGV4dENvbnRlbnQgPSBgXG5cdFx0LnRhc2stbGluZSB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdGdhcDogOHB4O1xuXHRcdFx0cGFkZGluZzogMnB4IDA7XG5cdFx0fVxuXG5cdFx0LnRhc2stbGluZSBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0ge1xuXHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0dHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xuXHRcdH1cblxuXHRcdC50YXNrLWxpbmUgc3BhbiB7XG5cdFx0XHRmb250LXNpemU6IDE0cHg7XG5cdFx0fVxuXHRgO1xuXHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFjdGl2YXRlcyB0aGUgc2lkZWJhciB2aWV3LlxuXHQgKi9cblx0YXN5bmMgYWN0aXZhdGVTaWRlYmFyKCkge1xuXHRcdGNvbnN0IHJpZ2h0TGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpO1xuXHRcdGlmICghcmlnaHRMZWFmKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJObyByaWdodCBsZWFmIGF2YWlsYWJsZS5cIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0YXdhaXQgcmlnaHRMZWFmLnNldFZpZXdTdGF0ZSh7XG5cdFx0XHR0eXBlOiBWSUVXX1RZUEVfVE9ET19TSURFQkFSLFxuXHRcdFx0YWN0aXZlOiB0cnVlLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYocmlnaHRMZWFmKTtcblx0fVxuXHQvKipcblx0ICogTG9hZHMgcGx1Z2luIHNldHRpbmdzIGZyb20gdGhlIE9ic2lkaWFuIHZhdWx0LlxuXHQgKi9cblx0YXN5bmMgbG9hZFNldHRpbmdzKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKFxuXHRcdFx0e30sXG5cdFx0XHRERUZBVUxUX1NFVFRJTkdTLFxuXHRcdFx0YXdhaXQgdGhpcy5sb2FkRGF0YSgpLFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZXMgcGx1Z2luIHNldHRpbmdzIHRvIHRoZSBPYnNpZGlhbiB2YXVsdC5cblx0ICovXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG5cblx0YXN5bmMgZ2V0QWNjZXNzVG9rZW4oKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgdG9rZW5EYXRhID0gYXdhaXQgdGhpcy5hdXRoTWFuYWdlci5nZXRUb2tlbigpO1xuXHRcdFx0cmV0dXJuIHRva2VuRGF0YS5hY2Nlc3NUb2tlbjtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGFjY2VzcyB0b2tlbjpcIiwgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZldGNoZXMgYXZhaWxhYmxlIE1pY3Jvc29mdCBUby1EbyB0YXNrIGxpc3RzIGFuZCB1cGRhdGVzIHRoZSBwbHVnaW4gc2V0dGluZ3MuXG5cdCAqL1xuXHRhc3luYyBsb2FkQXZhaWxhYmxlVGFza0xpc3RzKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdG5vdGlmeShcIkxvYWRpbmcgdGFzayBsaXN0cy4uLlwiKTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XG5cdFx0XHRjb25zdCBsaXN0QXJyYXkgPSBhd2FpdCBmZXRjaFRhc2tMaXN0cyhhY2Nlc3NUb2tlbik7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkZldGNoZWQgVGFzayBMaXN0czpcIiwgbGlzdEFycmF5KTtcblxuXHRcdFx0dGhpcy5zZXR0aW5ncy50YXNrTGlzdHMgPSBsaXN0QXJyYXkubWFwKChsaXN0KSA9PiAoe1xuXHRcdFx0XHRpZDogbGlzdC5pZCxcblx0XHRcdFx0dGl0bGU6IGxpc3QudGl0bGUsXG5cdFx0XHR9KSk7XG5cblx0XHRcdG5vdGlmeShcIlRhc2sgbGlzdHMgbG9hZGVkIHN1Y2Nlc3NmdWxseSFcIiwgXCJzdWNjZXNzXCIpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgdGFzayBsaXN0czpcIiwgZXJyKTtcblx0XHRcdG5vdGlmeShcblx0XHRcdFx0XCJFcnJvciBsb2FkaW5nIHRhc2sgbGlzdHMuIENoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLlwiLFxuXHRcdFx0XHRcImVycm9yXCIsXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGFzayBsaXN0cyB1c2luZyBhY2Nlc3MgdG9rZW4gd2l0aCBmZXRjaFRhc2tMaXN0cyBhcGkgZnVuY3Rpb24uXG5cdCAqIEByZXR1cm5zIEEgVGFza0xpc3QgaW50ZXJmYWNlIHdpdGggZmV0Y2hlZCB0YXNrIGxpc3RzLlxuXHQgKiAqL1xuXHRhc3luYyBnZXRUYXNrTGlzdHMoKTogUHJvbWlzZTxUYXNrTGlzdFtdPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuXHRcdFx0Y29uc3QgdGFza0xpc3RzID0gYXdhaXQgZmV0Y2hUYXNrTGlzdHMoYWNjZXNzVG9rZW4pO1xuXHRcdFx0cmV0dXJuIHRhc2tMaXN0cztcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHRhc2sgbGlzdHM6XCIsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBGZXRjaGVzIHRhc2tzIGZyb20gdGhlIHNlbGVjdGVkIE1pY3Jvc29mdCBUb1x1MjAxMURvIGxpc3QuXG5cdCAqIEByZXR1cm5zIEEgbWFwIG9mIHRhc2sgdGl0bGUgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGFzayBkZXRhaWxzLlxuXHQgKi9cblx0YXN5bmMgZ2V0VGFza3NGcm9tU2VsZWN0ZWRMaXN0KCk6IFByb21pc2U8XG5cdFx0TWFwPHN0cmluZywgeyB0aXRsZTogc3RyaW5nOyBzdGF0dXM6IHN0cmluZzsgaWQ6IHN0cmluZyB9PlxuXHQ+IHtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3Muc2VsZWN0ZWRUYXNrTGlzdElkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFwiTm8gdGFzayBsaXN0IHNlbGVjdGVkLiBQbGVhc2UgY2hvb3NlIG9uZSBpbiBzZXR0aW5ncy5cIixcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMudGFza0NhY2hlICYmIHRoaXMudGFza0NhY2hlLnRhc2tzKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlVzaW5nIGNhY2hlZCB0YXNrczpcIiwgdGhpcy50YXNrQ2FjaGUudGFza3MpO1xuXHRcdFx0cmV0dXJuIG5ldyBNYXAodGhpcy50YXNrQ2FjaGUudGFza3MpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJObyBjYWNoZWQgdGFza3MgZm91bmQsIHJlZnJlc2hpbmcgdGFzayBjYWNoZS5cIik7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5yZWZyZXNoVGFza0NhY2hlKCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB0YXNrczpcIiwgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFB1c2hlcyB0YXNrcyBmcm9tIHRoZSBhY3RpdmUgbm90ZSB0byBNaWNyb3NvZnQgVG9cdTIwMTFEby5cblx0ICogQHJldHVybnMgVGhlIG51bWJlciBvZiBuZXcgdGFza3MgY3JlYXRlZC5cblx0ICovXG5cdGFzeW5jIHB1c2hUYXNrc0Zyb21Ob3RlKCk6IFByb21pc2U8bnVtYmVyPiB7XG5cdFx0Ly8gRW5zdXJlIGEgdGFzayBsaXN0IGlzIHNlbGVjdGVkLlxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5zZWxlY3RlZFRhc2tMaXN0SWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XCJObyB0YXNrIGxpc3Qgc2VsZWN0ZWQuIFBsZWFzZSBjaG9vc2Ugb25lIGluIHNldHRpbmdzLlwiLFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBHZXQgdGhlIGFjdGl2ZSBub3RlLlxuXHRcdGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuXHRcdGlmICghYWN0aXZlRmlsZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIGZpbGUgZm91bmQuXCIpO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgbm90ZSBjb250ZW50IGFuZCBleHRyYWN0IHRhc2tzIHVzaW5nIGEgcmVnZXguXG5cdFx0Y29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGFjdGl2ZUZpbGUpO1xuXHRcdGNvbnN0IHRhc2tSZWdleCA9IC9eLVxccypcXFsoIHx4KVxcXVxccysoLispJC9nbTtcblx0XHRjb25zdCBub3RlVGFza3M6IEFycmF5PHsgdGl0bGU6IHN0cmluZzsgY29tcGxldGU6IGJvb2xlYW4gfT4gPSBbXTtcblx0XHRsZXQgbWF0Y2g7XG5cdFx0d2hpbGUgKChtYXRjaCA9IHRhc2tSZWdleC5leGVjKGZpbGVDb250ZW50KSkgIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IGNvbXBsZXRlID0gbWF0Y2hbMV0gPT09IFwieFwiO1xuXHRcdFx0Y29uc3QgdGl0bGUgPSBtYXRjaFsyXS50cmltKCk7XG5cdFx0XHRub3RlVGFza3MucHVzaCh7IHRpdGxlLCBjb21wbGV0ZSB9KTtcblx0XHR9XG5cdFx0aWYgKG5vdGVUYXNrcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk5vIHRhc2tzIGZvdW5kIGluIHRoZSBhY3RpdmUgbm90ZS5cIik7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIEdldCBhIGZyZXNoIGFjY2VzcyB0b2tlbi5cblx0XHRcdGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuXHRcdFx0Ly8gRmV0Y2ggZXhpc3RpbmcgdGFza3MgZnJvbSBNaWNyb3NvZnQgVG9cdTIwMTFEbyB2aWEgQVBJLlxuXHRcdFx0Y29uc3QgZXhpc3RpbmdUYXNrcyA9IGF3YWl0IGZldGNoVGFza3ModGhpcy5zZXR0aW5ncywgYWNjZXNzVG9rZW4pO1xuXHRcdFx0bGV0IG5ld1Rhc2tzQ291bnQgPSAwO1xuXG5cdFx0XHQvLyBMb29wIG92ZXIgZWFjaCBub3RlIHRhc2suXG5cdFx0XHRmb3IgKGNvbnN0IHRhc2sgb2Ygbm90ZVRhc2tzKSB7XG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nVGFzayA9IGV4aXN0aW5nVGFza3MuZ2V0KHRhc2sudGl0bGUpO1xuXHRcdFx0XHRpZiAoZXhpc3RpbmdUYXNrKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHRhc2sgZXhpc3RzIGFuZCB0aGUgbm90ZSBtYXJrcyBpdCBhcyBjb21wbGV0ZSB3aGlsZSBpdHMgc3RhdHVzIGlzIG5vdCBjb21wbGV0ZSwgdXBkYXRlIGl0LlxuXHRcdFx0XHRcdGlmICh0YXNrLmNvbXBsZXRlICYmIGV4aXN0aW5nVGFzay5zdGF0dXMgIT09IFwiY29tcGxldGVkXCIpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHVwZGF0ZVRhc2soXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MsXG5cdFx0XHRcdFx0XHRcdGFjY2Vzc1Rva2VuLFxuXHRcdFx0XHRcdFx0XHRleGlzdGluZ1Rhc2suaWQsXG5cdFx0XHRcdFx0XHRcdHRydWUsXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgVGFzayBhbHJlYWR5IGV4aXN0czogJHt0YXNrLnRpdGxlfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXNrIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBzdGF0dXMuXG5cdFx0XHRcdGNvbnN0IGluaXRpYWxTdGF0dXMgPSB0YXNrLmNvbXBsZXRlXG5cdFx0XHRcdFx0PyBcImNvbXBsZXRlZFwiXG5cdFx0XHRcdFx0OiBcIm5vdFN0YXJ0ZWRcIjtcblx0XHRcdFx0YXdhaXQgY3JlYXRlVGFzayhcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLFxuXHRcdFx0XHRcdGFjY2Vzc1Rva2VuLFxuXHRcdFx0XHRcdHRhc2sudGl0bGUsXG5cdFx0XHRcdFx0aW5pdGlhbFN0YXR1cyxcblx0XHRcdFx0KTtcblx0XHRcdFx0bmV3VGFza3NDb3VudCsrO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coXCJTeW5jZWQgVGFza3M6XCIsIG5vdGVUYXNrcyk7XG5cdFx0XHRyZXR1cm4gbmV3VGFza3NDb3VudDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIHN5bmNpbmcgdGFza3M6XCIsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQdXNoZXMgYSBzaW5nbGUgdGFzayB0byBzZWxlY3RlZCBsaXN0IGluIE1pY3Jvc29mdCBUb1x1MjAxMURvLlxuXHQgKiBAcGFyYW0gdGFzayAtIFRoZSB0YXNrIHRpdGxlIHRleHQgdG8gcHVzaC5cblx0ICovXG5cdGFzeW5jIHB1c2hPbmVUYXNrKHRhc2s6IHN0cmluZykge1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5zZWxlY3RlZFRhc2tMaXN0SWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XCJObyB0YXNrIGxpc3Qgc2VsZWN0ZWQuIFBsZWFzZSBjaG9vc2Ugb25lIGluIHNldHRpbmdzLlwiLFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XG5cdFx0XHRjb25zdCBleGlzdGluZ1Rhc2tzID0gYXdhaXQgZmV0Y2hUYXNrcyh0aGlzLnNldHRpbmdzLCBhY2Nlc3NUb2tlbik7XG5cdFx0XHRjb25zdCBleGlzdGluZ1Rhc2sgPSBleGlzdGluZ1Rhc2tzLmdldCh0YXNrKTtcblxuXHRcdFx0aWYgKGV4aXN0aW5nVGFzaykge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgVGFzayBhbHJlYWR5IGV4aXN0czogJHt0YXNrfWApO1xuXHRcdFx0fVxuXG5cdFx0XHRhd2FpdCBjcmVhdGVUYXNrKHRoaXMuc2V0dGluZ3MsIGFjY2Vzc1Rva2VuLCB0YXNrKTtcblx0XHRcdGF3YWl0IHRoaXMucmVmcmVzaFZpZXdBbmRDYWNoZSgpO1xuXHRcdFx0Y29uc29sZS5sb2coXCJTeW5jZWQgVGFza3M6XCIsIHRhc2spO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3Igc3luY2luZyB0YXNrczpcIiwgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdhdGhlcnMgdGFza3MgZnJvbSBhbGwgbWFya2Rvd24gZmlsZXMgaW4gdGhlIHZhdWx0IGFuZCB1cGRhdGVzIChvciBjcmVhdGVzKSBhIGNvbnNvbGlkYXRlZCBub3RlLlxuXHQgKiBAcmV0dXJucyBBIG1hcCBvZiB0YXNrIHRleHQgdG8gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdCAqL1xuXHRhc3luYyBnYXRoZXJUYXNrcygpOiBQcm9taXNlPE1hcDxzdHJpbmcsIHN0cmluZz4+IHtcblx0XHRjb25zdCBub3RlTmFtZSA9IFwiVGFza3MgTGlzdC5tZFwiO1xuXHRcdGNvbnN0IG1hcmtkb3duRmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG5cdFx0Y29uc3QgdGFza3NNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXG5cdFx0Ly8gUmVnZXggdG8gbWF0Y2ggYm90aCB1bmRvbmUgKC0gWyBdKSBhbmQgZG9uZSAoLSBbeF0pIHRhc2tzLCBhbGxvd2luZyBvcHRpb25hbCBsZWFkaW5nIHNwYWNlcy5cblx0XHRjb25zdCB0YXNrUmVnZXggPSAvXlxccyotXFxzKlxcWyggfHgpXFxdXFxzKyguKikkL2dtO1xuXG5cdFx0Ly8gTG9vcCB0aHJvdWdoIGV2ZXJ5IGZpbGUgaW4gdGhlIHZhdWx0LlxuXHRcdGZvciAoY29uc3QgZmlsZSBvZiBtYXJrZG93bkZpbGVzKSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcblx0XHRcdGxldCBtYXRjaDtcblx0XHRcdHdoaWxlICgobWF0Y2ggPSB0YXNrUmVnZXguZXhlYyhjb250ZW50KSkgIT09IG51bGwpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJNYXRjaDpcIiwgbWF0Y2gpO1xuXHRcdFx0XHQvLyBtYXRjaFsxXSBpcyBlaXRoZXIgXCIgXCIgKHVuZG9uZSkgb3IgXCJ4XCIgKGRvbmUpXG5cdFx0XHRcdC8vIG1hdGNoWzJdIGlzIHRoZSB0YXNrIHRleHRcblx0XHRcdFx0Y29uc3QgY3VycmVudFN0YXRlID0gbWF0Y2hbMV0gPT09IFwieFwiID8gXCJbeF1cIiA6IFwiWyBdXCI7XG5cdFx0XHRcdGNvbnN0IHRhc2tUZXh0ID0gbWF0Y2hbMl0udHJpbSgpO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXNrIGFscmVhZHkgZXhpc3RzIGFuZCBhbnkgb2NjdXJyZW5jZSBpcyBkb25lLCBtYXJrIGl0IGFzIGRvbmUuXG5cdFx0XHRcdGlmICh0YXNrc01hcC5oYXModGFza1RleHQpKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZSA9PT0gXCJbeF1cIikge1xuXHRcdFx0XHRcdFx0dGFza3NNYXAuc2V0KHRhc2tUZXh0LCBcIlt4XVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFza3NNYXAuc2V0KHRhc2tUZXh0LCBjdXJyZW50U3RhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQnVpbGQgdGhlIG5ldyBjb25zb2xpZGF0ZWQgY29udGVudC5cblx0XHRjb25zdCBmaW5hbFRhc2tzID0gQXJyYXkuZnJvbSh0YXNrc01hcC5lbnRyaWVzKCkpLm1hcChcblx0XHRcdChbdGFza1RleHQsIHN0YXRlXSkgPT4gYC0gJHtzdGF0ZX0gJHt0YXNrVGV4dH1gLFxuXHRcdCk7XG5cdFx0Y29uc3QgbmV3Q29udGVudCA9IGZpbmFsVGFza3Muam9pbihcIlxcblwiKTtcblxuXHRcdC8vIFVwZGF0ZSBvciBjcmVhdGUgdGhlIGNvbnNvbGlkYXRlZCBub3RlLlxuXHRcdGNvbnN0IHRhcmdldEZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm90ZU5hbWUpO1xuXHRcdGlmICghdGFyZ2V0RmlsZSkge1xuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKG5vdGVOYW1lLCBuZXdDb250ZW50KTtcblx0XHR9IGVsc2UgaWYgKHRhcmdldEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KHRhcmdldEZpbGUsIG5ld0NvbnRlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGZpbGUgdHlwZSBmb3IgVGFza3MgTGlzdFwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFza3NNYXA7XG5cdH1cblxuXHQvKipcblx0ICogT3BlbiBhIGludGVyYWN0aXZlIHdpbmRvdyBmb3IgdGhlIHVzZXIgdG8gaW50ZXJhY3QgYW5kIHNlbGVjdCBhIHRhcmdldCB0YXNrIGxpc3QuXG5cdCAqL1xuXHRhc3luYyBvcGVuVGFza0xpc3RzTW9kYWwoKSB7XG5cdFx0Y29uc3QgdGFza3NMaXN0cyA9IHRoaXMuc2V0dGluZ3MudGFza0xpc3RzO1xuXG5cdFx0Y29uc29sZS5sb2coXCJUYXNrIExpc3RzOlwiLCB0YXNrc0xpc3RzKTtcblx0XHRuZXcgR2VuZXJpY1NlbGVjdE1vZGFsPFRhc2tMaXN0Pihcblx0XHRcdHRoaXMuYXBwLFxuXHRcdFx0dGFza3NMaXN0cyxcblx0XHRcdCh0YXNrTGlzdCkgPT4gdGFza0xpc3QudGl0bGUsXG5cdFx0XHRhc3luYyAodGFza0xpc3Q6IFRhc2tMaXN0KSA9PiB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc2VsZWN0ZWRUYXNrTGlzdElkID0gdGFza0xpc3QuaWQ7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVmcmVzaFZpZXdBbmRDYWNoZSgpO1xuXHRcdFx0fSxcblx0XHQpLm9wZW4oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPcGVuIGEgaW50ZXJhY3RpdmUgd2luZG93IGZvciB0aGUgdXNlciB0byBpbnRlcmFjdCBhbmQgc2VsZWN0IHRvIGNvbXBsZXRlIHRhc2sgaXRlbXMuXG5cdCAqL1xuXHRhc3luYyBvcGVuVGFza0NvbXBsZXRlTW9kYWwoKSB7XG5cdFx0Y29uc3QgdGFza3NNYXAgPSBhd2FpdCB0aGlzLmdldFRhc2tzRnJvbVNlbGVjdGVkTGlzdCgpO1xuXHRcdGNvbnN0IG5vdFN0YXJ0ZWRUYXNrcyA9IEFycmF5LmZyb20odGFza3NNYXAudmFsdWVzKCkpLmZpbHRlcihcblx0XHRcdCh0YXNrKSA9PiB0YXNrLnN0YXR1cyAhPT0gXCJjb21wbGV0ZWRcIixcblx0XHQpO1xuXG5cdFx0bmV3IEdlbmVyaWNTZWxlY3RNb2RhbDxUYXNrSXRlbT4oXG5cdFx0XHR0aGlzLmFwcCxcblx0XHRcdG5vdFN0YXJ0ZWRUYXNrcyxcblx0XHRcdCh0YXNrKSA9PiAodGFzay5zdGF0dXMgIT09IFwiY29tcGxldGVkXCIgPyB0YXNrLnRpdGxlIDogXCJcIiksXG5cdFx0XHRhc3luYyAodGFzazogeyB0aXRsZTogc3RyaW5nOyBzdGF0dXM6IHN0cmluZzsgaWQ6IHN0cmluZyB9KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuXG5cdFx0XHRcdGF3YWl0IHVwZGF0ZVRhc2sodGhpcy5zZXR0aW5ncywgYWNjZXNzVG9rZW4sIHRhc2suaWQsIHRydWUpO1xuXHRcdFx0XHRub3RpZnkoXG5cdFx0XHRcdFx0YFRhc2sgXCIke3Rhc2sudGl0bGV9XCIgbWFya2VkIGFzIGNvbXBsZXRlIGFuZCBzeW5jZWQuYCxcblx0XHRcdFx0XHRcInN1Y2Nlc3NcIixcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRhd2FpdCB0aGlzLnJlZnJlc2hWaWV3QW5kQ2FjaGUoKTtcblx0XHRcdH0sXG5cdFx0KS5vcGVuKCk7XG5cdH1cblxuXHQvKipcblx0ICogRmV0Y2ggdGFzayB1c2luZyBhcGkgZnVuY3Rpb24gYW5kIHN0b3JlIGluIHRoZSBjYWNoZSBmb3IgcXVpY2sgYWNjZXNzLlxuXHQgKi9cblx0YXN5bmMgcmVmcmVzaFRhc2tDYWNoZSgpOiBQcm9taXNlPFxuXHRcdE1hcDxzdHJpbmcsIHsgdGl0bGU6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmc7IGlkOiBzdHJpbmcgfT5cblx0PiB7XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLnNlbGVjdGVkVGFza0xpc3RJZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcIk5vIHRhc2sgbGlzdCBzZWxlY3RlZC4gUGxlYXNlIGNob29zZSBvbmUgaW4gc2V0dGluZ3MuXCIsXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcblx0XHRcdGNvbnN0IHRhc2tzID0gYXdhaXQgZmV0Y2hUYXNrcyh0aGlzLnNldHRpbmdzLCBhY2Nlc3NUb2tlbik7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkZldGNoZWQgVGFza3M6XCIsIHRhc2tzKTtcblxuXHRcdFx0Y29uc3QgY3VycmVudERhdGEgPSAoYXdhaXQgdGhpcy5sb2FkRGF0YSgpKSB8fCB7fTtcblx0XHRcdGN1cnJlbnREYXRhLnRhc2tzID0gQXJyYXkuZnJvbSh0YXNrcy5lbnRyaWVzKCkpO1xuXG5cdFx0XHR0aGlzLnRhc2tDYWNoZSA9IGN1cnJlbnREYXRhO1xuXHRcdFx0YXdhaXQgdGhpcy5zYXZlRGF0YShjdXJyZW50RGF0YSk7XG5cblx0XHRcdHJldHVybiB0YXNrcztcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHRhc2tzOlwiLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlIHRoZSBkZWxldGVUYXNrIGFwaSBmdW5jdGlvbiB0byBkZWxldGUgYWxsIGNvbXBsZXRlZCB0YXNrIGluIHRoZSB0YXJnZXRlZCB0YXNrIGxpc3QuXG5cdCAqIEByZXR1cm5zIEFtb3VudCBvZiBkZWxldGVkIHRhc2tzLlxuXHQgKi9cblx0YXN5bmMgZGVsZXRlQWxsQ29tcGxldGVkVGFza3MoKTogUHJvbWlzZTxudW1iZXI+IHtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3Muc2VsZWN0ZWRUYXNrTGlzdElkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFwiTm8gdGFzayBsaXN0IHNlbGVjdGVkLiBQbGVhc2UgY2hvb3NlIG9uZSBpbiBzZXR0aW5ncy5cIixcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IGRlbGV0ZWRUYXNrc0NvdW50ID0gMDtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XG5cdFx0XHRjb25zdCB0YXNrcyA9IGF3YWl0IHRoaXMuZ2V0VGFza3NGcm9tU2VsZWN0ZWRMaXN0KCk7XG5cdFx0XHRjb25zdCBjb21wbGV0ZWRUYXNrcyA9IEFycmF5LmZyb20odGFza3MudmFsdWVzKCkpLmZpbHRlcihcblx0XHRcdFx0KHRhc2spID0+IHRhc2suc3RhdHVzID09PSBcImNvbXBsZXRlZFwiLFxuXHRcdFx0KTtcblxuXHRcdFx0Zm9yIChjb25zdCB0YXNrIG9mIGNvbXBsZXRlZFRhc2tzKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiRGVsZXRpbmcgVGFzazpcIiwgdGFzayk7XG5cdFx0XHRcdGF3YWl0IGRlbGV0ZVRhc2sodGhpcy5zZXR0aW5ncywgYWNjZXNzVG9rZW4sIHRhc2suaWQpO1xuXHRcdFx0XHRkZWxldGVkVGFza3NDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlZnJlc2hWaWV3QW5kQ2FjaGUoKTtcblx0XHRcdHJldHVybiBkZWxldGVkVGFza3NDb3VudDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGRlbGV0aW5nIHRhc2tzOlwiLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gZGVsZXRlZFRhc2tzQ291bnQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgc2lkZWJhciB2aWV3IGFuZCB0YXNrIGNhY2hlIHRvIGRpc3BsYXkgdGhlIGxhdGVzdCB0YXNrcy5cblx0ICovXG5cdGFzeW5jIHJlZnJlc2hWaWV3QW5kQ2FjaGUoKSB7XG5cdFx0Y29uc3QgdGFza3MgPSBhd2FpdCB0aGlzLnJlZnJlc2hUYXNrQ2FjaGUoKTtcblx0XHRpZiAodGhpcy5zaWRlYmFyVmlldykge1xuXHRcdFx0YXdhaXQgdGhpcy5zaWRlYmFyVmlldy5yZW5kZXIodGFza3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJTaWRlYmFyIHZpZXcgaXMgbm90IGFjdGl2ZS5cIik7XG5cdFx0fVxuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgVGFza1N5bmNlclBsdWdpbiBmcm9tIFwic3JjL21haW5cIjtcblxuZXhwb3J0IGludGVyZmFjZSBNeVRvZG9TZXR0aW5ncyB7XG5cdHNlbGVjdGVkVGFza0xpc3RJZDogc3RyaW5nO1xuXHQvLyBBIGxpc3Qgb2YgYXZhaWxhYmxlIHRhc2sgbGlzdHMsIGVhY2ggd2l0aCBhbiBpZCBhbmQgZGlzcGxheSBuYW1lLlxuXHR0YXNrTGlzdHM6IEFycmF5PHsgaWQ6IHN0cmluZzsgdGl0bGU6IHN0cmluZyB9Pjtcblx0Y2xpZW50SWQ6IHN0cmluZztcblx0Y2xpZW50U2VjcmV0OiBzdHJpbmc7XG5cdHJlZGlyZWN0VXJsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVRvZG9TZXR0aW5ncyA9IHtcblx0c2VsZWN0ZWRUYXNrTGlzdElkOiBcIlwiLFxuXHR0YXNrTGlzdHM6IFtdLFxuXHRjbGllbnRJZDogXCJcIixcblx0Y2xpZW50U2VjcmV0OiBcIlwiLFxuXHRyZWRpcmVjdFVybDogXCJodHRwOi8vbG9jYWxob3N0OjUwMDBcIixcbn07XG5cbmV4cG9ydCBjbGFzcyBNeVRvZG9TZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogVGFza1N5bmNlclBsdWdpbjtcblx0c2V0dGluZ3M6IE15VG9kb1NldHRpbmdzO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFRhc2tTeW5jZXJQbHVnaW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHBsdWdpbi5zZXR0aW5ncztcblx0fVxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIk1pY3Jvc29mdCBUb1x1MjAxMURvIFNldHRpbmdzXCIgfSk7XG5cblx0XHQvLyBBZGQgYSBzZWN0aW9uIGZvciBlbnRlcmluZyBjbGllbnQgSUQgYW5kIHNlY3JldC5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiQ2xpZW50IERldGFpbHNcIilcblx0XHRcdC5zZXREZXNjKFxuXHRcdFx0XHRcIkVudGVyIHRoZSBjbGllbnQgSUQgYW5kIGNsaWVudCBzZWNyZXQgb2YgeW91ciBBenVyZSBBRCBhcHAuXCIsXG5cdFx0XHQpXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT5cblx0XHRcdFx0dGV4dFxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihcIkNsaWVudCBJRFwiKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbGllbnRJZClcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbGllbnRJZCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0fSksXG5cdFx0XHQpXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT5cblx0XHRcdFx0dGV4dFxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihcIkNsaWVudCBTZWNyZXRcIilcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2xpZW50U2VjcmV0KVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmNsaWVudFNlY3JldCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0fSksXG5cdFx0XHQpO1xuXG5cdFx0Ly8gQWRkIGEgc2VjdGlvbiBmb3IgVVJMIHRvIHJlZGlyZWN0IHRvIGFmdGVyIGF1dGhlbnRpY2F0aW9uLlxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJSZWRpcmVjdCBVUkxcIilcblx0XHRcdC5zZXREZXNjKFwiRW50ZXIgdGhlIFVSTCB0byByZWRpcmVjdCB0byBhZnRlciBhdXRoZW50aWNhdGlvbi5cIilcblx0XHRcdC5hZGRUZXh0KCh0ZXh0KSA9PlxuXHRcdFx0XHR0ZXh0XG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKFwiaHR0cDovL2xvY2FsaG9zdDo1MDAwXCIpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlZGlyZWN0VXJsKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJlZGlyZWN0VXJsID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHR9KSxcblx0XHRcdCk7XG5cblx0XHQvLyBBZGQgYSBidXR0b24gdG8gZ2V0IHRoZSB0YXNrIGxpc3RzLlxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJHZXQgVGFzayBMaXN0c1wiKVxuXHRcdFx0LnNldERlc2MoXCJDbGljayB0byBnZXQgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRhc2sgbGlzdHMuXCIpXG5cdFx0XHQuYWRkQnV0dG9uKChidXR0b24pID0+IHtcblx0XHRcdFx0YnV0dG9uLnNldEJ1dHRvblRleHQoXCJHZXQgVGFzayBMaXN0c1wiKS5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5sb2FkQXZhaWxhYmxlVGFza0xpc3RzKCk7XG5cdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHQvLyBBZGQgYSBkcm9wZG93biB0byBzZWxlY3QgdGhlIHRhc2tcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiVGFzayBMaXN0XCIpXG5cdFx0XHQuc2V0RGVzYyhcblx0XHRcdFx0XCJTZWxlY3QgdGhlIE1pY3Jvc29mdCBUb1x1MjAxMURvIGxpc3QgdG8gc3RvcmUgeW91ciBPYnNpZGlhbiB0YXNrcy5cIixcblx0XHRcdClcblx0XHRcdC5hZGREcm9wZG93bigoZHJvcCkgPT4ge1xuXHRcdFx0XHQvLyBBZGQgYSBkZWZhdWx0IG9wdGlvbi5cblx0XHRcdFx0ZHJvcC5hZGRPcHRpb24oXCJcIiwgXCJTZWxlY3QgYSB0YXNrIGxpc3RcIik7XG5cblx0XHRcdFx0Ly8gUG9wdWxhdGUgZHJvcGRvd24gd2l0aCBhdmFpbGFibGUgdGFzayBsaXN0cy5cblx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MudGFza0xpc3RzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLnRhc2tMaXN0cy5mb3JFYWNoKChsaXN0KSA9PiB7XG5cdFx0XHRcdFx0XHRkcm9wLmFkZE9wdGlvbihsaXN0LmlkLCBsaXN0LnRpdGxlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBPcHRpb25hbGx5LCBpbmZvcm0gdGhlIHVzZXIgbm8gdGFzayBsaXN0cyBhcmUgYXZhaWxhYmxlLlxuXHRcdFx0XHRcdGRyb3AuYWRkT3B0aW9uKFwibm9uZVwiLCBcIk5vIHRhc2sgbGlzdHMgYXZhaWxhYmxlXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBjdXJyZW50IHZhbHVlLlxuXHRcdFx0XHRkcm9wLnNldFZhbHVlKHRoaXMuc2V0dGluZ3Muc2VsZWN0ZWRUYXNrTGlzdElkKTtcblx0XHRcdFx0ZHJvcC5vbkNoYW5nZShhc3luYyAodmFsdWU6IHN0cmluZykgPT4ge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc2VsZWN0ZWRUYXNrTGlzdElkID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBJdGVtVmlldywgV29ya3NwYWNlTGVhZiB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHR5cGUgVGFza1N5bmNlclBsdWdpbiBmcm9tIFwic3JjL21haW5cIjtcbmltcG9ydCB7IG5vdGlmeSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBWSUVXX1RZUEVfVE9ET19TSURFQkFSID0gXCJ0YXNrcy1zeW5jZXItc2lkZWJhclwiO1xuXG5leHBvcnQgY2xhc3MgVGFza1NpZGViYXJWaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xuXHRwbHVnaW46IFRhc2tTeW5jZXJQbHVnaW47XG5cblx0Y29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBUYXNrU3luY2VyUGx1Z2luKSB7XG5cdFx0c3VwZXIobGVhZik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRnZXRWaWV3VHlwZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiBWSUVXX1RZUEVfVE9ET19TSURFQkFSO1xuXHR9XG5cblx0Z2V0RGlzcGxheVRleHQoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCJUby1EbyBUYXNrc1wiO1xuXHR9XG5cblx0YXN5bmMgb25PcGVuKCkge1xuXHRcdHRoaXMucmVuZGVyKG5ldyBNYXAoKSk7XG5cdFx0dGhpcy5wbHVnaW5cblx0XHRcdC5nZXRUYXNrc0Zyb21TZWxlY3RlZExpc3QoKVxuXHRcdFx0LnRoZW4oKHRhc2tzKSA9PiB0aGlzLnJlbmRlcih0YXNrcykpXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHRhc2tzIGluIHNpZGViYXI6XCIsIGVycm9yKTtcblx0XHRcdFx0bm90aWZ5KFwiRXJyb3IgbG9hZGluZyB0YXNrcyBpbiBzaWRlYmFyXCIsIGVycm9yKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHVwIGJ1dHRvbiBmb3IgcmVmcmVzaGluZyBzaWRlYmFyIHRhc2tzLlxuXHQgKiBAcGFyYW0gQ29udGFpbmVyIGZvciBidXR0b25cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgc2V0dXBSZWZyZXNoQnV0dG9uKGNvbnRhaW5lcjogRWxlbWVudCkge1xuXHRcdGNvbnN0IGJ1dHRvbiA9IGNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiUmVmcmVzaCBUYXNrc1wiIH0pO1xuXHRcdGJ1dHRvbi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuXHRcdFx0bm90aWZ5KFwiUmVmcmVzaGluZyB0YXNrcy4uLlwiKTtcblx0XHRcdGNvbnN0IHRhc2tzID0gYXdhaXQgdGhpcy5wbHVnaW4ucmVmcmVzaFRhc2tDYWNoZSgpO1xuXHRcdFx0dGhpcy5yZW5kZXIodGFza3MpO1xuXHRcdFx0bm90aWZ5KFwiVGFzayByZWZyZXNoZWQhXCIsIFwic3VjY2Vzc1wiKTtcblx0XHR9O1xuXHR9XG5cblx0YXN5bmMgcmVuZGVyKFxuXHRcdHRhc2tzOiBNYXA8c3RyaW5nLCB7IHRpdGxlOiBzdHJpbmc7IHN0YXR1czogc3RyaW5nOyBpZDogc3RyaW5nIH0+LFxuXHQpIHtcblx0XHRjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdO1xuXHRcdGNvbnRhaW5lci5lbXB0eSgpO1xuXG5cdFx0dGhpcy5zZXR1cFJlZnJlc2hCdXR0b24oY29udGFpbmVyKTtcblxuXHRcdGNvbnRhaW5lci5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJUYXNrc1wiIH0pO1xuXG5cdFx0aWYgKHRhc2tzLnNpemUgPT09IDApIHtcblx0XHRcdGNvbnRhaW5lci5jcmVhdGVFbChcInBcIiwge1xuXHRcdFx0XHR0ZXh0OiBcIk5vIHRhc2tzIGZvdW5kIG9yIG5vdCBhdXRoZW50aWNhdGVkLlwiLFxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0QXJyYXkuZnJvbSh0YXNrcy52YWx1ZXMoKSlcblx0XHRcdC5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRcdC8vIE1vdmUgY29tcGxldGVkIHRhc2tzIHRvIHRoZSBib3R0b21cblx0XHRcdFx0aWYgKGEuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiICYmIGIuc3RhdHVzICE9PSBcImNvbXBsZXRlZFwiKVxuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHRpZiAoYS5zdGF0dXMgIT09IFwiY29tcGxldGVkXCIgJiYgYi5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpXG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHRyZXR1cm4gMDsgLy8gS2VlcCBvcmlnaW5hbCBvcmRlciBvdGhlcndpc2Vcblx0XHRcdH0pXG5cdFx0XHQuZm9yRWFjaCgodGFzaykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaW5lID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcInRhc2stbGluZVwiIH0pO1xuXG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94ID0gbGluZS5jcmVhdGVFbChcImlucHV0XCIsIHtcblx0XHRcdFx0XHR0eXBlOiBcImNoZWNrYm94XCIsXG5cdFx0XHRcdH0pIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0XHRcdFx0Y2hlY2tib3guY2hlY2tlZCA9IHRhc2suc3RhdHVzID09PSBcImNvbXBsZXRlZFwiO1xuXHRcdFx0XHRjaGVja2JveC5kaXNhYmxlZCA9IHRydWU7XG5cblx0XHRcdFx0bGluZS5jcmVhdGVFbChcInNwYW5cIiwge1xuXHRcdFx0XHRcdHRleHQ6IHRhc2sudGl0bGUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdH1cblx0YXN5bmMgb25DbG9zZSgpIHtcblx0XHQvLyBPcHRpb25hbCBjbGVhbnVwXG5cdH1cbn1cbiIsICJpbXBvcnQgeyBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuLyoqXG4gKiBEaXNwbGF5IGEgbm90aWZpY2F0aW9uIGluIE9ic2lkaWFuIHdpdGggb3B0aW9uYWwgdHlwZS1iYXNlZCBwcmVmaXguXG4gKiBAcGFyYW0gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gc2hvd1xuICogQHBhcmFtIHR5cGUgLSBPbmUgb2YgXCJlcnJvclwiLCBcIndhcm5pbmdcIiwgXCJzdWNjZXNzXCIsIFwiaW5mb1wiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RpZnkoXG5cdG1lc3NhZ2U6IHN0cmluZyxcblx0dHlwZTogXCJlcnJvclwiIHwgXCJ3YXJuaW5nXCIgfCBcInN1Y2Nlc3NcIiB8IFwiaW5mb1wiID0gXCJpbmZvXCIsXG4pOiB2b2lkIHtcblx0bGV0IHByZWZpeCA9IFwiXCI7XG5cdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgXCJlcnJvclwiOlxuXHRcdFx0cHJlZml4ID0gXCJcdTI3NEMgXCI7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwid2FybmluZ1wiOlxuXHRcdFx0cHJlZml4ID0gXCJcdTI2QTBcdUZFMEYgXCI7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwic3VjY2Vzc1wiOlxuXHRcdFx0cHJlZml4ID0gXCJcdTI3MDUgXCI7XG5cdFx0XHRicmVhaztcblx0fVxuXHRuZXcgTm90aWNlKGAke3ByZWZpeH0ke21lc3NhZ2V9YCk7XG59XG4iLCAiaW1wb3J0IHsgcmVxdWVzdFVybCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgTXlUb2RvU2V0dGluZ3MgfSBmcm9tIFwic3JjL3NldHRpbmdcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNU1Rhc2sge1xuXHR0aXRsZTogc3RyaW5nO1xuXHRzdGF0dXM6IHN0cmluZztcblx0aWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBGZXRjaGVzIHRhc2tzIGZyb20gdGhlIHNlbGVjdGVkIE1pY3Jvc29mdCBUb1x1MjAxMURvIGxpc3QuXG4gKiBAcGFyYW0gc2V0dGluZ3MgUGx1Z2luIHNldHRpbmdzIHRoYXQgY29udGFpbiB0aGUgc2VsZWN0ZWQgdGFzayBsaXN0IElELlxuICogQHBhcmFtIGFjY2Vzc1Rva2VuIEEgdmFsaWQgYWNjZXNzIHRva2VuLlxuICogQHJldHVybnMgQSBtYXAgb2YgdGFzayB0aXRsZSB0byBNU1Rhc2suXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRhc2tzKFxuXHRzZXR0aW5nczogTXlUb2RvU2V0dGluZ3MsXG5cdGFjY2Vzc1Rva2VuOiBzdHJpbmcsXG4pOiBQcm9taXNlPE1hcDxzdHJpbmcsIE1TVGFzaz4+IHtcblx0Y29uc3QgdGFza3MgPSBuZXcgTWFwPHN0cmluZywgTVNUYXNrPigpO1xuXHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuXHRcdHVybDogYGh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS92MS4wL21lL3RvZG8vbGlzdHMvJHtzZXR0aW5ncy5zZWxlY3RlZFRhc2tMaXN0SWR9L3Rhc2tzYCxcblx0XHRtZXRob2Q6IFwiR0VUXCIsXG5cdFx0aGVhZGVyczogeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCB9LFxuXHR9KTtcblxuXHRpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggdGFza3M6IFwiICsgcmVzcG9uc2UudGV4dCk7XG5cdH1cblxuXHRjb25zdCBkYXRhID0gcmVzcG9uc2UuanNvbjtcblx0aWYgKGRhdGEudmFsdWUgJiYgQXJyYXkuaXNBcnJheShkYXRhLnZhbHVlKSkge1xuXHRcdGZvciAoY29uc3QgdGFzayBvZiBkYXRhLnZhbHVlKSB7XG5cdFx0XHRjb25zdCB0aXRsZSA9IHRhc2sudGl0bGUudHJpbSgpO1xuXHRcdFx0dGFza3Muc2V0KHRpdGxlLCB7IHRpdGxlLCBzdGF0dXM6IHRhc2suc3RhdHVzLCBpZDogdGFzay5pZCB9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGFza3M7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIGluIE1pY3Jvc29mdCBUb1x1MjAxMURvLlxuICogQHBhcmFtIHNldHRpbmdzIFBsdWdpbiBzZXR0aW5ncyBjb250YWluaW5nIHRoZSBzZWxlY3RlZCB0YXNrIGxpc3QgSUQuXG4gKiBAcGFyYW0gYWNjZXNzVG9rZW4gQSB2YWxpZCBhY2Nlc3MgdG9rZW4uXG4gKiBAcGFyYW0gdGFza1RpdGxlIFRoZSB0aXRsZSBvZiB0aGUgdGFzayB0byBjcmVhdGUuXG4gKiBAcGFyYW0gc3RhdHVzIE9wdGlvbmFsIGluaXRpYWwgc3RhdHVzIChcImNvbXBsZXRlZFwiIG9yIFwibm90U3RhcnRlZFwiKS4gRGVmYXVsdHMgdG8gXCJub3RTdGFydGVkXCIuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUYXNrKFxuXHRzZXR0aW5nczogTXlUb2RvU2V0dGluZ3MsXG5cdGFjY2Vzc1Rva2VuOiBzdHJpbmcsXG5cdHRhc2tUaXRsZTogc3RyaW5nLFxuXHRzdGF0dXM6IHN0cmluZyA9IFwibm90U3RhcnRlZFwiLFxuKTogUHJvbWlzZTx2b2lkPiB7XG5cdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG5cdFx0dXJsOiBgaHR0cHM6Ly9ncmFwaC5taWNyb3NvZnQuY29tL3YxLjAvbWUvdG9kby9saXN0cy8ke3NldHRpbmdzLnNlbGVjdGVkVGFza0xpc3RJZH0vdGFza3NgLFxuXHRcdG1ldGhvZDogXCJQT1NUXCIsXG5cdFx0aGVhZGVyczoge1xuXHRcdFx0QXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXG5cdFx0XHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcblx0XHR9LFxuXHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdHRpdGxlOiB0YXNrVGl0bGUsXG5cdFx0XHRzdGF0dXM6IHN0YXR1cyxcblx0XHR9KSxcblx0fSk7XG5cblx0aWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAxKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHRhc2s6ICR7cmVzcG9uc2UudGV4dH1gKTtcblx0fVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGFzaydzIHN0YXR1cy5cbiAqIEBwYXJhbSBzZXR0aW5ncyBQbHVnaW4gc2V0dGluZ3MgY29udGFpbmluZyB0aGUgc2VsZWN0ZWQgdGFzayBsaXN0IElELlxuICogQHBhcmFtIGFjY2Vzc1Rva2VuIEEgdmFsaWQgYWNjZXNzIHRva2VuLlxuICogQHBhcmFtIHRhc2tJZCBUaGUgSUQgb2YgdGhlIHRhc2sgdG8gdXBkYXRlLlxuICogQHBhcmFtIGNvbXBsZXRlIFdoZXRoZXIgdG8gbWFyayB0aGUgdGFzayBhcyBjb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRhc2soXG5cdHNldHRpbmdzOiBNeVRvZG9TZXR0aW5ncyxcblx0YWNjZXNzVG9rZW46IHN0cmluZyxcblx0dGFza0lkOiBzdHJpbmcsXG5cdGNvbXBsZXRlOiBib29sZWFuLFxuKTogUHJvbWlzZTx2b2lkPiB7XG5cdGNvbnN0IG5ld1N0YXR1cyA9IGNvbXBsZXRlID8gXCJjb21wbGV0ZWRcIiA6IFwibm90U3RhcnRlZFwiO1xuXHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuXHRcdHVybDogYGh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS92MS4wL21lL3RvZG8vbGlzdHMvJHtzZXR0aW5ncy5zZWxlY3RlZFRhc2tMaXN0SWR9L3Rhc2tzLyR7dGFza0lkfWAsXG5cdFx0bWV0aG9kOiBcIlBBVENIXCIsXG5cdFx0aGVhZGVyczoge1xuXHRcdFx0QXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXG5cdFx0XHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcblx0XHR9LFxuXHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc3RhdHVzOiBuZXdTdGF0dXMgfSksXG5cdH0pO1xuXG5cdGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSB0YXNrOiAke3Jlc3BvbnNlLnRleHR9YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIHRoZSBhdmFpbGFibGUgTWljcm9zb2Z0IFRvXHUyMDExRG8gdGFzayBsaXN0cy5cbiAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBBIHZhbGlkIGFjY2VzcyB0b2tlbi5cbiAqIEByZXR1cm5zIEEgbWFwIHdoZXJlIGVhY2gga2V5IGlzIHRoZSB0YXNrIGxpc3QgdGl0bGUgYW5kIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aXRsZSwgc3RhdHVzIChkZWZhdWx0KSwgYW5kIGlkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUYXNrTGlzdHMoXG5cdGFjY2Vzc1Rva2VuOiBzdHJpbmcsXG4pOiBQcm9taXNlPEFycmF5PHsgdGl0bGU6IHN0cmluZzsgaWQ6IHN0cmluZyB9Pj4ge1xuXHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuXHRcdHVybDogXCJodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdjEuMC9tZS90b2RvL2xpc3RzXCIsXG5cdFx0bWV0aG9kOiBcIkdFVFwiLFxuXHRcdGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAgfSxcblx0fSk7XG5cblx0aWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHRhc2sgbGlzdHM6IFwiICsgcmVzcG9uc2UudGV4dCk7XG5cdH1cblxuXHRjb25zdCBkYXRhID0gcmVzcG9uc2UuanNvbjtcblx0Y29uc3QgdGFza0xpc3RzID0gbmV3IEFycmF5PHsgdGl0bGU6IHN0cmluZzsgaWQ6IHN0cmluZyB9PigpO1xuXG5cdGNvbnNvbGUubG9nKFwiVGFzayBsaXN0cyBkYXRhOlwiLCBkYXRhKTtcblx0aWYgKGRhdGEudmFsdWUgJiYgQXJyYXkuaXNBcnJheShkYXRhLnZhbHVlKSkge1xuXHRcdGZvciAoY29uc3QgbGlzdCBvZiBkYXRhLnZhbHVlKSB7XG5cdFx0XHR0YXNrTGlzdHMucHVzaCh7IHRpdGxlOiBsaXN0LmRpc3BsYXlOYW1lLCBpZDogbGlzdC5pZCB9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGFza0xpc3RzO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgYSB0YXNrIGZyb20gTWljcm9zb2Z0IFRvXHUyMDExRG8uXG4gKiBAcGFyYW0gc2V0dGluZ3MgUGx1Z2luIHNldHRpbmdzIGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIHRhc2sgbGlzdCBJRC5cbiAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBBIHZhbGlkIGFjY2VzcyB0b2tlbi5cbiAqIEBwYXJhbSB0YXNrSWQgVGhlIElEIG9mIHRoZSB0YXNrIHRvIGRlbGV0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRhc2soXG5cdHNldHRpbmdzOiBNeVRvZG9TZXR0aW5ncyxcblx0YWNjZXNzVG9rZW46IHN0cmluZyxcblx0dGFza0lkOiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+IHtcblx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHtcblx0XHR1cmw6IGBodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdjEuMC9tZS90b2RvL2xpc3RzLyR7c2V0dGluZ3Muc2VsZWN0ZWRUYXNrTGlzdElkfS90YXNrcy8ke3Rhc2tJZH1gLFxuXHRcdG1ldGhvZDogXCJERUxFVEVcIixcblx0XHRoZWFkZXJzOiB7XG5cdFx0XHRBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcblx0XHRcdFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuXHRcdH0sXG5cdH0pO1xuXG5cdGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwNCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSB0YXNrOiAke3Jlc3BvbnNlLnRleHR9YCk7XG5cdH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBBY2NvdW50Q2FjaGUsXG4gICAgSWRUb2tlbkNhY2hlLFxuICAgIEFjY2Vzc1Rva2VuQ2FjaGUsXG4gICAgUmVmcmVzaFRva2VuQ2FjaGUsXG4gICAgQXBwTWV0YWRhdGFDYWNoZSxcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQge1xuICAgIEluTWVtb3J5Q2FjaGUsXG4gICAgSnNvbkNhY2hlLFxuICAgIFNlcmlhbGl6ZWRBY2NvdW50RW50aXR5LFxuICAgIFNlcmlhbGl6ZWRJZFRva2VuRW50aXR5LFxuICAgIFNlcmlhbGl6ZWRBY2Nlc3NUb2tlbkVudGl0eSxcbiAgICBTZXJpYWxpemVkUmVmcmVzaFRva2VuRW50aXR5LFxuICAgIFNlcmlhbGl6ZWRBcHBNZXRhZGF0YUVudGl0eSxcbn0gZnJvbSBcIi4vU2VyaWFsaXplclR5cGVzLmpzXCI7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBzZXJpYWxpemVzIGNhY2hlIGVudGl0aWVzIHRvIGJlIHNhdmVkIGludG8gaW4tbWVtb3J5IG9iamVjdCB0eXBlcyBkZWZpbmVkIGludGVybmFsbHlcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgU2VyaWFsaXplciB7XG4gICAgLyoqXG4gICAgICogc2VyaWFsaXplIHRoZSBKU09OIGJsb2JcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEpTT04gYmxvYiBjYWNoZVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXJpYWxpemVKU09OQmxvYihkYXRhOiBKc29uQ2FjaGUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIEFjY291bnRzXG4gICAgICogQHBhcmFtIGFjY0NhY2hlIC0gY2FjaGUgb2YgYWNjb3VudHNcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VyaWFsaXplQWNjb3VudHMoXG4gICAgICAgIGFjY0NhY2hlOiBBY2NvdW50Q2FjaGVcbiAgICApOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkQWNjb3VudEVudGl0eT4ge1xuICAgICAgICBjb25zdCBhY2NvdW50czogUmVjb3JkPHN0cmluZywgU2VyaWFsaXplZEFjY291bnRFbnRpdHk+ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGFjY0NhY2hlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudEVudGl0eSA9IGFjY0NhY2hlW2tleV07XG4gICAgICAgICAgICBhY2NvdW50c1trZXldID0ge1xuICAgICAgICAgICAgICAgIGhvbWVfYWNjb3VudF9pZDogYWNjb3VudEVudGl0eS5ob21lQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBhY2NvdW50RW50aXR5LmVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHJlYWxtOiBhY2NvdW50RW50aXR5LnJlYWxtLFxuICAgICAgICAgICAgICAgIGxvY2FsX2FjY291bnRfaWQ6IGFjY291bnRFbnRpdHkubG9jYWxBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IGFjY291bnRFbnRpdHkudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5X3R5cGU6IGFjY291bnRFbnRpdHkuYXV0aG9yaXR5VHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBhY2NvdW50RW50aXR5Lm5hbWUsXG4gICAgICAgICAgICAgICAgY2xpZW50X2luZm86IGFjY291bnRFbnRpdHkuY2xpZW50SW5mbyxcbiAgICAgICAgICAgICAgICBsYXN0X21vZGlmaWNhdGlvbl90aW1lOiBhY2NvdW50RW50aXR5Lmxhc3RNb2RpZmljYXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIGxhc3RfbW9kaWZpY2F0aW9uX2FwcDogYWNjb3VudEVudGl0eS5sYXN0TW9kaWZpY2F0aW9uQXBwLFxuICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGVzOiBhY2NvdW50RW50aXR5LnRlbmFudFByb2ZpbGVzPy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICh0ZW5hbnRQcm9maWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGVuYW50UHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSBJZFRva2Vuc1xuICAgICAqIEBwYXJhbSBpZFRDYWNoZSAtIGNhY2hlIG9mIElEIHRva2Vuc1xuICAgICAqL1xuICAgIHN0YXRpYyBzZXJpYWxpemVJZFRva2VucyhcbiAgICAgICAgaWRUQ2FjaGU6IElkVG9rZW5DYWNoZVxuICAgICk6IFJlY29yZDxzdHJpbmcsIFNlcmlhbGl6ZWRJZFRva2VuRW50aXR5PiB7XG4gICAgICAgIGNvbnN0IGlkVG9rZW5zOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkSWRUb2tlbkVudGl0eT4gPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWRUQ2FjaGUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBpZFRFbnRpdHkgPSBpZFRDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWRUb2tlbnNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBob21lX2FjY291bnRfaWQ6IGlkVEVudGl0eS5ob21lQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBpZFRFbnRpdHkuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbF90eXBlOiBpZFRFbnRpdHkuY3JlZGVudGlhbFR5cGUsXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiBpZFRFbnRpdHkuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgc2VjcmV0OiBpZFRFbnRpdHkuc2VjcmV0LFxuICAgICAgICAgICAgICAgIHJlYWxtOiBpZFRFbnRpdHkucmVhbG0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaWRUb2tlbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBBY2Nlc3NUb2tlbnNcbiAgICAgKiBAcGFyYW0gYXRDYWNoZSAtIGNhY2hlIG9mIGFjY2VzcyB0b2tlbnNcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VyaWFsaXplQWNjZXNzVG9rZW5zKFxuICAgICAgICBhdENhY2hlOiBBY2Nlc3NUb2tlbkNhY2hlXG4gICAgKTogUmVjb3JkPHN0cmluZywgU2VyaWFsaXplZEFjY2Vzc1Rva2VuRW50aXR5PiB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuczogUmVjb3JkPHN0cmluZywgU2VyaWFsaXplZEFjY2Vzc1Rva2VuRW50aXR5PiA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhhdENhY2hlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgYXRFbnRpdHkgPSBhdENhY2hlW2tleV07XG4gICAgICAgICAgICBhY2Nlc3NUb2tlbnNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBob21lX2FjY291bnRfaWQ6IGF0RW50aXR5LmhvbWVBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGF0RW50aXR5LmVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfdHlwZTogYXRFbnRpdHkuY3JlZGVudGlhbFR5cGUsXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiBhdEVudGl0eS5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IGF0RW50aXR5LnNlY3JldCxcbiAgICAgICAgICAgICAgICByZWFsbTogYXRFbnRpdHkucmVhbG0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhdEVudGl0eS50YXJnZXQsXG4gICAgICAgICAgICAgICAgY2FjaGVkX2F0OiBhdEVudGl0eS5jYWNoZWRBdCxcbiAgICAgICAgICAgICAgICBleHBpcmVzX29uOiBhdEVudGl0eS5leHBpcmVzT24sXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRfZXhwaXJlc19vbjogYXRFbnRpdHkuZXh0ZW5kZWRFeHBpcmVzT24sXG4gICAgICAgICAgICAgICAgcmVmcmVzaF9vbjogYXRFbnRpdHkucmVmcmVzaE9uLFxuICAgICAgICAgICAgICAgIGtleV9pZDogYXRFbnRpdHkua2V5SWQsXG4gICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogYXRFbnRpdHkudG9rZW5UeXBlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZENsYWltczogYXRFbnRpdHkucmVxdWVzdGVkQ2xhaW1zLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZENsYWltc0hhc2g6IGF0RW50aXR5LnJlcXVlc3RlZENsYWltc0hhc2gsXG4gICAgICAgICAgICAgICAgdXNlckFzc2VydGlvbkhhc2g6IGF0RW50aXR5LnVzZXJBc3NlcnRpb25IYXNoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgcmVmcmVzaFRva2Vuc1xuICAgICAqIEBwYXJhbSBydENhY2hlIC0gY2FjaGUgb2YgcmVmcmVzaCB0b2tlbnNcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VyaWFsaXplUmVmcmVzaFRva2VucyhcbiAgICAgICAgcnRDYWNoZTogUmVmcmVzaFRva2VuQ2FjaGVcbiAgICApOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkUmVmcmVzaFRva2VuRW50aXR5PiB7XG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbnM6IFJlY29yZDxzdHJpbmcsIFNlcmlhbGl6ZWRSZWZyZXNoVG9rZW5FbnRpdHk+ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHJ0Q2FjaGUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBydEVudGl0eSA9IHJ0Q2FjaGVba2V5XTtcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbnNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBob21lX2FjY291bnRfaWQ6IHJ0RW50aXR5LmhvbWVBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHJ0RW50aXR5LmVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfdHlwZTogcnRFbnRpdHkuY3JlZGVudGlhbFR5cGUsXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiBydEVudGl0eS5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJ0RW50aXR5LnNlY3JldCxcbiAgICAgICAgICAgICAgICBmYW1pbHlfaWQ6IHJ0RW50aXR5LmZhbWlseUlkLFxuICAgICAgICAgICAgICAgIHRhcmdldDogcnRFbnRpdHkudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHJlYWxtOiBydEVudGl0eS5yZWFsbSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWZyZXNoVG9rZW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSBhbWR0Q2FjaGVcbiAgICAgKiBAcGFyYW0gYW1kdENhY2hlIC0gY2FjaGUgb2YgYXBwIG1ldGFkYXRhXG4gICAgICovXG4gICAgc3RhdGljIHNlcmlhbGl6ZUFwcE1ldGFkYXRhKFxuICAgICAgICBhbWR0Q2FjaGU6IEFwcE1ldGFkYXRhQ2FjaGVcbiAgICApOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkQXBwTWV0YWRhdGFFbnRpdHk+IHtcbiAgICAgICAgY29uc3QgYXBwTWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIFNlcmlhbGl6ZWRBcHBNZXRhZGF0YUVudGl0eT4gPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoYW1kdENhY2hlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgYW1kdEVudGl0eSA9IGFtZHRDYWNoZVtrZXldO1xuICAgICAgICAgICAgYXBwTWV0YWRhdGFba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IGFtZHRFbnRpdHkuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGFtZHRFbnRpdHkuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgZmFtaWx5X2lkOiBhbWR0RW50aXR5LmZhbWlseUlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFwcE1ldGFkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgY2FjaGVcbiAgICAgKiBAcGFyYW0gaW5NZW1DYWNoZSAtIGl0ZW1pc2VkIGNhY2hlIHJlYWQgZnJvbSB0aGUgSlNPTlxuICAgICAqL1xuICAgIHN0YXRpYyBzZXJpYWxpemVBbGxDYWNoZShpbk1lbUNhY2hlOiBJbk1lbW9yeUNhY2hlKTogSnNvbkNhY2hlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEFjY291bnQ6IHRoaXMuc2VyaWFsaXplQWNjb3VudHMoaW5NZW1DYWNoZS5hY2NvdW50cyksXG4gICAgICAgICAgICBJZFRva2VuOiB0aGlzLnNlcmlhbGl6ZUlkVG9rZW5zKGluTWVtQ2FjaGUuaWRUb2tlbnMpLFxuICAgICAgICAgICAgQWNjZXNzVG9rZW46IHRoaXMuc2VyaWFsaXplQWNjZXNzVG9rZW5zKGluTWVtQ2FjaGUuYWNjZXNzVG9rZW5zKSxcbiAgICAgICAgICAgIFJlZnJlc2hUb2tlbjogdGhpcy5zZXJpYWxpemVSZWZyZXNoVG9rZW5zKGluTWVtQ2FjaGUucmVmcmVzaFRva2VucyksXG4gICAgICAgICAgICBBcHBNZXRhZGF0YTogdGhpcy5zZXJpYWxpemVBcHBNZXRhZGF0YShpbk1lbUNhY2hlLmFwcE1ldGFkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBDb25zdGFudHMgPSB7XG4gICAgTElCUkFSWV9OQU1FOiBcIk1TQUwuSlNcIixcbiAgICBTS1U6IFwibXNhbC5qcy5jb21tb25cIixcbiAgICAvLyBQcmVmaXggZm9yIGFsbCBsaWJyYXJ5IGNhY2hlIGVudHJpZXNcbiAgICBDQUNIRV9QUkVGSVg6IFwibXNhbFwiLFxuICAgIC8vIGRlZmF1bHQgYXV0aG9yaXR5XG4gICAgREVGQVVMVF9BVVRIT1JJVFk6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi9cIixcbiAgICBERUZBVUxUX0FVVEhPUklUWV9IT1NUOiBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb21cIixcbiAgICBERUZBVUxUX0NPTU1PTl9URU5BTlQ6IFwiY29tbW9uXCIsXG4gICAgLy8gQURGUyBTdHJpbmdcbiAgICBBREZTOiBcImFkZnNcIixcbiAgICBEU1RTOiBcImRzdHN2MlwiLFxuICAgIC8vIERlZmF1bHQgQUFEIEluc3RhbmNlIERpc2NvdmVyeSBFbmRwb2ludFxuICAgIEFBRF9JTlNUQU5DRV9ESVNDT1ZFUllfRU5EUFQ6XG4gICAgICAgIFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi9kaXNjb3ZlcnkvaW5zdGFuY2U/YXBpLXZlcnNpb249MS4xJmF1dGhvcml6YXRpb25fZW5kcG9pbnQ9XCIsXG4gICAgLy8gQ0lBTSBVUkxcbiAgICBDSUFNX0FVVEhfVVJMOiBcIi5jaWFtbG9naW4uY29tXCIsXG4gICAgQUFEX1RFTkFOVF9ET01BSU5fU1VGRklYOiBcIi5vbm1pY3Jvc29mdC5jb21cIixcbiAgICAvLyBSZXNvdXJjZSBkZWxpbWl0ZXIgLSB1c2VkIGZvciBjZXJ0YWluIGNhY2hlIGVudHJpZXNcbiAgICBSRVNPVVJDRV9ERUxJTTogXCJ8XCIsXG4gICAgLy8gUGxhY2Vob2xkZXIgZm9yIG5vbi1leGlzdGVudCBhY2NvdW50IGlkcy9vYmplY3RzXG4gICAgTk9fQUNDT1VOVDogXCJOT19BQ0NPVU5UXCIsXG4gICAgLy8gQ2xhaW1zXG4gICAgQ0xBSU1TOiBcImNsYWltc1wiLFxuICAgIC8vIENvbnN1bWVyIFVUSURcbiAgICBDT05TVU1FUl9VVElEOiBcIjkxODgwNDBkLTZjNjctNGM1Yi1iMTEyLTM2YTMwNGI2NmRhZFwiLFxuICAgIC8vIERlZmF1bHQgc2NvcGVzXG4gICAgT1BFTklEX1NDT1BFOiBcIm9wZW5pZFwiLFxuICAgIFBST0ZJTEVfU0NPUEU6IFwicHJvZmlsZVwiLFxuICAgIE9GRkxJTkVfQUNDRVNTX1NDT1BFOiBcIm9mZmxpbmVfYWNjZXNzXCIsXG4gICAgRU1BSUxfU0NPUEU6IFwiZW1haWxcIixcbiAgICBDT0RFX0dSQU5UX1RZUEU6IFwiYXV0aG9yaXphdGlvbl9jb2RlXCIsXG4gICAgUlRfR1JBTlRfVFlQRTogXCJyZWZyZXNoX3Rva2VuXCIsXG4gICAgUzI1Nl9DT0RFX0NIQUxMRU5HRV9NRVRIT0Q6IFwiUzI1NlwiLFxuICAgIFVSTF9GT1JNX0NPTlRFTlRfVFlQRTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOFwiLFxuICAgIEFVVEhPUklaQVRJT05fUEVORElORzogXCJhdXRob3JpemF0aW9uX3BlbmRpbmdcIixcbiAgICBOT1RfREVGSU5FRDogXCJub3RfZGVmaW5lZFwiLFxuICAgIEVNUFRZX1NUUklORzogXCJcIixcbiAgICBOT1RfQVBQTElDQUJMRTogXCJOL0FcIixcbiAgICBOT1RfQVZBSUxBQkxFOiBcIk5vdCBBdmFpbGFibGVcIixcbiAgICBGT1JXQVJEX1NMQVNIOiBcIi9cIixcbiAgICBJTURTX0VORFBPSU5UOiBcImh0dHA6Ly8xNjkuMjU0LjE2OS4yNTQvbWV0YWRhdGEvaW5zdGFuY2UvY29tcHV0ZS9sb2NhdGlvblwiLFxuICAgIElNRFNfVkVSU0lPTjogXCIyMDIwLTA2LTAxXCIsXG4gICAgSU1EU19USU1FT1VUOiAyMDAwLFxuICAgIEFaVVJFX1JFR0lPTl9BVVRPX0RJU0NPVkVSX0ZMQUc6IFwiVHJ5QXV0b0RldGVjdFwiLFxuICAgIFJFR0lPTkFMX0FVVEhfUFVCTElDX0NMT1VEX1NVRkZJWDogXCJsb2dpbi5taWNyb3NvZnQuY29tXCIsXG4gICAgS05PV05fUFVCTElDX0NMT1VEUzogW1xuICAgICAgICBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb21cIixcbiAgICAgICAgXCJsb2dpbi53aW5kb3dzLm5ldFwiLFxuICAgICAgICBcImxvZ2luLm1pY3Jvc29mdC5jb21cIixcbiAgICAgICAgXCJzdHMud2luZG93cy5uZXRcIixcbiAgICBdLFxuICAgIFNIUl9OT05DRV9WQUxJRElUWTogMjQwLFxuICAgIElOVkFMSURfSU5TVEFOQ0U6IFwiaW52YWxpZF9pbnN0YW5jZVwiLFxufTtcblxuZXhwb3J0IGNvbnN0IEh0dHBTdGF0dXMgPSB7XG4gICAgU1VDQ0VTUzogMjAwLFxuICAgIFNVQ0NFU1NfUkFOR0VfU1RBUlQ6IDIwMCxcbiAgICBTVUNDRVNTX1JBTkdFX0VORDogMjk5LFxuICAgIFJFRElSRUNUOiAzMDIsXG4gICAgQ0xJRU5UX0VSUk9SOiA0MDAsXG4gICAgQ0xJRU5UX0VSUk9SX1JBTkdFX1NUQVJUOiA0MDAsXG4gICAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgICBVTkFVVEhPUklaRUQ6IDQwMSxcbiAgICBOT1RfRk9VTkQ6IDQwNCxcbiAgICBSRVFVRVNUX1RJTUVPVVQ6IDQwOCxcbiAgICBUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuICAgIENMSUVOVF9FUlJPUl9SQU5HRV9FTkQ6IDQ5OSxcbiAgICBTRVJWRVJfRVJST1I6IDUwMCxcbiAgICBTRVJWRVJfRVJST1JfUkFOR0VfU1RBUlQ6IDUwMCxcbiAgICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gICAgR0FURVdBWV9USU1FT1VUOiA1MDQsXG4gICAgU0VSVkVSX0VSUk9SX1JBTkdFX0VORDogNTk5LFxuICAgIE1VTFRJX1NJREVEX0VSUk9SOiA2MDAsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgSHR0cFN0YXR1cyA9ICh0eXBlb2YgSHR0cFN0YXR1cylba2V5b2YgdHlwZW9mIEh0dHBTdGF0dXNdO1xuXG5leHBvcnQgY29uc3QgT0lEQ19ERUZBVUxUX1NDT1BFUyA9IFtcbiAgICBDb25zdGFudHMuT1BFTklEX1NDT1BFLFxuICAgIENvbnN0YW50cy5QUk9GSUxFX1NDT1BFLFxuICAgIENvbnN0YW50cy5PRkZMSU5FX0FDQ0VTU19TQ09QRSxcbl07XG5cbmV4cG9ydCBjb25zdCBPSURDX1NDT1BFUyA9IFsuLi5PSURDX0RFRkFVTFRfU0NPUEVTLCBDb25zdGFudHMuRU1BSUxfU0NPUEVdO1xuXG4vKipcbiAqIFJlcXVlc3QgaGVhZGVyIG5hbWVzXG4gKi9cbmV4cG9ydCBjb25zdCBIZWFkZXJOYW1lcyA9IHtcbiAgICBDT05URU5UX1RZUEU6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgQ09OVEVOVF9MRU5HVEg6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICBSRVRSWV9BRlRFUjogXCJSZXRyeS1BZnRlclwiLFxuICAgIENDU19IRUFERVI6IFwiWC1BbmNob3JNYWlsYm94XCIsXG4gICAgV1dXQXV0aGVudGljYXRlOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICBBdXRoZW50aWNhdGlvbkluZm86IFwiQXV0aGVudGljYXRpb24tSW5mb1wiLFxuICAgIFhfTVNfUkVRVUVTVF9JRDogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICBYX01TX0hUVFBfVkVSU0lPTjogXCJ4LW1zLWh0dHB2ZXJcIixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBIZWFkZXJOYW1lcyA9ICh0eXBlb2YgSGVhZGVyTmFtZXMpW2tleW9mIHR5cGVvZiBIZWFkZXJOYW1lc107XG5cbi8qKlxuICogUGVyc2lzdGVudCBjYWNoZSBrZXlzIE1TQUwgd2hpY2ggc3RheSB3aGlsZSB1c2VyIGlzIGxvZ2dlZCBpbi5cbiAqL1xuZXhwb3J0IGNvbnN0IFBlcnNpc3RlbnRDYWNoZUtleXMgPSB7XG4gICAgQUNUSVZFX0FDQ09VTlRfRklMVEVSUzogXCJhY3RpdmUtYWNjb3VudC1maWx0ZXJzXCIsIC8vIG5ldyBjYWNoZSBlbnRyeSBmb3IgYWN0aXZlX2FjY291bnQgZm9yIGEgbW9yZSByb2J1c3QgdmVyc2lvbiBmb3IgYnJvd3NlclxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFBlcnNpc3RlbnRDYWNoZUtleXMgPVxuICAgICh0eXBlb2YgUGVyc2lzdGVudENhY2hlS2V5cylba2V5b2YgdHlwZW9mIFBlcnNpc3RlbnRDYWNoZUtleXNdO1xuXG4vKipcbiAqIFN0cmluZyBjb25zdGFudHMgcmVsYXRlZCB0byBBQUQgQXV0aG9yaXR5XG4gKi9cbmV4cG9ydCBjb25zdCBBQURBdXRob3JpdHlDb25zdGFudHMgPSB7XG4gICAgQ09NTU9OOiBcImNvbW1vblwiLFxuICAgIE9SR0FOSVpBVElPTlM6IFwib3JnYW5pemF0aW9uc1wiLFxuICAgIENPTlNVTUVSUzogXCJjb25zdW1lcnNcIixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBBQURBdXRob3JpdHlDb25zdGFudHMgPVxuICAgICh0eXBlb2YgQUFEQXV0aG9yaXR5Q29uc3RhbnRzKVtrZXlvZiB0eXBlb2YgQUFEQXV0aG9yaXR5Q29uc3RhbnRzXTtcblxuLyoqXG4gKiBDbGFpbXMgcmVxdWVzdCBrZXlzXG4gKi9cbmV4cG9ydCBjb25zdCBDbGFpbXNSZXF1ZXN0S2V5cyA9IHtcbiAgICBBQ0NFU1NfVE9LRU46IFwiYWNjZXNzX3Rva2VuXCIsXG4gICAgWE1TX0NDOiBcInhtc19jY1wiLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIENsYWltc1JlcXVlc3RLZXlzID1cbiAgICAodHlwZW9mIENsYWltc1JlcXVlc3RLZXlzKVtrZXlvZiB0eXBlb2YgQ2xhaW1zUmVxdWVzdEtleXNdO1xuXG4vKipcbiAqIHdlIGNvbnNpZGVyZWQgbWFraW5nIHRoaXMgXCJlbnVtXCIgaW4gdGhlIHJlcXVlc3QgaW5zdGVhZCBvZiBzdHJpbmcsIGhvd2V2ZXIgaXQgbG9va3MgbGlrZSB0aGUgYWxsb3dlZCBsaXN0IG9mXG4gKiBwcm9tcHQgdmFsdWVzIGtlcHQgY2hhbmdpbmcgb3ZlciBwYXN0IGNvdXBsZSBvZiB5ZWFycy4gVGhlcmUgYXJlIHNvbWUgdW5kb2N1bWVudGVkIHByb21wdCB2YWx1ZXMgZm9yIHNvbWVcbiAqIGludGVybmFsIHBhcnRuZXJzIHRvbywgaGVuY2UgdGhlIGNob2ljZSBvZiBnZW5lcmljIFwic3RyaW5nXCIgdHlwZSBpbnN0ZWFkIG9mIHRoZSBcImVudW1cIlxuICovXG5leHBvcnQgY29uc3QgUHJvbXB0VmFsdWUgPSB7XG4gICAgTE9HSU46IFwibG9naW5cIixcbiAgICBTRUxFQ1RfQUNDT1VOVDogXCJzZWxlY3RfYWNjb3VudFwiLFxuICAgIENPTlNFTlQ6IFwiY29uc2VudFwiLFxuICAgIE5PTkU6IFwibm9uZVwiLFxuICAgIENSRUFURTogXCJjcmVhdGVcIixcbiAgICBOT19TRVNTSU9OOiBcIm5vX3Nlc3Npb25cIixcbn07XG5cbi8qKlxuICogYWxsb3dlZCB2YWx1ZXMgZm9yIGNvZGVWZXJpZmllclxuICovXG5leHBvcnQgY29uc3QgQ29kZUNoYWxsZW5nZU1ldGhvZFZhbHVlcyA9IHtcbiAgICBQTEFJTjogXCJwbGFpblwiLFxuICAgIFMyNTY6IFwiUzI1NlwiLFxufTtcblxuLyoqXG4gKiBBbGxvd2VkIHZhbHVlcyBmb3IgcmVzcG9uc2VfdHlwZVxuICovXG5leHBvcnQgY29uc3QgT0F1dGhSZXNwb25zZVR5cGUgPSB7XG4gICAgQ09ERTogXCJjb2RlXCIsXG4gICAgSURUT0tFTl9UT0tFTjogXCJpZF90b2tlbiB0b2tlblwiLFxuICAgIElEVE9LRU5fVE9LRU5fUkVGUkVTSFRPS0VOOiBcImlkX3Rva2VuIHRva2VuIHJlZnJlc2hfdG9rZW5cIixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBPQXV0aFJlc3BvbnNlVHlwZSA9XG4gICAgKHR5cGVvZiBPQXV0aFJlc3BvbnNlVHlwZSlba2V5b2YgdHlwZW9mIE9BdXRoUmVzcG9uc2VUeXBlXTtcblxuLyoqXG4gKiBhbGxvd2VkIHZhbHVlcyBmb3Igc2VydmVyIHJlc3BvbnNlIHR5cGVcbiAqIEBkZXByZWNhdGVkIFVzZSBSZXNwb25zZU1vZGUgaW5zdGVhZFxuICovXG5leHBvcnQgY29uc3QgU2VydmVyUmVzcG9uc2VUeXBlID0ge1xuICAgIFFVRVJZOiBcInF1ZXJ5XCIsXG4gICAgRlJBR01FTlQ6IFwiZnJhZ21lbnRcIixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBTZXJ2ZXJSZXNwb25zZVR5cGUgPVxuICAgICh0eXBlb2YgU2VydmVyUmVzcG9uc2VUeXBlKVtrZXlvZiB0eXBlb2YgU2VydmVyUmVzcG9uc2VUeXBlXTtcblxuLyoqXG4gKiBhbGxvd2VkIHZhbHVlcyBmb3IgcmVzcG9uc2VfbW9kZVxuICovXG5leHBvcnQgY29uc3QgUmVzcG9uc2VNb2RlID0ge1xuICAgIFFVRVJZOiBcInF1ZXJ5XCIsXG4gICAgRlJBR01FTlQ6IFwiZnJhZ21lbnRcIixcbiAgICBGT1JNX1BPU1Q6IFwiZm9ybV9wb3N0XCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgUmVzcG9uc2VNb2RlID0gKHR5cGVvZiBSZXNwb25zZU1vZGUpW2tleW9mIHR5cGVvZiBSZXNwb25zZU1vZGVdO1xuXG4vKipcbiAqIGFsbG93ZWQgZ3JhbnRfdHlwZVxuICovXG5leHBvcnQgY29uc3QgR3JhbnRUeXBlID0ge1xuICAgIElNUExJQ0lUX0dSQU5UOiBcImltcGxpY2l0XCIsXG4gICAgQVVUSE9SSVpBVElPTl9DT0RFX0dSQU5UOiBcImF1dGhvcml6YXRpb25fY29kZVwiLFxuICAgIENMSUVOVF9DUkVERU5USUFMU19HUkFOVDogXCJjbGllbnRfY3JlZGVudGlhbHNcIixcbiAgICBSRVNPVVJDRV9PV05FUl9QQVNTV09SRF9HUkFOVDogXCJwYXNzd29yZFwiLFxuICAgIFJFRlJFU0hfVE9LRU5fR1JBTlQ6IFwicmVmcmVzaF90b2tlblwiLFxuICAgIERFVklDRV9DT0RFX0dSQU5UOiBcImRldmljZV9jb2RlXCIsXG4gICAgSldUX0JFQVJFUjogXCJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpqd3QtYmVhcmVyXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgR3JhbnRUeXBlID0gKHR5cGVvZiBHcmFudFR5cGUpW2tleW9mIHR5cGVvZiBHcmFudFR5cGVdO1xuXG4vKipcbiAqIEFjY291bnQgdHlwZXMgaW4gQ2FjaGVcbiAqL1xuZXhwb3J0IGNvbnN0IENhY2hlQWNjb3VudFR5cGUgPSB7XG4gICAgTVNTVFNfQUNDT1VOVF9UWVBFOiBcIk1TU1RTXCIsXG4gICAgQURGU19BQ0NPVU5UX1RZUEU6IFwiQURGU1wiLFxuICAgIE1TQVYxX0FDQ09VTlRfVFlQRTogXCJNU0FcIixcbiAgICBHRU5FUklDX0FDQ09VTlRfVFlQRTogXCJHZW5lcmljXCIsIC8vIE5UTE0sIEtlcmJlcm9zLCBGQkEsIEJhc2ljIGV0Y1xufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIENhY2hlQWNjb3VudFR5cGUgPVxuICAgICh0eXBlb2YgQ2FjaGVBY2NvdW50VHlwZSlba2V5b2YgdHlwZW9mIENhY2hlQWNjb3VudFR5cGVdO1xuXG4vKipcbiAqIFNlcGFyYXRvcnMgdXNlZCBpbiBjYWNoZVxuICovXG5leHBvcnQgY29uc3QgU2VwYXJhdG9ycyA9IHtcbiAgICBDQUNIRV9LRVlfU0VQQVJBVE9SOiBcIi1cIixcbiAgICBDTElFTlRfSU5GT19TRVBBUkFUT1I6IFwiLlwiLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFNlcGFyYXRvcnMgPSAodHlwZW9mIFNlcGFyYXRvcnMpW2tleW9mIHR5cGVvZiBTZXBhcmF0b3JzXTtcblxuLyoqXG4gKiBDcmVkZW50aWFsIFR5cGUgc3RvcmVkIGluIHRoZSBjYWNoZVxuICovXG5leHBvcnQgY29uc3QgQ3JlZGVudGlhbFR5cGUgPSB7XG4gICAgSURfVE9LRU46IFwiSWRUb2tlblwiLFxuICAgIEFDQ0VTU19UT0tFTjogXCJBY2Nlc3NUb2tlblwiLFxuICAgIEFDQ0VTU19UT0tFTl9XSVRIX0FVVEhfU0NIRU1FOiBcIkFjY2Vzc1Rva2VuX1dpdGhfQXV0aFNjaGVtZVwiLFxuICAgIFJFRlJFU0hfVE9LRU46IFwiUmVmcmVzaFRva2VuXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgQ3JlZGVudGlhbFR5cGUgPVxuICAgICh0eXBlb2YgQ3JlZGVudGlhbFR5cGUpW2tleW9mIHR5cGVvZiBDcmVkZW50aWFsVHlwZV07XG5cbi8qKlxuICogQ29tYmluZSBhbGwgY2FjaGUgdHlwZXNcbiAqL1xuZXhwb3J0IGNvbnN0IENhY2hlVHlwZSA9IHtcbiAgICBBREZTOiAxMDAxLFxuICAgIE1TQTogMTAwMixcbiAgICBNU1NUUzogMTAwMyxcbiAgICBHRU5FUklDOiAxMDA0LFxuICAgIEFDQ0VTU19UT0tFTjogMjAwMSxcbiAgICBSRUZSRVNIX1RPS0VOOiAyMDAyLFxuICAgIElEX1RPS0VOOiAyMDAzLFxuICAgIEFQUF9NRVRBREFUQTogMzAwMSxcbiAgICBVTkRFRklORUQ6IDk5OTksXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgQ2FjaGVUeXBlID0gKHR5cGVvZiBDYWNoZVR5cGUpW2tleW9mIHR5cGVvZiBDYWNoZVR5cGVdO1xuXG4vKipcbiAqIE1vcmUgQ2FjaGUgcmVsYXRlZCBjb25zdGFudHNcbiAqL1xuZXhwb3J0IGNvbnN0IEFQUF9NRVRBREFUQSA9IFwiYXBwbWV0YWRhdGFcIjtcbmV4cG9ydCBjb25zdCBDTElFTlRfSU5GTyA9IFwiY2xpZW50X2luZm9cIjtcbmV4cG9ydCBjb25zdCBUSEVfRkFNSUxZX0lEID0gXCIxXCI7XG5cbmV4cG9ydCBjb25zdCBBVVRIT1JJVFlfTUVUQURBVEFfQ09OU1RBTlRTID0ge1xuICAgIENBQ0hFX0tFWTogXCJhdXRob3JpdHktbWV0YWRhdGFcIixcbiAgICBSRUZSRVNIX1RJTUVfU0VDT05EUzogMzYwMCAqIDI0LCAvLyAyNCBIb3Vyc1xufTtcblxuZXhwb3J0IGNvbnN0IEF1dGhvcml0eU1ldGFkYXRhU291cmNlID0ge1xuICAgIENPTkZJRzogXCJjb25maWdcIixcbiAgICBDQUNIRTogXCJjYWNoZVwiLFxuICAgIE5FVFdPUks6IFwibmV0d29ya1wiLFxuICAgIEhBUkRDT0RFRF9WQUxVRVM6IFwiaGFyZGNvZGVkX3ZhbHVlc1wiLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIEF1dGhvcml0eU1ldGFkYXRhU291cmNlID1cbiAgICAodHlwZW9mIEF1dGhvcml0eU1ldGFkYXRhU291cmNlKVtrZXlvZiB0eXBlb2YgQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2VdO1xuXG5leHBvcnQgY29uc3QgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUyA9IHtcbiAgICBTQ0hFTUFfVkVSU0lPTjogNSxcbiAgICBNQVhfQ1VSX0hFQURFUl9CWVRFUzogODAsIC8vIEVTVFMgbGltaXQgaXMgMTAwQiwgc2V0IHRvIDgwIHRvIHByb3ZpZGUgYSAyMEIgYnVmZmVyXG4gICAgTUFYX0xBU1RfSEVBREVSX0JZVEVTOiAzMzAsIC8vIEVTVFMgbGltaXQgaXMgMzUwQiwgc2V0IHRvIDMzMCB0byBwcm92aWRlIGEgMjBCIGJ1ZmZlcixcbiAgICBNQVhfQ0FDSEVEX0VSUk9SUzogNTAsIC8vIExpbWl0IHRoZSBudW1iZXIgb2YgZXJyb3JzIHRoYXQgY2FuIGJlIHN0b3JlZCB0byBwcmV2ZW50IHVuY29udHJvbGxlZCBzaXplIGdhaW5zXG4gICAgQ0FDSEVfS0VZOiBcInNlcnZlci10ZWxlbWV0cnlcIixcbiAgICBDQVRFR09SWV9TRVBBUkFUT1I6IFwifFwiLFxuICAgIFZBTFVFX1NFUEFSQVRPUjogXCIsXCIsXG4gICAgT1ZFUkZMT1dfVFJVRTogXCIxXCIsXG4gICAgT1ZFUkZMT1dfRkFMU0U6IFwiMFwiLFxuICAgIFVOS05PV05fRVJST1I6IFwidW5rbm93bl9lcnJvclwiLFxufTtcblxuLyoqXG4gKiBUeXBlIG9mIHRoZSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBBdXRoZW50aWNhdGlvblNjaGVtZSA9IHtcbiAgICBCRUFSRVI6IFwiQmVhcmVyXCIsXG4gICAgUE9QOiBcInBvcFwiLFxuICAgIFNTSDogXCJzc2gtY2VydFwiLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIEF1dGhlbnRpY2F0aW9uU2NoZW1lID1cbiAgICAodHlwZW9mIEF1dGhlbnRpY2F0aW9uU2NoZW1lKVtrZXlvZiB0eXBlb2YgQXV0aGVudGljYXRpb25TY2hlbWVdO1xuXG4vKipcbiAqIENvbnN0YW50cyByZWxhdGVkIHRvIHRocm90dGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFRocm90dGxpbmdDb25zdGFudHMgPSB7XG4gICAgLy8gRGVmYXVsdCB0aW1lIHRvIHRocm90dGxlIFJlcXVlc3RUaHVtYnByaW50IGluIHNlY29uZHNcbiAgICBERUZBVUxUX1RIUk9UVExFX1RJTUVfU0VDT05EUzogNjAsXG4gICAgLy8gRGVmYXVsdCBtYXhpbXVtIHRpbWUgdG8gdGhyb3R0bGUgaW4gc2Vjb25kcywgb3ZlcnJpZGVzIHdoYXQgdGhlIHNlcnZlciBzZW5kcyBiYWNrXG4gICAgREVGQVVMVF9NQVhfVEhST1RUTEVfVElNRV9TRUNPTkRTOiAzNjAwLFxuICAgIC8vIFByZWZpeCBmb3Igc3RvcmluZyB0aHJvdHRsaW5nIGVudHJpZXNcbiAgICBUSFJPVFRMSU5HX1BSRUZJWDogXCJ0aHJvdHRsaW5nXCIsXG4gICAgLy8gVmFsdWUgYXNzaWduZWQgdG8gdGhlIHgtbXMtbGliLWNhcGFiaWxpdHkgaGVhZGVyIHRvIGluZGljYXRlIHRvIHRoZSBzZXJ2ZXIgdGhlIGxpYnJhcnkgc3VwcG9ydHMgdGhyb3R0bGluZ1xuICAgIFhfTVNfTElCX0NBUEFCSUxJVFlfVkFMVUU6IFwicmV0cnktYWZ0ZXIsIGg0MjlcIixcbn07XG5cbmV4cG9ydCBjb25zdCBFcnJvcnMgPSB7XG4gICAgSU5WQUxJRF9HUkFOVF9FUlJPUjogXCJpbnZhbGlkX2dyYW50XCIsXG4gICAgQ0xJRU5UX01JU01BVENIX0VSUk9SOiBcImNsaWVudF9taXNtYXRjaFwiLFxufTtcblxuLyoqXG4gKiBQYXNzd29yZCBncmFudCBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBQYXNzd29yZEdyYW50Q29uc3RhbnRzID0ge1xuICAgIHVzZXJuYW1lOiBcInVzZXJuYW1lXCIsXG4gICAgcGFzc3dvcmQ6IFwicGFzc3dvcmRcIixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBQYXNzd29yZEdyYW50Q29uc3RhbnRzID1cbiAgICAodHlwZW9mIFBhc3N3b3JkR3JhbnRDb25zdGFudHMpW2tleW9mIHR5cGVvZiBQYXNzd29yZEdyYW50Q29uc3RhbnRzXTtcblxuLyoqXG4gKiBSZXNwb25zZSBjb2Rlc1xuICovXG5leHBvcnQgY29uc3QgUmVzcG9uc2VDb2RlcyA9IHtcbiAgICBodHRwU3VjY2VzczogMjAwLFxuICAgIGh0dHBCYWRSZXF1ZXN0OiA0MDAsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgUmVzcG9uc2VDb2RlcyA9ICh0eXBlb2YgUmVzcG9uc2VDb2Rlcylba2V5b2YgdHlwZW9mIFJlc3BvbnNlQ29kZXNdO1xuXG4vKipcbiAqIFJlZ2lvbiBEaXNjb3ZlcnkgU291cmNlc1xuICovXG5leHBvcnQgY29uc3QgUmVnaW9uRGlzY292ZXJ5U291cmNlcyA9IHtcbiAgICBGQUlMRURfQVVUT19ERVRFQ1RJT046IFwiMVwiLFxuICAgIElOVEVSTkFMX0NBQ0hFOiBcIjJcIixcbiAgICBFTlZJUk9OTUVOVF9WQVJJQUJMRTogXCIzXCIsXG4gICAgSU1EUzogXCI0XCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgUmVnaW9uRGlzY292ZXJ5U291cmNlcyA9XG4gICAgKHR5cGVvZiBSZWdpb25EaXNjb3ZlcnlTb3VyY2VzKVtrZXlvZiB0eXBlb2YgUmVnaW9uRGlzY292ZXJ5U291cmNlc107XG5cbi8qKlxuICogUmVnaW9uIERpc2NvdmVyeSBPdXRjb21lc1xuICovXG5leHBvcnQgY29uc3QgUmVnaW9uRGlzY292ZXJ5T3V0Y29tZXMgPSB7XG4gICAgQ09ORklHVVJFRF9NQVRDSEVTX0RFVEVDVEVEOiBcIjFcIixcbiAgICBDT05GSUdVUkVEX05PX0FVVE9fREVURUNUSU9OOiBcIjJcIixcbiAgICBDT05GSUdVUkVEX05PVF9ERVRFQ1RFRDogXCIzXCIsXG4gICAgQVVUT19ERVRFQ1RJT05fUkVRVUVTVEVEX1NVQ0NFU1NGVUw6IFwiNFwiLFxuICAgIEFVVE9fREVURUNUSU9OX1JFUVVFU1RFRF9GQUlMRUQ6IFwiNVwiLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFJlZ2lvbkRpc2NvdmVyeU91dGNvbWVzID1cbiAgICAodHlwZW9mIFJlZ2lvbkRpc2NvdmVyeU91dGNvbWVzKVtrZXlvZiB0eXBlb2YgUmVnaW9uRGlzY292ZXJ5T3V0Y29tZXNdO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgcmVhc29uIGZvciBmZXRjaGluZyB0aGUgYWNjZXNzIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBDYWNoZU91dGNvbWUgPSB7XG4gICAgLy8gV2hlbiBhIHRva2VuIGlzIGZvdW5kIGluIHRoZSBjYWNoZSBvciB0aGUgY2FjaGUgaXMgbm90IHN1cHBvc2VkIHRvIGJlIGhpdCB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdFxuICAgIE5PVF9BUFBMSUNBQkxFOiBcIjBcIixcbiAgICAvLyBXaGVuIHRoZSB0b2tlbiByZXF1ZXN0IGdvZXMgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVyIGJlY2F1c2UgZm9yY2VfcmVmcmVzaCB3YXMgc2V0IHRvIHRydWUuIEFsc28gb2NjdXJzIGlmIGNsYWltcyB3ZXJlIHJlcXVlc3RlZFxuICAgIEZPUkNFX1JFRlJFU0hfT1JfQ0xBSU1TOiBcIjFcIixcbiAgICAvLyBXaGVuIHRoZSB0b2tlbiByZXF1ZXN0IGdvZXMgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVyIGJlY2F1c2Ugbm8gY2FjaGVkIGFjY2VzcyB0b2tlbiBleGlzdHNcbiAgICBOT19DQUNIRURfQUNDRVNTX1RPS0VOOiBcIjJcIixcbiAgICAvLyBXaGVuIHRoZSB0b2tlbiByZXF1ZXN0IGdvZXMgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVyIGJlY2F1c2UgY2FjaGVkIGFjY2VzcyB0b2tlbiBleHBpcmVkXG4gICAgQ0FDSEVEX0FDQ0VTU19UT0tFTl9FWFBJUkVEOiBcIjNcIixcbiAgICAvLyBXaGVuIHRoZSB0b2tlbiByZXF1ZXN0IGdvZXMgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVyIGJlY2F1c2UgcmVmcmVzaF9pbiB3YXMgdXNlZCBhbmQgdGhlIGV4aXN0aW5nIHRva2VuIG5lZWRzIHRvIGJlIHJlZnJlc2hlZFxuICAgIFBST0FDVElWRUxZX1JFRlJFU0hFRDogXCI0XCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgQ2FjaGVPdXRjb21lID0gKHR5cGVvZiBDYWNoZU91dGNvbWUpW2tleW9mIHR5cGVvZiBDYWNoZU91dGNvbWVdO1xuXG5leHBvcnQgY29uc3QgSnNvbldlYlRva2VuVHlwZXMgPSB7XG4gICAgSnd0OiBcIkpXVFwiLFxuICAgIEp3azogXCJKV0tcIixcbiAgICBQb3A6IFwicG9wXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgSnNvbldlYlRva2VuVHlwZXMgPVxuICAgICh0eXBlb2YgSnNvbldlYlRva2VuVHlwZXMpW2tleW9mIHR5cGVvZiBKc29uV2ViVG9rZW5UeXBlc107XG5cbmV4cG9ydCBjb25zdCBPTkVfREFZX0lOX01TID0gODY0MDAwMDA7XG5cbi8vIFRva2VuIHJlbmV3YWwgb2Zmc2V0IGRlZmF1bHQgaW4gc2Vjb25kc1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVE9LRU5fUkVORVdBTF9PRkZTRVRfU0VDID0gMzAwO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEF1dGhFcnJvck1lc3NhZ2UgY2xhc3MgY29udGFpbmluZyBzdHJpbmcgY29uc3RhbnRzIHVzZWQgYnkgZXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgY29uc3QgdW5leHBlY3RlZEVycm9yID0gXCJ1bmV4cGVjdGVkX2Vycm9yXCI7XG5leHBvcnQgY29uc3QgcG9zdFJlcXVlc3RGYWlsZWQgPSBcInBvc3RfcmVxdWVzdF9mYWlsZWRcIjtcbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0ICogYXMgQXV0aEVycm9yQ29kZXMgZnJvbSBcIi4vQXV0aEVycm9yQ29kZXMuanNcIjtcbmV4cG9ydCB7IEF1dGhFcnJvckNvZGVzIH07XG5cbmV4cG9ydCBjb25zdCBBdXRoRXJyb3JNZXNzYWdlcyA9IHtcbiAgICBbQXV0aEVycm9yQ29kZXMudW5leHBlY3RlZEVycm9yXTogXCJVbmV4cGVjdGVkIGVycm9yIGluIGF1dGhlbnRpY2F0aW9uLlwiLFxuICAgIFtBdXRoRXJyb3JDb2Rlcy5wb3N0UmVxdWVzdEZhaWxlZF06XG4gICAgICAgIFwiUG9zdCByZXF1ZXN0IGZhaWxlZCBmcm9tIHRoZSBuZXR3b3JrLCBjb3VsZCBiZSBhIDR4eC81eHggb3IgYSBuZXR3b3JrIHVuYXZhaWxhYmlsaXR5LiBQbGVhc2UgY2hlY2sgdGhlIGV4YWN0IGVycm9yIGNvZGUgZm9yIGRldGFpbHMuXCIsXG59O1xuXG4vKipcbiAqIEF1dGhFcnJvck1lc3NhZ2UgY2xhc3MgY29udGFpbmluZyBzdHJpbmcgY29uc3RhbnRzIHVzZWQgYnkgZXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxuICogQGRlcHJlY2F0ZWQgVXNlIEF1dGhFcnJvckNvZGVzIGluc3RlYWRcbiAqL1xuZXhwb3J0IGNvbnN0IEF1dGhFcnJvck1lc3NhZ2UgPSB7XG4gICAgdW5leHBlY3RlZEVycm9yOiB7XG4gICAgICAgIGNvZGU6IEF1dGhFcnJvckNvZGVzLnVuZXhwZWN0ZWRFcnJvcixcbiAgICAgICAgZGVzYzogQXV0aEVycm9yTWVzc2FnZXNbQXV0aEVycm9yQ29kZXMudW5leHBlY3RlZEVycm9yXSxcbiAgICB9LFxuICAgIHBvc3RSZXF1ZXN0RmFpbGVkOiB7XG4gICAgICAgIGNvZGU6IEF1dGhFcnJvckNvZGVzLnBvc3RSZXF1ZXN0RmFpbGVkLFxuICAgICAgICBkZXNjOiBBdXRoRXJyb3JNZXNzYWdlc1tBdXRoRXJyb3JDb2Rlcy5wb3N0UmVxdWVzdEZhaWxlZF0sXG4gICAgfSxcbn07XG5cbi8qKlxuICogR2VuZXJhbCBlcnJvciBjbGFzcyB0aHJvd24gYnkgdGhlIE1TQUwuanMgbGlicmFyeS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBTaG9ydCBzdHJpbmcgZGVub3RpbmcgZXJyb3JcbiAgICAgKi9cbiAgICBlcnJvckNvZGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIERldGFpbGVkIGRlc2NyaXB0aW9uIG9mIGVycm9yXG4gICAgICovXG4gICAgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgdGhlIHN1YmNsYXNzIG9mIGFuIGVycm9yXG4gICAgICovXG4gICAgc3ViRXJyb3I6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENvcnJlbGF0aW9uSWQgYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvclxuICAgICAqL1xuICAgIGNvcnJlbGF0aW9uSWQ6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZT86IHN0cmluZywgZXJyb3JNZXNzYWdlPzogc3RyaW5nLCBzdWJlcnJvcj86IHN0cmluZykge1xuICAgICAgICBjb25zdCBlcnJvclN0cmluZyA9IGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgPyBgJHtlcnJvckNvZGV9OiAke2Vycm9yTWVzc2FnZX1gXG4gICAgICAgICAgICA6IGVycm9yQ29kZTtcbiAgICAgICAgc3VwZXIoZXJyb3JTdHJpbmcpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQXV0aEVycm9yLnByb3RvdHlwZSk7XG5cbiAgICAgICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGUgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2UgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgdGhpcy5zdWJFcnJvciA9IHN1YmVycm9yIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQXV0aEVycm9yXCI7XG4gICAgfVxuXG4gICAgc2V0Q29ycmVsYXRpb25JZChjb3JyZWxhdGlvbklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gY29ycmVsYXRpb25JZDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdXRoRXJyb3IoXG4gICAgY29kZTogc3RyaW5nLFxuICAgIGFkZGl0aW9uYWxNZXNzYWdlPzogc3RyaW5nXG4pOiBBdXRoRXJyb3Ige1xuICAgIHJldHVybiBuZXcgQXV0aEVycm9yKFxuICAgICAgICBjb2RlLFxuICAgICAgICBhZGRpdGlvbmFsTWVzc2FnZVxuICAgICAgICAgICAgPyBgJHtBdXRoRXJyb3JNZXNzYWdlc1tjb2RlXX0gJHthZGRpdGlvbmFsTWVzc2FnZX1gXG4gICAgICAgICAgICA6IEF1dGhFcnJvck1lc3NhZ2VzW2NvZGVdXG4gICAgKTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNsaWVudEluZm9EZWNvZGluZ0Vycm9yID0gXCJjbGllbnRfaW5mb19kZWNvZGluZ19lcnJvclwiO1xuZXhwb3J0IGNvbnN0IGNsaWVudEluZm9FbXB0eUVycm9yID0gXCJjbGllbnRfaW5mb19lbXB0eV9lcnJvclwiO1xuZXhwb3J0IGNvbnN0IHRva2VuUGFyc2luZ0Vycm9yID0gXCJ0b2tlbl9wYXJzaW5nX2Vycm9yXCI7XG5leHBvcnQgY29uc3QgbnVsbE9yRW1wdHlUb2tlbiA9IFwibnVsbF9vcl9lbXB0eV90b2tlblwiO1xuZXhwb3J0IGNvbnN0IGVuZHBvaW50UmVzb2x1dGlvbkVycm9yID0gXCJlbmRwb2ludHNfcmVzb2x1dGlvbl9lcnJvclwiO1xuZXhwb3J0IGNvbnN0IG5ldHdvcmtFcnJvciA9IFwibmV0d29ya19lcnJvclwiO1xuZXhwb3J0IGNvbnN0IG9wZW5JZENvbmZpZ0Vycm9yID0gXCJvcGVuaWRfY29uZmlnX2Vycm9yXCI7XG5leHBvcnQgY29uc3QgaGFzaE5vdERlc2VyaWFsaXplZCA9IFwiaGFzaF9ub3RfZGVzZXJpYWxpemVkXCI7XG5leHBvcnQgY29uc3QgaW52YWxpZFN0YXRlID0gXCJpbnZhbGlkX3N0YXRlXCI7XG5leHBvcnQgY29uc3Qgc3RhdGVNaXNtYXRjaCA9IFwic3RhdGVfbWlzbWF0Y2hcIjtcbmV4cG9ydCBjb25zdCBzdGF0ZU5vdEZvdW5kID0gXCJzdGF0ZV9ub3RfZm91bmRcIjtcbmV4cG9ydCBjb25zdCBub25jZU1pc21hdGNoID0gXCJub25jZV9taXNtYXRjaFwiO1xuZXhwb3J0IGNvbnN0IGF1dGhUaW1lTm90Rm91bmQgPSBcImF1dGhfdGltZV9ub3RfZm91bmRcIjtcbmV4cG9ydCBjb25zdCBtYXhBZ2VUcmFuc3BpcmVkID0gXCJtYXhfYWdlX3RyYW5zcGlyZWRcIjtcbmV4cG9ydCBjb25zdCBtdWx0aXBsZU1hdGNoaW5nVG9rZW5zID0gXCJtdWx0aXBsZV9tYXRjaGluZ190b2tlbnNcIjtcbmV4cG9ydCBjb25zdCBtdWx0aXBsZU1hdGNoaW5nQWNjb3VudHMgPSBcIm11bHRpcGxlX21hdGNoaW5nX2FjY291bnRzXCI7XG5leHBvcnQgY29uc3QgbXVsdGlwbGVNYXRjaGluZ0FwcE1ldGFkYXRhID0gXCJtdWx0aXBsZV9tYXRjaGluZ19hcHBNZXRhZGF0YVwiO1xuZXhwb3J0IGNvbnN0IHJlcXVlc3RDYW5ub3RCZU1hZGUgPSBcInJlcXVlc3RfY2Fubm90X2JlX21hZGVcIjtcbmV4cG9ydCBjb25zdCBjYW5ub3RSZW1vdmVFbXB0eVNjb3BlID0gXCJjYW5ub3RfcmVtb3ZlX2VtcHR5X3Njb3BlXCI7XG5leHBvcnQgY29uc3QgY2Fubm90QXBwZW5kU2NvcGVTZXQgPSBcImNhbm5vdF9hcHBlbmRfc2NvcGVzZXRcIjtcbmV4cG9ydCBjb25zdCBlbXB0eUlucHV0U2NvcGVTZXQgPSBcImVtcHR5X2lucHV0X3Njb3Blc2V0XCI7XG5leHBvcnQgY29uc3QgZGV2aWNlQ29kZVBvbGxpbmdDYW5jZWxsZWQgPSBcImRldmljZV9jb2RlX3BvbGxpbmdfY2FuY2VsbGVkXCI7XG5leHBvcnQgY29uc3QgZGV2aWNlQ29kZUV4cGlyZWQgPSBcImRldmljZV9jb2RlX2V4cGlyZWRcIjtcbmV4cG9ydCBjb25zdCBkZXZpY2VDb2RlVW5rbm93bkVycm9yID0gXCJkZXZpY2VfY29kZV91bmtub3duX2Vycm9yXCI7XG5leHBvcnQgY29uc3Qgbm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0ID0gXCJub19hY2NvdW50X2luX3NpbGVudF9yZXF1ZXN0XCI7XG5leHBvcnQgY29uc3QgaW52YWxpZENhY2hlUmVjb3JkID0gXCJpbnZhbGlkX2NhY2hlX3JlY29yZFwiO1xuZXhwb3J0IGNvbnN0IGludmFsaWRDYWNoZUVudmlyb25tZW50ID0gXCJpbnZhbGlkX2NhY2hlX2Vudmlyb25tZW50XCI7XG5leHBvcnQgY29uc3Qgbm9BY2NvdW50Rm91bmQgPSBcIm5vX2FjY291bnRfZm91bmRcIjtcbmV4cG9ydCBjb25zdCBub0NyeXB0b09iamVjdCA9IFwibm9fY3J5cHRvX29iamVjdFwiO1xuZXhwb3J0IGNvbnN0IHVuZXhwZWN0ZWRDcmVkZW50aWFsVHlwZSA9IFwidW5leHBlY3RlZF9jcmVkZW50aWFsX3R5cGVcIjtcbmV4cG9ydCBjb25zdCBpbnZhbGlkQXNzZXJ0aW9uID0gXCJpbnZhbGlkX2Fzc2VydGlvblwiO1xuZXhwb3J0IGNvbnN0IGludmFsaWRDbGllbnRDcmVkZW50aWFsID0gXCJpbnZhbGlkX2NsaWVudF9jcmVkZW50aWFsXCI7XG5leHBvcnQgY29uc3QgdG9rZW5SZWZyZXNoUmVxdWlyZWQgPSBcInRva2VuX3JlZnJlc2hfcmVxdWlyZWRcIjtcbmV4cG9ydCBjb25zdCB1c2VyVGltZW91dFJlYWNoZWQgPSBcInVzZXJfdGltZW91dF9yZWFjaGVkXCI7XG5leHBvcnQgY29uc3QgdG9rZW5DbGFpbXNDbmZSZXF1aXJlZEZvclNpZ25lZEp3dCA9XG4gICAgXCJ0b2tlbl9jbGFpbXNfY25mX3JlcXVpcmVkX2Zvcl9zaWduZWRqd3RcIjtcbmV4cG9ydCBjb25zdCBhdXRob3JpemF0aW9uQ29kZU1pc3NpbmdGcm9tU2VydmVyUmVzcG9uc2UgPVxuICAgIFwiYXV0aG9yaXphdGlvbl9jb2RlX21pc3NpbmdfZnJvbV9zZXJ2ZXJfcmVzcG9uc2VcIjtcbmV4cG9ydCBjb25zdCBiaW5kaW5nS2V5Tm90UmVtb3ZlZCA9IFwiYmluZGluZ19rZXlfbm90X3JlbW92ZWRcIjtcbmV4cG9ydCBjb25zdCBlbmRTZXNzaW9uRW5kcG9pbnROb3RTdXBwb3J0ZWQgPVxuICAgIFwiZW5kX3Nlc3Npb25fZW5kcG9pbnRfbm90X3N1cHBvcnRlZFwiO1xuZXhwb3J0IGNvbnN0IGtleUlkTWlzc2luZyA9IFwia2V5X2lkX21pc3NpbmdcIjtcbmV4cG9ydCBjb25zdCBub05ldHdvcmtDb25uZWN0aXZpdHkgPSBcIm5vX25ldHdvcmtfY29ubmVjdGl2aXR5XCI7XG5leHBvcnQgY29uc3QgdXNlckNhbmNlbGVkID0gXCJ1c2VyX2NhbmNlbGVkXCI7XG5leHBvcnQgY29uc3QgbWlzc2luZ1RlbmFudElkRXJyb3IgPSBcIm1pc3NpbmdfdGVuYW50X2lkX2Vycm9yXCI7XG5leHBvcnQgY29uc3QgbWV0aG9kTm90SW1wbGVtZW50ZWQgPSBcIm1ldGhvZF9ub3RfaW1wbGVtZW50ZWRcIjtcbmV4cG9ydCBjb25zdCBuZXN0ZWRBcHBBdXRoQnJpZGdlRGlzYWJsZWQgPSBcIm5lc3RlZF9hcHBfYXV0aF9icmlkZ2VfZGlzYWJsZWRcIjtcbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSBcIi4vQXV0aEVycm9yLmpzXCI7XG5pbXBvcnQgKiBhcyBDbGllbnRBdXRoRXJyb3JDb2RlcyBmcm9tIFwiLi9DbGllbnRBdXRoRXJyb3JDb2Rlcy5qc1wiO1xuZXhwb3J0IHsgQ2xpZW50QXV0aEVycm9yQ29kZXMgfTsgLy8gQWxsb3cgaW1wb3J0aW5nIGFzIFwiQ2xpZW50QXV0aEVycm9yQ29kZXNcIjtcblxuLyoqXG4gKiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlIGNsYXNzIGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyB1c2VkIGJ5IGVycm9yIGNvZGVzIGFuZCBtZXNzYWdlcy5cbiAqL1xuXG5leHBvcnQgY29uc3QgQ2xpZW50QXV0aEVycm9yTWVzc2FnZXMgPSB7XG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLmNsaWVudEluZm9EZWNvZGluZ0Vycm9yXTpcbiAgICAgICAgXCJUaGUgY2xpZW50IGluZm8gY291bGQgbm90IGJlIHBhcnNlZC9kZWNvZGVkIGNvcnJlY3RseVwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5jbGllbnRJbmZvRW1wdHlFcnJvcl06IFwiVGhlIGNsaWVudCBpbmZvIHdhcyBlbXB0eVwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblBhcnNpbmdFcnJvcl06IFwiVG9rZW4gY2Fubm90IGJlIHBhcnNlZFwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5udWxsT3JFbXB0eVRva2VuXTogXCJUaGUgdG9rZW4gaXMgbnVsbCBvciBlbXB0eVwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5lbmRwb2ludFJlc29sdXRpb25FcnJvcl06XG4gICAgICAgIFwiRW5kcG9pbnRzIGNhbm5vdCBiZSByZXNvbHZlZFwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5uZXR3b3JrRXJyb3JdOiBcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMub3BlbklkQ29uZmlnRXJyb3JdOlxuICAgICAgICBcIkNvdWxkIG5vdCByZXRyaWV2ZSBlbmRwb2ludHMuIENoZWNrIHlvdXIgYXV0aG9yaXR5IGFuZCB2ZXJpZnkgdGhlIC53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uIGVuZHBvaW50IHJldHVybnMgdGhlIHJlcXVpcmVkIGVuZHBvaW50cy5cIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMuaGFzaE5vdERlc2VyaWFsaXplZF06XG4gICAgICAgIFwiVGhlIGhhc2ggcGFyYW1ldGVycyBjb3VsZCBub3QgYmUgZGVzZXJpYWxpemVkXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRTdGF0ZV06IFwiU3RhdGUgd2FzIG5vdCB0aGUgZXhwZWN0ZWQgZm9ybWF0XCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLnN0YXRlTWlzbWF0Y2hdOiBcIlN0YXRlIG1pc21hdGNoIGVycm9yXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLnN0YXRlTm90Rm91bmRdOiBcIlN0YXRlIG5vdCBmb3VuZFwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub25jZU1pc21hdGNoXTogXCJOb25jZSBtaXNtYXRjaCBlcnJvclwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5hdXRoVGltZU5vdEZvdW5kXTpcbiAgICAgICAgXCJNYXggQWdlIHdhcyByZXF1ZXN0ZWQgYW5kIHRoZSBJRCB0b2tlbiBpcyBtaXNzaW5nIHRoZSBhdXRoX3RpbWUgdmFyaWFibGUuXCIgK1xuICAgICAgICBcIiBhdXRoX3RpbWUgaXMgYW4gb3B0aW9uYWwgY2xhaW0gYW5kIGlzIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQgLSBpdCBtdXN0IGJlIGVuYWJsZWQuXCIgK1xuICAgICAgICBcIiBTZWUgaHR0cHM6Ly9ha2EubXMvbXNhbGpzL29wdGlvbmFsLWNsYWltcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMubWF4QWdlVHJhbnNwaXJlZF06XG4gICAgICAgIFwiTWF4IEFnZSBpcyBzZXQgdG8gMCwgb3IgdG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBlbmQtdXNlciBhdXRoZW50aWNhdGlvbi5cIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMubXVsdGlwbGVNYXRjaGluZ1Rva2Vuc106XG4gICAgICAgIFwiVGhlIGNhY2hlIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucyBzYXRpc2Z5aW5nIHRoZSByZXF1aXJlbWVudHMuIFwiICtcbiAgICAgICAgXCJDYWxsIEFjcXVpcmVUb2tlbiBhZ2FpbiBwcm92aWRpbmcgbW9yZSByZXF1aXJlbWVudHMgc3VjaCBhcyBhdXRob3JpdHkgb3IgYWNjb3VudC5cIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMubXVsdGlwbGVNYXRjaGluZ0FjY291bnRzXTpcbiAgICAgICAgXCJUaGUgY2FjaGUgY29udGFpbnMgbXVsdGlwbGUgYWNjb3VudHMgc2F0aXNmeWluZyB0aGUgZ2l2ZW4gcGFyYW1ldGVycy4gUGxlYXNlIHBhc3MgbW9yZSBpbmZvIHRvIG9idGFpbiB0aGUgY29ycmVjdCBhY2NvdW50XCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdBcHBNZXRhZGF0YV06XG4gICAgICAgIFwiVGhlIGNhY2hlIGNvbnRhaW5zIG11bHRpcGxlIGFwcE1ldGFkYXRhIHNhdGlzZnlpbmcgdGhlIGdpdmVuIHBhcmFtZXRlcnMuIFBsZWFzZSBwYXNzIG1vcmUgaW5mbyB0byBvYnRhaW4gdGhlIGNvcnJlY3QgYXBwTWV0YWRhdGFcIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMucmVxdWVzdENhbm5vdEJlTWFkZV06XG4gICAgICAgIFwiVG9rZW4gcmVxdWVzdCBjYW5ub3QgYmUgbWFkZSB3aXRob3V0IGF1dGhvcml6YXRpb24gY29kZSBvciByZWZyZXNoIHRva2VuLlwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5jYW5ub3RSZW1vdmVFbXB0eVNjb3BlXTpcbiAgICAgICAgXCJDYW5ub3QgcmVtb3ZlIG51bGwgb3IgZW1wdHkgc2NvcGUgZnJvbSBTY29wZVNldFwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5jYW5ub3RBcHBlbmRTY29wZVNldF06IFwiQ2Fubm90IGFwcGVuZCBTY29wZVNldFwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5lbXB0eUlucHV0U2NvcGVTZXRdOlxuICAgICAgICBcIkVtcHR5IGlucHV0IFNjb3BlU2V0IGNhbm5vdCBiZSBwcm9jZXNzZWRcIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMuZGV2aWNlQ29kZVBvbGxpbmdDYW5jZWxsZWRdOlxuICAgICAgICBcIkNhbGxlciBoYXMgY2FuY2VsbGVkIHRva2VuIGVuZHBvaW50IHBvbGxpbmcgZHVyaW5nIGRldmljZSBjb2RlIGZsb3cgYnkgc2V0dGluZyBEZXZpY2VDb2RlUmVxdWVzdC5jYW5jZWwgPSB0cnVlLlwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5kZXZpY2VDb2RlRXhwaXJlZF06IFwiRGV2aWNlIGNvZGUgaXMgZXhwaXJlZC5cIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMuZGV2aWNlQ29kZVVua25vd25FcnJvcl06XG4gICAgICAgIFwiRGV2aWNlIGNvZGUgc3RvcHBlZCBwb2xsaW5nIGZvciB1bmtub3duIHJlYXNvbnMuXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLm5vQWNjb3VudEluU2lsZW50UmVxdWVzdF06XG4gICAgICAgIFwiUGxlYXNlIHBhc3MgYW4gYWNjb3VudCBvYmplY3QsIHNpbGVudCBmbG93IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCBhY2NvdW50IGluZm9ybWF0aW9uXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDYWNoZVJlY29yZF06XG4gICAgICAgIFwiQ2FjaGUgcmVjb3JkIG9iamVjdCB3YXMgbnVsbCBvciB1bmRlZmluZWQuXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDYWNoZUVudmlyb25tZW50XTpcbiAgICAgICAgXCJJbnZhbGlkIGVudmlyb25tZW50IHdoZW4gYXR0ZW1wdGluZyB0byBjcmVhdGUgY2FjaGUgZW50cnlcIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMubm9BY2NvdW50Rm91bmRdOlxuICAgICAgICBcIk5vIGFjY291bnQgZm91bmQgaW4gY2FjaGUgZm9yIGdpdmVuIGtleS5cIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMubm9DcnlwdG9PYmplY3RdOiBcIk5vIGNyeXB0byBvYmplY3QgZGV0ZWN0ZWQuXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLnVuZXhwZWN0ZWRDcmVkZW50aWFsVHlwZV06XG4gICAgICAgIFwiVW5leHBlY3RlZCBjcmVkZW50aWFsIHR5cGUuXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRBc3NlcnRpb25dOlxuICAgICAgICBcIkNsaWVudCBhc3NlcnRpb24gbXVzdCBtZWV0IHJlcXVpcmVtZW50cyBkZXNjcmliZWQgaW4gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTVcIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMuaW52YWxpZENsaWVudENyZWRlbnRpYWxdOlxuICAgICAgICBcIkNsaWVudCBjcmVkZW50aWFsIChzZWNyZXQsIGNlcnRpZmljYXRlLCBvciBhc3NlcnRpb24pIG11c3Qgbm90IGJlIGVtcHR5IHdoZW4gY3JlYXRpbmcgYSBjb25maWRlbnRpYWwgY2xpZW50LiBBbiBhcHBsaWNhdGlvbiBzaG91bGQgYXQgbW9zdCBoYXZlIG9uZSBjcmVkZW50aWFsXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuUmVmcmVzaFJlcXVpcmVkXTpcbiAgICAgICAgXCJDYW5ub3QgcmV0dXJuIHRva2VuIGZyb20gY2FjaGUgYmVjYXVzZSBpdCBtdXN0IGJlIHJlZnJlc2hlZC4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6IGZvcmNlUmVmcmVzaCBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWUsIGNsYWltcyBoYXZlIGJlZW4gcmVxdWVzdGVkLCB0aGVyZSBpcyBubyBjYWNoZWQgYWNjZXNzIHRva2VuIG9yIGl0IGlzIGV4cGlyZWQuXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLnVzZXJUaW1lb3V0UmVhY2hlZF06XG4gICAgICAgIFwiVXNlciBkZWZpbmVkIHRpbWVvdXQgZm9yIGRldmljZSBjb2RlIHBvbGxpbmcgcmVhY2hlZFwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlbkNsYWltc0NuZlJlcXVpcmVkRm9yU2lnbmVkSnd0XTpcbiAgICAgICAgXCJDYW5ub3QgZ2VuZXJhdGUgYSBQT1Agand0IGlmIHRoZSB0b2tlbl9jbGFpbXMgYXJlIG5vdCBwb3B1bGF0ZWRcIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aG9yaXphdGlvbkNvZGVNaXNzaW5nRnJvbVNlcnZlclJlc3BvbnNlXTpcbiAgICAgICAgXCJTZXJ2ZXIgcmVzcG9uc2UgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpemF0aW9uIGNvZGUgdG8gcHJvY2VlZFwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5iaW5kaW5nS2V5Tm90UmVtb3ZlZF06XG4gICAgICAgIFwiQ291bGQgbm90IHJlbW92ZSB0aGUgY3JlZGVudGlhbCdzIGJpbmRpbmcga2V5IGZyb20gc3RvcmFnZS5cIixcbiAgICBbQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kU2Vzc2lvbkVuZHBvaW50Tm90U3VwcG9ydGVkXTpcbiAgICAgICAgXCJUaGUgcHJvdmlkZWQgYXV0aG9yaXR5IGRvZXMgbm90IHN1cHBvcnQgbG9nb3V0XCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLmtleUlkTWlzc2luZ106XG4gICAgICAgIFwiQSBrZXlJZCB2YWx1ZSBpcyBtaXNzaW5nIGZyb20gdGhlIHJlcXVlc3RlZCBib3VuZCB0b2tlbidzIGNhY2hlIHJlY29yZCBhbmQgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggdGhlIHRva2VuIHRvIGl0J3Mgc3RvcmVkIGJpbmRpbmcga2V5LlwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub05ldHdvcmtDb25uZWN0aXZpdHldOlxuICAgICAgICBcIk5vIG5ldHdvcmsgY29ubmVjdGl2aXR5LiBDaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLnVzZXJDYW5jZWxlZF06IFwiVXNlciBjYW5jZWxsZWQgdGhlIGZsb3cuXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLm1pc3NpbmdUZW5hbnRJZEVycm9yXTpcbiAgICAgICAgXCJBIHRlbmFudCBpZCAtIG5vdCBjb21tb24sIG9yZ2FuaXphdGlvbnMsIG9yIGNvbnN1bWVycyAtIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gdXNpbmcgdGhlIGNsaWVudF9jcmVkZW50aWFscyBmbG93LlwiLFxuICAgIFtDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZF06XG4gICAgICAgIFwiVGhpcyBtZXRob2QgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkXCIsXG4gICAgW0NsaWVudEF1dGhFcnJvckNvZGVzLm5lc3RlZEFwcEF1dGhCcmlkZ2VEaXNhYmxlZF06XG4gICAgICAgIFwiVGhlIG5lc3RlZCBhcHAgYXV0aCBicmlkZ2UgaXMgZGlzYWJsZWRcIixcbn07XG5cbi8qKlxuICogU3RyaW5nIGNvbnN0YW50cyB1c2VkIGJ5IGVycm9yIGNvZGVzIGFuZCBtZXNzYWdlcy5cbiAqIEBkZXByZWNhdGVkIFVzZSBDbGllbnRBdXRoRXJyb3JDb2RlcyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBjb25zdCBDbGllbnRBdXRoRXJyb3JNZXNzYWdlID0ge1xuICAgIGNsaWVudEluZm9EZWNvZGluZ0Vycm9yOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLmNsaWVudEluZm9EZWNvZGluZ0Vycm9yLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmNsaWVudEluZm9EZWNvZGluZ0Vycm9yXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBjbGllbnRJbmZvRW1wdHlFcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5jbGllbnRJbmZvRW1wdHlFcnJvcixcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5jbGllbnRJbmZvRW1wdHlFcnJvclxuICAgICAgICBdLFxuICAgIH0sXG4gICAgdG9rZW5QYXJzaW5nRXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5QYXJzaW5nRXJyb3IsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuUGFyc2luZ0Vycm9yXSxcbiAgICB9LFxuICAgIG51bGxPckVtcHR5VG9rZW46IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMubnVsbE9yRW1wdHlUb2tlbixcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMubnVsbE9yRW1wdHlUb2tlbl0sXG4gICAgfSxcbiAgICBlbmRwb2ludFJlc29sdXRpb25FcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5lbmRwb2ludFJlc29sdXRpb25FcnJvcixcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5lbmRwb2ludFJlc29sdXRpb25FcnJvclxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbmV0d29ya0Vycm9yOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLm5ldHdvcmtFcnJvcixcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMubmV0d29ya0Vycm9yXSxcbiAgICB9LFxuICAgIHVuYWJsZVRvR2V0T3BlbmlkQ29uZmlnRXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMub3BlbklkQ29uZmlnRXJyb3IsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLm9wZW5JZENvbmZpZ0Vycm9yXSxcbiAgICB9LFxuICAgIGhhc2hOb3REZXNlcmlhbGl6ZWQ6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMuaGFzaE5vdERlc2VyaWFsaXplZCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMuaGFzaE5vdERlc2VyaWFsaXplZF0sXG4gICAgfSxcbiAgICBpbnZhbGlkU3RhdGVFcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkU3RhdGUsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRTdGF0ZV0sXG4gICAgfSxcbiAgICBzdGF0ZU1pc21hdGNoRXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMuc3RhdGVNaXNtYXRjaCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMuc3RhdGVNaXNtYXRjaF0sXG4gICAgfSxcbiAgICBzdGF0ZU5vdEZvdW5kRXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMuc3RhdGVOb3RGb3VuZCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMuc3RhdGVOb3RGb3VuZF0sXG4gICAgfSxcbiAgICBub25jZU1pc21hdGNoRXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMubm9uY2VNaXNtYXRjaCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMubm9uY2VNaXNtYXRjaF0sXG4gICAgfSxcbiAgICBhdXRoVGltZU5vdEZvdW5kRXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aFRpbWVOb3RGb3VuZCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aFRpbWVOb3RGb3VuZF0sXG4gICAgfSxcbiAgICBtYXhBZ2VUcmFuc3BpcmVkOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLm1heEFnZVRyYW5zcGlyZWQsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLm1heEFnZVRyYW5zcGlyZWRdLFxuICAgIH0sXG4gICAgbXVsdGlwbGVNYXRjaGluZ1Rva2Vuczoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5tdWx0aXBsZU1hdGNoaW5nVG9rZW5zLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdUb2tlbnNcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIG11bHRpcGxlTWF0Y2hpbmdBY2NvdW50czoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5tdWx0aXBsZU1hdGNoaW5nQWNjb3VudHMsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMubXVsdGlwbGVNYXRjaGluZ0FjY291bnRzXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBtdWx0aXBsZU1hdGNoaW5nQXBwTWV0YWRhdGE6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMubXVsdGlwbGVNYXRjaGluZ0FwcE1ldGFkYXRhLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdBcHBNZXRhZGF0YVxuICAgICAgICBdLFxuICAgIH0sXG4gICAgdG9rZW5SZXF1ZXN0Q2Fubm90QmVNYWRlOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLnJlcXVlc3RDYW5ub3RCZU1hZGUsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLnJlcXVlc3RDYW5ub3RCZU1hZGVdLFxuICAgIH0sXG4gICAgcmVtb3ZlRW1wdHlTY29wZUVycm9yOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLmNhbm5vdFJlbW92ZUVtcHR5U2NvcGUsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuY2Fubm90UmVtb3ZlRW1wdHlTY29wZVxuICAgICAgICBdLFxuICAgIH0sXG4gICAgYXBwZW5kU2NvcGVTZXRFcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5jYW5ub3RBcHBlbmRTY29wZVNldCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5jYW5ub3RBcHBlbmRTY29wZVNldFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgZW1wdHlJbnB1dFNjb3BlU2V0RXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMuZW1wdHlJbnB1dFNjb3BlU2V0LFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tDbGllbnRBdXRoRXJyb3JDb2Rlcy5lbXB0eUlucHV0U2NvcGVTZXRdLFxuICAgIH0sXG4gICAgRGV2aWNlQ29kZVBvbGxpbmdDYW5jZWxsZWQ6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMuZGV2aWNlQ29kZVBvbGxpbmdDYW5jZWxsZWQsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuZGV2aWNlQ29kZVBvbGxpbmdDYW5jZWxsZWRcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIERldmljZUNvZGVFeHBpcmVkOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLmRldmljZUNvZGVFeHBpcmVkLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tDbGllbnRBdXRoRXJyb3JDb2Rlcy5kZXZpY2VDb2RlRXhwaXJlZF0sXG4gICAgfSxcbiAgICBEZXZpY2VDb2RlVW5rbm93bkVycm9yOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLmRldmljZUNvZGVVbmtub3duRXJyb3IsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuZGV2aWNlQ29kZVVua25vd25FcnJvclxuICAgICAgICBdLFxuICAgIH0sXG4gICAgTm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0OiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLm5vQWNjb3VudEluU2lsZW50UmVxdWVzdCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub0FjY291bnRJblNpbGVudFJlcXVlc3RcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGludmFsaWRDYWNoZVJlY29yZDoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQ2FjaGVSZWNvcmQsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDYWNoZVJlY29yZF0sXG4gICAgfSxcbiAgICBpbnZhbGlkQ2FjaGVFbnZpcm9ubWVudDoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQ2FjaGVFbnZpcm9ubWVudCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQ2FjaGVFbnZpcm9ubWVudFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbm9BY2NvdW50Rm91bmQ6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMubm9BY2NvdW50Rm91bmQsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLm5vQWNjb3VudEZvdW5kXSxcbiAgICB9LFxuICAgIG5vQ3J5cHRvT2JqOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLm5vQ3J5cHRvT2JqZWN0LFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub0NyeXB0b09iamVjdF0sXG4gICAgfSxcbiAgICB1bmV4cGVjdGVkQ3JlZGVudGlhbFR5cGU6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMudW5leHBlY3RlZENyZWRlbnRpYWxUeXBlLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLnVuZXhwZWN0ZWRDcmVkZW50aWFsVHlwZVxuICAgICAgICBdLFxuICAgIH0sXG4gICAgaW52YWxpZEFzc2VydGlvbjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQXNzZXJ0aW9uLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQXNzZXJ0aW9uXSxcbiAgICB9LFxuICAgIGludmFsaWRDbGllbnRDcmVkZW50aWFsOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDbGllbnRDcmVkZW50aWFsLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDbGllbnRDcmVkZW50aWFsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB0b2tlblJlZnJlc2hSZXF1aXJlZDoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblJlZnJlc2hSZXF1aXJlZCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblJlZnJlc2hSZXF1aXJlZFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgdXNlclRpbWVvdXRSZWFjaGVkOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLnVzZXJUaW1lb3V0UmVhY2hlZCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMudXNlclRpbWVvdXRSZWFjaGVkXSxcbiAgICB9LFxuICAgIHRva2VuQ2xhaW1zUmVxdWlyZWQ6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5DbGFpbXNDbmZSZXF1aXJlZEZvclNpZ25lZEp3dCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlbkNsYWltc0NuZlJlcXVpcmVkRm9yU2lnbmVkSnd0XG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBub0F1dGhvcml6YXRpb25Db2RlRnJvbVNlcnZlcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5hdXRob3JpemF0aW9uQ29kZU1pc3NpbmdGcm9tU2VydmVyUmVzcG9uc2UsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aG9yaXphdGlvbkNvZGVNaXNzaW5nRnJvbVNlcnZlclJlc3BvbnNlXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBiaW5kaW5nS2V5Tm90UmVtb3ZlZEVycm9yOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLmJpbmRpbmdLZXlOb3RSZW1vdmVkLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmJpbmRpbmdLZXlOb3RSZW1vdmVkXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2dvdXROb3RTdXBwb3J0ZWQ6IHtcbiAgICAgICAgY29kZTogQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kU2Vzc2lvbkVuZHBvaW50Tm90U3VwcG9ydGVkLFxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmVuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZFxuICAgICAgICBdLFxuICAgIH0sXG4gICAga2V5SWRNaXNzaW5nOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLmtleUlkTWlzc2luZyxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbQ2xpZW50QXV0aEVycm9yQ29kZXMua2V5SWRNaXNzaW5nXSxcbiAgICB9LFxuICAgIG5vTmV0d29ya0Nvbm5lY3Rpdml0eToge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub05ldHdvcmtDb25uZWN0aXZpdHksXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMubm9OZXR3b3JrQ29ubmVjdGl2aXR5XG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB1c2VyQ2FuY2VsZWRFcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy51c2VyQ2FuY2VsZWQsXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW0NsaWVudEF1dGhFcnJvckNvZGVzLnVzZXJDYW5jZWxlZF0sXG4gICAgfSxcbiAgICBtaXNzaW5nVGVuYW50SWRFcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRBdXRoRXJyb3JDb2Rlcy5taXNzaW5nVGVuYW50SWRFcnJvcixcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5taXNzaW5nVGVuYW50SWRFcnJvclxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbmVzdGVkQXBwQXV0aEJyaWRnZURpc2FibGVkOiB7XG4gICAgICAgIGNvZGU6IENsaWVudEF1dGhFcnJvckNvZGVzLm5lc3RlZEFwcEF1dGhCcmlkZ2VEaXNhYmxlZCxcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5uZXN0ZWRBcHBBdXRoQnJpZGdlRGlzYWJsZWRcbiAgICAgICAgXSxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgY2xpZW50IGNvZGUgcnVubmluZyBvbiB0aGUgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGNsYXNzIENsaWVudEF1dGhFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlOiBzdHJpbmcsIGFkZGl0aW9uYWxNZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgICAgZXJyb3JDb2RlLFxuICAgICAgICAgICAgYWRkaXRpb25hbE1lc3NhZ2VcbiAgICAgICAgICAgICAgICA/IGAke0NsaWVudEF1dGhFcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV19OiAke2FkZGl0aW9uYWxNZXNzYWdlfWBcbiAgICAgICAgICAgICAgICA6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV1cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDbGllbnRBdXRoRXJyb3JcIjtcblxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2xpZW50QXV0aEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgIGVycm9yQ29kZTogc3RyaW5nLFxuICAgIGFkZGl0aW9uYWxNZXNzYWdlPzogc3RyaW5nXG4pOiBDbGllbnRBdXRoRXJyb3Ige1xuICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKGVycm9yQ29kZSwgYWRkaXRpb25hbE1lc3NhZ2UpO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgQmFzZUF1dGhSZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQmFzZUF1dGhSZXF1ZXN0LmpzXCI7XG5pbXBvcnQgeyBTaHJPcHRpb25zLCBTaWduZWRIdHRwUmVxdWVzdCB9IGZyb20gXCIuL1NpZ25lZEh0dHBSZXF1ZXN0LmpzXCI7XG5cbi8qKlxuICogVGhlIFBrY2VDb2RlcyB0eXBlIGRlc2NyaWJlcyB0aGUgc3RydWN0dXJlXG4gKiBvZiBvYmplY3RzIHRoYXQgY29udGFpbiBQS0NFIGNvZGVcbiAqIGNoYWxsZW5nZSBhbmQgdmVyaWZpZXIgcGFpcnNcbiAqL1xuZXhwb3J0IHR5cGUgUGtjZUNvZGVzID0ge1xuICAgIHZlcmlmaWVyOiBzdHJpbmc7XG4gICAgY2hhbGxlbmdlOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBTaWduZWRIdHRwUmVxdWVzdFBhcmFtZXRlcnMgPSBQaWNrPFxuICAgIEJhc2VBdXRoUmVxdWVzdCxcbiAgICB8IFwicmVzb3VyY2VSZXF1ZXN0TWV0aG9kXCJcbiAgICB8IFwicmVzb3VyY2VSZXF1ZXN0VXJpXCJcbiAgICB8IFwic2hyQ2xhaW1zXCJcbiAgICB8IFwic2hyTm9uY2VcIlxuICAgIHwgXCJzaHJPcHRpb25zXCJcbj4gJiB7XG4gICAgY29ycmVsYXRpb25JZD86IHN0cmluZztcbn07XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBjcnlwdG8gZnVuY3Rpb25zIHVzZWQgYnkgbGlicmFyeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDcnlwdG8ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBndWlkIHJhbmRvbWx5LlxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0d1aWQoKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIGJhc2U2NCBFbmNvZGUgc3RyaW5nXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICovXG4gICAgYmFzZTY0RW5jb2RlKGlucHV0OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogYmFzZTY0IGRlY29kZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKi9cbiAgICBiYXNlNjREZWNvZGUoaW5wdXQ6IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBiYXNlNjQgVVJMIHNhZmUgZW5jb2RlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBiYXNlNjRVcmxFbmNvZGUoaW5wdXQ6IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTdHJpbmdpZmllcyBhbmQgYmFzZTY0VXJsIGVuY29kZXMgaW5wdXQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpbnB1dEtpZFxuICAgICAqIEByZXR1cm5zIEJhc2U2NFVybCBlbmNvZGVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBlbmNvZGVLaWQoaW5wdXRLaWQ6IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSldLIFJTQSBTMjU2IFRodW1icHJpbnRcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAqL1xuICAgIGdldFB1YmxpY0tleVRodW1icHJpbnQoXG4gICAgICAgIHJlcXVlc3Q6IFNpZ25lZEh0dHBSZXF1ZXN0UGFyYW1ldGVyc1xuICAgICk6IFByb21pc2U8c3RyaW5nPjtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGNyeXB0b2dyYXBoaWMga2V5cGFpciBmcm9tIGtleSBzdG9yZSBtYXRjaGluZyB0aGUga2V5SWQgcGFzc2VkIGluXG4gICAgICogQHBhcmFtIGtpZFxuICAgICAqL1xuICAgIHJlbW92ZVRva2VuQmluZGluZ0tleShraWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgY3J5cHRvZ3JhcGhpYyBrZXlzIGZyb20gSW5kZXhlZERCIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjbGVhcktleXN0b3JlKCk6IFByb21pc2U8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpZ25lZCBwcm9vZi1vZi1wb3NzZXNzaW9uIHRva2VuIHdpdGggYSBnaXZlbiBhY2NlcyB0b2tlbiB0aGF0IGNvbnRhaW5zIGEgY25mIGNsYWltIHdpdGggdGhlIHJlcXVpcmVkIGtpZC5cbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW5cbiAgICAgKi9cbiAgICBzaWduSnd0KFxuICAgICAgICBwYXlsb2FkOiBTaWduZWRIdHRwUmVxdWVzdCxcbiAgICAgICAga2lkOiBzdHJpbmcsXG4gICAgICAgIHNock9wdGlvbnM/OiBTaHJPcHRpb25zLFxuICAgICAgICBjb3JyZWxhdGlvbklkPzogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNIQS0yNTYgaGFzaCBvZiBhbiBpbnB1dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0XG4gICAgICovXG4gICAgaGFzaFN0cmluZyhwbGFpblRleHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OOiBJQ3J5cHRvID0ge1xuICAgIGNyZWF0ZU5ld0d1aWQ6ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH0sXG4gICAgYmFzZTY0RGVjb2RlOiAoKTogc3RyaW5nID0+IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9LFxuICAgIGJhc2U2NEVuY29kZTogKCk6IHN0cmluZyA9PiB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfSxcbiAgICBiYXNlNjRVcmxFbmNvZGU6ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH0sXG4gICAgZW5jb2RlS2lkOiAoKTogc3RyaW5nID0+IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9LFxuICAgIGFzeW5jIGdldFB1YmxpY0tleVRodW1icHJpbnQoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9LFxuICAgIGFzeW5jIHJlbW92ZVRva2VuQmluZGluZ0tleSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9LFxuICAgIGFzeW5jIGNsZWFyS2V5c3RvcmUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfSxcbiAgICBhc3luYyBzaWduSnd0KCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfSxcbiAgICBhc3luYyBoYXNoU3RyaW5nKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfSxcbn07XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IExvZ2dlck9wdGlvbnMgfSBmcm9tIFwiLi4vY29uZmlnL0NsaWVudENvbmZpZ3VyYXRpb24uanNcIjtcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBsb2dnZXIgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCB0eXBlIExvZ2dlck1lc3NhZ2VPcHRpb25zID0ge1xuICAgIGxvZ0xldmVsOiBMb2dMZXZlbDtcbiAgICBjb250YWluc1BpaT86IGJvb2xlYW47XG4gICAgY29udGV4dD86IHN0cmluZztcbiAgICBjb3JyZWxhdGlvbklkPzogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBMb2cgbWVzc2FnZSBsZXZlbC5cbiAqL1xuZXhwb3J0IGVudW0gTG9nTGV2ZWwge1xuICAgIEVycm9yLFxuICAgIFdhcm5pbmcsXG4gICAgSW5mbyxcbiAgICBWZXJib3NlLFxuICAgIFRyYWNlLFxufVxuXG4vKipcbiAqIENhbGxiYWNrIHRvIHNlbmQgdGhlIG1lc3NhZ2VzIHRvLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElMb2dnZXJDYWxsYmFjayB7XG4gICAgKGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nLCBjb250YWluc1BpaTogYm9vbGVhbik6IHZvaWQ7XG59XG5cbi8qKlxuICogQ2xhc3Mgd2hpY2ggZmFjaWxpdGF0ZXMgbG9nZ2luZyBvZiBtZXNzYWdlcyB0byBhIHNwZWNpZmljIHBsYWNlLlxuICovXG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgICAvLyBDb3JyZWxhdGlvbiBJRCBmb3IgcmVxdWVzdCwgdXN1YWxseSBzZXQgYnkgdXNlci5cbiAgICBwcml2YXRlIGNvcnJlbGF0aW9uSWQ6IHN0cmluZztcblxuICAgIC8vIEN1cnJlbnQgbG9nIGxldmVsLCBkZWZhdWx0cyB0byBpbmZvLlxuICAgIHByaXZhdGUgbGV2ZWw6IExvZ0xldmVsID0gTG9nTGV2ZWwuSW5mbztcblxuICAgIC8vIEJvb2xlYW4gZGVzY3JpYmluZyB3aGV0aGVyIFBJSSBsb2dnaW5nIGlzIGFsbG93ZWQuXG4gICAgcHJpdmF0ZSBwaWlMb2dnaW5nRW5hYmxlZDogYm9vbGVhbjtcblxuICAgIC8vIENhbGxiYWNrIHRvIHNlbmQgbWVzc2FnZXMgdG8uXG4gICAgcHJpdmF0ZSBsb2NhbENhbGxiYWNrOiBJTG9nZ2VyQ2FsbGJhY2s7XG5cbiAgICAvLyBQYWNrYWdlIG5hbWUgaW1wbGVtZW50aW5nIHRoaXMgbG9nZ2VyXG4gICAgcHJpdmF0ZSBwYWNrYWdlTmFtZTogc3RyaW5nO1xuXG4gICAgLy8gUGFja2FnZSB2ZXJzaW9uIGltcGxlbWVudGluZyB0aGlzIGxvZ2dlclxuICAgIHByaXZhdGUgcGFja2FnZVZlcnNpb246IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zLFxuICAgICAgICBwYWNrYWdlTmFtZT86IHN0cmluZyxcbiAgICAgICAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdExvZ2dlckNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRMb2dnZXJPcHRpb25zID1cbiAgICAgICAgICAgIGxvZ2dlck9wdGlvbnMgfHwgTG9nZ2VyLmNyZWF0ZURlZmF1bHRMb2dnZXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMubG9jYWxDYWxsYmFjayA9XG4gICAgICAgICAgICBzZXRMb2dnZXJPcHRpb25zLmxvZ2dlckNhbGxiYWNrIHx8IGRlZmF1bHRMb2dnZXJDYWxsYmFjaztcbiAgICAgICAgdGhpcy5waWlMb2dnaW5nRW5hYmxlZCA9IHNldExvZ2dlck9wdGlvbnMucGlpTG9nZ2luZ0VuYWJsZWQgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMubGV2ZWwgPVxuICAgICAgICAgICAgdHlwZW9mIHNldExvZ2dlck9wdGlvbnMubG9nTGV2ZWwgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICA/IHNldExvZ2dlck9wdGlvbnMubG9nTGV2ZWxcbiAgICAgICAgICAgICAgICA6IExvZ0xldmVsLkluZm87XG4gICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9XG4gICAgICAgICAgICBzZXRMb2dnZXJPcHRpb25zLmNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgdGhpcy5wYWNrYWdlTmFtZSA9IHBhY2thZ2VOYW1lIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG4gICAgICAgIHRoaXMucGFja2FnZVZlcnNpb24gPSBwYWNrYWdlVmVyc2lvbiB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZURlZmF1bHRMb2dnZXJPcHRpb25zKCk6IExvZ2dlck9wdGlvbnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9nZ2VyQ2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB1c2VycyB0byBub3Qgc2V0IGxvZ2dlckNhbGxiYWNrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGlpTG9nZ2luZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm8sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG5ldyBMb2dnZXIgd2l0aCBleGlzdGluZyBjb25maWd1cmF0aW9ucy5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xvbmUoXG4gICAgICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgICAgIHBhY2thZ2VWZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmdcbiAgICApOiBMb2dnZXIge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJDYWxsYmFjazogdGhpcy5sb2NhbENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHBpaUxvZ2dpbmdFbmFibGVkOiB0aGlzLnBpaUxvZ2dpbmdFbmFibGVkLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsOiB0aGlzLmxldmVsLFxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgdGhpcy5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhY2thZ2VOYW1lLFxuICAgICAgICAgICAgcGFja2FnZVZlcnNpb25cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2cgbWVzc2FnZSB3aXRoIHJlcXVpcmVkIG9wdGlvbnMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2dNZXNzYWdlKFxuICAgICAgICBsb2dNZXNzYWdlOiBzdHJpbmcsXG4gICAgICAgIG9wdGlvbnM6IExvZ2dlck1lc3NhZ2VPcHRpb25zXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG9wdGlvbnMubG9nTGV2ZWwgPiB0aGlzLmxldmVsIHx8XG4gICAgICAgICAgICAoIXRoaXMucGlpTG9nZ2luZ0VuYWJsZWQgJiYgb3B0aW9ucy5jb250YWluc1BpaSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b1VUQ1N0cmluZygpO1xuXG4gICAgICAgIC8vIEFkZCBjb3JyZWxhdGlvbklkIHRvIGxvZ3MgaWYgc2V0LCBjb3JyZWxhdGlvbklkIHByb3ZpZGVkIG9uIGxvZyBtZXNzYWdlcyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgY29uc3QgbG9nSGVhZGVyID0gYFske3RpbWVzdGFtcH1dIDogWyR7XG4gICAgICAgICAgICBvcHRpb25zLmNvcnJlbGF0aW9uSWQgfHwgdGhpcy5jb3JyZWxhdGlvbklkIHx8IFwiXCJcbiAgICAgICAgfV1gO1xuXG4gICAgICAgIGNvbnN0IGxvZyA9IGAke2xvZ0hlYWRlcn0gOiAke3RoaXMucGFja2FnZU5hbWV9QCR7XG4gICAgICAgICAgICB0aGlzLnBhY2thZ2VWZXJzaW9uXG4gICAgICAgIH0gOiAke0xvZ0xldmVsW29wdGlvbnMubG9nTGV2ZWxdfSAtICR7bG9nTWVzc2FnZX1gO1xuICAgICAgICAvLyBkZWJ1ZyhgbXNhbDoke0xvZ0xldmVsW29wdGlvbnMubG9nTGV2ZWxdfSR7b3B0aW9ucy5jb250YWluc1BpaSA/IFwiLVBpaVwiOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HfSR7b3B0aW9ucy5jb250ZXh0ID8gYDoke29wdGlvbnMuY29udGV4dH1gIDogQ29uc3RhbnRzLkVNUFRZX1NUUklOR31gKShsb2dNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5leGVjdXRlQ2FsbGJhY2soXG4gICAgICAgICAgICBvcHRpb25zLmxvZ0xldmVsLFxuICAgICAgICAgICAgbG9nLFxuICAgICAgICAgICAgb3B0aW9ucy5jb250YWluc1BpaSB8fCBmYWxzZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgY2FsbGJhY2sgd2l0aCBtZXNzYWdlLlxuICAgICAqL1xuICAgIGV4ZWN1dGVDYWxsYmFjayhcbiAgICAgICAgbGV2ZWw6IExvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgICAgIGNvbnRhaW5zUGlpOiBib29sZWFuXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxDYWxsYmFjayhsZXZlbCwgbWVzc2FnZSwgY29udGFpbnNQaWkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBlcnJvciBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5FcnJvcixcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiBmYWxzZSxcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBlcnJvciBtZXNzYWdlcyB3aXRoIFBJSS5cbiAgICAgKi9cbiAgICBlcnJvclBpaShtZXNzYWdlOiBzdHJpbmcsIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5FcnJvcixcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiB0cnVlLFxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIHdhcm5pbmcgbWVzc2FnZXMuXG4gICAgICovXG4gICAgd2FybmluZyhtZXNzYWdlOiBzdHJpbmcsIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5XYXJuaW5nLFxuICAgICAgICAgICAgY29udGFpbnNQaWk6IGZhbHNlLFxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIHdhcm5pbmcgbWVzc2FnZXMgd2l0aCBQSUkuXG4gICAgICovXG4gICAgd2FybmluZ1BpaShtZXNzYWdlOiBzdHJpbmcsIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5XYXJuaW5nLFxuICAgICAgICAgICAgY29udGFpbnNQaWk6IHRydWUsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ3MgaW5mbyBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgY29ycmVsYXRpb25JZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm8sXG4gICAgICAgICAgICBjb250YWluc1BpaTogZmFsc2UsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ3MgaW5mbyBtZXNzYWdlcyB3aXRoIFBJSS5cbiAgICAgKi9cbiAgICBpbmZvUGlpKG1lc3NhZ2U6IHN0cmluZywgY29ycmVsYXRpb25JZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm8sXG4gICAgICAgICAgICBjb250YWluc1BpaTogdHJ1ZSxcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyB2ZXJib3NlIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHZlcmJvc2UobWVzc2FnZTogc3RyaW5nLCBjb3JyZWxhdGlvbklkPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nTWVzc2FnZShtZXNzYWdlLCB7XG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuVmVyYm9zZSxcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiBmYWxzZSxcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyB2ZXJib3NlIG1lc3NhZ2VzIHdpdGggUElJLlxuICAgICAqL1xuICAgIHZlcmJvc2VQaWkobWVzc2FnZTogc3RyaW5nLCBjb3JyZWxhdGlvbklkPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nTWVzc2FnZShtZXNzYWdlLCB7XG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuVmVyYm9zZSxcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiB0cnVlLFxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIHRyYWNlIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHRyYWNlKG1lc3NhZ2U6IHN0cmluZywgY29ycmVsYXRpb25JZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLlRyYWNlLFxuICAgICAgICAgICAgY29udGFpbnNQaWk6IGZhbHNlLFxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIHRyYWNlIG1lc3NhZ2VzIHdpdGggUElJLlxuICAgICAqL1xuICAgIHRyYWNlUGlpKG1lc3NhZ2U6IHN0cmluZywgY29ycmVsYXRpb25JZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLlRyYWNlLFxuICAgICAgICAgICAgY29udGFpbnNQaWk6IHRydWUsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBQSUkgTG9nZ2luZyBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBpc1BpaUxvZ2dpbmdFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5waWlMb2dnaW5nRW5hYmxlZCB8fCBmYWxzZTtcbiAgICB9XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgaGVhZGVyL2hlYWRlciAqL1xuZXhwb3J0IGNvbnN0IG5hbWUgPSBcIkBhenVyZS9tc2FsLWNvbW1vblwiO1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjE1LjQuMFwiO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQcm90b2NvbE1vZGUgfSBmcm9tIFwiLi9Qcm90b2NvbE1vZGUuanNcIjtcbmltcG9ydCB7IE9JRENPcHRpb25zIH0gZnJvbSBcIi4vT0lEQ09wdGlvbnMuanNcIjtcbmltcG9ydCB7IEF6dXJlUmVnaW9uQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuL0F6dXJlUmVnaW9uQ29uZmlndXJhdGlvbi5qc1wiO1xuaW1wb3J0IHsgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlIH0gZnJvbSBcIi4vQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlLmpzXCI7XG5cbmV4cG9ydCB0eXBlIEF1dGhvcml0eU9wdGlvbnMgPSB7XG4gICAgcHJvdG9jb2xNb2RlOiBQcm90b2NvbE1vZGU7XG4gICAgT0lEQ09wdGlvbnM/OiBPSURDT3B0aW9ucyB8IG51bGw7XG4gICAga25vd25BdXRob3JpdGllczogQXJyYXk8c3RyaW5nPjtcbiAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhOiBzdHJpbmc7XG4gICAgYXV0aG9yaXR5TWV0YWRhdGE6IHN0cmluZztcbiAgICBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZT86IGJvb2xlYW47XG4gICAgYXp1cmVSZWdpb25Db25maWd1cmF0aW9uPzogQXp1cmVSZWdpb25Db25maWd1cmF0aW9uO1xuICAgIGF1dGhvcml0eT86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIFN0YXRpY0F1dGhvcml0eU9wdGlvbnMgPSBQYXJ0aWFsPFxuICAgIFBpY2s8QXV0aG9yaXR5T3B0aW9ucywgXCJrbm93bkF1dGhvcml0aWVzXCI+XG4+ICYge1xuICAgIGNhbm9uaWNhbEF1dGhvcml0eT86IHN0cmluZztcbiAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhPzogQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlO1xufTtcblxuZXhwb3J0IGNvbnN0IEF6dXJlQ2xvdWRJbnN0YW5jZSA9IHtcbiAgICAvLyBBenVyZUNsb3VkSW5zdGFuY2UgaXMgbm90IHNwZWNpZmllZC5cbiAgICBOb25lOiBcIm5vbmVcIixcblxuICAgIC8vIE1pY3Jvc29mdCBBenVyZSBwdWJsaWMgY2xvdWRcbiAgICBBenVyZVB1YmxpYzogXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb21cIixcblxuICAgIC8vIE1pY3Jvc29mdCBQUEVcbiAgICBBenVyZVBwZTogXCJodHRwczovL2xvZ2luLndpbmRvd3MtcHBlLm5ldFwiLFxuXG4gICAgLy8gTWljcm9zb2Z0IENoaW5lc2UgbmF0aW9uYWwvcmVnaW9uYWwgY2xvdWRcbiAgICBBenVyZUNoaW5hOiBcImh0dHBzOi8vbG9naW4uY2hpbmFjbG91ZGFwaS5jblwiLFxuXG4gICAgLy8gTWljcm9zb2Z0IEdlcm1hbiBuYXRpb25hbC9yZWdpb25hbCBjbG91ZCAoXCJCbGFjayBGb3Jlc3RcIilcbiAgICBBenVyZUdlcm1hbnk6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuZGVcIixcblxuICAgIC8vIFVTIEdvdmVybm1lbnQgY2xvdWRcbiAgICBBenVyZVVzR292ZXJubWVudDogXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS51c1wiLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIEF6dXJlQ2xvdWRJbnN0YW5jZSA9XG4gICAgKHR5cGVvZiBBenVyZUNsb3VkSW5zdGFuY2UpW2tleW9mIHR5cGVvZiBBenVyZUNsb3VkSW5zdGFuY2VdO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBUb2tlbkNsYWltcyB9IGZyb20gXCIuL1Rva2VuQ2xhaW1zLmpzXCI7XG5pbXBvcnQge1xuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbiAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcyxcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuXG4vKipcbiAqIEV4dHJhY3QgdG9rZW4gYnkgZGVjb2RpbmcgdGhlIHJhd1Rva2VuXG4gKlxuICogQHBhcmFtIGVuY29kZWRUb2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRva2VuQ2xhaW1zKFxuICAgIGVuY29kZWRUb2tlbjogc3RyaW5nLFxuICAgIGJhc2U2NERlY29kZTogKGlucHV0OiBzdHJpbmcpID0+IHN0cmluZ1xuKTogVG9rZW5DbGFpbXMge1xuICAgIGNvbnN0IGpzd1BheWxvYWQgPSBnZXRKV1NQYXlsb2FkKGVuY29kZWRUb2tlbik7XG5cbiAgICAvLyB0b2tlbiB3aWxsIGJlIGRlY29kZWQgdG8gZ2V0IHRoZSB1c2VybmFtZVxuICAgIHRyeSB7XG4gICAgICAgIC8vIGJhc2U2NERlY29kZSgpIHNob3VsZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhbiBpc3N1ZVxuICAgICAgICBjb25zdCBiYXNlNjREZWNvZGVkID0gYmFzZTY0RGVjb2RlKGpzd1BheWxvYWQpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShiYXNlNjREZWNvZGVkKSBhcyBUb2tlbkNsYWltcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuUGFyc2luZ0Vycm9yKTtcbiAgICB9XG59XG5cbi8qKlxuICogZGVjb2RlIGEgSldUXG4gKlxuICogQHBhcmFtIGF1dGhUb2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SldTUGF5bG9hZChhdXRoVG9rZW46IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCFhdXRoVG9rZW4pIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm51bGxPckVtcHR5VG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCB0b2tlblBhcnRzUmVnZXggPSAvXihbXlxcLlxcc10qKVxcLihbXlxcLlxcc10rKVxcLihbXlxcLlxcc10qKSQvO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0b2tlblBhcnRzUmVnZXguZXhlYyhhdXRoVG9rZW4pO1xuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuUGFyc2luZ0Vycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29uc3QgY3JhY2tlZFRva2VuID0ge1xuICAgICAqICBoZWFkZXI6IG1hdGNoZXNbMV0sXG4gICAgICogIEpXU1BheWxvYWQ6IG1hdGNoZXNbMl0sXG4gICAgICogIEpXU1NpZzogbWF0Y2hlc1szXSxcbiAgICAgKiB9O1xuICAgICAqL1xuXG4gICAgcmV0dXJuIG1hdGNoZXNbMl07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSB0b2tlbidzIG1heF9hZ2UgaGFzIHRyYW5zcGlyZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTWF4QWdlKGF1dGhUaW1lOiBudW1iZXIsIG1heEFnZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLypcbiAgICAgKiBwZXIgaHR0cHM6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWNvcmUtMV8wLmh0bWwjQXV0aFJlcXVlc3RcbiAgICAgKiBUbyBmb3JjZSBhbiBpbW1lZGlhdGUgcmUtYXV0aGVudGljYXRpb246IElmIGFuIGFwcCByZXF1aXJlcyB0aGF0IGEgdXNlciByZS1hdXRoZW50aWNhdGUgcHJpb3IgdG8gYWNjZXNzLFxuICAgICAqIHByb3ZpZGUgYSB2YWx1ZSBvZiAwIGZvciB0aGUgbWF4X2FnZSBwYXJhbWV0ZXIgYW5kIHRoZSBBUyB3aWxsIGZvcmNlIGEgZnJlc2ggbG9naW4uXG4gICAgICovXG4gICAgY29uc3QgZml2ZU1pbnV0ZVNrZXcgPSAzMDAwMDA7IC8vIGZpdmUgbWludXRlcyBpbiBtaWxsaXNlY29uZHNcbiAgICBpZiAobWF4QWdlID09PSAwIHx8IERhdGUubm93KCkgLSBmaXZlTWludXRlU2tldyA+IGF1dGhUaW1lICsgbWF4QWdlKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tYXhBZ2VUcmFuc3BpcmVkKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGRhdGUgYW5kIHRpbWUgb3BlcmF0aW9ucy5cbiAqL1xuXG4vKipcbiAqIHJldHVybiB0aGUgY3VycmVudCB0aW1lIGluIFVuaXggdGltZSAoc2Vjb25kcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3dTZWNvbmRzKCk6IG51bWJlciB7XG4gICAgLy8gRGF0ZS5nZXRUaW1lKCkgcmV0dXJucyBpbiBtaWxsaXNlY29uZHMuXG4gICAgcmV0dXJuIE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwLjApO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIEpTIERhdGUgb2JqZWN0IHRvIHNlY29uZHNcbiAqIEBwYXJhbSBkYXRlIERhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU2Vjb25kc0Zyb21EYXRlKGRhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIC8vIENvbnZlcnQgZGF0ZSB0byBzZWNvbmRzXG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHNlY29uZHMgdG8gSlMgRGF0ZSBvYmplY3QuIFNlY29uZHMgY2FuIGJlIGluIGEgbnVtYmVyIG9yIHN0cmluZyBmb3JtYXQgb3IgdW5kZWZpbmVkICh3aWxsIHN0aWxsIHJldHVybiBhIGRhdGUpLlxuICogQHBhcmFtIHNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0ZUZyb21TZWNvbmRzKHNlY29uZHM6IG51bWJlciB8IHN0cmluZyB8IHVuZGVmaW5lZCk6IERhdGUge1xuICAgIGlmIChzZWNvbmRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIoc2Vjb25kcykgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG59XG5cbi8qKlxuICogY2hlY2sgaWYgYSB0b2tlbiBpcyBleHBpcmVkIGJhc2VkIG9uIGdpdmVuIFVUQyB0aW1lIGluIHNlY29uZHMuXG4gKiBAcGFyYW0gZXhwaXJlc09uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Rva2VuRXhwaXJlZChleHBpcmVzT246IHN0cmluZywgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBjaGVjayBmb3IgYWNjZXNzIHRva2VuIGV4cGlyeVxuICAgIGNvbnN0IGV4cGlyYXRpb25TZWMgPSBOdW1iZXIoZXhwaXJlc09uKSB8fCAwO1xuICAgIGNvbnN0IG9mZnNldEN1cnJlbnRUaW1lU2VjID0gbm93U2Vjb25kcygpICsgb2Zmc2V0O1xuXG4gICAgLy8gSWYgY3VycmVudCB0aW1lICsgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0b2tlbiBleHBpcmF0aW9uIHRpbWUsIHRoZW4gdG9rZW4gaXMgZXhwaXJlZC5cbiAgICByZXR1cm4gb2Zmc2V0Q3VycmVudFRpbWVTZWMgPiBleHBpcmF0aW9uU2VjO1xufVxuXG4vKipcbiAqIElmIHRoZSBjdXJyZW50IHRpbWUgaXMgZWFybGllciB0aGFuIHRoZSB0aW1lIHRoYXQgYSB0b2tlbiB3YXMgY2FjaGVkIGF0LCB3ZSBtdXN0IGRpc2NhcmQgdGhlIHRva2VuXG4gKiBpLmUuIFRoZSBzeXN0ZW0gY2xvY2sgd2FzIHR1cm5lZCBiYWNrIGFmdGVyIGFjcXVpcmluZyB0aGUgY2FjaGVkIHRva2VuXG4gKiBAcGFyYW0gY2FjaGVkQXRcbiAqIEBwYXJhbSBvZmZzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhc0Nsb2NrVHVybmVkQmFjayhjYWNoZWRBdDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgY2FjaGVkQXRTZWMgPSBOdW1iZXIoY2FjaGVkQXQpO1xuXG4gICAgcmV0dXJuIGNhY2hlZEF0U2VjID4gbm93U2Vjb25kcygpO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciB0IG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB0IG51bWJlclxuICogQHBhcmFtIHZhbHVlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5PFQ+KHQ6IG51bWJlciwgdmFsdWU/OiBUKTogUHJvbWlzZTxUIHwgdm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHZhbHVlKSwgdCkpO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBleHRyYWN0VG9rZW5DbGFpbXMgfSBmcm9tIFwiLi4vLi4vYWNjb3VudC9BdXRoVG9rZW4uanNcIjtcbmltcG9ydCB7IFRva2VuQ2xhaW1zIH0gZnJvbSBcIi4uLy4uL2FjY291bnQvVG9rZW5DbGFpbXMuanNcIjtcbmltcG9ydCB7IENsb3VkRGlzY292ZXJ5TWV0YWRhdGEgfSBmcm9tIFwiLi4vLi4vYXV0aG9yaXR5L0Nsb3VkRGlzY292ZXJ5TWV0YWRhdGEuanNcIjtcbmltcG9ydCB7IE9wZW5JZENvbmZpZ1Jlc3BvbnNlIH0gZnJvbSBcIi4uLy4uL2F1dGhvcml0eS9PcGVuSWRDb25maWdSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBDbGllbnRBdXRoRXJyb3JDb2RlcyxcbiAgICBjcmVhdGVDbGllbnRBdXRoRXJyb3IsXG59IGZyb20gXCIuLi8uLi9lcnJvci9DbGllbnRBdXRoRXJyb3IuanNcIjtcbmltcG9ydCB7XG4gICAgQVBQX01FVEFEQVRBLFxuICAgIEFVVEhPUklUWV9NRVRBREFUQV9DT05TVEFOVFMsXG4gICAgQXV0aGVudGljYXRpb25TY2hlbWUsXG4gICAgQ3JlZGVudGlhbFR5cGUsXG4gICAgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUyxcbiAgICBTZXBhcmF0b3JzLFxuICAgIFRocm90dGxpbmdDb25zdGFudHMsXG59IGZyb20gXCIuLi8uLi91dGlscy9Db25zdGFudHMuanNcIjtcbmltcG9ydCAqIGFzIFRpbWVVdGlscyBmcm9tIFwiLi4vLi4vdXRpbHMvVGltZVV0aWxzLmpzXCI7XG5pbXBvcnQgeyBBY2Nlc3NUb2tlbkVudGl0eSB9IGZyb20gXCIuLi9lbnRpdGllcy9BY2Nlc3NUb2tlbkVudGl0eS5qc1wiO1xuaW1wb3J0IHsgQXBwTWV0YWRhdGFFbnRpdHkgfSBmcm9tIFwiLi4vZW50aXRpZXMvQXBwTWV0YWRhdGFFbnRpdHkuanNcIjtcbmltcG9ydCB7IEF1dGhvcml0eU1ldGFkYXRhRW50aXR5IH0gZnJvbSBcIi4uL2VudGl0aWVzL0F1dGhvcml0eU1ldGFkYXRhRW50aXR5LmpzXCI7XG5pbXBvcnQgeyBDcmVkZW50aWFsRW50aXR5IH0gZnJvbSBcIi4uL2VudGl0aWVzL0NyZWRlbnRpYWxFbnRpdHkuanNcIjtcbmltcG9ydCB7IElkVG9rZW5FbnRpdHkgfSBmcm9tIFwiLi4vZW50aXRpZXMvSWRUb2tlbkVudGl0eS5qc1wiO1xuaW1wb3J0IHsgUmVmcmVzaFRva2VuRW50aXR5IH0gZnJvbSBcIi4uL2VudGl0aWVzL1JlZnJlc2hUb2tlbkVudGl0eS5qc1wiO1xuXG4vKipcbiAqIENhY2hlIEtleTogPGhvbWVfYWNjb3VudF9pZD4tPGVudmlyb25tZW50Pi08Y3JlZGVudGlhbF90eXBlPi08Y2xpZW50X2lkIG9yIGZhbWlseUlkPi08cmVhbG0+LTxzY29wZXM+LTxjbGFpbXMgaGFzaD4tPHNjaGVtZT5cbiAqIElkVG9rZW4gRXhhbXBsZTogdWlkLnV0aWQtbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS1pZHRva2VuLWFwcF9jbGllbnRfaWQtY29udG9zby5jb21cbiAqIEFjY2Vzc1Rva2VuIEV4YW1wbGU6IHVpZC51dGlkLWxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20tYWNjZXNzdG9rZW4tYXBwX2NsaWVudF9pZC1jb250b3NvLmNvbS1zY29wZTEgc2NvcGUyLS1wb3BcbiAqIFJlZnJlc2hUb2tlbiBFeGFtcGxlOiB1aWQudXRpZC1sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tLXJlZnJlc2h0b2tlbi0xLWNvbnRvc28uY29tXG4gKiBAcGFyYW0gY3JlZGVudGlhbEVudGl0eVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ3JlZGVudGlhbEtleShcbiAgICBjcmVkZW50aWFsRW50aXR5OiBDcmVkZW50aWFsRW50aXR5XG4pOiBzdHJpbmcge1xuICAgIGNvbnN0IGNyZWRlbnRpYWxLZXkgPSBbXG4gICAgICAgIGdlbmVyYXRlQWNjb3VudElkKGNyZWRlbnRpYWxFbnRpdHkpLFxuICAgICAgICBnZW5lcmF0ZUNyZWRlbnRpYWxJZChjcmVkZW50aWFsRW50aXR5KSxcbiAgICAgICAgZ2VuZXJhdGVUYXJnZXQoY3JlZGVudGlhbEVudGl0eSksXG4gICAgICAgIGdlbmVyYXRlQ2xhaW1zSGFzaChjcmVkZW50aWFsRW50aXR5KSxcbiAgICAgICAgZ2VuZXJhdGVTY2hlbWUoY3JlZGVudGlhbEVudGl0eSksXG4gICAgXTtcblxuICAgIHJldHVybiBjcmVkZW50aWFsS2V5LmpvaW4oU2VwYXJhdG9ycy5DQUNIRV9LRVlfU0VQQVJBVE9SKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBJZFRva2VuRW50aXR5XG4gKiBAcGFyYW0gaG9tZUFjY291bnRJZFxuICogQHBhcmFtIGF1dGhlbnRpY2F0aW9uUmVzdWx0XG4gKiBAcGFyYW0gY2xpZW50SWRcbiAqIEBwYXJhbSBhdXRob3JpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlkVG9rZW5FbnRpdHkoXG4gICAgaG9tZUFjY291bnRJZDogc3RyaW5nLFxuICAgIGVudmlyb25tZW50OiBzdHJpbmcsXG4gICAgaWRUb2tlbjogc3RyaW5nLFxuICAgIGNsaWVudElkOiBzdHJpbmcsXG4gICAgdGVuYW50SWQ6IHN0cmluZ1xuKTogSWRUb2tlbkVudGl0eSB7XG4gICAgY29uc3QgaWRUb2tlbkVudGl0eTogSWRUb2tlbkVudGl0eSA9IHtcbiAgICAgICAgY3JlZGVudGlhbFR5cGU6IENyZWRlbnRpYWxUeXBlLklEX1RPS0VOLFxuICAgICAgICBob21lQWNjb3VudElkOiBob21lQWNjb3VudElkLFxuICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcbiAgICAgICAgc2VjcmV0OiBpZFRva2VuLFxuICAgICAgICByZWFsbTogdGVuYW50SWQsXG4gICAgfTtcblxuICAgIHJldHVybiBpZFRva2VuRW50aXR5O1xufVxuXG4vKipcbiAqIENyZWF0ZSBBY2Nlc3NUb2tlbkVudGl0eVxuICogQHBhcmFtIGhvbWVBY2NvdW50SWRcbiAqIEBwYXJhbSBlbnZpcm9ubWVudFxuICogQHBhcmFtIGFjY2Vzc1Rva2VuXG4gKiBAcGFyYW0gY2xpZW50SWRcbiAqIEBwYXJhbSB0ZW5hbnRJZFxuICogQHBhcmFtIHNjb3Blc1xuICogQHBhcmFtIGV4cGlyZXNPblxuICogQHBhcmFtIGV4dEV4cGlyZXNPblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWNjZXNzVG9rZW5FbnRpdHkoXG4gICAgaG9tZUFjY291bnRJZDogc3RyaW5nLFxuICAgIGVudmlyb25tZW50OiBzdHJpbmcsXG4gICAgYWNjZXNzVG9rZW46IHN0cmluZyxcbiAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgIHRlbmFudElkOiBzdHJpbmcsXG4gICAgc2NvcGVzOiBzdHJpbmcsXG4gICAgZXhwaXJlc09uOiBudW1iZXIsXG4gICAgZXh0RXhwaXJlc09uOiBudW1iZXIsXG4gICAgYmFzZTY0RGVjb2RlOiAoaW5wdXQ6IHN0cmluZykgPT4gc3RyaW5nLFxuICAgIHJlZnJlc2hPbj86IG51bWJlcixcbiAgICB0b2tlblR5cGU/OiBBdXRoZW50aWNhdGlvblNjaGVtZSxcbiAgICB1c2VyQXNzZXJ0aW9uSGFzaD86IHN0cmluZyxcbiAgICBrZXlJZD86IHN0cmluZyxcbiAgICByZXF1ZXN0ZWRDbGFpbXM/OiBzdHJpbmcsXG4gICAgcmVxdWVzdGVkQ2xhaW1zSGFzaD86IHN0cmluZ1xuKTogQWNjZXNzVG9rZW5FbnRpdHkge1xuICAgIGNvbnN0IGF0RW50aXR5OiBBY2Nlc3NUb2tlbkVudGl0eSA9IHtcbiAgICAgICAgaG9tZUFjY291bnRJZDogaG9tZUFjY291bnRJZCxcbiAgICAgICAgY3JlZGVudGlhbFR5cGU6IENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTixcbiAgICAgICAgc2VjcmV0OiBhY2Nlc3NUb2tlbixcbiAgICAgICAgY2FjaGVkQXQ6IFRpbWVVdGlscy5ub3dTZWNvbmRzKCkudG9TdHJpbmcoKSxcbiAgICAgICAgZXhwaXJlc09uOiBleHBpcmVzT24udG9TdHJpbmcoKSxcbiAgICAgICAgZXh0ZW5kZWRFeHBpcmVzT246IGV4dEV4cGlyZXNPbi50b1N0cmluZygpLFxuICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcbiAgICAgICAgcmVhbG06IHRlbmFudElkLFxuICAgICAgICB0YXJnZXQ6IHNjb3BlcyxcbiAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGUgfHwgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSLFxuICAgIH07XG5cbiAgICBpZiAodXNlckFzc2VydGlvbkhhc2gpIHtcbiAgICAgICAgYXRFbnRpdHkudXNlckFzc2VydGlvbkhhc2ggPSB1c2VyQXNzZXJ0aW9uSGFzaDtcbiAgICB9XG5cbiAgICBpZiAocmVmcmVzaE9uKSB7XG4gICAgICAgIGF0RW50aXR5LnJlZnJlc2hPbiA9IHJlZnJlc2hPbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0ZWRDbGFpbXMpIHtcbiAgICAgICAgYXRFbnRpdHkucmVxdWVzdGVkQ2xhaW1zID0gcmVxdWVzdGVkQ2xhaW1zO1xuICAgICAgICBhdEVudGl0eS5yZXF1ZXN0ZWRDbGFpbXNIYXNoID0gcmVxdWVzdGVkQ2xhaW1zSGFzaDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENyZWF0ZSBBY2Nlc3MgVG9rZW4gV2l0aCBBdXRoIFNjaGVtZSBpbnN0ZWFkIG9mIHJlZ3VsYXIgYWNjZXNzIHRva2VuXG4gICAgICogQ2FzdCB0byBsb3dlciB0byBoYW5kbGUgXCJiZWFyZXJcIiBmcm9tIEFERlNcbiAgICAgKi9cbiAgICBpZiAoXG4gICAgICAgIGF0RW50aXR5LnRva2VuVHlwZT8udG9Mb3dlckNhc2UoKSAhPT1cbiAgICAgICAgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSLnRvTG93ZXJDYXNlKClcbiAgICApIHtcbiAgICAgICAgYXRFbnRpdHkuY3JlZGVudGlhbFR5cGUgPSBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRTtcbiAgICAgICAgc3dpdGNoIChhdEVudGl0eS50b2tlblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQXV0aGVudGljYXRpb25TY2hlbWUuUE9QOlxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBrZXlJZCBpcyBwcmVzZW50IGFuZCBhZGQgaXQgdG8gY3JlZGVudGlhbFxuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuQ2xhaW1zOiBUb2tlbkNsYWltcyB8IG51bGwgPSBleHRyYWN0VG9rZW5DbGFpbXMoXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBiYXNlNjREZWNvZGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5DbGFpbXM/LmNuZj8ua2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuQ2xhaW1zQ25mUmVxdWlyZWRGb3JTaWduZWRKd3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXRFbnRpdHkua2V5SWQgPSB0b2tlbkNsYWltcy5jbmYua2lkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBdXRoZW50aWNhdGlvblNjaGVtZS5TU0g6XG4gICAgICAgICAgICAgICAgYXRFbnRpdHkua2V5SWQgPSBrZXlJZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhdEVudGl0eTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgUmVmcmVzaFRva2VuRW50aXR5XG4gKiBAcGFyYW0gaG9tZUFjY291bnRJZFxuICogQHBhcmFtIGF1dGhlbnRpY2F0aW9uUmVzdWx0XG4gKiBAcGFyYW0gY2xpZW50SWRcbiAqIEBwYXJhbSBhdXRob3JpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZnJlc2hUb2tlbkVudGl0eShcbiAgICBob21lQWNjb3VudElkOiBzdHJpbmcsXG4gICAgZW52aXJvbm1lbnQ6IHN0cmluZyxcbiAgICByZWZyZXNoVG9rZW46IHN0cmluZyxcbiAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgIGZhbWlseUlkPzogc3RyaW5nLFxuICAgIHVzZXJBc3NlcnRpb25IYXNoPzogc3RyaW5nLFxuICAgIGV4cGlyZXNPbj86IG51bWJlclxuKTogUmVmcmVzaFRva2VuRW50aXR5IHtcbiAgICBjb25zdCBydEVudGl0eTogUmVmcmVzaFRva2VuRW50aXR5ID0ge1xuICAgICAgICBjcmVkZW50aWFsVHlwZTogQ3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTixcbiAgICAgICAgaG9tZUFjY291bnRJZDogaG9tZUFjY291bnRJZCxcbiAgICAgICAgZW52aXJvbm1lbnQ6IGVudmlyb25tZW50LFxuICAgICAgICBjbGllbnRJZDogY2xpZW50SWQsXG4gICAgICAgIHNlY3JldDogcmVmcmVzaFRva2VuLFxuICAgIH07XG5cbiAgICBpZiAodXNlckFzc2VydGlvbkhhc2gpIHtcbiAgICAgICAgcnRFbnRpdHkudXNlckFzc2VydGlvbkhhc2ggPSB1c2VyQXNzZXJ0aW9uSGFzaDtcbiAgICB9XG5cbiAgICBpZiAoZmFtaWx5SWQpIHtcbiAgICAgICAgcnRFbnRpdHkuZmFtaWx5SWQgPSBmYW1pbHlJZDtcbiAgICB9XG5cbiAgICBpZiAoZXhwaXJlc09uKSB7XG4gICAgICAgIHJ0RW50aXR5LmV4cGlyZXNPbiA9IGV4cGlyZXNPbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBydEVudGl0eTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3JlZGVudGlhbEVudGl0eShlbnRpdHk6IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImhvbWVBY2NvdW50SWRcIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiZW52aXJvbm1lbnRcIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiY3JlZGVudGlhbFR5cGVcIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiY2xpZW50SWRcIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwic2VjcmV0XCIpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYW4gZW50aXR5OiBjaGVja3MgZm9yIGFsbCBleHBlY3RlZCBwYXJhbXNcbiAqIEBwYXJhbSBlbnRpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWNjZXNzVG9rZW5FbnRpdHkoZW50aXR5OiBvYmplY3QpOiBib29sZWFuIHtcbiAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgaXNDcmVkZW50aWFsRW50aXR5KGVudGl0eSkgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwicmVhbG1cIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwidGFyZ2V0XCIpICYmXG4gICAgICAgIChlbnRpdHlbXCJjcmVkZW50aWFsVHlwZVwiXSA9PT0gQ3JlZGVudGlhbFR5cGUuQUNDRVNTX1RPS0VOIHx8XG4gICAgICAgICAgICBlbnRpdHlbXCJjcmVkZW50aWFsVHlwZVwiXSA9PT1cbiAgICAgICAgICAgICAgICBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRSlcbiAgICApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhbiBlbnRpdHk6IGNoZWNrcyBmb3IgYWxsIGV4cGVjdGVkIHBhcmFtc1xuICogQHBhcmFtIGVudGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJZFRva2VuRW50aXR5KGVudGl0eTogb2JqZWN0KTogYm9vbGVhbiB7XG4gICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIGlzQ3JlZGVudGlhbEVudGl0eShlbnRpdHkpICYmXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInJlYWxtXCIpICYmXG4gICAgICAgIGVudGl0eVtcImNyZWRlbnRpYWxUeXBlXCJdID09PSBDcmVkZW50aWFsVHlwZS5JRF9UT0tFTlxuICAgICk7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGFuIGVudGl0eTogY2hlY2tzIGZvciBhbGwgZXhwZWN0ZWQgcGFyYW1zXG4gKiBAcGFyYW0gZW50aXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZnJlc2hUb2tlbkVudGl0eShlbnRpdHk6IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICBpc0NyZWRlbnRpYWxFbnRpdHkoZW50aXR5KSAmJlxuICAgICAgICBlbnRpdHlbXCJjcmVkZW50aWFsVHlwZVwiXSA9PT0gQ3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTlxuICAgICk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgQWNjb3VudCBJZCBrZXkgY29tcG9uZW50IGFzIHBlciB0aGUgc2NoZW1hOiA8aG9tZV9hY2NvdW50X2lkPi08ZW52aXJvbm1lbnQ+XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQWNjb3VudElkKGNyZWRlbnRpYWxFbnRpdHk6IENyZWRlbnRpYWxFbnRpdHkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGFjY291bnRJZDogQXJyYXk8c3RyaW5nPiA9IFtcbiAgICAgICAgY3JlZGVudGlhbEVudGl0eS5ob21lQWNjb3VudElkLFxuICAgICAgICBjcmVkZW50aWFsRW50aXR5LmVudmlyb25tZW50LFxuICAgIF07XG4gICAgcmV0dXJuIGFjY291bnRJZC5qb2luKFNlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUikudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBDcmVkZW50aWFsIElkIGtleSBjb21wb25lbnQgYXMgcGVyIHRoZSBzY2hlbWE6IDxjcmVkZW50aWFsX3R5cGU+LTxjbGllbnRfaWQ+LTxyZWFsbT5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDcmVkZW50aWFsSWQoY3JlZGVudGlhbEVudGl0eTogQ3JlZGVudGlhbEVudGl0eSk6IHN0cmluZyB7XG4gICAgY29uc3QgY2xpZW50T3JGYW1pbHlJZCA9XG4gICAgICAgIGNyZWRlbnRpYWxFbnRpdHkuY3JlZGVudGlhbFR5cGUgPT09IENyZWRlbnRpYWxUeXBlLlJFRlJFU0hfVE9LRU5cbiAgICAgICAgICAgID8gY3JlZGVudGlhbEVudGl0eS5mYW1pbHlJZCB8fCBjcmVkZW50aWFsRW50aXR5LmNsaWVudElkXG4gICAgICAgICAgICA6IGNyZWRlbnRpYWxFbnRpdHkuY2xpZW50SWQ7XG4gICAgY29uc3QgY3JlZGVudGlhbElkOiBBcnJheTxzdHJpbmc+ID0gW1xuICAgICAgICBjcmVkZW50aWFsRW50aXR5LmNyZWRlbnRpYWxUeXBlLFxuICAgICAgICBjbGllbnRPckZhbWlseUlkLFxuICAgICAgICBjcmVkZW50aWFsRW50aXR5LnJlYWxtIHx8IFwiXCIsXG4gICAgXTtcblxuICAgIHJldHVybiBjcmVkZW50aWFsSWQuam9pbihTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1IpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgdGFyZ2V0IGtleSBjb21wb25lbnQgYXMgcGVyIHNjaGVtYTogPHRhcmdldD5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUYXJnZXQoY3JlZGVudGlhbEVudGl0eTogQ3JlZGVudGlhbEVudGl0eSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIChjcmVkZW50aWFsRW50aXR5LnRhcmdldCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHJlcXVlc3RlZCBjbGFpbXMga2V5IGNvbXBvbmVudCBhcyBwZXIgc2NoZW1hOiA8cmVxdWVzdGVkQ2xhaW1zPlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUNsYWltc0hhc2goY3JlZGVudGlhbEVudGl0eTogQ3JlZGVudGlhbEVudGl0eSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIChjcmVkZW50aWFsRW50aXR5LnJlcXVlc3RlZENsYWltc0hhc2ggfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBzY2hlbWUga2V5IGNvbXBvbmVuZXQgYXMgcGVyIHNjaGVtYTogPHNjaGVtZT5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTY2hlbWUoY3JlZGVudGlhbEVudGl0eTogQ3JlZGVudGlhbEVudGl0eSk6IHN0cmluZyB7XG4gICAgLypcbiAgICAgKiBQb1AgVG9rZW5zIGFuZCBTU0ggY2VydHMgaW5jbHVkZSBzY2hlbWUgaW4gY2FjaGUga2V5XG4gICAgICogQ2FzdCB0byBsb3dlcmNhc2UgdG8gaGFuZGxlIFwiYmVhcmVyXCIgZnJvbSBBREZTXG4gICAgICovXG4gICAgcmV0dXJuIGNyZWRlbnRpYWxFbnRpdHkudG9rZW5UeXBlICYmXG4gICAgICAgIGNyZWRlbnRpYWxFbnRpdHkudG9rZW5UeXBlLnRvTG93ZXJDYXNlKCkgIT09XG4gICAgICAgICAgICBBdXRoZW50aWNhdGlvblNjaGVtZS5CRUFSRVIudG9Mb3dlckNhc2UoKVxuICAgICAgICA/IGNyZWRlbnRpYWxFbnRpdHkudG9rZW5UeXBlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgOiBcIlwiO1xufVxuXG4vKipcbiAqIHZhbGlkYXRlcyBpZiBhIGdpdmVuIGNhY2hlIGVudHJ5IGlzIFwiVGVsZW1ldHJ5XCIsIHBhcnNlcyA8a2V5LHZhbHVlPlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIGVudGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJ2ZXJUZWxlbWV0cnlFbnRpdHkoa2V5OiBzdHJpbmcsIGVudGl0eT86IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHZhbGlkYXRlS2V5OiBib29sZWFuID1cbiAgICAgICAga2V5LmluZGV4T2YoU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5DQUNIRV9LRVkpID09PSAwO1xuICAgIGxldCB2YWxpZGF0ZUVudGl0eTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHZhbGlkYXRlRW50aXR5ID1cbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImZhaWxlZFJlcXVlc3RzXCIpICYmXG4gICAgICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJlcnJvcnNcIikgJiZcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImNhY2hlSGl0c1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVLZXkgJiYgdmFsaWRhdGVFbnRpdHk7XG59XG5cbi8qKlxuICogdmFsaWRhdGVzIGlmIGEgZ2l2ZW4gY2FjaGUgZW50cnkgaXMgXCJUaHJvdHRsaW5nXCIsIHBhcnNlcyA8a2V5LHZhbHVlPlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIGVudGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUaHJvdHRsaW5nRW50aXR5KGtleTogc3RyaW5nLCBlbnRpdHk/OiBvYmplY3QpOiBib29sZWFuIHtcbiAgICBsZXQgdmFsaWRhdGVLZXk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhbGlkYXRlS2V5ID0ga2V5LmluZGV4T2YoVGhyb3R0bGluZ0NvbnN0YW50cy5USFJPVFRMSU5HX1BSRUZJWCkgPT09IDA7XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkYXRlRW50aXR5OiBib29sZWFuID0gdHJ1ZTtcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHZhbGlkYXRlRW50aXR5ID0gZW50aXR5Lmhhc093blByb3BlcnR5KFwidGhyb3R0bGVUaW1lXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZUtleSAmJiB2YWxpZGF0ZUVudGl0eTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBBcHBNZXRhZGF0YSBDYWNoZSBLZXkgYXMgcGVyIHRoZSBzY2hlbWE6IGFwcG1ldGFkYXRhLTxlbnZpcm9ubWVudD4tPGNsaWVudF9pZD5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQXBwTWV0YWRhdGFLZXkoe1xuICAgIGVudmlyb25tZW50LFxuICAgIGNsaWVudElkLFxufTogQXBwTWV0YWRhdGFFbnRpdHkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGFwcE1ldGFEYXRhS2V5QXJyYXk6IEFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgIEFQUF9NRVRBREFUQSxcbiAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgIGNsaWVudElkLFxuICAgIF07XG4gICAgcmV0dXJuIGFwcE1ldGFEYXRhS2V5QXJyYXlcbiAgICAgICAgLmpvaW4oU2VwYXJhdG9ycy5DQUNIRV9LRVlfU0VQQVJBVE9SKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbn1cblxuLypcbiAqIFZhbGlkYXRlcyBhbiBlbnRpdHk6IGNoZWNrcyBmb3IgYWxsIGV4cGVjdGVkIHBhcmFtc1xuICogQHBhcmFtIGVudGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcHBNZXRhZGF0YUVudGl0eShrZXk6IHN0cmluZywgZW50aXR5OiBvYmplY3QpOiBib29sZWFuIHtcbiAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAga2V5LmluZGV4T2YoQVBQX01FVEFEQVRBKSA9PT0gMCAmJlxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJjbGllbnRJZFwiKSAmJlxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJlbnZpcm9ubWVudFwiKVxuICAgICk7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGFuIGVudGl0eTogY2hlY2tzIGZvciBhbGwgZXhwZWN0ZWQgcGFyYW1zXG4gKiBAcGFyYW0gZW50aXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhvcml0eU1ldGFkYXRhRW50aXR5KFxuICAgIGtleTogc3RyaW5nLFxuICAgIGVudGl0eTogb2JqZWN0XG4pOiBib29sZWFuIHtcbiAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAga2V5LmluZGV4T2YoQVVUSE9SSVRZX01FVEFEQVRBX0NPTlNUQU5UUy5DQUNIRV9LRVkpID09PSAwICYmXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImFsaWFzZXNcIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwicHJlZmVycmVkX2NhY2hlXCIpICYmXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInByZWZlcnJlZF9uZXR3b3JrXCIpICYmXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImNhbm9uaWNhbF9hdXRob3JpdHlcIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiYXV0aG9yaXphdGlvbl9lbmRwb2ludFwiKSAmJlxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJ0b2tlbl9lbmRwb2ludFwiKSAmJlxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJpc3N1ZXJcIikgJiZcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiYWxpYXNlc0Zyb21OZXR3b3JrXCIpICYmXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImVuZHBvaW50c0Zyb21OZXR3b3JrXCIpICYmXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImV4cGlyZXNBdFwiKSAmJlxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJqd2tzX3VyaVwiKVxuICAgICk7XG59XG5cbi8qKlxuICogUmVzZXQgdGhlIGV4aXJlc0F0IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUF1dGhvcml0eU1ldGFkYXRhRXhwaXJlc0F0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgVGltZVV0aWxzLm5vd1NlY29uZHMoKSArXG4gICAgICAgIEFVVEhPUklUWV9NRVRBREFUQV9DT05TVEFOVFMuUkVGUkVTSF9USU1FX1NFQ09ORFNcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQXV0aG9yaXR5RW5kcG9pbnRNZXRhZGF0YShcbiAgICBhdXRob3JpdHlNZXRhZGF0YTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHksXG4gICAgdXBkYXRlZFZhbHVlczogT3BlbklkQ29uZmlnUmVzcG9uc2UsXG4gICAgZnJvbU5ldHdvcms6IGJvb2xlYW5cbik6IHZvaWQge1xuICAgIGF1dGhvcml0eU1ldGFkYXRhLmF1dGhvcml6YXRpb25fZW5kcG9pbnQgPVxuICAgICAgICB1cGRhdGVkVmFsdWVzLmF1dGhvcml6YXRpb25fZW5kcG9pbnQ7XG4gICAgYXV0aG9yaXR5TWV0YWRhdGEudG9rZW5fZW5kcG9pbnQgPSB1cGRhdGVkVmFsdWVzLnRva2VuX2VuZHBvaW50O1xuICAgIGF1dGhvcml0eU1ldGFkYXRhLmVuZF9zZXNzaW9uX2VuZHBvaW50ID0gdXBkYXRlZFZhbHVlcy5lbmRfc2Vzc2lvbl9lbmRwb2ludDtcbiAgICBhdXRob3JpdHlNZXRhZGF0YS5pc3N1ZXIgPSB1cGRhdGVkVmFsdWVzLmlzc3VlcjtcbiAgICBhdXRob3JpdHlNZXRhZGF0YS5lbmRwb2ludHNGcm9tTmV0d29yayA9IGZyb21OZXR3b3JrO1xuICAgIGF1dGhvcml0eU1ldGFkYXRhLmp3a3NfdXJpID0gdXBkYXRlZFZhbHVlcy5qd2tzX3VyaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEoXG4gICAgYXV0aG9yaXR5TWV0YWRhdGE6IEF1dGhvcml0eU1ldGFkYXRhRW50aXR5LFxuICAgIHVwZGF0ZWRWYWx1ZXM6IENsb3VkRGlzY292ZXJ5TWV0YWRhdGEsXG4gICAgZnJvbU5ldHdvcms6IGJvb2xlYW5cbik6IHZvaWQge1xuICAgIGF1dGhvcml0eU1ldGFkYXRhLmFsaWFzZXMgPSB1cGRhdGVkVmFsdWVzLmFsaWFzZXM7XG4gICAgYXV0aG9yaXR5TWV0YWRhdGEucHJlZmVycmVkX2NhY2hlID0gdXBkYXRlZFZhbHVlcy5wcmVmZXJyZWRfY2FjaGU7XG4gICAgYXV0aG9yaXR5TWV0YWRhdGEucHJlZmVycmVkX25ldHdvcmsgPSB1cGRhdGVkVmFsdWVzLnByZWZlcnJlZF9uZXR3b3JrO1xuICAgIGF1dGhvcml0eU1ldGFkYXRhLmFsaWFzZXNGcm9tTmV0d29yayA9IGZyb21OZXR3b3JrO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGRhdGEgbmVlZHMgdG8gYmUgcmVmcmVzaGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhvcml0eU1ldGFkYXRhRXhwaXJlZChcbiAgICBtZXRhZGF0YTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHlcbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBtZXRhZGF0YS5leHBpcmVzQXQgPD0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IHJlZGlyZWN0VXJpRW1wdHkgPSBcInJlZGlyZWN0X3VyaV9lbXB0eVwiO1xuZXhwb3J0IGNvbnN0IGNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3IgPSBcImNsYWltc19yZXF1ZXN0X3BhcnNpbmdfZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBhdXRob3JpdHlVcmlJbnNlY3VyZSA9IFwiYXV0aG9yaXR5X3VyaV9pbnNlY3VyZVwiO1xuZXhwb3J0IGNvbnN0IHVybFBhcnNlRXJyb3IgPSBcInVybF9wYXJzZV9lcnJvclwiO1xuZXhwb3J0IGNvbnN0IHVybEVtcHR5RXJyb3IgPSBcImVtcHR5X3VybF9lcnJvclwiO1xuZXhwb3J0IGNvbnN0IGVtcHR5SW5wdXRTY29wZXNFcnJvciA9IFwiZW1wdHlfaW5wdXRfc2NvcGVzX2Vycm9yXCI7XG5leHBvcnQgY29uc3QgaW52YWxpZFByb21wdFZhbHVlID0gXCJpbnZhbGlkX3Byb21wdF92YWx1ZVwiO1xuZXhwb3J0IGNvbnN0IGludmFsaWRDbGFpbXMgPSBcImludmFsaWRfY2xhaW1zXCI7XG5leHBvcnQgY29uc3QgdG9rZW5SZXF1ZXN0RW1wdHkgPSBcInRva2VuX3JlcXVlc3RfZW1wdHlcIjtcbmV4cG9ydCBjb25zdCBsb2dvdXRSZXF1ZXN0RW1wdHkgPSBcImxvZ291dF9yZXF1ZXN0X2VtcHR5XCI7XG5leHBvcnQgY29uc3QgaW52YWxpZENvZGVDaGFsbGVuZ2VNZXRob2QgPSBcImludmFsaWRfY29kZV9jaGFsbGVuZ2VfbWV0aG9kXCI7XG5leHBvcnQgY29uc3QgcGtjZVBhcmFtc01pc3NpbmcgPSBcInBrY2VfcGFyYW1zX21pc3NpbmdcIjtcbmV4cG9ydCBjb25zdCBpbnZhbGlkQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSA9IFwiaW52YWxpZF9jbG91ZF9kaXNjb3ZlcnlfbWV0YWRhdGFcIjtcbmV4cG9ydCBjb25zdCBpbnZhbGlkQXV0aG9yaXR5TWV0YWRhdGEgPSBcImludmFsaWRfYXV0aG9yaXR5X21ldGFkYXRhXCI7XG5leHBvcnQgY29uc3QgdW50cnVzdGVkQXV0aG9yaXR5ID0gXCJ1bnRydXN0ZWRfYXV0aG9yaXR5XCI7XG5leHBvcnQgY29uc3QgbWlzc2luZ1NzaEp3ayA9IFwibWlzc2luZ19zc2hfandrXCI7XG5leHBvcnQgY29uc3QgbWlzc2luZ1NzaEtpZCA9IFwibWlzc2luZ19zc2hfa2lkXCI7XG5leHBvcnQgY29uc3QgbWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXIgPVxuICAgIFwibWlzc2luZ19ub25jZV9hdXRoZW50aWNhdGlvbl9oZWFkZXJcIjtcbmV4cG9ydCBjb25zdCBpbnZhbGlkQXV0aGVudGljYXRpb25IZWFkZXIgPSBcImludmFsaWRfYXV0aGVudGljYXRpb25faGVhZGVyXCI7XG5leHBvcnQgY29uc3QgY2Fubm90U2V0T0lEQ09wdGlvbnMgPSBcImNhbm5vdF9zZXRfT0lEQ09wdGlvbnNcIjtcbmV4cG9ydCBjb25zdCBjYW5ub3RBbGxvd1BsYXRmb3JtQnJva2VyID0gXCJjYW5ub3RfYWxsb3dfcGxhdGZvcm1fYnJva2VyXCI7XG5leHBvcnQgY29uc3QgYXV0aG9yaXR5TWlzbWF0Y2ggPSBcImF1dGhvcml0eV9taXNtYXRjaFwiO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiLi9BdXRoRXJyb3IuanNcIjtcbmltcG9ydCAqIGFzIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzIGZyb20gXCIuL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmpzXCI7XG5leHBvcnQgeyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2RlcyB9O1xuXG5leHBvcnQgY29uc3QgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXMgPSB7XG4gICAgW0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnJlZGlyZWN0VXJpRW1wdHldOlxuICAgICAgICBcIkEgcmVkaXJlY3QgVVJJIGlzIHJlcXVpcmVkIGZvciBhbGwgY2FsbHMsIGFuZCBub25lIGhhcyBiZWVuIHNldC5cIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuY2xhaW1zUmVxdWVzdFBhcnNpbmdFcnJvcl06XG4gICAgICAgIFwiQ291bGQgbm90IHBhcnNlIHRoZSBnaXZlbiBjbGFpbXMgcmVxdWVzdCBvYmplY3QuXCIsXG4gICAgW0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmF1dGhvcml0eVVyaUluc2VjdXJlXTpcbiAgICAgICAgXCJBdXRob3JpdHkgVVJJcyBtdXN0IHVzZSBodHRwcy4gIFBsZWFzZSBzZWUgaGVyZSBmb3IgdmFsaWQgYXV0aG9yaXR5IGNvbmZpZ3VyYXRpb24gb3B0aW9uczogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvYWN0aXZlLWRpcmVjdG9yeS9kZXZlbG9wL21zYWwtanMtaW5pdGlhbGl6aW5nLWNsaWVudC1hcHBsaWNhdGlvbnMjY29uZmlndXJhdGlvbi1vcHRpb25zXCIsXG4gICAgW0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybFBhcnNlRXJyb3JdOlxuICAgICAgICBcIlVSTCBjb3VsZCBub3QgYmUgcGFyc2VkIGludG8gYXBwcm9wcmlhdGUgc2VnbWVudHMuXCIsXG4gICAgW0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybEVtcHR5RXJyb3JdOiBcIlVSTCB3YXMgZW1wdHkgb3IgbnVsbC5cIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuZW1wdHlJbnB1dFNjb3Blc0Vycm9yXTpcbiAgICAgICAgXCJTY29wZXMgY2Fubm90IGJlIHBhc3NlZCBhcyBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkgYXJyYXkgYmVjYXVzZSB0aGV5IGFyZSByZXF1aXJlZCB0byBvYnRhaW4gYW4gYWNjZXNzIHRva2VuLlwiLFxuICAgIFtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkUHJvbXB0VmFsdWVdOlxuICAgICAgICBcIlBsZWFzZSBzZWUgaGVyZSBmb3IgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb25zOiBodHRwczovL2F6dXJlYWQuZ2l0aHViLmlvL21pY3Jvc29mdC1hdXRoZW50aWNhdGlvbi1saWJyYXJ5LWZvci1qcy9yZWYvbW9kdWxlcy9fYXp1cmVfbXNhbF9jb21tb24uaHRtbCNjb21tb25hdXRob3JpemF0aW9udXJscmVxdWVzdFwiLFxuICAgIFtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ2xhaW1zXTpcbiAgICAgICAgXCJHaXZlbiBjbGFpbXMgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmdpZmllZCBKU09OIG9iamVjdC5cIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudG9rZW5SZXF1ZXN0RW1wdHldOlxuICAgICAgICBcIlRva2VuIHJlcXVlc3Qgd2FzIGVtcHR5IGFuZCBub3QgZm91bmQgaW4gY2FjaGUuXCIsXG4gICAgW0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmxvZ291dFJlcXVlc3RFbXB0eV06XG4gICAgICAgIFwiVGhlIGxvZ291dCByZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZC5cIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZENvZGVDaGFsbGVuZ2VNZXRob2RdOlxuICAgICAgICAnY29kZV9jaGFsbGVuZ2VfbWV0aG9kIHBhc3NlZCBpcyBpbnZhbGlkLiBWYWxpZCB2YWx1ZXMgYXJlIFwicGxhaW5cIiBhbmQgXCJTMjU2XCIuJyxcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMucGtjZVBhcmFtc01pc3NpbmddOlxuICAgICAgICBcIkJvdGggcGFyYW1zOiBjb2RlX2NoYWxsZW5nZSBhbmQgY29kZV9jaGFsbGVuZ2VfbWV0aG9kIGFyZSB0byBiZSBwYXNzZWQgaWYgdG8gYmUgc2VudCBpbiB0aGUgcmVxdWVzdFwiLFxuICAgIFtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YV06XG4gICAgICAgIFwiSW52YWxpZCBjbG91ZERpc2NvdmVyeU1ldGFkYXRhIHByb3ZpZGVkLiBNdXN0IGJlIGEgc3RyaW5naWZpZWQgSlNPTiBvYmplY3QgY29udGFpbmluZyB0ZW5hbnRfZGlzY292ZXJ5X2VuZHBvaW50IGFuZCBtZXRhZGF0YSBmaWVsZHNcIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZEF1dGhvcml0eU1ldGFkYXRhXTpcbiAgICAgICAgXCJJbnZhbGlkIGF1dGhvcml0eU1ldGFkYXRhIHByb3ZpZGVkLiBNdXN0IGJ5IGEgc3RyaW5naWZpZWQgSlNPTiBvYmplY3QgY29udGFpbmluZyBhdXRob3JpemF0aW9uX2VuZHBvaW50LCB0b2tlbl9lbmRwb2ludCwgaXNzdWVyIGZpZWxkcy5cIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudW50cnVzdGVkQXV0aG9yaXR5XTpcbiAgICAgICAgXCJUaGUgcHJvdmlkZWQgYXV0aG9yaXR5IGlzIG5vdCBhIHRydXN0ZWQgYXV0aG9yaXR5LiBQbGVhc2UgaW5jbHVkZSB0aGlzIGF1dGhvcml0eSBpbiB0aGUga25vd25BdXRob3JpdGllcyBjb25maWcgcGFyYW1ldGVyLlwiLFxuICAgIFtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5taXNzaW5nU3NoSndrXTpcbiAgICAgICAgXCJNaXNzaW5nIHNzaEp3ayBpbiBTU0ggY2VydGlmaWNhdGUgcmVxdWVzdC4gQSBzdHJpbmdpZmllZCBKU09OIFdlYiBLZXkgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyB0aGUgU1NIIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ1NzaEtpZF06XG4gICAgICAgIFwiTWlzc2luZyBzc2hLaWQgaW4gU1NIIGNlcnRpZmljYXRlIHJlcXVlc3QuIEEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgcHVibGljIFNTSCBrZXkgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyB0aGUgU1NIIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cIixcbiAgICBbQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXJdOlxuICAgICAgICBcIlVuYWJsZSB0byBmaW5kIGFuIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBjb250YWluaW5nIHNlcnZlciBub25jZS4gRWl0aGVyIHRoZSBBdXRoZW50aWNhdGlvbi1JbmZvIG9yIFdXVy1BdXRoZW50aWNhdGUgaGVhZGVycyBtdXN0IGJlIHByZXNlbnQgaW4gb3JkZXIgdG8gb2J0YWluIGEgc2VydmVyIG5vbmNlLlwiLFxuICAgIFtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQXV0aGVudGljYXRpb25IZWFkZXJdOlxuICAgICAgICBcIkludmFsaWQgYXV0aGVudGljYXRpb24gaGVhZGVyIHByb3ZpZGVkXCIsXG4gICAgW0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmNhbm5vdFNldE9JRENPcHRpb25zXTpcbiAgICAgICAgXCJDYW5ub3Qgc2V0IE9JRENPcHRpb25zIHBhcmFtZXRlci4gUGxlYXNlIGNoYW5nZSB0aGUgcHJvdG9jb2wgbW9kZSB0byBPSURDIG9yIHVzZSBhIG5vbi1NaWNyb3NvZnQgYXV0aG9yaXR5LlwiLFxuICAgIFtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5jYW5ub3RBbGxvd1BsYXRmb3JtQnJva2VyXTpcbiAgICAgICAgXCJDYW5ub3Qgc2V0IGFsbG93UGxhdGZvcm1Ccm9rZXIgcGFyYW1ldGVyIHRvIHRydWUgd2hlbiBub3QgaW4gQUFEIHByb3RvY29sIG1vZGUuXCIsXG4gICAgW0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmF1dGhvcml0eU1pc21hdGNoXTpcbiAgICAgICAgXCJBdXRob3JpdHkgbWlzbWF0Y2ggZXJyb3IuIEF1dGhvcml0eSBwcm92aWRlZCBpbiBsb2dpbiByZXF1ZXN0IG9yIFB1YmxpY0NsaWVudEFwcGxpY2F0aW9uIGNvbmZpZyBkb2VzIG5vdCBtYXRjaCB0aGUgZW52aXJvbm1lbnQgb2YgdGhlIHByb3ZpZGVkIGFjY291bnQuIFBsZWFzZSB1c2UgYSBtYXRjaGluZyBhY2NvdW50IG9yIG1ha2UgYW4gaW50ZXJhY3RpdmUgcmVxdWVzdCB0byBsb2dpbiB0byB0aGlzIGF1dGhvcml0eS5cIixcbn07XG5cbi8qKlxuICogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZSBjbGFzcyBjb250YWluaW5nIHN0cmluZyBjb25zdGFudHMgdXNlZCBieSBlcnJvciBjb2RlcyBhbmQgbWVzc2FnZXMuXG4gKiBAZGVwcmVjYXRlZCBVc2UgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMgaW5zdGVhZFxuICovXG5leHBvcnQgY29uc3QgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZSA9IHtcbiAgICByZWRpcmVjdFVyaU5vdFNldDoge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5yZWRpcmVjdFVyaUVtcHR5LFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnJlZGlyZWN0VXJpRW1wdHlcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuY2xhaW1zUmVxdWVzdFBhcnNpbmdFcnJvcixcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5jbGFpbXNSZXF1ZXN0UGFyc2luZ0Vycm9yXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBhdXRob3JpdHlVcmlJbnNlY3VyZToge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5hdXRob3JpdHlVcmlJbnNlY3VyZSxcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5hdXRob3JpdHlVcmlJbnNlY3VyZVxuICAgICAgICBdLFxuICAgIH0sXG4gICAgdXJsUGFyc2VFcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy51cmxQYXJzZUVycm9yLFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybFBhcnNlRXJyb3JcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHVybEVtcHR5RXJyb3I6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudXJsRW1wdHlFcnJvcixcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy51cmxFbXB0eUVycm9yXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBlbXB0eVNjb3Blc0Vycm9yOiB7XG4gICAgICAgIGNvZGU6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmVtcHR5SW5wdXRTY29wZXNFcnJvcixcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5lbXB0eUlucHV0U2NvcGVzRXJyb3JcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGludmFsaWRQcm9tcHQ6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZFByb21wdFZhbHVlLFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRQcm9tcHRWYWx1ZVxuICAgICAgICBdLFxuICAgIH0sXG4gICAgaW52YWxpZENsYWltc1JlcXVlc3Q6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZENsYWltcyxcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ2xhaW1zXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB0b2tlblJlcXVlc3RFbXB0eUVycm9yOiB7XG4gICAgICAgIGNvZGU6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnRva2VuUmVxdWVzdEVtcHR5LFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnRva2VuUmVxdWVzdEVtcHR5XG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2dvdXRSZXF1ZXN0RW1wdHlFcnJvcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5sb2dvdXRSZXF1ZXN0RW1wdHksXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubG9nb3V0UmVxdWVzdEVtcHR5XG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBpbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZDoge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgaW52YWxpZENvZGVDaGFsbGVuZ2VQYXJhbXM6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMucGtjZVBhcmFtc01pc3NpbmcsXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMucGtjZVBhcmFtc01pc3NpbmdcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhOiB7XG4gICAgICAgIGNvZGU6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhLFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBpbnZhbGlkQXV0aG9yaXR5TWV0YWRhdGE6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZEF1dGhvcml0eU1ldGFkYXRhLFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRBdXRob3JpdHlNZXRhZGF0YVxuICAgICAgICBdLFxuICAgIH0sXG4gICAgdW50cnVzdGVkQXV0aG9yaXR5OiB7XG4gICAgICAgIGNvZGU6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVudHJ1c3RlZEF1dGhvcml0eSxcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy51bnRydXN0ZWRBdXRob3JpdHlcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIG1pc3NpbmdTc2hKd2s6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ1NzaEp3ayxcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5taXNzaW5nU3NoSndrXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBtaXNzaW5nU3NoS2lkOiB7XG4gICAgICAgIGNvZGU6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1pc3NpbmdTc2hLaWQsXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ1NzaEtpZFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXI6IHtcbiAgICAgICAgY29kZTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXIsXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXJcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGludmFsaWRBdXRoZW50aWNhdGlvbkhlYWRlcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQXV0aGVudGljYXRpb25IZWFkZXIsXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZEF1dGhlbnRpY2F0aW9uSGVhZGVyXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBjYW5ub3RTZXRPSURDT3B0aW9uczoge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5jYW5ub3RTZXRPSURDT3B0aW9ucyxcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5jYW5ub3RTZXRPSURDT3B0aW9uc1xuICAgICAgICBdLFxuICAgIH0sXG4gICAgY2Fubm90QWxsb3dQbGF0Zm9ybUJyb2tlcjoge1xuICAgICAgICBjb2RlOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5jYW5ub3RBbGxvd1BsYXRmb3JtQnJva2VyLFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmNhbm5vdEFsbG93UGxhdGZvcm1Ccm9rZXJcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGF1dGhvcml0eU1pc21hdGNoOiB7XG4gICAgICAgIGNvZGU6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmF1dGhvcml0eU1pc21hdGNoLFxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmF1dGhvcml0eU1pc21hdGNoXG4gICAgICAgIF0sXG4gICAgfSxcbn07XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgaW4gY29uZmlndXJhdGlvbiBvZiB0aGUgTVNBTC5qcyBsaWJyYXJ5LlxuICovXG5leHBvcnQgY2xhc3MgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvckNvZGU6IHN0cmluZykge1xuICAgICAgICBzdXBlcihlcnJvckNvZGUsIENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvclwiO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgIGVycm9yQ29kZTogc3RyaW5nXG4pOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3Ige1xuICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKGVycm9yQ29kZSk7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU3RyaW5nVXRpbHMge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHN0cmluZ2lmaWVkIG9iamVjdCBpcyBlbXB0eVxuICAgICAqIEBwYXJhbSBzdHJPYmpcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbXB0eU9iaihzdHJPYmo/OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHN0ck9iaikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHN0ck9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc3RhcnRzV2l0aChzdHI6IHN0cmluZywgc2VhcmNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCkgPT09IDA7XG4gICAgfVxuXG4gICAgc3RhdGljIGVuZHNXaXRoKHN0cjogc3RyaW5nLCBzZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc3RyLmxlbmd0aCA+PSBzZWFyY2gubGVuZ3RoICYmXG4gICAgICAgICAgICBzdHIubGFzdEluZGV4T2Yoc2VhcmNoKSA9PT0gc3RyLmxlbmd0aCAtIHNlYXJjaC5sZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5XG4gICAgICovXG4gICAgc3RhdGljIHF1ZXJ5U3RyaW5nVG9PYmplY3Q8VD4ocXVlcnk6IHN0cmluZyk6IFQge1xuICAgICAgICBjb25zdCBvYmo6IHt9ID0ge307XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHM6IHN0cmluZykgPT4gZGVjb2RlVVJJQ29tcG9uZW50KHMucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG4gICAgICAgIHBhcmFtcy5mb3JFYWNoKChwYWlyKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFpci50cmltKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyLnNwbGl0KC89KC4rKS9nLCAyKTsgLy8gU3BsaXQgb24gdGhlIGZpcnN0IG9jY3VyZW5jZSBvZiB0aGUgJz0nIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2RlY29kZShrZXkpXSA9IGRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iaiBhcyBUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaW1zIGVudHJpZXMgaW4gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyXG4gICAgICovXG4gICAgc3RhdGljIHRyaW1BcnJheUVudHJpZXMoYXJyOiBBcnJheTxzdHJpbmc+KTogQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKChlbnRyeSkgPT4gZW50cnkudHJpbSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVtcHR5IHN0cmluZ3MgZnJvbSBhcnJheVxuICAgICAqIEBwYXJhbSBhcnJcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlRW1wdHlTdHJpbmdzRnJvbUFycmF5KGFycjogQXJyYXk8c3RyaW5nPik6IEFycmF5PHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gYXJyLmZpbHRlcigoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhIWVudHJ5O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBwYXJzZSBhIHN0cmluZyBpbnRvIEpTT05cbiAgICAgKiBAcGFyYW0gc3RyXG4gICAgICovXG4gICAgc3RhdGljIGpzb25QYXJzZUhlbHBlcjxUPihzdHI6IHN0cmluZyk6IFQgfCBudWxsIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cikgYXMgVDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIGdpdmVuIHN0cmluZyBtYXRjaGVzIGEgZ2l2ZW4gcGF0dGVybiwgd2l0aCBzdXBwb3J0IGZvciB3aWxkY2FyZHMgYW5kIHF1ZXJpZXMuXG4gICAgICogQHBhcmFtIHBhdHRlcm4gV2lsZGNhcmQgcGF0dGVybiB0byBzdHJpbmcgbWF0Y2guIFN1cHBvcnRzIFwiKlwiIGZvciB3aWxkY2FyZHMgYW5kIFwiP1wiIGZvciBxdWVyaWVzXG4gICAgICogQHBhcmFtIGlucHV0IFN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICovXG4gICAgc3RhdGljIG1hdGNoUGF0dGVybihwYXR0ZXJuOiBzdHJpbmcsIGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGRjYXJkIHN1cHBvcnQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTE3MjQ4LzQ4ODg1NTlcbiAgICAgICAgICogUXVlcmllczogcmVwbGFjZXMgXCI/XCIgaW4gc3RyaW5nIHdpdGggZXNjYXBlZCBcIlxcP1wiIGZvciByZWdleCB0ZXN0XG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5vbi1saXRlcmFsLXJlZ2V4cFxuICAgICAgICBjb25zdCByZWdleDogUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKi9nLCBcIlteIF0qXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcPy9nLCBcIlxcXFw/XCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoaW5wdXQpO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IsXG4gICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMsXG59IGZyb20gXCIuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3IuanNcIjtcbmltcG9ydCB7IFN0cmluZ1V0aWxzIH0gZnJvbSBcIi4uL3V0aWxzL1N0cmluZ1V0aWxzLmpzXCI7XG5pbXBvcnQge1xuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBPSURDX1NDT1BFUyB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcblxuLyoqXG4gKiBUaGUgU2NvcGVTZXQgY2xhc3MgY3JlYXRlcyBhIHNldCBvZiBzY29wZXMuIFNjb3BlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSwgdW5pcXVlIHZhbHVlcywgc28gdGhlIFNldCBvYmplY3QgaW4gSlMgbWFrZXNcbiAqIHRoZSBtb3N0IHNlbnNlIHRvIGltcGxlbWVudCBmb3IgdGhpcyBjbGFzcy4gQWxsIHNjb3BlcyBhcmUgdHJpbW1lZCBhbmQgY29udmVydGVkIHRvIGxvd2VyIGNhc2Ugc3RyaW5ncyBpbiBpbnRlcnNlY3Rpb24gYW5kIHVuaW9uIGZ1bmN0aW9uc1xuICogdG8gZW5zdXJlIHVuaXF1ZW5lc3Mgb2Ygc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNjb3BlU2V0IHtcbiAgICAvLyBTY29wZXMgYXMgYSBTZXQgb2Ygc3RyaW5nc1xuICAgIHByaXZhdGUgc2NvcGVzOiBTZXQ8c3RyaW5nPjtcblxuICAgIGNvbnN0cnVjdG9yKGlucHV0U2NvcGVzOiBBcnJheTxzdHJpbmc+KSB7XG4gICAgICAgIC8vIEZpbHRlciBlbXB0eSBzdHJpbmcgYW5kIG51bGwvdW5kZWZpbmVkIGFycmF5IGl0ZW1zXG4gICAgICAgIGNvbnN0IHNjb3BlQXJyID0gaW5wdXRTY29wZXNcbiAgICAgICAgICAgID8gU3RyaW5nVXRpbHMudHJpbUFycmF5RW50cmllcyhbLi4uaW5wdXRTY29wZXNdKVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRJbnB1dCA9IHNjb3BlQXJyXG4gICAgICAgICAgICA/IFN0cmluZ1V0aWxzLnJlbW92ZUVtcHR5U3RyaW5nc0Zyb21BcnJheShzY29wZUFycilcbiAgICAgICAgICAgIDogW107XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgc2NvcGVzIGFycmF5IGhhcyBhdCBsZWFzdCBvbmUgbWVtYmVyXG4gICAgICAgIGlmICghZmlsdGVyZWRJbnB1dCB8fCAhZmlsdGVyZWRJbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5lbXB0eUlucHV0U2NvcGVzRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjb3BlcyA9IG5ldyBTZXQ8c3RyaW5nPigpOyAvLyBJdGVyYXRvciBpbiBjb25zdHJ1Y3RvciBub3Qgc3VwcG9ydGVkIGJ5IElFMTFcbiAgICAgICAgZmlsdGVyZWRJbnB1dC5mb3JFYWNoKChzY29wZSkgPT4gdGhpcy5zY29wZXMuYWRkKHNjb3BlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIFNjb3BlU2V0IGZyb20gc3BhY2UtZGVsaW1pdGVkIHN0cmluZ1xuICAgICAqIEBwYXJhbSBpbnB1dFNjb3BlU3RyaW5nXG4gICAgICogQHBhcmFtIGFwcENsaWVudElkXG4gICAgICogQHBhcmFtIHNjb3Blc1JlcXVpcmVkXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoaW5wdXRTY29wZVN0cmluZzogc3RyaW5nKTogU2NvcGVTZXQge1xuICAgICAgICBjb25zdCBzY29wZVN0cmluZyA9IGlucHV0U2NvcGVTdHJpbmcgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgY29uc3QgaW5wdXRTY29wZXM6IEFycmF5PHN0cmluZz4gPSBzY29wZVN0cmluZy5zcGxpdChcIiBcIik7XG4gICAgICAgIHJldHVybiBuZXcgU2NvcGVTZXQoaW5wdXRTY29wZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHNldCBvZiBzY29wZXMgdG8gc2VhcmNoIGZvciBpbiBjYWNoZSBsb29rdXBzXG4gICAgICogQHBhcmFtIGlucHV0U2NvcGVTdHJpbmdcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZWFyY2hTY29wZXMoaW5wdXRTY29wZVN0cmluZzogQXJyYXk8c3RyaW5nPik6IFNjb3BlU2V0IHtcbiAgICAgICAgY29uc3Qgc2NvcGVTZXQgPSBuZXcgU2NvcGVTZXQoaW5wdXRTY29wZVN0cmluZyk7XG4gICAgICAgIGlmICghc2NvcGVTZXQuY29udGFpbnNPbmx5T0lEQ1Njb3BlcygpKSB7XG4gICAgICAgICAgICBzY29wZVNldC5yZW1vdmVPSURDU2NvcGVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY29wZVNldC5yZW1vdmVTY29wZShDb25zdGFudHMuT0ZGTElORV9BQ0NFU1NfU0NPUEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlU2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZ2l2ZW4gc2NvcGUgaXMgcHJlc2VudCBpbiB0aGlzIHNldCBvZiBzY29wZXMuXG4gICAgICogQHBhcmFtIHNjb3BlXG4gICAgICovXG4gICAgY29udGFpbnNTY29wZShzY29wZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZVNjb3BlcyA9IHRoaXMucHJpbnRTY29wZXNMb3dlckNhc2UoKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZVNjb3Blc1NldCA9IG5ldyBTY29wZVNldChsb3dlckNhc2VTY29wZXMpO1xuICAgICAgICAvLyBjb21wYXJlIGxvd2VyY2FzZSBzY29wZXNcbiAgICAgICAgcmV0dXJuIHNjb3BlXG4gICAgICAgICAgICA/IGxvd2VyQ2FzZVNjb3Blc1NldC5zY29wZXMuaGFzKHNjb3BlLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc2V0IG9mIHNjb3BlcyBpcyBwcmVzZW50IGluIHRoaXMgc2V0IG9mIHNjb3Blcy5cbiAgICAgKiBAcGFyYW0gc2NvcGVTZXRcbiAgICAgKi9cbiAgICBjb250YWluc1Njb3BlU2V0KHNjb3BlU2V0OiBTY29wZVNldCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXNjb3BlU2V0IHx8IHNjb3BlU2V0LnNjb3Blcy5zaXplIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnNjb3Blcy5zaXplID49IHNjb3BlU2V0LnNjb3Blcy5zaXplICYmXG4gICAgICAgICAgICBzY29wZVNldC5hc0FycmF5KCkuZXZlcnkoKHNjb3BlKSA9PiB0aGlzLmNvbnRhaW5zU2NvcGUoc2NvcGUpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHNldCBvZiBzY29wZXMgY29udGFpbnMgb25seSB0aGUgZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb250YWluc09ubHlPSURDU2NvcGVzKCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZGVmYXVsdFNjb3BlQ291bnQgPSAwO1xuICAgICAgICBPSURDX1NDT1BFUy5mb3JFYWNoKChkZWZhdWx0U2NvcGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbnNTY29wZShkZWZhdWx0U2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFNjb3BlQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzLnNpemUgPT09IGRlZmF1bHRTY29wZUNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgc2luZ2xlIHNjb3BlIGlmIHBhc3NlZFxuICAgICAqIEBwYXJhbSBuZXdTY29wZVxuICAgICAqL1xuICAgIGFwcGVuZFNjb3BlKG5ld1Njb3BlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKG5ld1Njb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3Blcy5hZGQobmV3U2NvcGUudHJpbSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgbXVsdGlwbGUgc2NvcGVzIGlmIHBhc3NlZFxuICAgICAqIEBwYXJhbSBuZXdTY29wZXNcbiAgICAgKi9cbiAgICBhcHBlbmRTY29wZXMobmV3U2NvcGVzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdTY29wZXMuZm9yRWFjaCgobmV3U2NvcGUpID0+IHRoaXMuYXBwZW5kU2NvcGUobmV3U2NvcGUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmNhbm5vdEFwcGVuZFNjb3BlU2V0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50IGZyb20gc2V0IG9mIHNjb3Blcy5cbiAgICAgKiBAcGFyYW0gc2NvcGVcbiAgICAgKi9cbiAgICByZW1vdmVTY29wZShzY29wZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmICghc2NvcGUpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5jYW5ub3RSZW1vdmVFbXB0eVNjb3BlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NvcGVzLmRlbGV0ZShzY29wZS50cmltKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZGVmYXVsdCBzY29wZXMgZnJvbSBzZXQgb2Ygc2NvcGVzXG4gICAgICogUHJpbWFyaWx5IHVzZWQgdG8gcHJldmVudCBjYWNoZSBtaXNzZXMgaWYgdGhlIGRlZmF1bHQgc2NvcGVzIGFyZSBub3QgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgcmVtb3ZlT0lEQ1Njb3BlcygpOiB2b2lkIHtcbiAgICAgICAgT0lEQ19TQ09QRVMuZm9yRWFjaCgoZGVmYXVsdFNjb3BlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzLmRlbGV0ZShkZWZhdWx0U2NvcGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyBhbiBhcnJheSBvZiBzY29wZXMgd2l0aCB0aGUgY3VycmVudCBzZXQgb2Ygc2NvcGVzLlxuICAgICAqIEBwYXJhbSBvdGhlclNjb3Blc1xuICAgICAqL1xuICAgIHVuaW9uU2NvcGVTZXRzKG90aGVyU2NvcGVzOiBTY29wZVNldCk6IFNldDxzdHJpbmc+IHtcbiAgICAgICAgaWYgKCFvdGhlclNjb3Blcykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmVtcHR5SW5wdXRTY29wZVNldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmlvblNjb3BlcyA9IG5ldyBTZXQ8c3RyaW5nPigpOyAvLyBJdGVyYXRvciBpbiBjb25zdHJ1Y3RvciBub3Qgc3VwcG9ydGVkIGluIElFMTFcbiAgICAgICAgb3RoZXJTY29wZXMuc2NvcGVzLmZvckVhY2goKHNjb3BlKSA9PlxuICAgICAgICAgICAgdW5pb25TY29wZXMuYWRkKHNjb3BlLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2NvcGVzLmZvckVhY2goKHNjb3BlKSA9PiB1bmlvblNjb3Blcy5hZGQoc2NvcGUudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICByZXR1cm4gdW5pb25TY29wZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgc2NvcGVzIGludGVyc2VjdCBiZXR3ZWVuIHRoaXMgc2V0IGFuZCBhbm90aGVyLlxuICAgICAqIEBwYXJhbSBvdGhlclNjb3Blc1xuICAgICAqL1xuICAgIGludGVyc2VjdGluZ1Njb3BlU2V0cyhvdGhlclNjb3BlczogU2NvcGVTZXQpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFvdGhlclNjb3Blcykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmVtcHR5SW5wdXRTY29wZVNldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBPSURDIHNjb3BlcyB0byBiZSB0aGUgb25seSBpbnRlcnNlY3Rpbmcgc2NvcGVzXG4gICAgICAgIGlmICghb3RoZXJTY29wZXMuY29udGFpbnNPbmx5T0lEQ1Njb3BlcygpKSB7XG4gICAgICAgICAgICBvdGhlclNjb3Blcy5yZW1vdmVPSURDU2NvcGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5pb25TY29wZXMgPSB0aGlzLnVuaW9uU2NvcGVTZXRzKG90aGVyU2NvcGVzKTtcbiAgICAgICAgY29uc3Qgc2l6ZU90aGVyU2NvcGVzID0gb3RoZXJTY29wZXMuZ2V0U2NvcGVDb3VudCgpO1xuICAgICAgICBjb25zdCBzaXplVGhpc1Njb3BlcyA9IHRoaXMuZ2V0U2NvcGVDb3VudCgpO1xuICAgICAgICBjb25zdCBzaXplVW5pb25TY29wZXMgPSB1bmlvblNjb3Blcy5zaXplO1xuICAgICAgICByZXR1cm4gc2l6ZVVuaW9uU2NvcGVzIDwgc2l6ZVRoaXNTY29wZXMgKyBzaXplT3RoZXJTY29wZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzaXplIG9mIHNldCBvZiBzY29wZXMuXG4gICAgICovXG4gICAgZ2V0U2NvcGVDb3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZXMuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY29wZXMgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nIHZhbHVlc1xuICAgICAqL1xuICAgIGFzQXJyYXkoKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGFycmF5OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIHRoaXMuc2NvcGVzLmZvckVhY2goKHZhbCkgPT4gYXJyYXkucHVzaCh2YWwpKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByaW50cyBzY29wZXMgaW50byBhIHNwYWNlLWRlbGltaXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBwcmludFNjb3BlcygpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlQXJyID0gdGhpcy5hc0FycmF5KCk7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVBcnIuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJpbnRzIHNjb3BlcyBpbnRvIGEgc3BhY2UtZGVsaW1pdGVkIGxvd2VyLWNhc2Ugc3RyaW5nICh1c2VkIGZvciBjYWNoaW5nKVxuICAgICAqL1xuICAgIHByaW50U2NvcGVzTG93ZXJDYXNlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW50U2NvcGVzKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLmpzXCI7XG5pbXBvcnQgeyBTZXBhcmF0b3JzLCBDb25zdGFudHMgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5cbi8qKlxuICogQ2xpZW50IGluZm8gb2JqZWN0IHdoaWNoIGNvbnNpc3RzIG9mIHR3byBJRHMuIE5lZWQgdG8gYWRkIG1vcmUgaW5mbyBoZXJlLlxuICovXG5leHBvcnQgdHlwZSBDbGllbnRJbmZvID0ge1xuICAgIHVpZDogc3RyaW5nO1xuICAgIHV0aWQ6IHN0cmluZztcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYnVpbGQgYSBjbGllbnQgaW5mbyBvYmplY3QgZnJvbSBzZXJ2ZXIgY2xpZW50SW5mbyBzdHJpbmdcbiAqIEBwYXJhbSByYXdDbGllbnRJbmZvXG4gKiBAcGFyYW0gY3J5cHRvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENsaWVudEluZm8oXG4gICAgcmF3Q2xpZW50SW5mbzogc3RyaW5nLFxuICAgIGJhc2U2NERlY29kZTogKGlucHV0OiBzdHJpbmcpID0+IHN0cmluZ1xuKTogQ2xpZW50SW5mbyB7XG4gICAgaWYgKCFyYXdDbGllbnRJbmZvKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5jbGllbnRJbmZvRW1wdHlFcnJvcik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZENsaWVudEluZm86IHN0cmluZyA9IGJhc2U2NERlY29kZShyYXdDbGllbnRJbmZvKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZENsaWVudEluZm8pIGFzIENsaWVudEluZm87XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5jbGllbnRJbmZvRGVjb2RpbmdFcnJvclxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBidWlsZCBhIGNsaWVudCBpbmZvIG9iamVjdCBmcm9tIGNhY2hlZCBob21lQWNjb3VudElkIHN0cmluZ1xuICogQHBhcmFtIGhvbWVBY2NvdW50SWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ2xpZW50SW5mb0Zyb21Ib21lQWNjb3VudElkKFxuICAgIGhvbWVBY2NvdW50SWQ6IHN0cmluZ1xuKTogQ2xpZW50SW5mbyB7XG4gICAgaWYgKCFob21lQWNjb3VudElkKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmNsaWVudEluZm9EZWNvZGluZ0Vycm9yXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudEluZm9QYXJ0czogc3RyaW5nW10gPSBob21lQWNjb3VudElkLnNwbGl0KFxuICAgICAgICBTZXBhcmF0b3JzLkNMSUVOVF9JTkZPX1NFUEFSQVRPUixcbiAgICAgICAgMlxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdWlkOiBjbGllbnRJbmZvUGFydHNbMF0sXG4gICAgICAgIHV0aWQ6XG4gICAgICAgICAgICBjbGllbnRJbmZvUGFydHMubGVuZ3RoIDwgMlxuICAgICAgICAgICAgICAgID8gQ29uc3RhbnRzLkVNUFRZX1NUUklOR1xuICAgICAgICAgICAgICAgIDogY2xpZW50SW5mb1BhcnRzWzFdLFxuICAgIH07XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFRva2VuQ2xhaW1zIH0gZnJvbSBcIi4vVG9rZW5DbGFpbXMuanNcIjtcbi8qKlxuICogQWNjb3VudCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqIC0gaG9tZUFjY291bnRJZCAgICAgICAgICAtIEhvbWUgYWNjb3VudCBpZGVudGlmaWVyIGZvciB0aGlzIGFjY291bnQgb2JqZWN0XG4gKiAtIGVudmlyb25tZW50ICAgICAgICAgICAgLSBFbnRpdHkgd2hpY2ggaXNzdWVkIHRoZSB0b2tlbiByZXByZXNlbnRlZCBieSB0aGUgZG9tYWluIG9mIHRoZSBpc3N1ZXIgKGUuZy4gbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbSlcbiAqIC0gdGVuYW50SWQgICAgICAgICAgICAgICAtIEZ1bGwgdGVuYW50IG9yIG9yZ2FuaXphdGlvbmFsIGlkIHRoYXQgdGhpcyBhY2NvdW50IGJlbG9uZ3MgdG9cbiAqIC0gdXNlcm5hbWUgICAgICAgICAgICAgICAtIHByZWZlcnJlZF91c2VybmFtZSBjbGFpbSBvZiB0aGUgaWRfdG9rZW4gdGhhdCByZXByZXNlbnRzIHRoaXMgYWNjb3VudFxuICogLSBsb2NhbEFjY291bnRJZCAgICAgICAgIC0gTG9jYWwsIHRlbmFudC1zcGVjaWZpYyBhY2NvdW50IGlkZW50aWZlciBmb3IgdGhpcyBhY2NvdW50IG9iamVjdCwgdXN1YWxseSB1c2VkIGluIGxlZ2FjeSBjYXNlc1xuICogLSBuYW1lICAgICAgICAgICAgICAgICAgIC0gRnVsbCBuYW1lIGZvciB0aGUgYWNjb3VudCwgaW5jbHVkaW5nIGdpdmVuIG5hbWUgYW5kIGZhbWlseSBuYW1lXG4gKiAtIGlkVG9rZW4gICAgICAgICAgICAgICAgLSByYXcgSUQgdG9rZW5cbiAqIC0gaWRUb2tlbkNsYWltcyAgICAgICAgICAtIE9iamVjdCBjb250YWlucyBjbGFpbXMgZnJvbSBJRCB0b2tlblxuICogLSBuYXRpdmVBY2NvdW50SWQgICAgICAgIC0gVGhlIHVzZXIncyBuYXRpdmUgYWNjb3VudCBJRFxuICogLSB0ZW5hbnRQcm9maWxlcyAgICAgICAgIC0gTWFwIG9mIHRlbmFudCBwcm9maWxlIG9iamVjdHMgZm9yIGVhY2ggdGVuYW50IHRoYXQgdGhlIGFjY291bnQgaGFzIGF1dGhlbnRpY2F0ZWQgd2l0aCBpbiB0aGUgYnJvd3NlclxuICovXG5leHBvcnQgdHlwZSBBY2NvdW50SW5mbyA9IHtcbiAgICBob21lQWNjb3VudElkOiBzdHJpbmc7XG4gICAgZW52aXJvbm1lbnQ6IHN0cmluZztcbiAgICB0ZW5hbnRJZDogc3RyaW5nO1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgbG9jYWxBY2NvdW50SWQ6IHN0cmluZztcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIGlkVG9rZW4/OiBzdHJpbmc7XG4gICAgaWRUb2tlbkNsYWltcz86IFRva2VuQ2xhaW1zICYge1xuICAgICAgICBba2V5OiBzdHJpbmddOlxuICAgICAgICAgICAgfCBzdHJpbmdcbiAgICAgICAgICAgIHwgbnVtYmVyXG4gICAgICAgICAgICB8IHN0cmluZ1tdXG4gICAgICAgICAgICB8IG9iamVjdFxuICAgICAgICAgICAgfCB1bmRlZmluZWRcbiAgICAgICAgICAgIHwgdW5rbm93bjtcbiAgICB9O1xuICAgIG5hdGl2ZUFjY291bnRJZD86IHN0cmluZztcbiAgICBhdXRob3JpdHlUeXBlPzogc3RyaW5nO1xuICAgIHRlbmFudFByb2ZpbGVzPzogTWFwPHN0cmluZywgVGVuYW50UHJvZmlsZT47XG59O1xuXG4vKipcbiAqIEFjY291bnQgZGV0YWlscyB0aGF0IHZhcnkgYWNyb3NzIHRlbmFudHMgZm9yIHRoZSBzYW1lIHVzZXJcbiAqL1xuZXhwb3J0IHR5cGUgVGVuYW50UHJvZmlsZSA9IFBpY2s8XG4gICAgQWNjb3VudEluZm8sXG4gICAgXCJ0ZW5hbnRJZFwiIHwgXCJsb2NhbEFjY291bnRJZFwiIHwgXCJuYW1lXCJcbj4gJiB7XG4gICAgLyoqXG4gICAgICogLSBpc0hvbWVUZW5hbnQgICAgICAgICAgIC0gVHJ1ZSBpZiB0aGlzIGlzIHRoZSBob21lIHRlbmFudCBwcm9maWxlIG9mIHRoZSBhY2NvdW50LCBmYWxzZSBpZiBpdCdzIGEgZ3Vlc3QgdGVuYW50IHByb2ZpbGVcbiAgICAgKi9cbiAgICBpc0hvbWVUZW5hbnQ/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgQWN0aXZlQWNjb3VudEZpbHRlcnMgPSB7XG4gICAgaG9tZUFjY291bnRJZDogc3RyaW5nO1xuICAgIGxvY2FsQWNjb3VudElkOiBzdHJpbmc7XG4gICAgdGVuYW50SWQ/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0ZW5hbnRJZCBtYXRjaGVzIHRoZSB1dGlkIHBvcnRpb24gb2YgaG9tZUFjY291bnRJZFxuICogQHBhcmFtIHRlbmFudElkXG4gKiBAcGFyYW0gaG9tZUFjY291bnRJZFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbmFudElkTWF0Y2hlc0hvbWVUZW5hbnQoXG4gICAgdGVuYW50SWQ/OiBzdHJpbmcsXG4gICAgaG9tZUFjY291bnRJZD86IHN0cmluZ1xuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgISF0ZW5hbnRJZCAmJlxuICAgICAgICAhIWhvbWVBY2NvdW50SWQgJiZcbiAgICAgICAgdGVuYW50SWQgPT09IGhvbWVBY2NvdW50SWQuc3BsaXQoXCIuXCIpWzFdXG4gICAgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCB0ZW5hbnQgcHJvZmlsZVxuICogQHBhcmFtIGhvbWVBY2NvdW50SWQgLSBIb21lIGFjY291bnQgaWRlbnRpZmllciBmb3IgdGhpcyBhY2NvdW50IG9iamVjdFxuICogQHBhcmFtIGxvY2FsQWNjb3VudElkIC0gTG9jYWwgYWNjb3VudCBpZGVudGlmZXIgZm9yIHRoaXMgYWNjb3VudCBvYmplY3RcbiAqIEBwYXJhbSB0ZW5hbnRJZCAtIEZ1bGwgdGVuYW50IG9yIG9yZ2FuaXphdGlvbmFsIGlkIHRoYXQgdGhpcyBhY2NvdW50IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBpZFRva2VuQ2xhaW1zIC0gQ2xhaW1zIGZyb20gdGhlIElEIHRva2VuXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRUZW5hbnRQcm9maWxlKFxuICAgIGhvbWVBY2NvdW50SWQ6IHN0cmluZyxcbiAgICBsb2NhbEFjY291bnRJZDogc3RyaW5nLFxuICAgIHRlbmFudElkOiBzdHJpbmcsXG4gICAgaWRUb2tlbkNsYWltcz86IFRva2VuQ2xhaW1zXG4pOiBUZW5hbnRQcm9maWxlIHtcbiAgICBpZiAoaWRUb2tlbkNsYWltcykge1xuICAgICAgICBjb25zdCB7IG9pZCwgc3ViLCB0aWQsIG5hbWUsIHRmcCwgYWNyIH0gPSBpZFRva2VuQ2xhaW1zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhdXRob3JpdHkgaXMgQUFEIG9yIEIyQywgd2UgZXhoYXVzdCBhbGwgdGhlIHBvc3NpYmxlIGNsYWltcyB0aGF0IGNhbiBzZXJ2ZSBhcyB0ZW5hbnQgSUQgd2l0aCB0aGUgZm9sbG93aW5nIHByZWNlZGVuY2U6XG4gICAgICAgICAqIHRpZCAtIFRlbmFudElEIGNsYWltIHRoYXQgaWRlbnRpZmllcyB0aGUgdGVuYW50IHRoYXQgaXNzdWVkIHRoZSB0b2tlbiBpbiBBQUQuIEV4cGVjdGVkIGluIGFsbCBBQUQgSUQgdG9rZW5zLCBub3QgcHJlc2VudCBpbiBCMkMgSUQgVG9rZW5zLlxuICAgICAgICAgKiB0ZnAgLSBUcnVzdCBGcmFtZXdvcmsgUG9saWN5IGNsYWltIHRoYXQgaWRlbnRpZmllcyB0aGUgcG9saWN5IHRoYXQgd2FzIHVzZWQgdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyLiBGdW5jdGlvbnMgYXMgdGVuYW50IGZvciBCMkMgc2NlbmFyaW9zLlxuICAgICAgICAgKiBhY3IgLSBBdXRoZW50aWNhdGlvbiBDb250ZXh0IENsYXNzIFJlZmVyZW5jZSBjbGFpbSB1c2VkIG9ubHkgd2l0aCBvbGRlciBCMkMgcG9saWNpZXMuIEZhbGxiYWNrIGluIGNhc2UgdGZwIGlzIG5vdCBwcmVzZW50LCBidXQgbGlrZWx5IHdvbid0IGJlIHByZXNlbnQgYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSB0aWQgfHwgdGZwIHx8IGFjciB8fCBcIlwiO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZW5hbnRJZDogdGVuYW50SWQsXG4gICAgICAgICAgICBsb2NhbEFjY291bnRJZDogb2lkIHx8IHN1YiB8fCBcIlwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGlzSG9tZVRlbmFudDogdGVuYW50SWRNYXRjaGVzSG9tZVRlbmFudCh0ZW5hbnRJZCwgaG9tZUFjY291bnRJZCksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgICAgbG9jYWxBY2NvdW50SWQsXG4gICAgICAgICAgICBpc0hvbWVUZW5hbnQ6IHRlbmFudElkTWF0Y2hlc0hvbWVUZW5hbnQodGVuYW50SWQsIGhvbWVBY2NvdW50SWQpLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBhY2NvdW50IGluZm8gdGhhdCB2YXJpZXMgYnkgdGVuYW50IHByb2ZpbGUgc291cmNlZCBmcm9tIHRoZSBJRCB0b2tlbiBjbGFpbXMgcGFzc2VkIGluIHdpdGggdGhlIHRlbmFudC1zcGVjaWZpYyBhY2NvdW50IGluZm9cbiAqIEBwYXJhbSBiYXNlQWNjb3VudEluZm9cbiAqIEBwYXJhbSBpZFRva2VuQ2xhaW1zXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQWNjb3VudFRlbmFudFByb2ZpbGVEYXRhKFxuICAgIGJhc2VBY2NvdW50SW5mbzogQWNjb3VudEluZm8sXG4gICAgdGVuYW50UHJvZmlsZT86IFRlbmFudFByb2ZpbGUsXG4gICAgaWRUb2tlbkNsYWltcz86IFRva2VuQ2xhaW1zLFxuICAgIGlkVG9rZW5TZWNyZXQ/OiBzdHJpbmdcbik6IEFjY291bnRJbmZvIHtcbiAgICBsZXQgdXBkYXRlZEFjY291bnRJbmZvID0gYmFzZUFjY291bnRJbmZvO1xuICAgIC8vIFRlbmFudCBQcm9maWxlIG92ZXJyaWRlcyBwYXNzZWQgaW4gYWNjb3VudCBpbmZvXG4gICAgaWYgKHRlbmFudFByb2ZpbGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IGlzSG9tZVRlbmFudCwgLi4udGVuYW50UHJvZmlsZU92ZXJyaWRlIH0gPSB0ZW5hbnRQcm9maWxlO1xuICAgICAgICB1cGRhdGVkQWNjb3VudEluZm8gPSB7IC4uLmJhc2VBY2NvdW50SW5mbywgLi4udGVuYW50UHJvZmlsZU92ZXJyaWRlIH07XG4gICAgfVxuXG4gICAgLy8gSUQgdG9rZW4gY2xhaW1zIG92ZXJyaWRlIHBhc3NlZCBpbiBhY2NvdW50IGluZm8gYW5kIHRlbmFudCBwcm9maWxlXG4gICAgaWYgKGlkVG9rZW5DbGFpbXMpIHtcbiAgICAgICAgLy8gSWdub3JlIGlzSG9tZVRlbmFudCwgbG9naW5IaW50LCBhbmQgc2lkIHdoaWNoIGFyZSBwYXJ0IG9mIHRlbmFudCBwcm9maWxlIGJ1dCBub3QgYmFzZSBhY2NvdW50IGluZm9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IGlzSG9tZVRlbmFudCwgLi4uY2xhaW1zU291cmNlZFRlbmFudFByb2ZpbGUgfSA9XG4gICAgICAgICAgICBidWlsZFRlbmFudFByb2ZpbGUoXG4gICAgICAgICAgICAgICAgYmFzZUFjY291bnRJbmZvLmhvbWVBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYmFzZUFjY291bnRJbmZvLmxvY2FsQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGJhc2VBY2NvdW50SW5mby50ZW5hbnRJZCxcbiAgICAgICAgICAgICAgICBpZFRva2VuQ2xhaW1zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHVwZGF0ZWRBY2NvdW50SW5mbyA9IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZWRBY2NvdW50SW5mbyxcbiAgICAgICAgICAgIC4uLmNsYWltc1NvdXJjZWRUZW5hbnRQcm9maWxlLFxuICAgICAgICAgICAgaWRUb2tlbkNsYWltczogaWRUb2tlbkNsYWltcyxcbiAgICAgICAgICAgIGlkVG9rZW46IGlkVG9rZW5TZWNyZXQsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRBY2NvdW50SW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZEFjY291bnRJbmZvO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEF1dGhvcml0eSB0eXBlcyBzdXBwb3J0ZWQgYnkgTVNBTC5cbiAqL1xuZXhwb3J0IGNvbnN0IEF1dGhvcml0eVR5cGUgPSB7XG4gICAgRGVmYXVsdDogMCxcbiAgICBBZGZzOiAxLFxuICAgIERzdHM6IDIsXG4gICAgQ2lhbTogMyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBBdXRob3JpdHlUeXBlID0gKHR5cGVvZiBBdXRob3JpdHlUeXBlKVtrZXlvZiB0eXBlb2YgQXV0aG9yaXR5VHlwZV07XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogVHlwZSB3aGljaCBkZXNjcmliZXMgSWQgVG9rZW4gY2xhaW1zIGtub3duIGJ5IE1TQUwuXG4gKi9cbmV4cG9ydCB0eXBlIFRva2VuQ2xhaW1zID0ge1xuICAgIC8qKlxuICAgICAqIEF1ZGllbmNlXG4gICAgICovXG4gICAgYXVkPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIElzc3VlclxuICAgICAqL1xuICAgIGlzcz86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBJc3N1ZWQgYXRcbiAgICAgKi9cbiAgICBpYXQ/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogTm90IHZhbGlkIGJlZm9yZVxuICAgICAqL1xuICAgIG5iZj86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbW11dGFibGUgb2JqZWN0IGlkZW50aWZpZXIsIHRoaXMgSUQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgdXNlciBhY3Jvc3MgYXBwbGljYXRpb25zXG4gICAgICovXG4gICAgb2lkPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEltbXV0YWJsZSBzdWJqZWN0IGlkZW50aWZpZXIsIHRoaXMgaXMgYSBwYWlyd2lzZSBpZGVudGlmaWVyIC0gaXQgaXMgdW5pcXVlIHRvIGEgcGFydGljdWxhciBhcHBsaWNhdGlvbiBJRFxuICAgICAqL1xuICAgIHN1Yj86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBVc2VycycgdGVuYW50IG9yICc5MTg4MDQwZC02YzY3LTRjNWItYjExMi0zNmEzMDRiNjZkYWQnIGZvciBwZXJzb25hbCBhY2NvdW50cy5cbiAgICAgKi9cbiAgICB0aWQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVHJ1c3RlZCBGcmFtZXdvcmsgUG9saWN5IChCMkMpIFRoZSBuYW1lIG9mIHRoZSBwb2xpY3kgdGhhdCB3YXMgdXNlZCB0byBhY3F1aXJlIHRoZSBJRCB0b2tlbi5cbiAgICAgKi9cbiAgICB0ZnA/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRpb24gQ29udGV4dCBDbGFzcyBSZWZlcmVuY2UgKEIyQykgVXNlZCBvbmx5IHdpdGggb2xkZXIgcG9saWNpZXMuXG4gICAgICovXG4gICAgYWNyPzogc3RyaW5nO1xuICAgIHZlcj86IHN0cmluZztcbiAgICB1cG4/OiBzdHJpbmc7XG4gICAgcHJlZmVycmVkX3VzZXJuYW1lPzogc3RyaW5nO1xuICAgIGxvZ2luX2hpbnQ/OiBzdHJpbmc7XG4gICAgZW1haWxzPzogc3RyaW5nW107XG4gICAgbmFtZT86IHN0cmluZztcbiAgICBub25jZT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBFeHBpcmF0aW9uXG4gICAgICovXG4gICAgZXhwPzogbnVtYmVyO1xuICAgIGhvbWVfb2lkPzogc3RyaW5nO1xuICAgIHNpZD86IHN0cmluZztcbiAgICBjbG91ZF9pbnN0YW5jZV9ob3N0X25hbWU/OiBzdHJpbmc7XG4gICAgY25mPzoge1xuICAgICAgICBraWQ6IHN0cmluZztcbiAgICB9O1xuICAgIHg1Y19jYT86IHN0cmluZ1tdO1xuICAgIHRzPzogbnVtYmVyO1xuICAgIGF0Pzogc3RyaW5nO1xuICAgIHU/OiBzdHJpbmc7XG4gICAgcD86IHN0cmluZztcbiAgICBtPzogc3RyaW5nO1xuICAgIHJvbGVzPzogc3RyaW5nW107XG4gICAgYW1yPzogc3RyaW5nW107XG4gICAgaWRwPzogc3RyaW5nO1xuICAgIGF1dGhfdGltZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBcdFJlZ2lvbiBvZiB0aGUgcmVzb3VyY2UgdGVuYW50XG4gICAgICovXG4gICAgdGVuYW50X3JlZ2lvbl9zY29wZT86IHN0cmluZztcbiAgICB0ZW5hbnRfcmVnaW9uX3N1Yl9zY29wZT86IHN0cmluZztcbn07XG5cbi8qKlxuICogR2V0cyB0ZW5hbnRJZCBmcm9tIGF2YWlsYWJsZSBJRCB0b2tlbiBjbGFpbXMgdG8gc2V0IGFzIGNyZWRlbnRpYWwgcmVhbG0gd2l0aCB0aGUgZm9sbG93aW5nIHByZWNlZGVuY2U6XG4gKiAxLiB0aWQgLSBpZiB0aGUgdG9rZW4gaXMgYWNxdWlyZWQgZnJvbSBhbiBBenVyZSBBRCB0ZW5hbnQgdGlkIHdpbGwgYmUgcHJlc2VudFxuICogMi4gdGZwIC0gaWYgdGhlIHRva2VuIGlzIGFjcXVpcmVkIGZyb20gYSBtb2Rlcm4gQjJDIHRlbmFudCB0ZnAgc2hvdWxkIGJlIHByZXNlbnRcbiAqIDMuIGFjciAtIGlmIHRoZSB0b2tlbiBpcyBhY3F1aXJlZCBmcm9tIGEgbGVnYWN5IEIyQyB0ZW5hbnQgYWNyIHNob3VsZCBiZSBwcmVzZW50XG4gKiBEb3duY2FzZWQgdG8gbWF0Y2ggdGhlIHJlYWxtIGNhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvbiByZXF1aXJlbWVudHNcbiAqIEBwYXJhbSBpZFRva2VuQ2xhaW1zXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVuYW50SWRGcm9tSWRUb2tlbkNsYWltcyhcbiAgICBpZFRva2VuQ2xhaW1zPzogVG9rZW5DbGFpbXNcbik6IHN0cmluZyB8IG51bGwge1xuICAgIGlmIChpZFRva2VuQ2xhaW1zKSB7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID1cbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMudGlkIHx8IGlkVG9rZW5DbGFpbXMudGZwIHx8IGlkVG9rZW5DbGFpbXMuYWNyO1xuICAgICAgICByZXR1cm4gdGVuYW50SWQgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUHJvdG9jb2wgbW9kZXMgc3VwcG9ydGVkIGJ5IE1TQUwuXG4gKi9cbmV4cG9ydCBjb25zdCBQcm90b2NvbE1vZGUgPSB7XG4gICAgLyoqXG4gICAgICogQXV0aCBDb2RlICsgUEtDRSB3aXRoIEVudHJhIElEIChmb3JtZXJseSBBQUQpIHNwZWNpZmljIG9wdGltaXphdGlvbnMgYW5kIGZlYXR1cmVzXG4gICAgICovXG4gICAgQUFEOiBcIkFBRFwiLFxuICAgIC8qKlxuICAgICAqIEF1dGggQ29kZSArIFBLQ0Ugd2l0aG91dCBFbnRyYSBJRCBzcGVjaWZpYyBvcHRpbWl6YXRpb25zIGFuZCBmZWF0dXJlcy4gRm9yIHVzZSBvbmx5IHdpdGggbm9uLU1pY3Jvc29mdCBvd25lZCBhdXRob3JpdGllcy5cbiAgICAgKiBTdXBwb3J0IGlzIGxpbWl0ZWQgZm9yIHRoaXMgbW9kZS5cbiAgICAgKi9cbiAgICBPSURDOiBcIk9JRENcIixcbiAgICAvKipcbiAgICAgKiBFbmNyeXB0ZWQgQXV0aG9yaXplIFJlc3BvbnNlIChFQVIpIHdpdGggRW50cmEgSUQgc3BlY2lmaWMgb3B0aW1pemF0aW9ucyBhbmQgZmVhdHVyZXNcbiAgICAgKi9cbiAgICBFQVI6IFwiRUFSXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgUHJvdG9jb2xNb2RlID0gKHR5cGVvZiBQcm90b2NvbE1vZGUpW2tleW9mIHR5cGVvZiBQcm90b2NvbE1vZGVdO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDYWNoZUFjY291bnRUeXBlLCBTZXBhcmF0b3JzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgQXV0aG9yaXR5IH0gZnJvbSBcIi4uLy4uL2F1dGhvcml0eS9BdXRob3JpdHkuanNcIjtcbmltcG9ydCB7IElDcnlwdG8gfSBmcm9tIFwiLi4vLi4vY3J5cHRvL0lDcnlwdG8uanNcIjtcbmltcG9ydCB7IENsaWVudEluZm8sIGJ1aWxkQ2xpZW50SW5mbyB9IGZyb20gXCIuLi8uLi9hY2NvdW50L0NsaWVudEluZm8uanNcIjtcbmltcG9ydCB7XG4gICAgQWNjb3VudEluZm8sXG4gICAgVGVuYW50UHJvZmlsZSxcbiAgICBidWlsZFRlbmFudFByb2ZpbGUsXG59IGZyb20gXCIuLi8uLi9hY2NvdW50L0FjY291bnRJbmZvLmpzXCI7XG5pbXBvcnQge1xuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbiAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcyxcbn0gZnJvbSBcIi4uLy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgQXV0aG9yaXR5VHlwZSB9IGZyb20gXCIuLi8uLi9hdXRob3JpdHkvQXV0aG9yaXR5VHlwZS5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uL2xvZ2dlci9Mb2dnZXIuanNcIjtcbmltcG9ydCB7XG4gICAgVG9rZW5DbGFpbXMsXG4gICAgZ2V0VGVuYW50SWRGcm9tSWRUb2tlbkNsYWltcyxcbn0gZnJvbSBcIi4uLy4uL2FjY291bnQvVG9rZW5DbGFpbXMuanNcIjtcbmltcG9ydCB7IFByb3RvY29sTW9kZSB9IGZyb20gXCIuLi8uLi9hdXRob3JpdHkvUHJvdG9jb2xNb2RlLmpzXCI7XG5cbi8qKlxuICogVHlwZSB0aGF0IGRlZmluZXMgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGFuIEFjY291bnQgZmllbGQgKGJhc2VkIG9uIHVuaXZlcnNhbCBjYWNoZSBzY2hlbWEgaW1wbGVtZW50ZWQgYnkgYWxsIE1TQUxzKS5cbiAqXG4gKiBLZXkgOiBWYWx1ZSBTY2hlbWFcbiAqXG4gKiBLZXk6IDxob21lX2FjY291bnRfaWQ+LTxlbnZpcm9ubWVudD4tPHJlYWxtKj5cbiAqXG4gKiBWYWx1ZSBTY2hlbWE6XG4gKiB7XG4gKiAgICAgIGhvbWVBY2NvdW50SWQ6IGhvbWUgYWNjb3VudCBpZGVudGlmaWVyIGZvciB0aGUgYXV0aCBzY2hlbWUsXG4gKiAgICAgIGVudmlyb25tZW50OiBlbnRpdHkgdGhhdCBpc3N1ZWQgdGhlIHRva2VuLCByZXByZXNlbnRlZCBhcyBhIGZ1bGwgaG9zdFxuICogICAgICByZWFsbTogRnVsbCB0ZW5hbnQgb3Igb3JnYW5pemF0aW9uYWwgaWRlbnRpZmllciB0aGF0IHRoZSBhY2NvdW50IGJlbG9uZ3MgdG9cbiAqICAgICAgbG9jYWxBY2NvdW50SWQ6IE9yaWdpbmFsIHRlbmFudC1zcGVjaWZpYyBhY2NvdW50SUQsIHVzdWFsbHkgdXNlZCBmb3IgbGVnYWN5IGNhc2VzXG4gKiAgICAgIHVzZXJuYW1lOiBwcmltYXJ5IHVzZXJuYW1lIHRoYXQgcmVwcmVzZW50cyB0aGUgdXNlciwgdXN1YWxseSBjb3JyZXNwb25kcyB0byBwcmVmZXJyZWRfdXNlcm5hbWUgaW4gdGhlIHYyIGVuZHB0XG4gKiAgICAgIGF1dGhvcml0eVR5cGU6IEFjY291bnRzIGF1dGhvcml0eSB0eXBlIGFzIGEgc3RyaW5nXG4gKiAgICAgIG5hbWU6IEZ1bGwgbmFtZSBmb3IgdGhlIGFjY291bnQsIGluY2x1ZGluZyBnaXZlbiBuYW1lIGFuZCBmYW1pbHkgbmFtZSxcbiAqICAgICAgbGFzdE1vZGlmaWNhdGlvblRpbWU6IGxhc3QgdGltZSB0aGlzIGVudGl0eSB3YXMgbW9kaWZpZWQgaW4gdGhlIGNhY2hlXG4gKiAgICAgIGxhc3RNb2RpZmljYXRpb25BcHA6XG4gKiAgICAgIG5hdGl2ZUFjY291bnRJZDogQWNjb3VudCBpZGVudGlmaWVyIG9uIHRoZSBuYXRpdmUgZGV2aWNlXG4gKiAgICAgIHRlbmFudFByb2ZpbGVzOiBBcnJheSBvZiB0ZW5hbnQgcHJvZmlsZSBvYmplY3RzIGZvciBlYWNoIHRlbmFudCB0aGF0IHRoZSBhY2NvdW50IGhhcyBhdXRoZW50aWNhdGVkIHdpdGggaW4gdGhlIGJyb3dzZXJcbiAqIH1cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQWNjb3VudEVudGl0eSB7XG4gICAgaG9tZUFjY291bnRJZDogc3RyaW5nO1xuICAgIGVudmlyb25tZW50OiBzdHJpbmc7XG4gICAgcmVhbG06IHN0cmluZztcbiAgICBsb2NhbEFjY291bnRJZDogc3RyaW5nO1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgYXV0aG9yaXR5VHlwZTogc3RyaW5nO1xuICAgIGNsaWVudEluZm8/OiBzdHJpbmc7XG4gICAgbmFtZT86IHN0cmluZztcbiAgICBsYXN0TW9kaWZpY2F0aW9uVGltZT86IHN0cmluZztcbiAgICBsYXN0TW9kaWZpY2F0aW9uQXBwPzogc3RyaW5nO1xuICAgIGNsb3VkR3JhcGhIb3N0TmFtZT86IHN0cmluZztcbiAgICBtc0dyYXBoSG9zdD86IHN0cmluZztcbiAgICBuYXRpdmVBY2NvdW50SWQ/OiBzdHJpbmc7XG4gICAgdGVuYW50UHJvZmlsZXM/OiBBcnJheTxUZW5hbnRQcm9maWxlPjtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIEFjY291bnQgSWQga2V5IGNvbXBvbmVudCBhcyBwZXIgdGhlIHNjaGVtYTogPGhvbWVfYWNjb3VudF9pZD4tPGVudmlyb25tZW50PlxuICAgICAqL1xuICAgIGdlbmVyYXRlQWNjb3VudElkKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGFjY291bnRJZDogQXJyYXk8c3RyaW5nPiA9IFt0aGlzLmhvbWVBY2NvdW50SWQsIHRoaXMuZW52aXJvbm1lbnRdO1xuICAgICAgICByZXR1cm4gYWNjb3VudElkLmpvaW4oU2VwYXJhdG9ycy5DQUNIRV9LRVlfU0VQQVJBVE9SKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIEFjY291bnQgQ2FjaGUgS2V5IGFzIHBlciB0aGUgc2NoZW1hOiA8aG9tZV9hY2NvdW50X2lkPi08ZW52aXJvbm1lbnQ+LTxyZWFsbSo+XG4gICAgICovXG4gICAgZ2VuZXJhdGVBY2NvdW50S2V5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBBY2NvdW50RW50aXR5LmdlbmVyYXRlQWNjb3VudENhY2hlS2V5KHtcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHRoaXMuaG9tZUFjY291bnRJZCxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiB0aGlzLmVudmlyb25tZW50LFxuICAgICAgICAgICAgdGVuYW50SWQ6IHRoaXMucmVhbG0sXG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgICAgICAgIGxvY2FsQWNjb3VudElkOiB0aGlzLmxvY2FsQWNjb3VudElkLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBY2NvdW50SW5mbyBpbnRlcmZhY2UgZm9yIHRoaXMgYWNjb3VudC5cbiAgICAgKi9cbiAgICBnZXRBY2NvdW50SW5mbygpOiBBY2NvdW50SW5mbyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob21lQWNjb3VudElkOiB0aGlzLmhvbWVBY2NvdW50SWQsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogdGhpcy5lbnZpcm9ubWVudCxcbiAgICAgICAgICAgIHRlbmFudElkOiB0aGlzLnJlYWxtLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICAgICAgICBsb2NhbEFjY291bnRJZDogdGhpcy5sb2NhbEFjY291bnRJZCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG5hdGl2ZUFjY291bnRJZDogdGhpcy5uYXRpdmVBY2NvdW50SWQsXG4gICAgICAgICAgICBhdXRob3JpdHlUeXBlOiB0aGlzLmF1dGhvcml0eVR5cGUsXG4gICAgICAgICAgICAvLyBEZXNlcmlhbGl6ZSB0ZW5hbnQgcHJvZmlsZXMgYXJyYXkgaW50byBhIE1hcFxuICAgICAgICAgICAgdGVuYW50UHJvZmlsZXM6IG5ldyBNYXAoXG4gICAgICAgICAgICAgICAgKHRoaXMudGVuYW50UHJvZmlsZXMgfHwgW10pLm1hcCgodGVuYW50UHJvZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RlbmFudFByb2ZpbGUudGVuYW50SWQsIHRlbmFudFByb2ZpbGVdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWNjb3VudCBlbnRpdHkgaXMgaW4gc2luZ2xlIHRlbmFudCBmb3JtYXQgKG91dGRhdGVkKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNTaW5nbGVUZW5hbnQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy50ZW5hbnRQcm9maWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYWNjb3VudCBrZXkgZnJvbSBpbnRlcmZhY2VcbiAgICAgKiBAcGFyYW0gYWNjb3VudEludGVyZmFjZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZUFjY291bnRDYWNoZUtleShhY2NvdW50SW50ZXJmYWNlOiBBY2NvdW50SW5mbyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGhvbWVUZW5hbnRJZCA9IGFjY291bnRJbnRlcmZhY2UuaG9tZUFjY291bnRJZC5zcGxpdChcIi5cIilbMV07XG4gICAgICAgIGNvbnN0IGFjY291bnRLZXkgPSBbXG4gICAgICAgICAgICBhY2NvdW50SW50ZXJmYWNlLmhvbWVBY2NvdW50SWQsXG4gICAgICAgICAgICBhY2NvdW50SW50ZXJmYWNlLmVudmlyb25tZW50IHx8IFwiXCIsXG4gICAgICAgICAgICBob21lVGVuYW50SWQgfHwgYWNjb3VudEludGVyZmFjZS50ZW5hbnRJZCB8fCBcIlwiLFxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBhY2NvdW50S2V5LmpvaW4oU2VwYXJhdG9ycy5DQUNIRV9LRVlfU0VQQVJBVE9SKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIEFjY291bnQgY2FjaGUgZnJvbSBJZFRva2VuLCBjbGllbnRJbmZvIGFuZCBhdXRob3JpdHkvcG9saWN5LiBBc3NvY2lhdGVkIHdpdGggQUFELlxuICAgICAqIEBwYXJhbSBhY2NvdW50RGV0YWlsc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVBY2NvdW50KFxuICAgICAgICBhY2NvdW50RGV0YWlsczoge1xuICAgICAgICAgICAgaG9tZUFjY291bnRJZDogc3RyaW5nO1xuICAgICAgICAgICAgaWRUb2tlbkNsYWltcz86IFRva2VuQ2xhaW1zO1xuICAgICAgICAgICAgY2xpZW50SW5mbz86IHN0cmluZztcbiAgICAgICAgICAgIGNsb3VkR3JhcGhIb3N0TmFtZT86IHN0cmluZztcbiAgICAgICAgICAgIG1zR3JhcGhIb3N0Pzogc3RyaW5nO1xuICAgICAgICAgICAgZW52aXJvbm1lbnQ/OiBzdHJpbmc7XG4gICAgICAgICAgICBuYXRpdmVBY2NvdW50SWQ/OiBzdHJpbmc7XG4gICAgICAgICAgICB0ZW5hbnRQcm9maWxlcz86IEFycmF5PFRlbmFudFByb2ZpbGU+O1xuICAgICAgICB9LFxuICAgICAgICBhdXRob3JpdHk6IEF1dGhvcml0eSxcbiAgICAgICAgYmFzZTY0RGVjb2RlPzogKGlucHV0OiBzdHJpbmcpID0+IHN0cmluZ1xuICAgICk6IEFjY291bnRFbnRpdHkge1xuICAgICAgICBjb25zdCBhY2NvdW50OiBBY2NvdW50RW50aXR5ID0gbmV3IEFjY291bnRFbnRpdHkoKTtcblxuICAgICAgICBpZiAoYXV0aG9yaXR5LmF1dGhvcml0eVR5cGUgPT09IEF1dGhvcml0eVR5cGUuQWRmcykge1xuICAgICAgICAgICAgYWNjb3VudC5hdXRob3JpdHlUeXBlID0gQ2FjaGVBY2NvdW50VHlwZS5BREZTX0FDQ09VTlRfVFlQRTtcbiAgICAgICAgfSBlbHNlIGlmIChhdXRob3JpdHkucHJvdG9jb2xNb2RlID09PSBQcm90b2NvbE1vZGUuT0lEQykge1xuICAgICAgICAgICAgYWNjb3VudC5hdXRob3JpdHlUeXBlID0gQ2FjaGVBY2NvdW50VHlwZS5HRU5FUklDX0FDQ09VTlRfVFlQRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY291bnQuYXV0aG9yaXR5VHlwZSA9IENhY2hlQWNjb3VudFR5cGUuTVNTVFNfQUNDT1VOVF9UWVBFO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNsaWVudEluZm86IENsaWVudEluZm8gfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGFjY291bnREZXRhaWxzLmNsaWVudEluZm8gJiYgYmFzZTY0RGVjb2RlKSB7XG4gICAgICAgICAgICBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvKFxuICAgICAgICAgICAgICAgIGFjY291bnREZXRhaWxzLmNsaWVudEluZm8sXG4gICAgICAgICAgICAgICAgYmFzZTY0RGVjb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYWNjb3VudC5jbGllbnRJbmZvID0gYWNjb3VudERldGFpbHMuY2xpZW50SW5mbztcbiAgICAgICAgYWNjb3VudC5ob21lQWNjb3VudElkID0gYWNjb3VudERldGFpbHMuaG9tZUFjY291bnRJZDtcbiAgICAgICAgYWNjb3VudC5uYXRpdmVBY2NvdW50SWQgPSBhY2NvdW50RGV0YWlscy5uYXRpdmVBY2NvdW50SWQ7XG5cbiAgICAgICAgY29uc3QgZW52ID1cbiAgICAgICAgICAgIGFjY291bnREZXRhaWxzLmVudmlyb25tZW50IHx8XG4gICAgICAgICAgICAoYXV0aG9yaXR5ICYmIGF1dGhvcml0eS5nZXRQcmVmZXJyZWRDYWNoZSgpKTtcblxuICAgICAgICBpZiAoIWVudikge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDYWNoZUVudmlyb25tZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYWNjb3VudC5lbnZpcm9ubWVudCA9IGVudjtcbiAgICAgICAgLy8gbm9uIEFBRCBzY2VuYXJpb3MgY2FuIGhhdmUgZW1wdHkgcmVhbG1cbiAgICAgICAgYWNjb3VudC5yZWFsbSA9XG4gICAgICAgICAgICBjbGllbnRJbmZvPy51dGlkIHx8XG4gICAgICAgICAgICBnZXRUZW5hbnRJZEZyb21JZFRva2VuQ2xhaW1zKGFjY291bnREZXRhaWxzLmlkVG9rZW5DbGFpbXMpIHx8XG4gICAgICAgICAgICBcIlwiO1xuXG4gICAgICAgIC8vIEhvdyBkbyB5b3UgYWNjb3VudCBmb3IgTVNBIENJRCBoZXJlP1xuICAgICAgICBhY2NvdW50LmxvY2FsQWNjb3VudElkID1cbiAgICAgICAgICAgIGNsaWVudEluZm8/LnVpZCB8fFxuICAgICAgICAgICAgYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltcz8ub2lkIHx8XG4gICAgICAgICAgICBhY2NvdW50RGV0YWlscy5pZFRva2VuQ2xhaW1zPy5zdWIgfHxcbiAgICAgICAgICAgIFwiXCI7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSW4gQjJDIHNjZW5hcmlvcyB0aGUgZW1haWxzIGNsYWltIGlzIHVzZWQgaW5zdGVhZCBvZiBwcmVmZXJyZWRfdXNlcm5hbWUgYW5kIGl0IGlzIGFuIGFycmF5LlxuICAgICAgICAgKiBJbiBtb3N0IGNhc2VzIGl0IHdpbGwgY29udGFpbiBhIHNpbmdsZSBlbWFpbC4gVGhpcyBmaWVsZCBzaG91bGQgbm90IGJlIHJlbGllZCB1cG9uIGlmIGEgY3VzdG9tXG4gICAgICAgICAqIHBvbGljeSBpcyBjb25maWd1cmVkIHRvIHJldHVybiBtb3JlIHRoYW4gMSBlbWFpbC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZWZlcnJlZFVzZXJuYW1lID1cbiAgICAgICAgICAgIGFjY291bnREZXRhaWxzLmlkVG9rZW5DbGFpbXM/LnByZWZlcnJlZF91c2VybmFtZSB8fFxuICAgICAgICAgICAgYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltcz8udXBuO1xuICAgICAgICBjb25zdCBlbWFpbCA9IGFjY291bnREZXRhaWxzLmlkVG9rZW5DbGFpbXM/LmVtYWlsc1xuICAgICAgICAgICAgPyBhY2NvdW50RGV0YWlscy5pZFRva2VuQ2xhaW1zLmVtYWlsc1swXVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIGFjY291bnQudXNlcm5hbWUgPSBwcmVmZXJyZWRVc2VybmFtZSB8fCBlbWFpbCB8fCBcIlwiO1xuICAgICAgICBhY2NvdW50Lm5hbWUgPSBhY2NvdW50RGV0YWlscy5pZFRva2VuQ2xhaW1zPy5uYW1lIHx8IFwiXCI7XG5cbiAgICAgICAgYWNjb3VudC5jbG91ZEdyYXBoSG9zdE5hbWUgPSBhY2NvdW50RGV0YWlscy5jbG91ZEdyYXBoSG9zdE5hbWU7XG4gICAgICAgIGFjY291bnQubXNHcmFwaEhvc3QgPSBhY2NvdW50RGV0YWlscy5tc0dyYXBoSG9zdDtcblxuICAgICAgICBpZiAoYWNjb3VudERldGFpbHMudGVuYW50UHJvZmlsZXMpIHtcbiAgICAgICAgICAgIGFjY291bnQudGVuYW50UHJvZmlsZXMgPSBhY2NvdW50RGV0YWlscy50ZW5hbnRQcm9maWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudFByb2ZpbGUgPSBidWlsZFRlbmFudFByb2ZpbGUoXG4gICAgICAgICAgICAgICAgYWNjb3VudERldGFpbHMuaG9tZUFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY2NvdW50LmxvY2FsQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjY291bnQucmVhbG0sXG4gICAgICAgICAgICAgICAgYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFjY291bnQudGVuYW50UHJvZmlsZXMgPSBbdGVuYW50UHJvZmlsZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEFjY291bnRFbnRpdHkgb2JqZWN0IGZyb20gQWNjb3VudEluZm9cbiAgICAgKiBAcGFyYW0gYWNjb3VudEluZm9cbiAgICAgKiBAcGFyYW0gY2xvdWRHcmFwaEhvc3ROYW1lXG4gICAgICogQHBhcmFtIG1zR3JhcGhIb3N0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUFjY291bnRJbmZvKFxuICAgICAgICBhY2NvdW50SW5mbzogQWNjb3VudEluZm8sXG4gICAgICAgIGNsb3VkR3JhcGhIb3N0TmFtZT86IHN0cmluZyxcbiAgICAgICAgbXNHcmFwaEhvc3Q/OiBzdHJpbmdcbiAgICApOiBBY2NvdW50RW50aXR5IHtcbiAgICAgICAgY29uc3QgYWNjb3VudDogQWNjb3VudEVudGl0eSA9IG5ldyBBY2NvdW50RW50aXR5KCk7XG5cbiAgICAgICAgYWNjb3VudC5hdXRob3JpdHlUeXBlID1cbiAgICAgICAgICAgIGFjY291bnRJbmZvLmF1dGhvcml0eVR5cGUgfHwgQ2FjaGVBY2NvdW50VHlwZS5HRU5FUklDX0FDQ09VTlRfVFlQRTtcbiAgICAgICAgYWNjb3VudC5ob21lQWNjb3VudElkID0gYWNjb3VudEluZm8uaG9tZUFjY291bnRJZDtcbiAgICAgICAgYWNjb3VudC5sb2NhbEFjY291bnRJZCA9IGFjY291bnRJbmZvLmxvY2FsQWNjb3VudElkO1xuICAgICAgICBhY2NvdW50Lm5hdGl2ZUFjY291bnRJZCA9IGFjY291bnRJbmZvLm5hdGl2ZUFjY291bnRJZDtcblxuICAgICAgICBhY2NvdW50LnJlYWxtID0gYWNjb3VudEluZm8udGVuYW50SWQ7XG4gICAgICAgIGFjY291bnQuZW52aXJvbm1lbnQgPSBhY2NvdW50SW5mby5lbnZpcm9ubWVudDtcblxuICAgICAgICBhY2NvdW50LnVzZXJuYW1lID0gYWNjb3VudEluZm8udXNlcm5hbWU7XG4gICAgICAgIGFjY291bnQubmFtZSA9IGFjY291bnRJbmZvLm5hbWU7XG5cbiAgICAgICAgYWNjb3VudC5jbG91ZEdyYXBoSG9zdE5hbWUgPSBjbG91ZEdyYXBoSG9zdE5hbWU7XG4gICAgICAgIGFjY291bnQubXNHcmFwaEhvc3QgPSBtc0dyYXBoSG9zdDtcbiAgICAgICAgLy8gU2VyaWFsaXplIHRlbmFudCBwcm9maWxlcyBtYXAgaW50byBhbiBhcnJheVxuICAgICAgICBhY2NvdW50LnRlbmFudFByb2ZpbGVzID0gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIGFjY291bnRJbmZvLnRlbmFudFByb2ZpbGVzPy52YWx1ZXMoKSB8fCBbXVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIEhvbWVBY2NvdW50SWQgZnJvbSBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0gc2VydmVyQ2xpZW50SW5mb1xuICAgICAqIEBwYXJhbSBhdXRoVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZUhvbWVBY2NvdW50SWQoXG4gICAgICAgIHNlcnZlckNsaWVudEluZm86IHN0cmluZyxcbiAgICAgICAgYXV0aFR5cGU6IEF1dGhvcml0eVR5cGUsXG4gICAgICAgIGxvZ2dlcjogTG9nZ2VyLFxuICAgICAgICBjcnlwdG9PYmo6IElDcnlwdG8sXG4gICAgICAgIGlkVG9rZW5DbGFpbXM/OiBUb2tlbkNsYWltc1xuICAgICk6IHN0cmluZyB7XG4gICAgICAgIC8vIHNpbmNlIEFERlMvRFNUUyBkbyBub3QgaGF2ZSB0aWQgYW5kIGRvZXMgbm90IHNldCBjbGllbnRfaW5mb1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIGF1dGhUeXBlID09PSBBdXRob3JpdHlUeXBlLkFkZnMgfHxcbiAgICAgICAgICAgICAgICBhdXRoVHlwZSA9PT0gQXV0aG9yaXR5VHlwZS5Ec3RzXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGlzIGNsaWVudEluZm9cbiAgICAgICAgICAgIGlmIChzZXJ2ZXJDbGllbnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mbyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckNsaWVudEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG9PYmouYmFzZTY0RGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnRJbmZvLnVpZCAmJiBjbGllbnRJbmZvLnV0aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtjbGllbnRJbmZvLnVpZH0uJHtjbGllbnRJbmZvLnV0aWR9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIud2FybmluZyhcIk5vIGNsaWVudCBpbmZvIGluIHJlc3BvbnNlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVmYXVsdCB0byBcInN1YlwiIGNsYWltXG4gICAgICAgIHJldHVybiBpZFRva2VuQ2xhaW1zPy5zdWIgfHwgXCJcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgYW4gZW50aXR5OiBjaGVja3MgZm9yIGFsbCBleHBlY3RlZCBwYXJhbXNcbiAgICAgKiBAcGFyYW0gZW50aXR5XG4gICAgICovXG4gICAgc3RhdGljIGlzQWNjb3VudEVudGl0eShlbnRpdHk6IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImhvbWVBY2NvdW50SWRcIikgJiZcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImVudmlyb25tZW50XCIpICYmXG4gICAgICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJyZWFsbVwiKSAmJlxuICAgICAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwibG9jYWxBY2NvdW50SWRcIikgJiZcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInVzZXJuYW1lXCIpICYmXG4gICAgICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJhdXRob3JpdHlUeXBlXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIDIgYWNjb3VudEluZm8gb2JqZWN0cyByZXByZXNlbnQgdGhlIHNhbWUgYWNjb3VudFxuICAgICAqIEBwYXJhbSBhY2NvdW50QVxuICAgICAqIEBwYXJhbSBhY2NvdW50QlxuICAgICAqIEBwYXJhbSBjb21wYXJlQ2xhaW1zIC0gSWYgc2V0IHRvIHRydWUgaWRUb2tlbkNsYWltcyB3aWxsIGFsc28gYmUgY29tcGFyZWQgdG8gZGV0ZXJtaW5lIGFjY291bnQgZXF1YWxpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgYWNjb3VudEluZm9Jc0VxdWFsKFxuICAgICAgICBhY2NvdW50QTogQWNjb3VudEluZm8gfCBudWxsLFxuICAgICAgICBhY2NvdW50QjogQWNjb3VudEluZm8gfCBudWxsLFxuICAgICAgICBjb21wYXJlQ2xhaW1zPzogYm9vbGVhblxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIWFjY291bnRBIHx8ICFhY2NvdW50Qikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNsYWltc01hdGNoID0gdHJ1ZTsgLy8gZGVmYXVsdCB0byB0cnVlIHNvIGFzIHRvIG5vdCBmYWlsIGNvbXBhcmlzb24gYmVsb3cgaWYgY29tcGFyZUNsYWltczogZmFsc2VcbiAgICAgICAgaWYgKGNvbXBhcmVDbGFpbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRBQ2xhaW1zID0gKGFjY291bnRBLmlkVG9rZW5DbGFpbXMgfHxcbiAgICAgICAgICAgICAgICB7fSkgYXMgVG9rZW5DbGFpbXM7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50QkNsYWltcyA9IChhY2NvdW50Qi5pZFRva2VuQ2xhaW1zIHx8XG4gICAgICAgICAgICAgICAge30pIGFzIFRva2VuQ2xhaW1zO1xuXG4gICAgICAgICAgICAvLyBpc3N1ZWQgYXQgdGltZXN0YW1wIGFuZCBub25jZSBhcmUgZXhwZWN0ZWQgdG8gY2hhbmdlIGVhY2ggdGltZSBhIG5ldyBpZCB0b2tlbiBpcyBhY3F1aXJlZFxuICAgICAgICAgICAgY2xhaW1zTWF0Y2ggPVxuICAgICAgICAgICAgICAgIGFjY291bnRBQ2xhaW1zLmlhdCA9PT0gYWNjb3VudEJDbGFpbXMuaWF0ICYmXG4gICAgICAgICAgICAgICAgYWNjb3VudEFDbGFpbXMubm9uY2UgPT09IGFjY291bnRCQ2xhaW1zLm5vbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGFjY291bnRBLmhvbWVBY2NvdW50SWQgPT09IGFjY291bnRCLmhvbWVBY2NvdW50SWQgJiZcbiAgICAgICAgICAgIGFjY291bnRBLmxvY2FsQWNjb3VudElkID09PSBhY2NvdW50Qi5sb2NhbEFjY291bnRJZCAmJlxuICAgICAgICAgICAgYWNjb3VudEEudXNlcm5hbWUgPT09IGFjY291bnRCLnVzZXJuYW1lICYmXG4gICAgICAgICAgICBhY2NvdW50QS50ZW5hbnRJZCA9PT0gYWNjb3VudEIudGVuYW50SWQgJiZcbiAgICAgICAgICAgIGFjY291bnRBLmVudmlyb25tZW50ID09PSBhY2NvdW50Qi5lbnZpcm9ubWVudCAmJlxuICAgICAgICAgICAgYWNjb3VudEEubmF0aXZlQWNjb3VudElkID09PSBhY2NvdW50Qi5uYXRpdmVBY2NvdW50SWQgJiZcbiAgICAgICAgICAgIGNsYWltc01hdGNoXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRob3JpemVSZXNwb25zZSB9IGZyb20gXCIuLi9yZXNwb25zZS9BdXRob3JpemVSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBDbGllbnRBdXRoRXJyb3JDb2RlcyxcbiAgICBjcmVhdGVDbGllbnRBdXRoRXJyb3IsXG59IGZyb20gXCIuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IuanNcIjtcblxuLyoqXG4gKiBQYXJzZXMgaGFzaCBzdHJpbmcgZnJvbSBnaXZlbiBzdHJpbmcuIFJldHVybnMgZW1wdHkgc3RyaW5nIGlmIG5vIGhhc2ggc3ltYm9sIGlzIGZvdW5kLlxuICogQHBhcmFtIGhhc2hTdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ0hhc2hPclF1ZXJ5KHJlc3BvbnNlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChyZXNwb25zZVN0cmluZy5zdGFydHNXaXRoKFwiIy9cIikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlU3RyaW5nLnN1YnN0cmluZygyKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICByZXNwb25zZVN0cmluZy5zdGFydHNXaXRoKFwiI1wiKSB8fFxuICAgICAgICByZXNwb25zZVN0cmluZy5zdGFydHNXaXRoKFwiP1wiKVxuICAgICkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VTdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFVSTCBoYXNoIGFzIHNlcnZlciBhdXRoIGNvZGUgcmVzcG9uc2Ugb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVzZXJpYWxpemVkUmVzcG9uc2UoXG4gICAgcmVzcG9uc2VTdHJpbmc6IHN0cmluZ1xuKTogQXV0aG9yaXplUmVzcG9uc2UgfCBudWxsIHtcbiAgICAvLyBDaGVjayBpZiBnaXZlbiBoYXNoIGlzIGVtcHR5XG4gICAgaWYgKCFyZXNwb25zZVN0cmluZyB8fCByZXNwb25zZVN0cmluZy5pbmRleE9mKFwiPVwiKSA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIFN0cmlwIHRoZSAjIG9yID8gc3ltYm9sIGlmIHByZXNlbnRcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlc3BvbnNlID0gc3RyaXBMZWFkaW5nSGFzaE9yUXVlcnkocmVzcG9uc2VTdHJpbmcpO1xuICAgICAgICAvLyBJZiAjIHN5bWJvbCB3YXMgbm90IHByZXNlbnQsIGFib3ZlIHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZywgc28gZ2l2ZSBvcmlnaW5hbCBoYXNoIHZhbHVlXG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEhhc2g6IEF1dGhvcml6ZVJlc3BvbnNlID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhub3JtYWxpemVkUmVzcG9uc2UpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGtub3duIHJlc3BvbnNlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGVzZXJpYWxpemVkSGFzaC5jb2RlIHx8XG4gICAgICAgICAgICBkZXNlcmlhbGl6ZWRIYXNoLmVhcl9qd2UgfHxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplZEhhc2guZXJyb3IgfHxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplZEhhc2guZXJyb3JfZGVzY3JpcHRpb24gfHxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplZEhhc2guc3RhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVkSGFzaDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLmhhc2hOb3REZXNlcmlhbGl6ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdG8gY3JlYXRlIGEgVVJMIGZyb20gdGhlIHBhcmFtcyBtYXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvUXVlcnlTdHJpbmcocGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPik6IHN0cmluZyB7XG4gICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJBcnJheTogQXJyYXk8c3RyaW5nPiA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICBwYXJhbWV0ZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcXVlcnlQYXJhbWV0ZXJBcnJheS5wdXNoKGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHF1ZXJ5UGFyYW1ldGVyQXJyYXkuam9pbihcIiZcIik7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLFxuICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmpzXCI7XG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlscy5qc1wiO1xuaW1wb3J0IHsgSVVyaSB9IGZyb20gXCIuL0lVcmkuanNcIjtcbmltcG9ydCB7IEFBREF1dGhvcml0eUNvbnN0YW50cywgQ29uc3RhbnRzIH0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0ICogYXMgVXJsVXRpbHMgZnJvbSBcIi4uL3V0aWxzL1VybFV0aWxzLmpzXCI7XG5cbi8qKlxuICogVXJsIG9iamVjdCBjbGFzcyB3aGljaCBjYW4gcGVyZm9ybSB2YXJpb3VzIHRyYW5zZm9ybWF0aW9ucyBvbiB1cmwgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVybFN0cmluZyB7XG4gICAgLy8gaW50ZXJuYWwgdXJsIHN0cmluZyBmaWVsZFxuICAgIHByaXZhdGUgX3VybFN0cmluZzogc3RyaW5nO1xuICAgIHB1YmxpYyBnZXQgdXJsU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmxTdHJpbmc7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdXJsU3RyaW5nID0gdXJsO1xuICAgICAgICBpZiAoIXRoaXMuX3VybFN0cmluZykge1xuICAgICAgICAgICAgLy8gVGhyb3dzIGVycm9yIGlmIHVybCBpcyBlbXB0eVxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybEVtcHR5RXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybC5pbmNsdWRlcyhcIiNcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3VybFN0cmluZyA9IFVybFN0cmluZy5jYW5vbmljYWxpemVVcmkodXJsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB1cmxzIGFyZSBsb3dlciBjYXNlIGFuZCBlbmQgd2l0aCBhIC8gY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBzdGF0aWMgY2Fub25pY2FsaXplVXJpKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgbGV0IGxvd2VyQ2FzZVVybCA9IHVybC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoU3RyaW5nVXRpbHMuZW5kc1dpdGgobG93ZXJDYXNlVXJsLCBcIj9cIikpIHtcbiAgICAgICAgICAgICAgICBsb3dlckNhc2VVcmwgPSBsb3dlckNhc2VVcmwuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChTdHJpbmdVdGlscy5lbmRzV2l0aChsb3dlckNhc2VVcmwsIFwiPy9cIikpIHtcbiAgICAgICAgICAgICAgICBsb3dlckNhc2VVcmwgPSBsb3dlckNhc2VVcmwuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmVuZHNXaXRoKGxvd2VyQ2FzZVVybCwgXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgbG93ZXJDYXNlVXJsICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbG93ZXJDYXNlVXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaHJvd3MgaWYgdXJsU3RyaW5nIHBhc3NlZCBpcyBub3QgYSB2YWxpZCBhdXRob3JpdHkgVVJJIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUFzVXJpKCk6IHZvaWQge1xuICAgICAgICAvLyBBdHRlbXB0cyB0byBwYXJzZSB1cmwgZm9yIHVyaSBjb21wb25lbnRzXG4gICAgICAgIGxldCBjb21wb25lbnRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IHRoaXMuZ2V0VXJsQ29tcG9uZW50cygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudXJsUGFyc2VFcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRocm93IGVycm9yIGlmIFVSSSBvciBwYXRoIHNlZ21lbnRzIGFyZSBub3QgcGFyc2VhYmxlLlxuICAgICAgICBpZiAoIWNvbXBvbmVudHMuSG9zdE5hbWVBbmRQb3J0IHx8ICFjb21wb25lbnRzLlBhdGhTZWdtZW50cykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybFBhcnNlRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaHJvdyBlcnJvciBpZiB1cmkgaXMgaW5zZWN1cmUuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFjb21wb25lbnRzLlByb3RvY29sIHx8XG4gICAgICAgICAgICBjb21wb25lbnRzLlByb3RvY29sLnRvTG93ZXJDYXNlKCkgIT09IFwiaHR0cHM6XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuYXV0aG9yaXR5VXJpSW5zZWN1cmVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHVybCBhbmQgYSBxdWVyeSBzdHJpbmcgcmV0dXJuIHRoZSB1cmwgd2l0aCBwcm92aWRlZCBxdWVyeSBzdHJpbmcgYXBwZW5kZWRcbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICogQHBhcmFtIHF1ZXJ5U3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGFwcGVuZFF1ZXJ5U3RyaW5nKHVybDogc3RyaW5nLCBxdWVyeVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmwuaW5kZXhPZihcIj9cIikgPCAwXG4gICAgICAgICAgICA/IGAke3VybH0/JHtxdWVyeVN0cmluZ31gXG4gICAgICAgICAgICA6IGAke3VybH0mJHtxdWVyeVN0cmluZ31gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1cmwgd2l0aCB0aGUgaGFzaCByZW1vdmVkXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVIYXNoRnJvbVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBVcmxTdHJpbmcuY2Fub25pY2FsaXplVXJpKHVybC5zcGxpdChcIiNcIilbMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdXJsIGxpa2UgaHR0cHM6Ly9hOmIvY29tbW9uL2Q/ZT1mI2csIGFuZCBhIHRlbmFudElkLCByZXR1cm5zIGh0dHBzOi8vYTpiL3RlbmFudElkL2RcbiAgICAgKiBAcGFyYW0gaHJlZiBUaGUgdXJsXG4gICAgICogQHBhcmFtIHRlbmFudElkIFRoZSB0ZW5hbnQgaWQgdG8gcmVwbGFjZVxuICAgICAqL1xuICAgIHJlcGxhY2VUZW5hbnRQYXRoKHRlbmFudElkOiBzdHJpbmcpOiBVcmxTdHJpbmcge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSB0aGlzLmdldFVybENvbXBvbmVudHMoKTtcbiAgICAgICAgY29uc3QgcGF0aEFycmF5ID0gdXJsT2JqZWN0LlBhdGhTZWdtZW50cztcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGVuYW50SWQgJiZcbiAgICAgICAgICAgIHBhdGhBcnJheS5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgIChwYXRoQXJyYXlbMF0gPT09IEFBREF1dGhvcml0eUNvbnN0YW50cy5DT01NT04gfHxcbiAgICAgICAgICAgICAgICBwYXRoQXJyYXlbMF0gPT09IEFBREF1dGhvcml0eUNvbnN0YW50cy5PUkdBTklaQVRJT05TKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHBhdGhBcnJheVswXSA9IHRlbmFudElkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVcmxTdHJpbmcuY29uc3RydWN0QXV0aG9yaXR5VXJpRnJvbU9iamVjdCh1cmxPYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBvdXQgdGhlIGNvbXBvbmVudHMgZnJvbSBhIHVybCBzdHJpbmcuXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHZhcmlvdXMgY29tcG9uZW50cy4gUGxlYXNlIGNhY2hlIHRoaXMgdmFsdWUgaW5zdGVkIG9mIGNhbGxpbmcgdGhpcyBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSB1cmwuXG4gICAgICovXG4gICAgZ2V0VXJsQ29tcG9uZW50cygpOiBJVXJpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vY3VydGlzei8xMTEzOWIyY2ZjYWVmNGEyNjFlMFxuICAgICAgICBjb25zdCByZWdFeCA9IFJlZ0V4cChcbiAgICAgICAgICAgIFwiXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXFxcPyhbXiNdKikpPygjKC4qKSk/XCJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB1cmwgc3RyaW5nIGRvZXMgbm90IG1hdGNoIHJlZ0V4LCB3ZSB0aHJvdyBhbiBlcnJvclxuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMudXJsU3RyaW5nLm1hdGNoKHJlZ0V4KTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybFBhcnNlRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcmwgY29tcG9uZW50IG9iamVjdFxuICAgICAgICBjb25zdCB1cmxDb21wb25lbnRzID0ge1xuICAgICAgICAgICAgUHJvdG9jb2w6IG1hdGNoWzFdLFxuICAgICAgICAgICAgSG9zdE5hbWVBbmRQb3J0OiBtYXRjaFs0XSxcbiAgICAgICAgICAgIEFic29sdXRlUGF0aDogbWF0Y2hbNV0sXG4gICAgICAgICAgICBRdWVyeVN0cmluZzogbWF0Y2hbN10sXG4gICAgICAgIH0gYXMgSVVyaTtcblxuICAgICAgICBsZXQgcGF0aFNlZ21lbnRzID0gdXJsQ29tcG9uZW50cy5BYnNvbHV0ZVBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgICBwYXRoU2VnbWVudHMgPSBwYXRoU2VnbWVudHMuZmlsdGVyKCh2YWwpID0+IHZhbCAmJiB2YWwubGVuZ3RoID4gMCk7IC8vIHJlbW92ZSBlbXB0eSBlbGVtZW50c1xuICAgICAgICB1cmxDb21wb25lbnRzLlBhdGhTZWdtZW50cyA9IHBhdGhTZWdtZW50cztcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB1cmxDb21wb25lbnRzLlF1ZXJ5U3RyaW5nICYmXG4gICAgICAgICAgICB1cmxDb21wb25lbnRzLlF1ZXJ5U3RyaW5nLmVuZHNXaXRoKFwiL1wiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHVybENvbXBvbmVudHMuUXVlcnlTdHJpbmcgPSB1cmxDb21wb25lbnRzLlF1ZXJ5U3RyaW5nLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHVybENvbXBvbmVudHMuUXVlcnlTdHJpbmcubGVuZ3RoIC0gMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsQ29tcG9uZW50cztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0RG9tYWluRnJvbVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJlZ0V4ID0gUmVnRXhwKFwiXihbXjovPyNdKzovLyk/KFteLz8jXSopXCIpO1xuXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlZ0V4KTtcblxuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudXJsUGFyc2VFcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaFsyXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QWJzb2x1dGVVcmwocmVsYXRpdmVVcmw6IHN0cmluZywgYmFzZVVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlVXJsWzBdID09PSBDb25zdGFudHMuRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVybFN0cmluZyhiYXNlVXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VDb21wb25lbnRzID0gdXJsLmdldFVybENvbXBvbmVudHMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBiYXNlQ29tcG9uZW50cy5Qcm90b2NvbCArXG4gICAgICAgICAgICAgICAgXCIvL1wiICtcbiAgICAgICAgICAgICAgICBiYXNlQ29tcG9uZW50cy5Ib3N0TmFtZUFuZFBvcnQgK1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlVXJsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlVXJsO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb25zdHJ1Y3RBdXRob3JpdHlVcmlGcm9tT2JqZWN0KHVybE9iamVjdDogSVVyaSk6IFVybFN0cmluZyB7XG4gICAgICAgIHJldHVybiBuZXcgVXJsU3RyaW5nKFxuICAgICAgICAgICAgdXJsT2JqZWN0LlByb3RvY29sICtcbiAgICAgICAgICAgICAgICBcIi8vXCIgK1xuICAgICAgICAgICAgICAgIHVybE9iamVjdC5Ib3N0TmFtZUFuZFBvcnQgK1xuICAgICAgICAgICAgICAgIFwiL1wiICtcbiAgICAgICAgICAgICAgICB1cmxPYmplY3QuUGF0aFNlZ21lbnRzLmpvaW4oXCIvXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGhhc2ggb2YgdGhlIFVSTCBzdHJpbmcgY29udGFpbnMga25vd24gcHJvcGVydGllc1xuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgQVBJIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hDb250YWluc0tub3duUHJvcGVydGllcyhyZXNwb25zZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIVVybFV0aWxzLmdldERlc2VyaWFsaXplZFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBVcmxTdHJpbmcgfSBmcm9tIFwiLi4vdXJsL1VybFN0cmluZy5qc1wiO1xuaW1wb3J0IHsgQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBTdGF0aWNBdXRob3JpdHlPcHRpb25zIH0gZnJvbSBcIi4vQXV0aG9yaXR5T3B0aW9ucy5qc1wiO1xuaW1wb3J0IHsgQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSB9IGZyb20gXCIuL0Nsb3VkRGlzY292ZXJ5TWV0YWRhdGEuanNcIjtcbmltcG9ydCB7IENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZSB9IGZyb20gXCIuL0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgT3BlbklkQ29uZmlnUmVzcG9uc2UgfSBmcm9tIFwiLi9PcGVuSWRDb25maWdSZXNwb25zZS5qc1wiO1xuXG50eXBlIFJhd01ldGFkYXRhID0ge1xuICAgIGVuZHBvaW50TWV0YWRhdGE6IHsgW2tleTogc3RyaW5nXTogT3BlbklkQ29uZmlnUmVzcG9uc2UgfTtcbiAgICBpbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhOiBDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2U7XG59O1xuXG5leHBvcnQgY29uc3QgcmF3TWV0ZGF0YUpTT046IFJhd01ldGFkYXRhID0ge1xuICAgIGVuZHBvaW50TWV0YWRhdGE6IHtcbiAgICAgICAgXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tXCI6IHtcbiAgICAgICAgICAgIHRva2VuX2VuZHBvaW50OlxuICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL3t0ZW5hbnRpZH0vb2F1dGgyL3YyLjAvdG9rZW5cIixcbiAgICAgICAgICAgIGp3a3NfdXJpOlxuICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL3t0ZW5hbnRpZH0vZGlzY292ZXJ5L3YyLjAva2V5c1wiLFxuICAgICAgICAgICAgaXNzdWVyOiBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS97dGVuYW50aWR9L3YyLjBcIixcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6XG4gICAgICAgICAgICAgICAgXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20ve3RlbmFudGlkfS9vYXV0aDIvdjIuMC9hdXRob3JpemVcIixcbiAgICAgICAgICAgIGVuZF9zZXNzaW9uX2VuZHBvaW50OlxuICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL3t0ZW5hbnRpZH0vb2F1dGgyL3YyLjAvbG9nb3V0XCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwibG9naW4uY2hpbmFjbG91ZGFwaS5jblwiOiB7XG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludDpcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vbG9naW4uY2hpbmFjbG91ZGFwaS5jbi97dGVuYW50aWR9L29hdXRoMi92Mi4wL3Rva2VuXCIsXG4gICAgICAgICAgICBqd2tzX3VyaTpcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vbG9naW4uY2hpbmFjbG91ZGFwaS5jbi97dGVuYW50aWR9L2Rpc2NvdmVyeS92Mi4wL2tleXNcIixcbiAgICAgICAgICAgIGlzc3VlcjogXCJodHRwczovL2xvZ2luLnBhcnRuZXIubWljcm9zb2Z0b25saW5lLmNuL3t0ZW5hbnRpZH0vdjIuMFwiLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbl9lbmRwb2ludDpcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vbG9naW4uY2hpbmFjbG91ZGFwaS5jbi97dGVuYW50aWR9L29hdXRoMi92Mi4wL2F1dGhvcml6ZVwiLFxuICAgICAgICAgICAgZW5kX3Nlc3Npb25fZW5kcG9pbnQ6XG4gICAgICAgICAgICAgICAgXCJodHRwczovL2xvZ2luLmNoaW5hY2xvdWRhcGkuY24ve3RlbmFudGlkfS9vYXV0aDIvdjIuMC9sb2dvdXRcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUudXNcIjoge1xuICAgICAgICAgICAgdG9rZW5fZW5kcG9pbnQ6XG4gICAgICAgICAgICAgICAgXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS51cy97dGVuYW50aWR9L29hdXRoMi92Mi4wL3Rva2VuXCIsXG4gICAgICAgICAgICBqd2tzX3VyaTpcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLnVzL3t0ZW5hbnRpZH0vZGlzY292ZXJ5L3YyLjAva2V5c1wiLFxuICAgICAgICAgICAgaXNzdWVyOiBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLnVzL3t0ZW5hbnRpZH0vdjIuMFwiLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbl9lbmRwb2ludDpcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLnVzL3t0ZW5hbnRpZH0vb2F1dGgyL3YyLjAvYXV0aG9yaXplXCIsXG4gICAgICAgICAgICBlbmRfc2Vzc2lvbl9lbmRwb2ludDpcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLnVzL3t0ZW5hbnRpZH0vb2F1dGgyL3YyLjAvbG9nb3V0XCIsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBpbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhOiB7XG4gICAgICAgIHRlbmFudF9kaXNjb3ZlcnlfZW5kcG9pbnQ6XG4gICAgICAgICAgICBcImh0dHBzOi8ve2Nhbm9uaWNhbEF1dGhvcml0eX0vdjIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvblwiLFxuICAgICAgICBtZXRhZGF0YTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9uZXR3b3JrOiBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb21cIixcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfY2FjaGU6IFwibG9naW4ud2luZG93cy5uZXRcIixcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4ubWljcm9zb2Z0b25saW5lLmNvbVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxvZ2luLndpbmRvd3MubmV0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4ubWljcm9zb2Z0LmNvbVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cy53aW5kb3dzLm5ldFwiLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9uZXR3b3JrOiBcImxvZ2luLnBhcnRuZXIubWljcm9zb2Z0b25saW5lLmNuXCIsXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkX2NhY2hlOiBcImxvZ2luLnBhcnRuZXIubWljcm9zb2Z0b25saW5lLmNuXCIsXG4gICAgICAgICAgICAgICAgYWxpYXNlczogW1xuICAgICAgICAgICAgICAgICAgICBcImxvZ2luLnBhcnRuZXIubWljcm9zb2Z0b25saW5lLmNuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4uY2hpbmFjbG91ZGFwaS5jblwiLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9uZXR3b3JrOiBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5kZVwiLFxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUuZGVcIixcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUuZGVcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9uZXR3b3JrOiBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS51c1wiLFxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUudXNcIixcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4ubWljcm9zb2Z0b25saW5lLnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4udXNnb3ZjbG91ZGFwaS5uZXRcIixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfbmV0d29yazogXCJsb2dpbi11cy5taWNyb3NvZnRvbmxpbmUuY29tXCIsXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkX2NhY2hlOiBcImxvZ2luLXVzLm1pY3Jvc29mdG9ubGluZS5jb21cIixcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXCJsb2dpbi11cy5taWNyb3NvZnRvbmxpbmUuY29tXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEVuZHBvaW50TWV0YWRhdGEgPSByYXdNZXRkYXRhSlNPTi5lbmRwb2ludE1ldGFkYXRhO1xuZXhwb3J0IGNvbnN0IEluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGEgPVxuICAgIHJhd01ldGRhdGFKU09OLmluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGE7XG5cbmV4cG9ydCBjb25zdCBJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhQWxpYXNlczogU2V0PFN0cmluZz4gPSBuZXcgU2V0KCk7XG5JbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhLm1ldGFkYXRhLmZvckVhY2goXG4gICAgKG1ldGFkYXRhRW50cnk6IENsb3VkRGlzY292ZXJ5TWV0YWRhdGEpID0+IHtcbiAgICAgICAgbWV0YWRhdGFFbnRyeS5hbGlhc2VzLmZvckVhY2goKGFsaWFzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIEluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGFBbGlhc2VzLmFkZChhbGlhcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbik7XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IGFuIGFsaWFzZXMgYXJyYXkgZnJvbSB0aGUgc3RhdGljIGF1dGhvcml0eSBtZXRhZGF0YSBzb3VyY2VzIGJhc2VkIG9uIHRoZSBjYW5vbmljYWwgYXV0aG9yaXR5IGhvc3RcbiAqIEBwYXJhbSBzdGF0aWNBdXRob3JpdHlPcHRpb25zXG4gKiBAcGFyYW0gbG9nZ2VyXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxpYXNlc0Zyb21TdGF0aWNTb3VyY2VzKFxuICAgIHN0YXRpY0F1dGhvcml0eU9wdGlvbnM6IFN0YXRpY0F1dGhvcml0eU9wdGlvbnMsXG4gICAgbG9nZ2VyPzogTG9nZ2VyXG4pOiBzdHJpbmdbXSB7XG4gICAgbGV0IHN0YXRpY0FsaWFzZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNhbm9uaWNhbEF1dGhvcml0eSA9IHN0YXRpY0F1dGhvcml0eU9wdGlvbnMuY2Fub25pY2FsQXV0aG9yaXR5O1xuICAgIGlmIChjYW5vbmljYWxBdXRob3JpdHkpIHtcbiAgICAgICAgY29uc3QgYXV0aG9yaXR5SG9zdCA9IG5ldyBVcmxTdHJpbmcoXG4gICAgICAgICAgICBjYW5vbmljYWxBdXRob3JpdHlcbiAgICAgICAgKS5nZXRVcmxDb21wb25lbnRzKCkuSG9zdE5hbWVBbmRQb3J0O1xuICAgICAgICBzdGF0aWNBbGlhc2VzID1cbiAgICAgICAgICAgIGdldEFsaWFzZXNGcm9tTWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5SG9zdCxcbiAgICAgICAgICAgICAgICBzdGF0aWNBdXRob3JpdHlPcHRpb25zLmNsb3VkRGlzY292ZXJ5TWV0YWRhdGE/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkNPTkZJRyxcbiAgICAgICAgICAgICAgICBsb2dnZXJcbiAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgIGdldEFsaWFzZXNGcm9tTWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5SG9zdCxcbiAgICAgICAgICAgICAgICBJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkhBUkRDT0RFRF9WQUxVRVMsXG4gICAgICAgICAgICAgICAgbG9nZ2VyXG4gICAgICAgICAgICApIHx8XG4gICAgICAgICAgICBzdGF0aWNBdXRob3JpdHlPcHRpb25zLmtub3duQXV0aG9yaXRpZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRpY0FsaWFzZXMgfHwgW107XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGlhc2VzIGZvciBmcm9tIHRoZSByYXcgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIHBhc3NlZCBpblxuICogQHBhcmFtIGF1dGhvcml0eUhvc3RcbiAqIEBwYXJhbSByYXdDbG91ZERpc2NvdmVyeU1ldGFkYXRhXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxpYXNlc0Zyb21NZXRhZGF0YShcbiAgICBhdXRob3JpdHlIb3N0Pzogc3RyaW5nLFxuICAgIGNsb3VkRGlzY292ZXJ5TWV0YWRhdGE/OiBDbG91ZERpc2NvdmVyeU1ldGFkYXRhW10sXG4gICAgc291cmNlPzogQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UsXG4gICAgbG9nZ2VyPzogTG9nZ2VyXG4pOiBzdHJpbmdbXSB8IG51bGwge1xuICAgIGxvZ2dlcj8udHJhY2UoYGdldEFsaWFzZXNGcm9tTWV0YWRhdGEgY2FsbGVkIHdpdGggc291cmNlOiAke3NvdXJjZX1gKTtcbiAgICBpZiAoYXV0aG9yaXR5SG9zdCAmJiBjbG91ZERpc2NvdmVyeU1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrUmVzcG9uc2UoXG4gICAgICAgICAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhLFxuICAgICAgICAgICAgYXV0aG9yaXR5SG9zdFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgbG9nZ2VyPy50cmFjZShcbiAgICAgICAgICAgICAgICBgZ2V0QWxpYXNlc0Zyb21NZXRhZGF0YTogZm91bmQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGluICR7c291cmNlfSwgcmV0dXJuaW5nIGFsaWFzZXNgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmFsaWFzZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXI/LnRyYWNlKFxuICAgICAgICAgICAgICAgIGBnZXRBbGlhc2VzRnJvbU1ldGFkYXRhOiBkaWQgbm90IGZpbmQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGluICR7c291cmNlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGZvciBjb21tb24gYXV0aG9yaXRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tSGFyZGNvZGVkVmFsdWVzKFxuICAgIGF1dGhvcml0eUhvc3Q6IHN0cmluZ1xuKTogQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSB8IG51bGwge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrUmVzcG9uc2UoXG4gICAgICAgIEluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGEubWV0YWRhdGEsXG4gICAgICAgIGF1dGhvcml0eUhvc3RcbiAgICApO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBpbnN0YW5jZSBkaXNjb3ZlcnkgbmV0d29yayByZXNwb25zZSBmb3IgdGhlIGVudHJ5IHRoYXQgY29udGFpbnMgdGhlIGhvc3QgaW4gdGhlIGFsaWFzZXMgbGlzdFxuICogQHBhcmFtIHJlc3BvbnNlXG4gKiBAcGFyYW0gYXV0aG9yaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcmtSZXNwb25zZShcbiAgICByZXNwb25zZTogQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YVtdLFxuICAgIGF1dGhvcml0eUhvc3Q6IHN0cmluZ1xuKTogQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSB8IG51bGwge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXNwb25zZVtpXTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmFsaWFzZXMuaW5jbHVkZXMoYXV0aG9yaXR5SG9zdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY2FjaGVRdW90YUV4Y2VlZGVkRXJyb3JDb2RlID0gXCJjYWNoZV9xdW90YV9leGNlZWRlZFwiO1xuZXhwb3J0IGNvbnN0IGNhY2hlVW5rbm93bkVycm9yQ29kZSA9IFwiY2FjaGVfZXJyb3JfdW5rbm93blwiO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBDYWNoZUVycm9yQ29kZXMgZnJvbSBcIi4vQ2FjaGVFcnJvckNvZGVzLmpzXCI7XG5leHBvcnQgeyBDYWNoZUVycm9yQ29kZXMgfTtcblxuZXhwb3J0IGNvbnN0IENhY2hlRXJyb3JNZXNzYWdlcyA9IHtcbiAgICBbQ2FjaGVFcnJvckNvZGVzLmNhY2hlUXVvdGFFeGNlZWRlZEVycm9yQ29kZV06XG4gICAgICAgIFwiRXhjZWVkZWQgY2FjaGUgc3RvcmFnZSBjYXBhY2l0eS5cIixcbiAgICBbQ2FjaGVFcnJvckNvZGVzLmNhY2hlVW5rbm93bkVycm9yQ29kZV06XG4gICAgICAgIFwiVW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCB3aGVuIHVzaW5nIGNhY2hlIHN0b3JhZ2UuXCIsXG59O1xuXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIHdpdGggdGhlIGNhY2hlXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWNoZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIFNob3J0IHN0cmluZyBkZW5vdGluZyBlcnJvclxuICAgICAqL1xuICAgIGVycm9yQ29kZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgZXJyb3JcbiAgICAgKi9cbiAgICBlcnJvck1lc3NhZ2U6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZTogc3RyaW5nLCBlcnJvck1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgfHxcbiAgICAgICAgICAgIChDYWNoZUVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXVxuICAgICAgICAgICAgICAgID8gQ2FjaGVFcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV1cbiAgICAgICAgICAgICAgICA6IENhY2hlRXJyb3JNZXNzYWdlc1tDYWNoZUVycm9yQ29kZXMuY2FjaGVVbmtub3duRXJyb3JDb2RlXSk7XG5cbiAgICAgICAgc3VwZXIoYCR7ZXJyb3JDb2RlfTogJHttZXNzYWdlfWApO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2FjaGVFcnJvci5wcm90b3R5cGUpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IFwiQ2FjaGVFcnJvclwiO1xuICAgICAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBBY2NvdW50RmlsdGVyLFxuICAgIENyZWRlbnRpYWxGaWx0ZXIsXG4gICAgVmFsaWRDcmVkZW50aWFsVHlwZSxcbiAgICBBcHBNZXRhZGF0YUZpbHRlcixcbiAgICBBcHBNZXRhZGF0YUNhY2hlLFxuICAgIFRva2VuS2V5cyxcbiAgICBUZW5hbnRQcm9maWxlRmlsdGVyLFxufSBmcm9tIFwiLi91dGlscy9DYWNoZVR5cGVzLmpzXCI7XG5pbXBvcnQgeyBDYWNoZVJlY29yZCB9IGZyb20gXCIuL2VudGl0aWVzL0NhY2hlUmVjb3JkLmpzXCI7XG5pbXBvcnQge1xuICAgIENyZWRlbnRpYWxUeXBlLFxuICAgIEFQUF9NRVRBREFUQSxcbiAgICBUSEVfRkFNSUxZX0lELFxuICAgIEFVVEhPUklUWV9NRVRBREFUQV9DT05TVEFOVFMsXG4gICAgQXV0aGVudGljYXRpb25TY2hlbWUsXG4gICAgU2VwYXJhdG9ycyxcbn0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgQ3JlZGVudGlhbEVudGl0eSB9IGZyb20gXCIuL2VudGl0aWVzL0NyZWRlbnRpYWxFbnRpdHkuanNcIjtcbmltcG9ydCB7IGdlbmVyYXRlQ3JlZGVudGlhbEtleSB9IGZyb20gXCIuL3V0aWxzL0NhY2hlSGVscGVycy5qc1wiO1xuaW1wb3J0IHsgU2NvcGVTZXQgfSBmcm9tIFwiLi4vcmVxdWVzdC9TY29wZVNldC5qc1wiO1xuaW1wb3J0IHsgQWNjb3VudEVudGl0eSB9IGZyb20gXCIuL2VudGl0aWVzL0FjY291bnRFbnRpdHkuanNcIjtcbmltcG9ydCB7IEFjY2Vzc1Rva2VuRW50aXR5IH0gZnJvbSBcIi4vZW50aXRpZXMvQWNjZXNzVG9rZW5FbnRpdHkuanNcIjtcbmltcG9ydCB7IElkVG9rZW5FbnRpdHkgfSBmcm9tIFwiLi9lbnRpdGllcy9JZFRva2VuRW50aXR5LmpzXCI7XG5pbXBvcnQgeyBSZWZyZXNoVG9rZW5FbnRpdHkgfSBmcm9tIFwiLi9lbnRpdGllcy9SZWZyZXNoVG9rZW5FbnRpdHkuanNcIjtcbmltcG9ydCB7IElDYWNoZU1hbmFnZXIgfSBmcm9tIFwiLi9pbnRlcmZhY2UvSUNhY2hlTWFuYWdlci5qc1wiO1xuaW1wb3J0IHtcbiAgICBjcmVhdGVDbGllbnRBdXRoRXJyb3IsXG4gICAgQ2xpZW50QXV0aEVycm9yQ29kZXMsXG59IGZyb20gXCIuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IuanNcIjtcbmltcG9ydCB7XG4gICAgQWNjb3VudEluZm8sXG4gICAgVGVuYW50UHJvZmlsZSxcbiAgICB1cGRhdGVBY2NvdW50VGVuYW50UHJvZmlsZURhdGEsXG59IGZyb20gXCIuLi9hY2NvdW50L0FjY291bnRJbmZvLmpzXCI7XG5pbXBvcnQgeyBBcHBNZXRhZGF0YUVudGl0eSB9IGZyb20gXCIuL2VudGl0aWVzL0FwcE1ldGFkYXRhRW50aXR5LmpzXCI7XG5pbXBvcnQgeyBTZXJ2ZXJUZWxlbWV0cnlFbnRpdHkgfSBmcm9tIFwiLi9lbnRpdGllcy9TZXJ2ZXJUZWxlbWV0cnlFbnRpdHkuanNcIjtcbmltcG9ydCB7IFRocm90dGxpbmdFbnRpdHkgfSBmcm9tIFwiLi9lbnRpdGllcy9UaHJvdHRsaW5nRW50aXR5LmpzXCI7XG5pbXBvcnQgeyBleHRyYWN0VG9rZW5DbGFpbXMgfSBmcm9tIFwiLi4vYWNjb3VudC9BdXRoVG9rZW4uanNcIjtcbmltcG9ydCB7IElDcnlwdG8gfSBmcm9tIFwiLi4vY3J5cHRvL0lDcnlwdG8uanNcIjtcbmltcG9ydCB7IEF1dGhvcml0eU1ldGFkYXRhRW50aXR5IH0gZnJvbSBcIi4vZW50aXRpZXMvQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkuanNcIjtcbmltcG9ydCB7IEJhc2VBdXRoUmVxdWVzdCB9IGZyb20gXCIuLi9yZXF1ZXN0L0Jhc2VBdXRoUmVxdWVzdC5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXIuanNcIjtcbmltcG9ydCB7IG5hbWUsIHZlcnNpb24gfSBmcm9tIFwiLi4vcGFja2FnZU1ldGFkYXRhLmpzXCI7XG5pbXBvcnQgeyBTdG9yZUluQ2FjaGUgfSBmcm9tIFwiLi4vcmVxdWVzdC9TdG9yZUluQ2FjaGUuanNcIjtcbmltcG9ydCB7IGdldEFsaWFzZXNGcm9tU3RhdGljU291cmNlcyB9IGZyb20gXCIuLi9hdXRob3JpdHkvQXV0aG9yaXR5TWV0YWRhdGEuanNcIjtcbmltcG9ydCB7IFN0YXRpY0F1dGhvcml0eU9wdGlvbnMgfSBmcm9tIFwiLi4vYXV0aG9yaXR5L0F1dGhvcml0eU9wdGlvbnMuanNcIjtcbmltcG9ydCB7IFRva2VuQ2xhaW1zIH0gZnJvbSBcIi4uL2FjY291bnQvVG9rZW5DbGFpbXMuanNcIjtcbmltcG9ydCB7IElQZXJmb3JtYW5jZUNsaWVudCB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvSVBlcmZvcm1hbmNlQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBDYWNoZUVycm9yLCBDYWNoZUVycm9yQ29kZXMgfSBmcm9tIFwiLi4vZXJyb3IvQ2FjaGVFcnJvci5qc1wiO1xuXG4vKipcbiAqIEludGVyZmFjZSBjbGFzcyB3aGljaCBpbXBsZW1lbnQgY2FjaGUgc3RvcmFnZSBmdW5jdGlvbnMgdXNlZCBieSBNU0FMIHRvIHBlcmZvcm0gdmFsaWRpdHkgY2hlY2tzLCBhbmQgc3RvcmUgdG9rZW5zLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYWNoZU1hbmFnZXIgaW1wbGVtZW50cyBJQ2FjaGVNYW5hZ2VyIHtcbiAgICBwcm90ZWN0ZWQgY2xpZW50SWQ6IHN0cmluZztcbiAgICBwcm90ZWN0ZWQgY3J5cHRvSW1wbDogSUNyeXB0bztcbiAgICAvLyBJbnN0YW5jZSBvZiBsb2dnZXIgZm9yIGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoZSBtc2FsLWNvbW1vbiBsYXllclxuICAgIHByaXZhdGUgY29tbW9uTG9nZ2VyOiBMb2dnZXI7XG4gICAgcHJpdmF0ZSBzdGF0aWNBdXRob3JpdHlPcHRpb25zPzogU3RhdGljQXV0aG9yaXR5T3B0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgICAgICBjcnlwdG9JbXBsOiBJQ3J5cHRvLFxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICAgICAgc3RhdGljQXV0aG9yaXR5T3B0aW9ucz86IFN0YXRpY0F1dGhvcml0eU9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLmNyeXB0b0ltcGwgPSBjcnlwdG9JbXBsO1xuICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlciA9IGxvZ2dlci5jbG9uZShuYW1lLCB2ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5zdGF0aWNBdXRob3JpdHlPcHRpb25zID0gc3RhdGljQXV0aG9yaXR5T3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaCB0aGUgYWNjb3VudCBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiAgQHBhcmFtIGFjY291bnRLZXlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRBY2NvdW50KFxuICAgICAgICBhY2NvdW50S2V5OiBzdHJpbmcsXG4gICAgICAgIGxvZ2dlcj86IExvZ2dlclxuICAgICk6IEFjY291bnRFbnRpdHkgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGFjY291bnQgZW50aXR5IGluIHRoZSBwbGF0Zm9ybSBjYWNoZVxuICAgICAqIEBwYXJhbSBhY2NvdW50XG4gICAgICogQHBhcmFtIGNvcnJlbGF0aW9uSWRcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRBY2NvdW50KFxuICAgICAgICBhY2NvdW50OiBBY2NvdW50RW50aXR5LFxuICAgICAgICBjb3JyZWxhdGlvbklkOiBzdHJpbmdcbiAgICApOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogZmV0Y2ggdGhlIGlkVG9rZW4gZW50aXR5IGZyb20gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIGlkVG9rZW5LZXlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRJZFRva2VuQ3JlZGVudGlhbChpZFRva2VuS2V5OiBzdHJpbmcpOiBJZFRva2VuRW50aXR5IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHNldCBpZFRva2VuIGVudGl0eSB0byB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gaWRUb2tlblxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkXG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2V0SWRUb2tlbkNyZWRlbnRpYWwoXG4gICAgICAgIGlkVG9rZW46IElkVG9rZW5FbnRpdHksXG4gICAgICAgIGNvcnJlbGF0aW9uSWQ6IHN0cmluZ1xuICAgICk6IFByb21pc2U8dm9pZD47XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaCB0aGUgaWRUb2tlbiBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW5LZXlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoXG4gICAgICAgIGFjY2Vzc1Rva2VuS2V5OiBzdHJpbmdcbiAgICApOiBBY2Nlc3NUb2tlbkVudGl0eSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgYWNjZXNzVG9rZW4gZW50aXR5IHRvIHRoZSBwbGF0Zm9ybSBjYWNoZVxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlblxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkXG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2V0QWNjZXNzVG9rZW5DcmVkZW50aWFsKFxuICAgICAgICBhY2Nlc3NUb2tlbjogQWNjZXNzVG9rZW5FbnRpdHksXG4gICAgICAgIGNvcnJlbGF0aW9uSWQ6IHN0cmluZ1xuICAgICk6IFByb21pc2U8dm9pZD47XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaCB0aGUgaWRUb2tlbiBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuS2V5XG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbChcbiAgICAgICAgcmVmcmVzaFRva2VuS2V5OiBzdHJpbmdcbiAgICApOiBSZWZyZXNoVG9rZW5FbnRpdHkgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHJlZnJlc2hUb2tlbiBlbnRpdHkgdG8gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlblxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkXG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbChcbiAgICAgICAgcmVmcmVzaFRva2VuOiBSZWZyZXNoVG9rZW5FbnRpdHksXG4gICAgICAgIGNvcnJlbGF0aW9uSWQ6IHN0cmluZ1xuICAgICk6IFByb21pc2U8dm9pZD47XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaCBhcHBNZXRhZGF0YSBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gYXBwTWV0YWRhdGFLZXlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRBcHBNZXRhZGF0YShhcHBNZXRhZGF0YUtleTogc3RyaW5nKTogQXBwTWV0YWRhdGFFbnRpdHkgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGFwcE1ldGFkYXRhIGVudGl0eSB0byB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gYXBwTWV0YWRhdGFcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRBcHBNZXRhZGF0YShhcHBNZXRhZGF0YTogQXBwTWV0YWRhdGFFbnRpdHkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogZmV0Y2ggc2VydmVyIHRlbGVtZXRyeSBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gc2VydmVyVGVsZW1ldHJ5S2V5XG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0U2VydmVyVGVsZW1ldHJ5KFxuICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlLZXk6IHN0cmluZ1xuICAgICk6IFNlcnZlclRlbGVtZXRyeUVudGl0eSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgc2VydmVyIHRlbGVtZXRyeSBlbnRpdHkgdG8gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIHNlcnZlclRlbGVtZXRyeUtleVxuICAgICAqIEBwYXJhbSBzZXJ2ZXJUZWxlbWV0cnlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgIHNlcnZlclRlbGVtZXRyeUtleTogc3RyaW5nLFxuICAgICAgICBzZXJ2ZXJUZWxlbWV0cnk6IFNlcnZlclRlbGVtZXRyeUVudGl0eVxuICAgICk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgZW50aXR5IGZyb20gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldEF1dGhvcml0eU1ldGFkYXRhKGtleTogc3RyaW5nKTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRBdXRob3JpdHlNZXRhZGF0YUtleXMoKTogQXJyYXk8c3RyaW5nPjtcblxuICAgIC8qKlxuICAgICAqIHNldCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgZW50aXR5IHRvIHRoZSBwbGF0Zm9ybSBjYWNoZVxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRBdXRob3JpdHlNZXRhZGF0YShcbiAgICAgICAga2V5OiBzdHJpbmcsXG4gICAgICAgIHZhbHVlOiBBdXRob3JpdHlNZXRhZGF0YUVudGl0eVxuICAgICk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaCB0aHJvdHRsaW5nIGVudGl0eSBmcm9tIHRoZSBwbGF0Zm9ybSBjYWNoZVxuICAgICAqIEBwYXJhbSB0aHJvdHRsaW5nQ2FjaGVLZXlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRUaHJvdHRsaW5nQ2FjaGUoXG4gICAgICAgIHRocm90dGxpbmdDYWNoZUtleTogc3RyaW5nXG4gICAgKTogVGhyb3R0bGluZ0VudGl0eSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhyb3R0bGluZyBlbnRpdHkgdG8gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIHRocm90dGxpbmdDYWNoZUtleVxuICAgICAqIEBwYXJhbSB0aHJvdHRsaW5nQ2FjaGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRUaHJvdHRsaW5nQ2FjaGUoXG4gICAgICAgIHRocm90dGxpbmdDYWNoZUtleTogc3RyaW5nLFxuICAgICAgICB0aHJvdHRsaW5nQ2FjaGU6IFRocm90dGxpbmdFbnRpdHlcbiAgICApOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gcmVtb3ZlIGFuIGl0ZW0gZnJvbSBjYWNoZSBnaXZlbiBpdHMga2V5LlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdoaWNoIHJldHJpZXZlcyBhbGwgY3VycmVudCBrZXlzIGZyb20gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldEtleXMoKTogc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCByZXRyaWV2ZXMgYWxsIGFjY291bnQga2V5cyBmcm9tIHRoZSBjYWNoZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldEFjY291bnRLZXlzKCk6IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2hpY2ggcmV0cmlldmVzIGFsbCB0b2tlbiBrZXlzIGZyb20gdGhlIGNhY2hlXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0VG9rZW5LZXlzKCk6IFRva2VuS2V5cztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSBhY2NvdW50cyBpbiB0aGUgY2FjaGUgdGhhdCBtYXRjaCB0aGUgb3B0aW9uYWwgZmlsdGVyLiBJZiBubyBmaWx0ZXIgaXMgcHJvdmlkZWQsIGFsbCBhY2NvdW50cyBhcmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIGFjY291bnRGaWx0ZXIgLSAoT3B0aW9uYWwpIGZpbHRlciB0byBuYXJyb3cgZG93biB0aGUgYWNjb3VudHMgcmV0dXJuZWRcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBBY2NvdW50SW5mbyBvYmplY3RzIGluIGNhY2hlXG4gICAgICovXG4gICAgZ2V0QWxsQWNjb3VudHMoYWNjb3VudEZpbHRlcj86IEFjY291bnRGaWx0ZXIpOiBBY2NvdW50SW5mb1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRUZW5hbnRQcm9maWxlcyhcbiAgICAgICAgICAgIHRoaXMuZ2V0QWNjb3VudHNGaWx0ZXJlZEJ5KGFjY291bnRGaWx0ZXIgfHwge30pLFxuICAgICAgICAgICAgYWNjb3VudEZpbHRlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgZmlyc3QgdGVuYW50ZWQgQWNjb3VudEluZm8gb2JqZWN0IGZvdW5kIGJhc2VkIG9uIHByb3ZpZGVkIGZpbHRlcnNcbiAgICAgKi9cbiAgICBnZXRBY2NvdW50SW5mb0ZpbHRlcmVkQnkoYWNjb3VudEZpbHRlcjogQWNjb3VudEZpbHRlcik6IEFjY291bnRJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGFsbEFjY291bnRzID0gdGhpcy5nZXRBbGxBY2NvdW50cyhhY2NvdW50RmlsdGVyKTtcbiAgICAgICAgaWYgKGFsbEFjY291bnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIElmIG9uZSBvciBtb3JlIGFjY291bnRzIGFyZSBmb3VuZCwgcHJpb3JpdGl6ZSBhY2NvdW50cyB0aGF0IGhhdmUgYW4gSUQgdG9rZW5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZEFjY291bnRzID0gYWxsQWNjb3VudHMuc29ydCgoYWNjb3VudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2NvdW50LmlkVG9rZW5DbGFpbXMgPyAtMSA6IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBY2NvdW50c1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxBY2NvdW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIGFjY291bnQgaXMgZm91bmQsIHJldHVybiBpdCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgYSBtYXRjaGluZyBJRCB0b2tlbiB3YXMgZm91bmRcbiAgICAgICAgICAgIHJldHVybiBhbGxBY2NvdW50c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBtYXRjaGluZ1xuICAgICAqIEBwYXJhbSBhY2NvdW50RmlsdGVyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRCYXNlQWNjb3VudEluZm8oYWNjb3VudEZpbHRlcjogQWNjb3VudEZpbHRlcik6IEFjY291bnRJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGFjY291bnRFbnRpdGllcyA9IHRoaXMuZ2V0QWNjb3VudHNGaWx0ZXJlZEJ5KGFjY291bnRGaWx0ZXIpO1xuICAgICAgICBpZiAoYWNjb3VudEVudGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50RW50aXRpZXNbMF0uZ2V0QWNjb3VudEluZm8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBmaWx0ZXJlZCBhY2NvdW50IGVudGl0aWVzIHdpdGggY2FjaGVkIElEIHRva2VucyB0aGF0IG1hdGNoIHRoZSB0ZW5hbnQgcHJvZmlsZS1zcGVjaWZpYyBhY2NvdW50IGZpbHRlcnNcbiAgICAgKiBhbmQgYnVpbGRzIHRoZSBhY2NvdW50IGluZm8gb2JqZWN0cyBmcm9tIHRoZSBtYXRjaGluZyBJRCB0b2tlbidzIGNsYWltc1xuICAgICAqIEBwYXJhbSBjYWNoZWRBY2NvdW50c1xuICAgICAqIEBwYXJhbSBhY2NvdW50RmlsdGVyXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgQWNjb3VudEluZm8gb2JqZWN0cyB0aGF0IG1hdGNoIGFjY291bnQgYW5kIHRlbmFudCBwcm9maWxlIGZpbHRlcnNcbiAgICAgKi9cbiAgICBwcml2YXRlIGJ1aWxkVGVuYW50UHJvZmlsZXMoXG4gICAgICAgIGNhY2hlZEFjY291bnRzOiBBY2NvdW50RW50aXR5W10sXG4gICAgICAgIGFjY291bnRGaWx0ZXI/OiBBY2NvdW50RmlsdGVyXG4gICAgKTogQWNjb3VudEluZm9bXSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRBY2NvdW50cy5mbGF0TWFwKChhY2NvdW50RW50aXR5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUZW5hbnRQcm9maWxlc0Zyb21BY2NvdW50RW50aXR5KFxuICAgICAgICAgICAgICAgIGFjY291bnRFbnRpdHksXG4gICAgICAgICAgICAgICAgYWNjb3VudEZpbHRlcj8udGVuYW50SWQsXG4gICAgICAgICAgICAgICAgYWNjb3VudEZpbHRlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUZW5hbnRlZEFjY291bnRJbmZvQnlGaWx0ZXIoXG4gICAgICAgIGFjY291bnRJbmZvOiBBY2NvdW50SW5mbyxcbiAgICAgICAgdG9rZW5LZXlzOiBUb2tlbktleXMsXG4gICAgICAgIHRlbmFudFByb2ZpbGU6IFRlbmFudFByb2ZpbGUsXG4gICAgICAgIHRlbmFudFByb2ZpbGVGaWx0ZXI/OiBUZW5hbnRQcm9maWxlRmlsdGVyXG4gICAgKTogQWNjb3VudEluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IHRlbmFudGVkQWNjb3VudEluZm86IEFjY291bnRJbmZvIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBpZFRva2VuQ2xhaW1zOiBUb2tlbkNsYWltcyB8IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodGVuYW50UHJvZmlsZUZpbHRlcikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLnRlbmFudFByb2ZpbGVNYXRjaGVzRmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICB0ZW5hbnRQcm9maWxlLFxuICAgICAgICAgICAgICAgICAgICB0ZW5hbnRQcm9maWxlRmlsdGVyXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZFRva2VuID0gdGhpcy5nZXRJZFRva2VuKFxuICAgICAgICAgICAgYWNjb3VudEluZm8sXG4gICAgICAgICAgICB0b2tlbktleXMsXG4gICAgICAgICAgICB0ZW5hbnRQcm9maWxlLnRlbmFudElkXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlkVG9rZW4pIHtcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMgPSBleHRyYWN0VG9rZW5DbGFpbXMoXG4gICAgICAgICAgICAgICAgaWRUb2tlbi5zZWNyZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5jcnlwdG9JbXBsLmJhc2U2NERlY29kZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLmlkVG9rZW5DbGFpbXNNYXRjaFRlbmFudFByb2ZpbGVGaWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMsXG4gICAgICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGVGaWx0ZXJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBJRCB0b2tlbiBzb3VyY2VkIGNsYWltcyBkb24ndCBtYXRjaCBzbyB0aGlzIHRlbmFudCBwcm9maWxlIGlzIG5vdCBhIG1hdGNoXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBhbmQgdGVuYW50IHByb2ZpbGUgaW50byBhY2NvdW50IGluZm8gYmFzZWQgb24gbWF0Y2hpbmcgdGVuYW50IHByb2ZpbGUgYW5kIGlmIGF2YWlsYWJsZSBtYXRjaGluZyBJRCB0b2tlbiBjbGFpbXNcbiAgICAgICAgdGVuYW50ZWRBY2NvdW50SW5mbyA9IHVwZGF0ZUFjY291bnRUZW5hbnRQcm9maWxlRGF0YShcbiAgICAgICAgICAgIGFjY291bnRJbmZvLFxuICAgICAgICAgICAgdGVuYW50UHJvZmlsZSxcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMsXG4gICAgICAgICAgICBpZFRva2VuPy5zZWNyZXRcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGVuYW50ZWRBY2NvdW50SW5mbztcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRlbmFudFByb2ZpbGVzRnJvbUFjY291bnRFbnRpdHkoXG4gICAgICAgIGFjY291bnRFbnRpdHk6IEFjY291bnRFbnRpdHksXG4gICAgICAgIHRhcmdldFRlbmFudElkPzogc3RyaW5nLFxuICAgICAgICB0ZW5hbnRQcm9maWxlRmlsdGVyPzogVGVuYW50UHJvZmlsZUZpbHRlclxuICAgICk6IEFjY291bnRJbmZvW10ge1xuICAgICAgICBjb25zdCBhY2NvdW50SW5mbyA9IGFjY291bnRFbnRpdHkuZ2V0QWNjb3VudEluZm8oKTtcbiAgICAgICAgbGV0IHNlYXJjaFRlbmFudFByb2ZpbGVzOiBNYXA8c3RyaW5nLCBUZW5hbnRQcm9maWxlPiA9XG4gICAgICAgICAgICBhY2NvdW50SW5mby50ZW5hbnRQcm9maWxlcyB8fCBuZXcgTWFwPHN0cmluZywgVGVuYW50UHJvZmlsZT4oKTtcbiAgICAgICAgY29uc3QgdG9rZW5LZXlzID0gdGhpcy5nZXRUb2tlbktleXMoKTtcblxuICAgICAgICAvLyBJZiBhIHRlbmFudCBJRCB3YXMgcHJvdmlkZWQsIG9ubHkgcmV0dXJuIHRoZSB0ZW5hbnQgcHJvZmlsZSBmb3IgdGhhdCB0ZW5hbnQgSUQgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0YXJnZXRUZW5hbnRJZCkge1xuICAgICAgICAgICAgY29uc3QgdGVuYW50UHJvZmlsZSA9IHNlYXJjaFRlbmFudFByb2ZpbGVzLmdldCh0YXJnZXRUZW5hbnRJZCk7XG4gICAgICAgICAgICBpZiAodGVuYW50UHJvZmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIFJlZHVjZSBzZWFyY2ggZmllbGQgdG8ganVzdCB0aGlzIHRlbmFudCBwcm9maWxlXG4gICAgICAgICAgICAgICAgc2VhcmNoVGVuYW50UHJvZmlsZXMgPSBuZXcgTWFwPHN0cmluZywgVGVuYW50UHJvZmlsZT4oW1xuICAgICAgICAgICAgICAgICAgICBbdGFyZ2V0VGVuYW50SWQsIHRlbmFudFByb2ZpbGVdLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyB0ZW5hbnQgcHJvZmlsZSBmb3Igc2VhcmNoIHRlbmFudCBJRCwgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF0Y2hpbmdUZW5hbnRQcm9maWxlczogQWNjb3VudEluZm9bXSA9IFtdO1xuICAgICAgICBzZWFyY2hUZW5hbnRQcm9maWxlcy5mb3JFYWNoKCh0ZW5hbnRQcm9maWxlOiBUZW5hbnRQcm9maWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRlZEFjY291bnRJbmZvID0gdGhpcy5nZXRUZW5hbnRlZEFjY291bnRJbmZvQnlGaWx0ZXIoXG4gICAgICAgICAgICAgICAgYWNjb3VudEluZm8sXG4gICAgICAgICAgICAgICAgdG9rZW5LZXlzLFxuICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGUsXG4gICAgICAgICAgICAgICAgdGVuYW50UHJvZmlsZUZpbHRlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0ZW5hbnRlZEFjY291bnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdUZW5hbnRQcm9maWxlcy5wdXNoKHRlbmFudGVkQWNjb3VudEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdUZW5hbnRQcm9maWxlcztcbiAgICB9XG5cbiAgICBwcml2YXRlIHRlbmFudFByb2ZpbGVNYXRjaGVzRmlsdGVyKFxuICAgICAgICB0ZW5hbnRQcm9maWxlOiBUZW5hbnRQcm9maWxlLFxuICAgICAgICB0ZW5hbnRQcm9maWxlRmlsdGVyOiBUZW5hbnRQcm9maWxlRmlsdGVyXG4gICAgKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEhdGVuYW50UHJvZmlsZUZpbHRlci5sb2NhbEFjY291bnRJZCAmJlxuICAgICAgICAgICAgIXRoaXMubWF0Y2hMb2NhbEFjY291bnRJZEZyb21UZW5hbnRQcm9maWxlKFxuICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGUsXG4gICAgICAgICAgICAgICAgdGVuYW50UHJvZmlsZUZpbHRlci5sb2NhbEFjY291bnRJZFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEhdGVuYW50UHJvZmlsZUZpbHRlci5uYW1lICYmXG4gICAgICAgICAgICAhKHRlbmFudFByb2ZpbGUubmFtZSA9PT0gdGVuYW50UHJvZmlsZUZpbHRlci5uYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRlbmFudFByb2ZpbGVGaWx0ZXIuaXNIb21lVGVuYW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICEodGVuYW50UHJvZmlsZS5pc0hvbWVUZW5hbnQgPT09IHRlbmFudFByb2ZpbGVGaWx0ZXIuaXNIb21lVGVuYW50KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgaWRUb2tlbkNsYWltc01hdGNoVGVuYW50UHJvZmlsZUZpbHRlcihcbiAgICAgICAgaWRUb2tlbkNsYWltczogVG9rZW5DbGFpbXMsXG4gICAgICAgIHRlbmFudFByb2ZpbGVGaWx0ZXI/OiBUZW5hbnRQcm9maWxlRmlsdGVyXG4gICAgKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFRlbmFudCBQcm9maWxlIGZpbHRlcmluZ1xuICAgICAgICBpZiAodGVuYW50UHJvZmlsZUZpbHRlcikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhdGVuYW50UHJvZmlsZUZpbHRlci5sb2NhbEFjY291bnRJZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoTG9jYWxBY2NvdW50SWRGcm9tVG9rZW5DbGFpbXMoXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMsXG4gICAgICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGVGaWx0ZXIubG9jYWxBY2NvdW50SWRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhIXRlbmFudFByb2ZpbGVGaWx0ZXIubG9naW5IaW50ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hMb2dpbkhpbnRGcm9tVG9rZW5DbGFpbXMoXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMsXG4gICAgICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGVGaWx0ZXIubG9naW5IaW50XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgISF0ZW5hbnRQcm9maWxlRmlsdGVyLnVzZXJuYW1lICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hVc2VybmFtZShcbiAgICAgICAgICAgICAgICAgICAgaWRUb2tlbkNsYWltcy5wcmVmZXJyZWRfdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGVGaWx0ZXIudXNlcm5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhIXRlbmFudFByb2ZpbGVGaWx0ZXIubmFtZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoTmFtZShpZFRva2VuQ2xhaW1zLCB0ZW5hbnRQcm9maWxlRmlsdGVyLm5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhIXRlbmFudFByb2ZpbGVGaWx0ZXIuc2lkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hTaWQoaWRUb2tlbkNsYWltcywgdGVuYW50UHJvZmlsZUZpbHRlci5zaWQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYXZlcyBhIGNhY2hlIHJlY29yZFxuICAgICAqIEBwYXJhbSBjYWNoZVJlY29yZCB7Q2FjaGVSZWNvcmR9XG4gICAgICogQHBhcmFtIHN0b3JlSW5DYWNoZSB7P1N0b3JlSW5DYWNoZX1cbiAgICAgKiBAcGFyYW0gY29ycmVsYXRpb25JZCB7P3N0cmluZ30gY29ycmVsYXRpb24gaWRcbiAgICAgKi9cbiAgICBhc3luYyBzYXZlQ2FjaGVSZWNvcmQoXG4gICAgICAgIGNhY2hlUmVjb3JkOiBDYWNoZVJlY29yZCxcbiAgICAgICAgY29ycmVsYXRpb25JZDogc3RyaW5nLFxuICAgICAgICBzdG9yZUluQ2FjaGU/OiBTdG9yZUluQ2FjaGVcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCFjYWNoZVJlY29yZCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDYWNoZVJlY29yZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoISFjYWNoZVJlY29yZC5hY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRBY2NvdW50KGNhY2hlUmVjb3JkLmFjY291bnQsIGNvcnJlbGF0aW9uSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISFjYWNoZVJlY29yZC5pZFRva2VuICYmIHN0b3JlSW5DYWNoZT8uaWRUb2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldElkVG9rZW5DcmVkZW50aWFsKFxuICAgICAgICAgICAgICAgICAgICBjYWNoZVJlY29yZC5pZFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhY2FjaGVSZWNvcmQuYWNjZXNzVG9rZW4gJiZcbiAgICAgICAgICAgICAgICBzdG9yZUluQ2FjaGU/LmFjY2Vzc1Rva2VuICE9PSBmYWxzZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlQWNjZXNzVG9rZW4oXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhY2FjaGVSZWNvcmQucmVmcmVzaFRva2VuICYmXG4gICAgICAgICAgICAgICAgc3RvcmVJbkNhY2hlPy5yZWZyZXNoVG9rZW4gIT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldFJlZnJlc2hUb2tlbkNyZWRlbnRpYWwoXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlUmVjb3JkLnJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghIWNhY2hlUmVjb3JkLmFwcE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBcHBNZXRhZGF0YShjYWNoZVJlY29yZC5hcHBNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGU6IHVua25vd24pIHtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyPy5lcnJvcihgQ2FjaGVNYW5hZ2VyLnNhdmVDYWNoZVJlY29yZDogZmFpbGVkYCk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb25Mb2dnZXI/LmVycm9yUGlpKFxuICAgICAgICAgICAgICAgICAgICBgQ2FjaGVNYW5hZ2VyLnNhdmVDYWNoZVJlY29yZDogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fFxuICAgICAgICAgICAgICAgICAgICBlLm5hbWUgPT09IFwiTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRURcIiB8fFxuICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2UuaW5jbHVkZXMoXCJleGNlZWRlZCB0aGUgcXVvdGFcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb25Mb2dnZXI/LmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYENhY2hlTWFuYWdlci5zYXZlQ2FjaGVSZWNvcmQ6IGV4Y2VlZGVkIHN0b3JhZ2UgcXVvdGFgLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FjaGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIENhY2hlRXJyb3JDb2Rlcy5jYWNoZVF1b3RhRXhjZWVkZWRFcnJvckNvZGVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FjaGVFcnJvcihlLm5hbWUsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlcj8uZXJyb3JQaWkoXG4gICAgICAgICAgICAgICAgICAgIGBDYWNoZU1hbmFnZXIuc2F2ZUNhY2hlUmVjb3JkOiAke2V9YCxcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENhY2hlRXJyb3IoQ2FjaGVFcnJvckNvZGVzLmNhY2hlVW5rbm93bkVycm9yQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYXZlcyBhY2Nlc3MgdG9rZW4gY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFsXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlQWNjZXNzVG9rZW4oXG4gICAgICAgIGNyZWRlbnRpYWw6IEFjY2Vzc1Rva2VuRW50aXR5LFxuICAgICAgICBjb3JyZWxhdGlvbklkOiBzdHJpbmdcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5GaWx0ZXI6IENyZWRlbnRpYWxGaWx0ZXIgPSB7XG4gICAgICAgICAgICBjbGllbnRJZDogY3JlZGVudGlhbC5jbGllbnRJZCxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOiBjcmVkZW50aWFsLmNyZWRlbnRpYWxUeXBlLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGNyZWRlbnRpYWwuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBob21lQWNjb3VudElkOiBjcmVkZW50aWFsLmhvbWVBY2NvdW50SWQsXG4gICAgICAgICAgICByZWFsbTogY3JlZGVudGlhbC5yZWFsbSxcbiAgICAgICAgICAgIHRva2VuVHlwZTogY3JlZGVudGlhbC50b2tlblR5cGUsXG4gICAgICAgICAgICByZXF1ZXN0ZWRDbGFpbXNIYXNoOiBjcmVkZW50aWFsLnJlcXVlc3RlZENsYWltc0hhc2gsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdG9rZW5LZXlzID0gdGhpcy5nZXRUb2tlbktleXMoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFNjb3BlcyA9IFNjb3BlU2V0LmZyb21TdHJpbmcoY3JlZGVudGlhbC50YXJnZXQpO1xuXG4gICAgICAgIGNvbnN0IHJlbW92ZWRBY2Nlc3NUb2tlbnM6IEFycmF5PFByb21pc2U8dm9pZD4+ID0gW107XG4gICAgICAgIHRva2VuS2V5cy5hY2Nlc3NUb2tlbi5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhdGhpcy5hY2Nlc3NUb2tlbktleU1hdGNoZXNGaWx0ZXIoa2V5LCBhY2Nlc3NUb2tlbkZpbHRlciwgZmFsc2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRva2VuRW50aXR5ID0gdGhpcy5nZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoa2V5KTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRva2VuRW50aXR5ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsTWF0Y2hlc0ZpbHRlcih0b2tlbkVudGl0eSwgYWNjZXNzVG9rZW5GaWx0ZXIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblNjb3BlU2V0ID0gU2NvcGVTZXQuZnJvbVN0cmluZyh0b2tlbkVudGl0eS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblNjb3BlU2V0LmludGVyc2VjdGluZ1Njb3BlU2V0cyhjdXJyZW50U2NvcGVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQWNjZXNzVG9rZW5zLnB1c2godGhpcy5yZW1vdmVBY2Nlc3NUb2tlbihrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZW1vdmVkQWNjZXNzVG9rZW5zKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoY3JlZGVudGlhbCwgY29ycmVsYXRpb25JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWNjb3VudCBlbnRpdGllcyBtYXRjaGluZyBhbGwgcHJvdmlkZWQgdGVuYW50LWFnbm9zdGljIGZpbHRlcnM7IGlmIG5vIGZpbHRlciBpcyBzZXQsIGdldCBhbGwgYWNjb3VudCBlbnRpdGllcyBpbiB0aGUgY2FjaGVcbiAgICAgKiBOb3QgY2hlY2tpbmcgZm9yIGNhc2luZyBhcyBrZXlzIGFyZSBhbGwgZ2VuZXJhdGVkIGluIGxvd2VyIGNhc2UsIHJlbWVtYmVyIHRvIGNvbnZlcnQgdG8gbG93ZXIgY2FzZSBpZiBvYmplY3QgcHJvcGVydGllcyBhcmUgY29tcGFyZWRcbiAgICAgKiBAcGFyYW0gYWNjb3VudEZpbHRlciAtIEFuIG9iamVjdCBjb250YWluaW5nIEFjY291bnQgcHJvcGVydGllcyB0byBmaWx0ZXIgYnlcbiAgICAgKi9cbiAgICBnZXRBY2NvdW50c0ZpbHRlcmVkQnkoYWNjb3VudEZpbHRlcjogQWNjb3VudEZpbHRlcik6IEFjY291bnRFbnRpdHlbXSB7XG4gICAgICAgIGNvbnN0IGFsbEFjY291bnRLZXlzID0gdGhpcy5nZXRBY2NvdW50S2V5cygpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ0FjY291bnRzOiBBY2NvdW50RW50aXR5W10gPSBbXTtcbiAgICAgICAgYWxsQWNjb3VudEtleXMuZm9yRWFjaCgoY2FjaGVLZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FjY291bnRLZXkoY2FjaGVLZXksIGFjY291bnRGaWx0ZXIuaG9tZUFjY291bnRJZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwYXJzZSB2YWx1ZSBpZiB0aGUga2V5IGRvZXNuJ3QgbWF0Y2ggdGhlIGFjY291bnQgZmlsdGVyc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZW50aXR5OiBBY2NvdW50RW50aXR5IHwgbnVsbCA9IHRoaXMuZ2V0QWNjb3VudChcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gTWF0Y2ggYmFzZSBhY2NvdW50IGZpZWxkc1xuXG4gICAgICAgICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhYWNjb3VudEZpbHRlci5ob21lQWNjb3VudElkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hIb21lQWNjb3VudElkKGVudGl0eSwgYWNjb3VudEZpbHRlci5ob21lQWNjb3VudElkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgISFhY2NvdW50RmlsdGVyLnVzZXJuYW1lICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hVc2VybmFtZShlbnRpdHkudXNlcm5hbWUsIGFjY291bnRGaWx0ZXIudXNlcm5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhIWFjY291bnRGaWx0ZXIuZW52aXJvbm1lbnQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaEVudmlyb25tZW50KGVudGl0eSwgYWNjb3VudEZpbHRlci5lbnZpcm9ubWVudClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhYWNjb3VudEZpbHRlci5yZWFsbSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoUmVhbG0oZW50aXR5LCBhY2NvdW50RmlsdGVyLnJlYWxtKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgISFhY2NvdW50RmlsdGVyLm5hdGl2ZUFjY291bnRJZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoTmF0aXZlQWNjb3VudElkKFxuICAgICAgICAgICAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRGaWx0ZXIubmF0aXZlQWNjb3VudElkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgISFhY2NvdW50RmlsdGVyLmF1dGhvcml0eVR5cGUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaEF1dGhvcml0eVR5cGUoZW50aXR5LCBhY2NvdW50RmlsdGVyLmF1dGhvcml0eVR5cGUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGF0IGxlYXN0IG9uZSB0ZW5hbnQgcHJvZmlsZSBtYXRjaGVzIHRoZSB0ZW5hbnQgcHJvZmlsZSBmaWx0ZXIsIGFkZCB0aGUgYWNjb3VudCB0byB0aGUgbGlzdCBvZiBtYXRjaGluZyBhY2NvdW50c1xuICAgICAgICAgICAgY29uc3QgdGVuYW50UHJvZmlsZUZpbHRlcjogVGVuYW50UHJvZmlsZUZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICBsb2NhbEFjY291bnRJZDogYWNjb3VudEZpbHRlcj8ubG9jYWxBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgbmFtZTogYWNjb3VudEZpbHRlcj8ubmFtZSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nVGVuYW50UHJvZmlsZXMgPSBlbnRpdHkudGVuYW50UHJvZmlsZXM/LmZpbHRlcihcbiAgICAgICAgICAgICAgICAodGVuYW50UHJvZmlsZTogVGVuYW50UHJvZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZW5hbnRQcm9maWxlTWF0Y2hlc0ZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5hbnRQcm9maWxlRmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVGVuYW50UHJvZmlsZXMgJiYgbWF0Y2hpbmdUZW5hbnRQcm9maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyB0ZW5hbnQgcHJvZmlsZSBmb3IgdGhpcyBhY2NvdW50IG1hdGNoZXMgZmlsdGVyLCBkb24ndCBhZGQgdG8gbGlzdCBvZiBtYXRjaGluZyBhY2NvdW50c1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hpbmdBY2NvdW50cy5wdXNoKGVudGl0eSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRjaGluZ0FjY291bnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4ga2V5IG1hdGNoZXMgb3VyIGFjY291bnQga2V5IHNjaGVtYS4gQWxzbyBtYXRjaGVzIGhvbWVBY2NvdW50SWQgYW5kL29yIHRlbmFudElkIGlmIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBob21lQWNjb3VudElkXG4gICAgICogQHBhcmFtIHRlbmFudElkXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBpc0FjY291bnRLZXkoXG4gICAgICAgIGtleTogc3RyaW5nLFxuICAgICAgICBob21lQWNjb3VudElkPzogc3RyaW5nLFxuICAgICAgICB0ZW5hbnRJZD86IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoa2V5LnNwbGl0KFNlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUikubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgLy8gQWNjb3VudCBjYWNoZSBrZXlzIGNvbnRhaW4gMyBpdGVtcyBzZXBhcmF0ZWQgYnkgJy0nIChlYWNoIGl0ZW0gbWF5IGFsc28gY29udGFpbiAnLScpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBob21lQWNjb3VudElkICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaG9tZUFjY291bnRJZC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZW5hbnRJZCAmJiAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVuYW50SWQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIG5vdCBjaGVjayBlbnZpcm9ubWVudCBhcyBhbGlhc2luZyBjYW4gY2F1c2UgZmFsc2UgbmVnYXRpdmVzXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBrZXkgbWF0Y2hlcyBvdXIgY3JlZGVudGlhbCBrZXkgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBpc0NyZWRlbnRpYWxLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGtleS5zcGxpdChTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1IpLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIC8vIENyZWRlbnRpYWwgY2FjaGUga2V5cyBjb250YWluIDYgaXRlbXMgc2VwYXJhdGVkIGJ5ICctJyAoZWFjaCBpdGVtIG1heSBhbHNvIGNvbnRhaW4gJy0nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG93ZXJDYXNlS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIENyZWRlbnRpYWwga2V5cyBtdXN0IGluZGljYXRlIHdoYXQgY3JlZGVudGlhbCB0eXBlIHRoZXkgcmVwcmVzZW50XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvd2VyQ2FzZUtleS5pbmRleE9mKENyZWRlbnRpYWxUeXBlLklEX1RPS0VOLnRvTG93ZXJDYXNlKCkpID09PVxuICAgICAgICAgICAgICAgIC0xICYmXG4gICAgICAgICAgICBsb3dlckNhc2VLZXkuaW5kZXhPZihDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU4udG9Mb3dlckNhc2UoKSkgPT09XG4gICAgICAgICAgICAgICAgLTEgJiZcbiAgICAgICAgICAgIGxvd2VyQ2FzZUtleS5pbmRleE9mKFxuICAgICAgICAgICAgICAgIENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTl9XSVRIX0FVVEhfU0NIRU1FLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICkgPT09IC0xICYmXG4gICAgICAgICAgICBsb3dlckNhc2VLZXkuaW5kZXhPZihDcmVkZW50aWFsVHlwZS5SRUZSRVNIX1RPS0VOLnRvTG93ZXJDYXNlKCkpID09PVxuICAgICAgICAgICAgICAgIC0xXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbG93ZXJDYXNlS2V5LmluZGV4T2YoQ3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTi50b0xvd2VyQ2FzZSgpKSA+XG4gICAgICAgICAgICAtMVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFJlZnJlc2ggdG9rZW5zIG11c3QgY29udGFpbiB0aGUgY2xpZW50IGlkIG9yIGZhbWlseSBpZFxuICAgICAgICAgICAgY29uc3QgY2xpZW50SWRWYWxpZGF0aW9uID0gYCR7Q3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTn0ke1NlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUn0ke3RoaXMuY2xpZW50SWR9JHtTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1J9YDtcbiAgICAgICAgICAgIGNvbnN0IGZhbWlseUlkVmFsaWRhdGlvbiA9IGAke0NyZWRlbnRpYWxUeXBlLlJFRlJFU0hfVE9LRU59JHtTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1J9JHtUSEVfRkFNSUxZX0lEfSR7U2VwYXJhdG9ycy5DQUNIRV9LRVlfU0VQQVJBVE9SfWA7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbG93ZXJDYXNlS2V5LmluZGV4T2YoY2xpZW50SWRWYWxpZGF0aW9uLnRvTG93ZXJDYXNlKCkpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGxvd2VyQ2FzZUtleS5pbmRleE9mKGZhbWlseUlkVmFsaWRhdGlvbi50b0xvd2VyQ2FzZSgpKSA9PT0gLTFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsb3dlckNhc2VLZXkuaW5kZXhPZih0aGlzLmNsaWVudElkLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gVG9rZW5zIG11c3QgY29udGFpbiB0aGUgY2xpZW50SWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGNyZWRlbnRpYWwgZW50aXR5IG1hdGNoZXMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gZmlsdGVyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBjcmVkZW50aWFsTWF0Y2hlc0ZpbHRlcihcbiAgICAgICAgZW50aXR5OiBWYWxpZENyZWRlbnRpYWxUeXBlLFxuICAgICAgICBmaWx0ZXI6IENyZWRlbnRpYWxGaWx0ZXJcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCEhZmlsdGVyLmNsaWVudElkICYmICF0aGlzLm1hdGNoQ2xpZW50SWQoZW50aXR5LCBmaWx0ZXIuY2xpZW50SWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhIWZpbHRlci51c2VyQXNzZXJ0aW9uSGFzaCAmJlxuICAgICAgICAgICAgIXRoaXMubWF0Y2hVc2VyQXNzZXJ0aW9uSGFzaChlbnRpdHksIGZpbHRlci51c2VyQXNzZXJ0aW9uSGFzaClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBob21lQWNjb3VudElkIGNhbiBiZSB1bmRlZmluZWQsIGFuZCB3ZSB3YW50IHRvIGZpbHRlciBvdXQgY2FjaGVkIGl0ZW1zIHRoYXQgaGF2ZSBhIGhvbWVBY2NvdW50SWQgb2YgXCJcIlxuICAgICAgICAgKiBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYSBjbGllbnRfY3JlZGVudGlhbCByZXF1ZXN0IHRvIHJldHVybiBhIGNhY2hlZCB0b2tlbiB0aGF0IGhhcyBhIGhvbWVBY2NvdW50SWRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmaWx0ZXIuaG9tZUFjY291bnRJZCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIXRoaXMubWF0Y2hIb21lQWNjb3VudElkKGVudGl0eSwgZmlsdGVyLmhvbWVBY2NvdW50SWQpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgISFmaWx0ZXIuZW52aXJvbm1lbnQgJiZcbiAgICAgICAgICAgICF0aGlzLm1hdGNoRW52aXJvbm1lbnQoZW50aXR5LCBmaWx0ZXIuZW52aXJvbm1lbnQpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhZmlsdGVyLnJlYWxtICYmICF0aGlzLm1hdGNoUmVhbG0oZW50aXR5LCBmaWx0ZXIucmVhbG0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhIWZpbHRlci5jcmVkZW50aWFsVHlwZSAmJlxuICAgICAgICAgICAgIXRoaXMubWF0Y2hDcmVkZW50aWFsVHlwZShlbnRpdHksIGZpbHRlci5jcmVkZW50aWFsVHlwZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISFmaWx0ZXIuZmFtaWx5SWQgJiYgIXRoaXMubWF0Y2hGYW1pbHlJZChlbnRpdHksIGZpbHRlci5mYW1pbHlJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGlkVG9rZW5zIGRvIG5vdCBoYXZlIFwidGFyZ2V0XCIsIHRhcmdldCBzcGVjaWZpYyByZWZyZXNoVG9rZW5zIGRvIGV4aXN0IGZvciBzb21lIHR5cGVzIG9mIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAqIFJlc291cmNlIHNwZWNpZmljIHJlZnJlc2ggdG9rZW5zIGNhc2Ugd2lsbCBiZSBhZGRlZCB3aGVuIHRoZSBzdXBwb3J0IGlzIGRlZW1lZCBuZWNlc3NhcnlcbiAgICAgICAgICovXG4gICAgICAgIGlmICghIWZpbHRlci50YXJnZXQgJiYgIXRoaXMubWF0Y2hUYXJnZXQoZW50aXR5LCBmaWx0ZXIudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgcmVxdWVzdCBPUiBjYWNoZWQgZW50aXR5IGhhcyByZXF1ZXN0ZWQgQ2xhaW1zIEhhc2gsIGNoZWNrIGlmIHRoZXkgbWF0Y2hcbiAgICAgICAgaWYgKGZpbHRlci5yZXF1ZXN0ZWRDbGFpbXNIYXNoIHx8IGVudGl0eS5yZXF1ZXN0ZWRDbGFpbXNIYXNoKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBtYXRjaCBpZiBlaXRoZXIgaXMgdW5kZWZpbmVkIG9yIHRoZXkgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgaWYgKGVudGl0eS5yZXF1ZXN0ZWRDbGFpbXNIYXNoICE9PSBmaWx0ZXIucmVxdWVzdGVkQ2xhaW1zSGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjY2VzcyBUb2tlbiB3aXRoIEF1dGggU2NoZW1lIHNwZWNpZmljIG1hdGNoaW5nXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGVudGl0eS5jcmVkZW50aWFsVHlwZSA9PT1cbiAgICAgICAgICAgIENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTl9XSVRIX0FVVEhfU0NIRU1FXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhZmlsdGVyLnRva2VuVHlwZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoVG9rZW5UeXBlKGVudGl0eSwgZmlsdGVyLnRva2VuVHlwZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gS2V5SWQgKHNzaEtpZCkgaW4gcmVxdWVzdCBtdXN0IG1hdGNoIGNhY2hlZCBTU0ggY2VydGlmaWNhdGUga2V5SWQgYmVjYXVzZSBTU0ggY2VydCBpcyBib3VuZCB0byBhIHNwZWNpZmljIGtleVxuICAgICAgICAgICAgaWYgKGZpbHRlci50b2tlblR5cGUgPT09IEF1dGhlbnRpY2F0aW9uU2NoZW1lLlNTSCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIua2V5SWQgJiYgIXRoaXMubWF0Y2hLZXlJZChlbnRpdHksIGZpbHRlci5rZXlJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFwcE1ldGFkYXRhIG1hdGNoaW5nIGFsbCBwcm92aWRlZCBmaWx0ZXJzOyBpZiBubyBmaWx0ZXIgaXMgc2V0LCBnZXQgYWxsIGFwcE1ldGFkYXRhXG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqL1xuICAgIGdldEFwcE1ldGFkYXRhRmlsdGVyZWRCeShmaWx0ZXI6IEFwcE1ldGFkYXRhRmlsdGVyKTogQXBwTWV0YWRhdGFDYWNoZSB7XG4gICAgICAgIGNvbnN0IGFsbENhY2hlS2V5cyA9IHRoaXMuZ2V0S2V5cygpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ0FwcE1ldGFkYXRhOiBBcHBNZXRhZGF0YUNhY2hlID0ge307XG5cbiAgICAgICAgYWxsQ2FjaGVLZXlzLmZvckVhY2goKGNhY2hlS2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBhbnkgbm9uLWFwcE1ldGFkYXRhIHR5cGUgY2FjaGUgZW50aXRpZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FwcE1ldGFkYXRhKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0ZW1wdCByZXRyaWV2YWxcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZ2V0QXBwTWV0YWRhdGEoY2FjaGVLZXkpO1xuXG4gICAgICAgICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhZmlsdGVyLmVudmlyb25tZW50ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hFbnZpcm9ubWVudChlbnRpdHksIGZpbHRlci5lbnZpcm9ubWVudClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEhZmlsdGVyLmNsaWVudElkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hDbGllbnRJZChlbnRpdHksIGZpbHRlci5jbGllbnRJZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hpbmdBcHBNZXRhZGF0YVtjYWNoZUtleV0gPSBlbnRpdHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRjaGluZ0FwcE1ldGFkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGF1dGhvcml0eU1ldGFkYXRhIHRoYXQgY29udGFpbnMgYSBtYXRjaGluZyBhbGlhc1xuICAgICAqIEBwYXJhbSBmaWx0ZXJcbiAgICAgKi9cbiAgICBnZXRBdXRob3JpdHlNZXRhZGF0YUJ5QWxpYXMoaG9zdDogc3RyaW5nKTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkgfCBudWxsIHtcbiAgICAgICAgY29uc3QgYWxsQ2FjaGVLZXlzID0gdGhpcy5nZXRBdXRob3JpdHlNZXRhZGF0YUtleXMoKTtcbiAgICAgICAgbGV0IG1hdGNoZWRFbnRpdHkgPSBudWxsO1xuXG4gICAgICAgIGFsbENhY2hlS2V5cy5mb3JFYWNoKChjYWNoZUtleSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgYW55IG5vbi1hdXRob3JpdHlNZXRhZGF0YSB0eXBlIGNhY2hlIGVudGl0aWVzXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNBdXRob3JpdHlNZXRhZGF0YShjYWNoZUtleSkgfHxcbiAgICAgICAgICAgICAgICBjYWNoZUtleS5pbmRleE9mKHRoaXMuY2xpZW50SWQpID09PSAtMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHJldHJpZXZhbFxuICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5nZXRBdXRob3JpdHlNZXRhZGF0YShjYWNoZUtleSk7XG5cbiAgICAgICAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50aXR5LmFsaWFzZXMuaW5kZXhPZihob3N0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoZWRFbnRpdHkgPSBlbnRpdHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRjaGVkRW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGFjY291bnRzIGFuZCByZWxhdGVkIHRva2VucyBmcm9tIGNhY2hlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbEFjY291bnRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBhbGxBY2NvdW50S2V5cyA9IHRoaXMuZ2V0QWNjb3VudEtleXMoKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZEFjY291bnRzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IFtdO1xuXG4gICAgICAgIGFsbEFjY291bnRLZXlzLmZvckVhY2goKGNhY2hlS2V5KSA9PiB7XG4gICAgICAgICAgICByZW1vdmVkQWNjb3VudHMucHVzaCh0aGlzLnJlbW92ZUFjY291bnQoY2FjaGVLZXkpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVtb3ZlZEFjY291bnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBhY2NvdW50IGFuZCByZWxhdGVkIHRva2VucyBmb3IgYSBnaXZlbiBhY2NvdW50IGtleVxuICAgICAqIEBwYXJhbSBhY2NvdW50XG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWNjb3VudChhY2NvdW50S2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHRoaXMuZ2V0QWNjb3VudChhY2NvdW50S2V5LCB0aGlzLmNvbW1vbkxvZ2dlcik7XG4gICAgICAgIGlmICghYWNjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQWNjb3VudENvbnRleHQoYWNjb3VudCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShhY2NvdW50S2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGNyZWRlbnRpYWxzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgYWNjb3VudFxuICAgICAqIEBwYXJhbSBhY2NvdW50XG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWNjb3VudENvbnRleHQoYWNjb3VudDogQWNjb3VudEVudGl0eSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBhbGxUb2tlbktleXMgPSB0aGlzLmdldFRva2VuS2V5cygpO1xuICAgICAgICBjb25zdCBhY2NvdW50SWQgPSBhY2NvdW50LmdlbmVyYXRlQWNjb3VudElkKCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRDcmVkZW50aWFsczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSBbXTtcblxuICAgICAgICBhbGxUb2tlbktleXMuaWRUb2tlbi5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihhY2NvdW50SWQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJZFRva2VuKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFsbFRva2VuS2V5cy5hY2Nlc3NUb2tlbi5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihhY2NvdW50SWQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZENyZWRlbnRpYWxzLnB1c2godGhpcy5yZW1vdmVBY2Nlc3NUb2tlbihrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWxsVG9rZW5LZXlzLnJlZnJlc2hUb2tlbi5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihhY2NvdW50SWQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWZyZXNoVG9rZW4oa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVtb3ZlZENyZWRlbnRpYWxzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEgYm9vbGVhbiBpZiB0aGUgZ2l2ZW4gY3JlZGVudGlhbCBpcyByZW1vdmVkXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBY2Nlc3NUb2tlbihrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsID0gdGhpcy5nZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoa2V5KTtcbiAgICAgICAgaWYgKCFjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgVG9rZW4gQmluZGluZyBLZXkgZnJvbSBrZXkgc3RvcmUgZm9yIFBvUCBUb2tlbnMgQ3JlZGVudGlhbHNcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY3JlZGVudGlhbC5jcmVkZW50aWFsVHlwZS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgQ3JlZGVudGlhbFR5cGUuQUNDRVNTX1RPS0VOX1dJVEhfQVVUSF9TQ0hFTUUudG9Mb3dlckNhc2UoKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChjcmVkZW50aWFsLnRva2VuVHlwZSA9PT0gQXV0aGVudGljYXRpb25TY2hlbWUuUE9QKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5XaXRoQXV0aFNjaGVtZUVudGl0eSA9XG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwgYXMgQWNjZXNzVG9rZW5FbnRpdHk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2lkID0gYWNjZXNzVG9rZW5XaXRoQXV0aFNjaGVtZUVudGl0eS5rZXlJZDtcblxuICAgICAgICAgICAgICAgIGlmIChraWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3J5cHRvSW1wbC5yZW1vdmVUb2tlbkJpbmRpbmdLZXkoa2lkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5iaW5kaW5nS2V5Tm90UmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBhcHAgbWV0YWRhdGEgb2JqZWN0cyBmcm9tIGNhY2hlLlxuICAgICAqL1xuICAgIHJlbW92ZUFwcE1ldGFkYXRhKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBhbGxDYWNoZUtleXMgPSB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgYWxsQ2FjaGVLZXlzLmZvckVhY2goKGNhY2hlS2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FwcE1ldGFkYXRhKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbShjYWNoZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIEFjY291bnRFbnRpdHkgZnJvbSBjYWNoZVxuICAgICAqIEBwYXJhbSBhY2NvdW50XG4gICAgICovXG4gICAgcmVhZEFjY291bnRGcm9tQ2FjaGUoYWNjb3VudDogQWNjb3VudEluZm8pOiBBY2NvdW50RW50aXR5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGFjY291bnRLZXk6IHN0cmluZyA9XG4gICAgICAgICAgICBBY2NvdW50RW50aXR5LmdlbmVyYXRlQWNjb3VudENhY2hlS2V5KGFjY291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50KGFjY291bnRLZXksIHRoaXMuY29tbW9uTG9nZ2VyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBJZFRva2VuRW50aXR5IGZyb20gY2FjaGVcbiAgICAgKiBAcGFyYW0gYWNjb3VudCB7QWNjb3VudEluZm99XG4gICAgICogQHBhcmFtIHRva2VuS2V5cyB7P1Rva2VuS2V5c31cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmVhbG0gez9zdHJpbmd9XG4gICAgICogQHBhcmFtIHBlcmZvcm1hbmNlQ2xpZW50IHs/SVBlcmZvcm1hbmNlQ2xpZW50fVxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkVG9rZW4oXG4gICAgICAgIGFjY291bnQ6IEFjY291bnRJbmZvLFxuICAgICAgICB0b2tlbktleXM/OiBUb2tlbktleXMsXG4gICAgICAgIHRhcmdldFJlYWxtPzogc3RyaW5nLFxuICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgY29ycmVsYXRpb25JZD86IHN0cmluZ1xuICAgICk6IElkVG9rZW5FbnRpdHkgfCBudWxsIHtcbiAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIudHJhY2UoXCJDYWNoZU1hbmFnZXIgLSBnZXRJZFRva2VuIGNhbGxlZFwiKTtcbiAgICAgICAgY29uc3QgaWRUb2tlbkZpbHRlcjogQ3JlZGVudGlhbEZpbHRlciA9IHtcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IGFjY291bnQuaG9tZUFjY291bnRJZCxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBhY2NvdW50LmVudmlyb25tZW50LFxuICAgICAgICAgICAgY3JlZGVudGlhbFR5cGU6IENyZWRlbnRpYWxUeXBlLklEX1RPS0VOLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICByZWFsbTogdGFyZ2V0UmVhbG0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaWRUb2tlbk1hcDogTWFwPHN0cmluZywgSWRUb2tlbkVudGl0eT4gPSB0aGlzLmdldElkVG9rZW5zQnlGaWx0ZXIoXG4gICAgICAgICAgICBpZFRva2VuRmlsdGVyLFxuICAgICAgICAgICAgdG9rZW5LZXlzXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbnVtSWRUb2tlbnMgPSBpZFRva2VuTWFwLnNpemU7XG5cbiAgICAgICAgaWYgKG51bUlkVG9rZW5zIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIuaW5mbyhcIkNhY2hlTWFuYWdlcjpnZXRJZFRva2VuIC0gTm8gdG9rZW4gZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChudW1JZFRva2VucyA+IDEpIHtcbiAgICAgICAgICAgIGxldCB0b2tlbnNUb0JlUmVtb3ZlZDogTWFwPHN0cmluZywgSWRUb2tlbkVudGl0eT4gPSBpZFRva2VuTWFwO1xuICAgICAgICAgICAgLy8gTXVsdGlwbGUgdGVuYW50IHByb2ZpbGVzIGFuZCBubyB0ZW5hbnQgc3BlY2lmaWVkLCBwaWNrIGhvbWUgYWNjb3VudFxuICAgICAgICAgICAgaWYgKCF0YXJnZXRSZWFsbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvbWVJZFRva2VuTWFwOiBNYXA8c3RyaW5nLCBJZFRva2VuRW50aXR5PiA9IG5ldyBNYXA8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgSWRUb2tlbkVudGl0eVxuICAgICAgICAgICAgICAgID4oKTtcbiAgICAgICAgICAgICAgICBpZFRva2VuTWFwLmZvckVhY2goKGlkVG9rZW4sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWRUb2tlbi5yZWFsbSA9PT0gYWNjb3VudC50ZW5hbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9tZUlkVG9rZW5NYXAuc2V0KGtleSwgaWRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Ib21lSWRUb2tlbnMgPSBob21lSWRUb2tlbk1hcC5zaXplO1xuICAgICAgICAgICAgICAgIGlmIChudW1Ib21lSWRUb2tlbnMgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNhY2hlTWFuYWdlcjpnZXRJZFRva2VuIC0gTXVsdGlwbGUgSUQgdG9rZW5zIGZvdW5kIGZvciBhY2NvdW50IGJ1dCBub25lIG1hdGNoIGFjY291bnQgZW50aXR5IHRlbmFudCBpZCwgcmV0dXJuaW5nIGZpcnN0IHJlc3VsdFwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZFRva2VuTWFwLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bUhvbWVJZFRva2VucyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJDYWNoZU1hbmFnZXI6Z2V0SWRUb2tlbiAtIE11bHRpcGxlIElEIHRva2VucyBmb3VuZCBmb3IgYWNjb3VudCwgZGVmYXVsdGluZyB0byBob21lIHRlbmFudCBwcm9maWxlXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvbWVJZFRva2VuTWFwLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aXBsZSBJRCB0b2tlbnMgZm9yIGhvbWUgdGVuYW50IHByb2ZpbGUsIHJlbW92ZSBhbGwgYW5kIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1RvQmVSZW1vdmVkID0gaG9tZUlkVG9rZW5NYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVsdGlwbGUgdG9rZW5zIGZvciBhIHNpbmdsZSB0ZW5hbnQgcHJvZmlsZSwgcmVtb3ZlIGFsbCBhbmQgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgXCJDYWNoZU1hbmFnZXI6Z2V0SWRUb2tlbiAtIE11bHRpcGxlIG1hdGNoaW5nIElEIHRva2VucyBmb3VuZCwgY2xlYXJpbmcgdGhlbVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdG9rZW5zVG9CZVJlbW92ZWQuZm9yRWFjaCgoaWRUb2tlbiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJZFRva2VuKGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZUNsaWVudCAmJiBjb3JyZWxhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQuYWRkRmllbGRzKFxuICAgICAgICAgICAgICAgICAgICB7IG11bHRpTWF0Y2hlZElEOiBpZFRva2VuTWFwLnNpemUgfSxcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXCJDYWNoZU1hbmFnZXI6Z2V0SWRUb2tlbiAtIFJldHVybmluZyBJRCB0b2tlblwiKTtcbiAgICAgICAgcmV0dXJuIGlkVG9rZW5NYXAudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGlkVG9rZW5zIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gZmlsdGVyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRJZFRva2Vuc0J5RmlsdGVyKFxuICAgICAgICBmaWx0ZXI6IENyZWRlbnRpYWxGaWx0ZXIsXG4gICAgICAgIHRva2VuS2V5cz86IFRva2VuS2V5c1xuICAgICk6IE1hcDxzdHJpbmcsIElkVG9rZW5FbnRpdHk+IHtcbiAgICAgICAgY29uc3QgaWRUb2tlbktleXMgPVxuICAgICAgICAgICAgKHRva2VuS2V5cyAmJiB0b2tlbktleXMuaWRUb2tlbikgfHwgdGhpcy5nZXRUb2tlbktleXMoKS5pZFRva2VuO1xuXG4gICAgICAgIGNvbnN0IGlkVG9rZW5zOiBNYXA8c3RyaW5nLCBJZFRva2VuRW50aXR5PiA9IG5ldyBNYXA8XG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBJZFRva2VuRW50aXR5XG4gICAgICAgID4oKTtcbiAgICAgICAgaWRUb2tlbktleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXRoaXMuaWRUb2tlbktleU1hdGNoZXNGaWx0ZXIoa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICAuLi5maWx0ZXIsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSB0aGlzLmdldElkVG9rZW5DcmVkZW50aWFsKGtleSk7XG4gICAgICAgICAgICBpZiAoaWRUb2tlbiAmJiB0aGlzLmNyZWRlbnRpYWxNYXRjaGVzRmlsdGVyKGlkVG9rZW4sIGZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICBpZFRva2Vucy5zZXQoa2V5LCBpZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlkVG9rZW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBjYWNoZSBrZXkgYWdhaW5zdCBmaWx0ZXIgYmVmb3JlIHJldHJpZXZpbmcgYW5kIHBhcnNpbmcgY2FjaGUgdmFsdWVcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgaWRUb2tlbktleU1hdGNoZXNGaWx0ZXIoXG4gICAgICAgIGlucHV0S2V5OiBzdHJpbmcsXG4gICAgICAgIGZpbHRlcjogQ3JlZGVudGlhbEZpbHRlclxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBrZXkgPSBpbnB1dEtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaWx0ZXIuY2xpZW50SWQgJiZcbiAgICAgICAgICAgIGtleS5pbmRleE9mKGZpbHRlci5jbGllbnRJZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaWx0ZXIuaG9tZUFjY291bnRJZCAmJlxuICAgICAgICAgICAga2V5LmluZGV4T2YoZmlsdGVyLmhvbWVBY2NvdW50SWQudG9Mb3dlckNhc2UoKSkgPT09IC0xXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBpZFRva2VuIGZyb20gdGhlIGNhY2hlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIHJlbW92ZUlkVG9rZW4oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyByZWZyZXNoIHRva2VuIGZyb20gdGhlIGNhY2hlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIHJlbW92ZVJlZnJlc2hUb2tlbihrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBBY2Nlc3NUb2tlbkVudGl0eSBmcm9tIGNhY2hlXG4gICAgICogQHBhcmFtIGFjY291bnQge0FjY291bnRJbmZvfVxuICAgICAqIEBwYXJhbSByZXF1ZXN0IHtCYXNlQXV0aFJlcXVlc3R9XG4gICAgICogQHBhcmFtIHRva2VuS2V5cyB7P1Rva2VuS2V5c31cbiAgICAgKiBAcGFyYW0gcGVyZm9ybWFuY2VDbGllbnQgez9JUGVyZm9ybWFuY2VDbGllbnR9XG4gICAgICogQHBhcmFtIGNvcnJlbGF0aW9uSWQgez9zdHJpbmd9XG4gICAgICovXG4gICAgZ2V0QWNjZXNzVG9rZW4oXG4gICAgICAgIGFjY291bnQ6IEFjY291bnRJbmZvLFxuICAgICAgICByZXF1ZXN0OiBCYXNlQXV0aFJlcXVlc3QsXG4gICAgICAgIHRva2VuS2V5cz86IFRva2VuS2V5cyxcbiAgICAgICAgdGFyZ2V0UmVhbG0/OiBzdHJpbmcsXG4gICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50PzogSVBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICBjb3JyZWxhdGlvbklkPzogc3RyaW5nXG4gICAgKTogQWNjZXNzVG9rZW5FbnRpdHkgfCBudWxsIHtcbiAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIudHJhY2UoXCJDYWNoZU1hbmFnZXIgLSBnZXRBY2Nlc3NUb2tlbiBjYWxsZWRcIik7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IFNjb3BlU2V0LmNyZWF0ZVNlYXJjaFNjb3BlcyhyZXF1ZXN0LnNjb3Blcyk7XG4gICAgICAgIGNvbnN0IGF1dGhTY2hlbWUgPVxuICAgICAgICAgICAgcmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSB8fCBBdXRoZW50aWNhdGlvblNjaGVtZS5CRUFSRVI7XG4gICAgICAgIC8qXG4gICAgICAgICAqIERpc3Rpbmd1aXNoIGJldHdlZW4gQmVhcmVyIGFuZCBQb1AvU1NIIHRva2VuIGNhY2hlIHR5cGVzXG4gICAgICAgICAqIENhc3QgdG8gbG93ZXJjYXNlIHRvIGhhbmRsZSBcImJlYXJlclwiIGZyb20gQURGU1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY3JlZGVudGlhbFR5cGUgPVxuICAgICAgICAgICAgYXV0aFNjaGVtZSAmJlxuICAgICAgICAgICAgYXV0aFNjaGVtZS50b0xvd2VyQ2FzZSgpICE9PVxuICAgICAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUi50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgPyBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRVxuICAgICAgICAgICAgICAgIDogQ3JlZGVudGlhbFR5cGUuQUNDRVNTX1RPS0VOO1xuXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuRmlsdGVyOiBDcmVkZW50aWFsRmlsdGVyID0ge1xuICAgICAgICAgICAgaG9tZUFjY291bnRJZDogYWNjb3VudC5ob21lQWNjb3VudElkLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGFjY291bnQuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBjcmVkZW50aWFsVHlwZTogY3JlZGVudGlhbFR5cGUsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIHJlYWxtOiB0YXJnZXRSZWFsbSB8fCBhY2NvdW50LnRlbmFudElkLFxuICAgICAgICAgICAgdGFyZ2V0OiBzY29wZXMsXG4gICAgICAgICAgICB0b2tlblR5cGU6IGF1dGhTY2hlbWUsXG4gICAgICAgICAgICBrZXlJZDogcmVxdWVzdC5zc2hLaWQsXG4gICAgICAgICAgICByZXF1ZXN0ZWRDbGFpbXNIYXNoOiByZXF1ZXN0LnJlcXVlc3RlZENsYWltc0hhc2gsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5LZXlzID1cbiAgICAgICAgICAgICh0b2tlbktleXMgJiYgdG9rZW5LZXlzLmFjY2Vzc1Rva2VuKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRUb2tlbktleXMoKS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5zOiBBY2Nlc3NUb2tlbkVudGl0eVtdID0gW107XG5cbiAgICAgICAgYWNjZXNzVG9rZW5LZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUga2V5XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbktleU1hdGNoZXNGaWx0ZXIoa2V5LCBhY2Nlc3NUb2tlbkZpbHRlciwgdHJ1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5nZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoa2V5KTtcblxuICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxNYXRjaGVzRmlsdGVyKGFjY2Vzc1Rva2VuLCBhY2Nlc3NUb2tlbkZpbHRlcilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW5zLnB1c2goYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbnVtQWNjZXNzVG9rZW5zID0gYWNjZXNzVG9rZW5zLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bUFjY2Vzc1Rva2VucyA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgXCJDYWNoZU1hbmFnZXI6Z2V0QWNjZXNzVG9rZW4gLSBObyB0b2tlbiBmb3VuZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtQWNjZXNzVG9rZW5zID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBcIkNhY2hlTWFuYWdlcjpnZXRBY2Nlc3NUb2tlbiAtIE11bHRpcGxlIGFjY2VzcyB0b2tlbnMgZm91bmQsIGNsZWFyaW5nIHRoZW1cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2Vucy5mb3JFYWNoKChhY2Nlc3NUb2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5yZW1vdmVBY2Nlc3NUb2tlbihnZW5lcmF0ZUNyZWRlbnRpYWxLZXkoYWNjZXNzVG9rZW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBlcmZvcm1hbmNlQ2xpZW50ICYmIGNvcnJlbGF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUNsaWVudC5hZGRGaWVsZHMoXG4gICAgICAgICAgICAgICAgICAgIHsgbXVsdGlNYXRjaGVkQVQ6IGFjY2Vzc1Rva2Vucy5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXG4gICAgICAgICAgICBcIkNhY2hlTWFuYWdlcjpnZXRBY2Nlc3NUb2tlbiAtIFJldHVybmluZyBhY2Nlc3MgdG9rZW5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW5zWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBjYWNoZSBrZXkgYWdhaW5zdCBmaWx0ZXIgYmVmb3JlIHJldHJpZXZpbmcgYW5kIHBhcnNpbmcgY2FjaGUgdmFsdWVcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqIEBwYXJhbSBrZXlNdXN0Q29udGFpbkFsbFNjb3Blc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYWNjZXNzVG9rZW5LZXlNYXRjaGVzRmlsdGVyKFxuICAgICAgICBpbnB1dEtleTogc3RyaW5nLFxuICAgICAgICBmaWx0ZXI6IENyZWRlbnRpYWxGaWx0ZXIsXG4gICAgICAgIGtleU11c3RDb250YWluQWxsU2NvcGVzOiBib29sZWFuXG4gICAgKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGlucHV0S2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpbHRlci5jbGllbnRJZCAmJlxuICAgICAgICAgICAga2V5LmluZGV4T2YoZmlsdGVyLmNsaWVudElkLnRvTG93ZXJDYXNlKCkpID09PSAtMVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpbHRlci5ob21lQWNjb3VudElkICYmXG4gICAgICAgICAgICBrZXkuaW5kZXhPZihmaWx0ZXIuaG9tZUFjY291bnRJZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVyLnJlYWxtICYmIGtleS5pbmRleE9mKGZpbHRlci5yZWFsbS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpbHRlci5yZXF1ZXN0ZWRDbGFpbXNIYXNoICYmXG4gICAgICAgICAgICBrZXkuaW5kZXhPZihmaWx0ZXIucmVxdWVzdGVkQ2xhaW1zSGFzaC50b0xvd2VyQ2FzZSgpKSA9PT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVyLnRhcmdldCkge1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVzID0gZmlsdGVyLnRhcmdldC5hc0FycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAga2V5TXVzdENvbnRhaW5BbGxTY29wZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgIWtleS5pbmNsdWRlcyhzY29wZXNbaV0udG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgY2FjaGUgbG9va3VwIGEgbWlzc2luZyBzY29wZSB3b3VsZCBiZSBhIGNhY2hlIG1pc3NcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFrZXlNdXN0Q29udGFpbkFsbFNjb3BlcyAmJlxuICAgICAgICAgICAgICAgICAgICBrZXkuaW5jbHVkZXMoc2NvcGVzW2ldLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIGNhY2hlIHdyaXRlLCBhbnkgdG9rZW4gd2l0aCBhIHN1YnNldCBvZiByZXF1ZXN0ZWQgc2NvcGVzIHNob3VsZCBiZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBhY2Nlc3MgdG9rZW5zIG1hdGNoaW5nIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gZmlsdGVyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRBY2Nlc3NUb2tlbnNCeUZpbHRlcihmaWx0ZXI6IENyZWRlbnRpYWxGaWx0ZXIpOiBBY2Nlc3NUb2tlbkVudGl0eVtdIHtcbiAgICAgICAgY29uc3QgdG9rZW5LZXlzID0gdGhpcy5nZXRUb2tlbktleXMoKTtcblxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbnM6IEFjY2Vzc1Rva2VuRW50aXR5W10gPSBbXTtcbiAgICAgICAgdG9rZW5LZXlzLmFjY2Vzc1Rva2VuLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjY2Vzc1Rva2VuS2V5TWF0Y2hlc0ZpbHRlcihrZXksIGZpbHRlciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5nZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoa2V5KTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbE1hdGNoZXNGaWx0ZXIoYWNjZXNzVG9rZW4sIGZpbHRlcilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2Vucy5wdXNoKGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gcmV0cmlldmUgdGhlIGFwcHJvcHJpYXRlIHJlZnJlc2ggdG9rZW4gZnJvbSBjYWNoZVxuICAgICAqIEBwYXJhbSBhY2NvdW50IHtBY2NvdW50SW5mb31cbiAgICAgKiBAcGFyYW0gZmFtaWx5UlQge2Jvb2xlYW59XG4gICAgICogQHBhcmFtIHRva2VuS2V5cyB7P1Rva2VuS2V5c31cbiAgICAgKiBAcGFyYW0gcGVyZm9ybWFuY2VDbGllbnQgez9JUGVyZm9ybWFuY2VDbGllbnR9XG4gICAgICogQHBhcmFtIGNvcnJlbGF0aW9uSWQgez9zdHJpbmd9XG4gICAgICovXG4gICAgZ2V0UmVmcmVzaFRva2VuKFxuICAgICAgICBhY2NvdW50OiBBY2NvdW50SW5mbyxcbiAgICAgICAgZmFtaWx5UlQ6IGJvb2xlYW4sXG4gICAgICAgIHRva2VuS2V5cz86IFRva2VuS2V5cyxcbiAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/OiBJUGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmdcbiAgICApOiBSZWZyZXNoVG9rZW5FbnRpdHkgfCBudWxsIHtcbiAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIudHJhY2UoXCJDYWNoZU1hbmFnZXIgLSBnZXRSZWZyZXNoVG9rZW4gY2FsbGVkXCIpO1xuICAgICAgICBjb25zdCBpZCA9IGZhbWlseVJUID8gVEhFX0ZBTUlMWV9JRCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuRmlsdGVyOiBDcmVkZW50aWFsRmlsdGVyID0ge1xuICAgICAgICAgICAgaG9tZUFjY291bnRJZDogYWNjb3VudC5ob21lQWNjb3VudElkLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGFjY291bnQuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBjcmVkZW50aWFsVHlwZTogQ3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTixcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgZmFtaWx5SWQ6IGlkLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbktleXMgPVxuICAgICAgICAgICAgKHRva2VuS2V5cyAmJiB0b2tlbktleXMucmVmcmVzaFRva2VuKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRUb2tlbktleXMoKS5yZWZyZXNoVG9rZW47XG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbnM6IFJlZnJlc2hUb2tlbkVudGl0eVtdID0gW107XG5cbiAgICAgICAgcmVmcmVzaFRva2VuS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGtleVxuICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRva2VuS2V5TWF0Y2hlc0ZpbHRlcihrZXksIHJlZnJlc2hUb2tlbkZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSB0aGlzLmdldFJlZnJlc2hUb2tlbkNyZWRlbnRpYWwoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbE1hdGNoZXNGaWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW5GaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW5zLnB1c2gocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG51bVJlZnJlc2hUb2tlbnMgPSByZWZyZXNoVG9rZW5zLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVJlZnJlc2hUb2tlbnMgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgIFwiQ2FjaGVNYW5hZ2VyOmdldFJlZnJlc2hUb2tlbiAtIE5vIHJlZnJlc2ggdG9rZW4gZm91bmQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGRyZXNzIHRoZSBlbHNlIGNhc2UgYWZ0ZXIgcmVtb3ZlIGZ1bmN0aW9ucyBhZGRyZXNzIGVudmlyb25tZW50IGFsaWFzZXNcblxuICAgICAgICBpZiAobnVtUmVmcmVzaFRva2VucyA+IDEgJiYgcGVyZm9ybWFuY2VDbGllbnQgJiYgY29ycmVsYXRpb25JZCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQuYWRkRmllbGRzKFxuICAgICAgICAgICAgICAgIHsgbXVsdGlNYXRjaGVkUlQ6IG51bVJlZnJlc2hUb2tlbnMgfSxcbiAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIFwiQ2FjaGVNYW5hZ2VyOmdldFJlZnJlc2hUb2tlbiAtIHJldHVybmluZyByZWZyZXNoIHRva2VuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlZnJlc2hUb2tlbnNbMF0gYXMgUmVmcmVzaFRva2VuRW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBjYWNoZSBrZXkgYWdhaW5zdCBmaWx0ZXIgYmVmb3JlIHJldHJpZXZpbmcgYW5kIHBhcnNpbmcgY2FjaGUgdmFsdWVcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqL1xuICAgIHJlZnJlc2hUb2tlbktleU1hdGNoZXNGaWx0ZXIoXG4gICAgICAgIGlucHV0S2V5OiBzdHJpbmcsXG4gICAgICAgIGZpbHRlcjogQ3JlZGVudGlhbEZpbHRlclxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBrZXkgPSBpbnB1dEtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaWx0ZXIuZmFtaWx5SWQgJiZcbiAgICAgICAgICAgIGtleS5pbmRleE9mKGZpbHRlci5mYW1pbHlJZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBmYW1pbHlJZCBpcyB1c2VkLCBjbGllbnRJZCBpcyBub3QgaW4gdGhlIGtleVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZmlsdGVyLmZhbWlseUlkICYmXG4gICAgICAgICAgICBmaWx0ZXIuY2xpZW50SWQgJiZcbiAgICAgICAgICAgIGtleS5pbmRleE9mKGZpbHRlci5jbGllbnRJZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaWx0ZXIuaG9tZUFjY291bnRJZCAmJlxuICAgICAgICAgICAga2V5LmluZGV4T2YoZmlsdGVyLmhvbWVBY2NvdW50SWQudG9Mb3dlckNhc2UoKSkgPT09IC0xXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgQXBwTWV0YWRhdGFFbnRpdHkgZnJvbSBjYWNoZVxuICAgICAqL1xuICAgIHJlYWRBcHBNZXRhZGF0YUZyb21DYWNoZShlbnZpcm9ubWVudDogc3RyaW5nKTogQXBwTWV0YWRhdGFFbnRpdHkgfCBudWxsIHtcbiAgICAgICAgY29uc3QgYXBwTWV0YWRhdGFGaWx0ZXI6IEFwcE1ldGFkYXRhRmlsdGVyID0ge1xuICAgICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YTogQXBwTWV0YWRhdGFDYWNoZSA9XG4gICAgICAgICAgICB0aGlzLmdldEFwcE1ldGFkYXRhRmlsdGVyZWRCeShhcHBNZXRhZGF0YUZpbHRlcik7XG4gICAgICAgIGNvbnN0IGFwcE1ldGFkYXRhRW50cmllczogQXBwTWV0YWRhdGFFbnRpdHlbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgICAgICAgYXBwTWV0YWRhdGFcbiAgICAgICAgKS5tYXAoKGtleSkgPT4gYXBwTWV0YWRhdGFba2V5XSk7XG5cbiAgICAgICAgY29uc3QgbnVtQXBwTWV0YWRhdGEgPSBhcHBNZXRhZGF0YUVudHJpZXMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQXBwTWV0YWRhdGEgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChudW1BcHBNZXRhZGF0YSA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5tdWx0aXBsZU1hdGNoaW5nQXBwTWV0YWRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBwTWV0YWRhdGFFbnRyaWVzWzBdIGFzIEFwcE1ldGFkYXRhRW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZmFtaWx5X2lkIHZhbHVlIGFzc29jaWF0ZWQgIHdpdGggRk9DSVxuICAgICAqIEBwYXJhbSBlbnZpcm9ubWVudFxuICAgICAqIEBwYXJhbSBjbGllbnRJZFxuICAgICAqL1xuICAgIGlzQXBwTWV0YWRhdGFGT0NJKGVudmlyb25tZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgYXBwTWV0YWRhdGEgPSB0aGlzLnJlYWRBcHBNZXRhZGF0YUZyb21DYWNoZShlbnZpcm9ubWVudCk7XG4gICAgICAgIHJldHVybiAhIShhcHBNZXRhZGF0YSAmJiBhcHBNZXRhZGF0YS5mYW1pbHlJZCA9PT0gVEhFX0ZBTUlMWV9JRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIG1hdGNoIGFjY291bnQgaWRzXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIGhvbWVBY2NvdW50SWRcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoSG9tZUFjY291bnRJZChcbiAgICAgICAgZW50aXR5OiBBY2NvdW50RW50aXR5IHwgQ3JlZGVudGlhbEVudGl0eSxcbiAgICAgICAgaG9tZUFjY291bnRJZDogc3RyaW5nXG4gICAgKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgICAgIHR5cGVvZiBlbnRpdHkuaG9tZUFjY291bnRJZCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgaG9tZUFjY291bnRJZCA9PT0gZW50aXR5LmhvbWVBY2NvdW50SWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggYWNjb3VudCBpZHNcbiAgICAgKiBAcGFyYW0gZW50aXR5XG4gICAgICogQHBhcmFtIGxvY2FsQWNjb3VudElkXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoTG9jYWxBY2NvdW50SWRGcm9tVG9rZW5DbGFpbXMoXG4gICAgICAgIHRva2VuQ2xhaW1zOiBUb2tlbkNsYWltcyxcbiAgICAgICAgbG9jYWxBY2NvdW50SWQ6IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpZFRva2VuTG9jYWxBY2NvdW50SWQgPSB0b2tlbkNsYWltcy5vaWQgfHwgdG9rZW5DbGFpbXMuc3ViO1xuICAgICAgICByZXR1cm4gbG9jYWxBY2NvdW50SWQgPT09IGlkVG9rZW5Mb2NhbEFjY291bnRJZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIG1hdGNoTG9jYWxBY2NvdW50SWRGcm9tVGVuYW50UHJvZmlsZShcbiAgICAgICAgdGVuYW50UHJvZmlsZTogVGVuYW50UHJvZmlsZSxcbiAgICAgICAgbG9jYWxBY2NvdW50SWQ6IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGVuYW50UHJvZmlsZS5sb2NhbEFjY291bnRJZCA9PT0gbG9jYWxBY2NvdW50SWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIG1hdGNoIG5hbWVzXG4gICAgICogQHBhcmFtIGVudGl0eVxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZG93bmNhc2VkIG5hbWUgcHJvcGVydGllcyBhcmUgcHJlc2VudCBhbmQgbWF0Y2ggaW4gdGhlIGZpbHRlciBhbmQgdGhlIGVudGl0eVxuICAgICAqL1xuICAgIHByaXZhdGUgbWF0Y2hOYW1lKGNsYWltczogVG9rZW5DbGFpbXMsIG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEobmFtZS50b0xvd2VyQ2FzZSgpID09PSBjbGFpbXMubmFtZT8udG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIG1hdGNoIHVzZXJuYW1lc1xuICAgICAqIEBwYXJhbSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gdXNlcm5hbWVcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHByaXZhdGUgbWF0Y2hVc2VybmFtZShcbiAgICAgICAgY2FjaGVkVXNlcm5hbWU/OiBzdHJpbmcsXG4gICAgICAgIGZpbHRlclVzZXJuYW1lPzogc3RyaW5nXG4gICAgKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgICAgIGNhY2hlZFVzZXJuYW1lICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FjaGVkVXNlcm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIGZpbHRlclVzZXJuYW1lPy50b0xvd2VyQ2FzZSgpID09PSBjYWNoZWRVc2VybmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIG1hdGNoIGFzc2VydGlvblxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvYm9Bc3NlcnRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoVXNlckFzc2VydGlvbkhhc2goXG4gICAgICAgIGVudGl0eTogQ3JlZGVudGlhbEVudGl0eSxcbiAgICAgICAgdXNlckFzc2VydGlvbkhhc2g6IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEoXG4gICAgICAgICAgICBlbnRpdHkudXNlckFzc2VydGlvbkhhc2ggJiZcbiAgICAgICAgICAgIHVzZXJBc3NlcnRpb25IYXNoID09PSBlbnRpdHkudXNlckFzc2VydGlvbkhhc2hcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggZW52aXJvbm1lbnRcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gZW52aXJvbm1lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoRW52aXJvbm1lbnQoXG4gICAgICAgIGVudGl0eTogQWNjb3VudEVudGl0eSB8IENyZWRlbnRpYWxFbnRpdHkgfCBBcHBNZXRhZGF0YUVudGl0eSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBDaGVjayBzdGF0aWMgYXV0aG9yaXR5IG9wdGlvbnMgZmlyc3QgZm9yIGNhc2VzIHdoZXJlIGF1dGhvcml0eSBtZXRhZGF0YSBoYXMgbm90IGJlZW4gcmVzb2x2ZWQgYW5kIGNhY2hlZCB5ZXRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGljQXV0aG9yaXR5T3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGljQWxpYXNlcyA9IGdldEFsaWFzZXNGcm9tU3RhdGljU291cmNlcyhcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpY0F1dGhvcml0eU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb25Mb2dnZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RhdGljQWxpYXNlcy5pbmNsdWRlcyhlbnZpcm9ubWVudCkgJiZcbiAgICAgICAgICAgICAgICBzdGF0aWNBbGlhc2VzLmluY2x1ZGVzKGVudGl0eS5lbnZpcm9ubWVudClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVlcnkgbWV0YWRhdGEgY2FjaGUgaWYgbm8gc3RhdGljIGF1dGhvcml0eSBjb25maWd1cmF0aW9uIGhhcyBhbGlhc2VzIHRoYXQgbWF0Y2ggZW52aXJvbWVudFxuICAgICAgICBjb25zdCBjbG91ZE1ldGFkYXRhID0gdGhpcy5nZXRBdXRob3JpdHlNZXRhZGF0YUJ5QWxpYXMoZW52aXJvbm1lbnQpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjbG91ZE1ldGFkYXRhICYmXG4gICAgICAgICAgICBjbG91ZE1ldGFkYXRhLmFsaWFzZXMuaW5kZXhPZihlbnRpdHkuZW52aXJvbm1lbnQpID4gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIG1hdGNoIGNyZWRlbnRpYWwgdHlwZVxuICAgICAqIEBwYXJhbSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbFR5cGVcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoQ3JlZGVudGlhbFR5cGUoXG4gICAgICAgIGVudGl0eTogQ3JlZGVudGlhbEVudGl0eSxcbiAgICAgICAgY3JlZGVudGlhbFR5cGU6IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZW50aXR5LmNyZWRlbnRpYWxUeXBlICYmXG4gICAgICAgICAgICBjcmVkZW50aWFsVHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbnRpdHkuY3JlZGVudGlhbFR5cGUudG9Mb3dlckNhc2UoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhlbHBlciB0byBtYXRjaCBjbGllbnQgaWRzXG4gICAgICogQHBhcmFtIGVudGl0eVxuICAgICAqIEBwYXJhbSBjbGllbnRJZFxuICAgICAqL1xuICAgIHByaXZhdGUgbWF0Y2hDbGllbnRJZChcbiAgICAgICAgZW50aXR5OiBDcmVkZW50aWFsRW50aXR5IHwgQXBwTWV0YWRhdGFFbnRpdHksXG4gICAgICAgIGNsaWVudElkOiBzdHJpbmdcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhKGVudGl0eS5jbGllbnRJZCAmJiBjbGllbnRJZCA9PT0gZW50aXR5LmNsaWVudElkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggZmFtaWx5IGlkc1xuICAgICAqIEBwYXJhbSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gZmFtaWx5SWRcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoRmFtaWx5SWQoXG4gICAgICAgIGVudGl0eTogQ3JlZGVudGlhbEVudGl0eSB8IEFwcE1ldGFkYXRhRW50aXR5LFxuICAgICAgICBmYW1pbHlJZDogc3RyaW5nXG4gICAgKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShlbnRpdHkuZmFtaWx5SWQgJiYgZmFtaWx5SWQgPT09IGVudGl0eS5mYW1pbHlJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIG1hdGNoIHJlYWxtXG4gICAgICogQHBhcmFtIGVudGl0eVxuICAgICAqIEBwYXJhbSByZWFsbVxuICAgICAqL1xuICAgIHByaXZhdGUgbWF0Y2hSZWFsbShcbiAgICAgICAgZW50aXR5OiBBY2NvdW50RW50aXR5IHwgQ3JlZGVudGlhbEVudGl0eSxcbiAgICAgICAgcmVhbG06IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEoZW50aXR5LnJlYWxtPy50b0xvd2VyQ2FzZSgpID09PSByZWFsbS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggbmF0aXZlQWNjb3VudElkXG4gICAgICogQHBhcmFtIGVudGl0eVxuICAgICAqIEBwYXJhbSBuYXRpdmVBY2NvdW50SWRcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgdGhlIG1hdGNoIHJlc3VsdFxuICAgICAqL1xuICAgIHByaXZhdGUgbWF0Y2hOYXRpdmVBY2NvdW50SWQoXG4gICAgICAgIGVudGl0eTogQWNjb3VudEVudGl0eSxcbiAgICAgICAgbmF0aXZlQWNjb3VudElkOiBzdHJpbmdcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhKFxuICAgICAgICAgICAgZW50aXR5Lm5hdGl2ZUFjY291bnRJZCAmJiBuYXRpdmVBY2NvdW50SWQgPT09IGVudGl0eS5uYXRpdmVBY2NvdW50SWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggbG9naW5IaW50IHdoaWNoIGNhbiBiZSBlaXRoZXI6XG4gICAgICogMS4gbG9naW5faGludCBJRCB0b2tlbiBjbGFpbVxuICAgICAqIDIuIHVzZXJuYW1lIGluIGNhY2hlZCBhY2NvdW50IG9iamVjdFxuICAgICAqIDMuIHVwbiBpbiBJRCB0b2tlbiBjbGFpbXNcbiAgICAgKiBAcGFyYW0gZW50aXR5XG4gICAgICogQHBhcmFtIGxvZ2luSGludFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcHJpdmF0ZSBtYXRjaExvZ2luSGludEZyb21Ub2tlbkNsYWltcyhcbiAgICAgICAgdG9rZW5DbGFpbXM6IFRva2VuQ2xhaW1zLFxuICAgICAgICBsb2dpbkhpbnQ6IHN0cmluZ1xuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodG9rZW5DbGFpbXMubG9naW5faGludCA9PT0gbG9naW5IaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbkNsYWltcy5wcmVmZXJyZWRfdXNlcm5hbWUgPT09IGxvZ2luSGludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW5DbGFpbXMudXBuID09PSBsb2dpbkhpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBtYXRjaCBzaWRcbiAgICAgKiBAcGFyYW0gZW50aXR5XG4gICAgICogQHBhcmFtIHNpZFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNpZCBjbGFpbSBpcyBwcmVzZW50IGFuZCBtYXRjaGVzIHRoZSBmaWx0ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoU2lkKGlkVG9rZW5DbGFpbXM6IFRva2VuQ2xhaW1zLCBzaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaWRUb2tlbkNsYWltcy5zaWQgPT09IHNpZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIG1hdGNoQXV0aG9yaXR5VHlwZShcbiAgICAgICAgZW50aXR5OiBBY2NvdW50RW50aXR5LFxuICAgICAgICBhdXRob3JpdHlUeXBlOiBzdHJpbmdcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhKFxuICAgICAgICAgICAgZW50aXR5LmF1dGhvcml0eVR5cGUgJiZcbiAgICAgICAgICAgIGF1dGhvcml0eVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZW50aXR5LmF1dGhvcml0eVR5cGUudG9Mb3dlckNhc2UoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFyZ2V0IHNjb3BlcyBhcmUgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgZW50aXR5J3Mgc2NvcGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIGVudGl0eVxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hdGNoVGFyZ2V0KGVudGl0eTogQ3JlZGVudGlhbEVudGl0eSwgdGFyZ2V0OiBTY29wZVNldCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpc05vdEFjY2Vzc1Rva2VuQ3JlZGVudGlhbCA9XG4gICAgICAgICAgICBlbnRpdHkuY3JlZGVudGlhbFR5cGUgIT09IENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTiAmJlxuICAgICAgICAgICAgZW50aXR5LmNyZWRlbnRpYWxUeXBlICE9PVxuICAgICAgICAgICAgICAgIENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTl9XSVRIX0FVVEhfU0NIRU1FO1xuXG4gICAgICAgIGlmIChpc05vdEFjY2Vzc1Rva2VuQ3JlZGVudGlhbCB8fCAhZW50aXR5LnRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW50aXR5U2NvcGVTZXQ6IFNjb3BlU2V0ID0gU2NvcGVTZXQuZnJvbVN0cmluZyhlbnRpdHkudGFyZ2V0KTtcblxuICAgICAgICByZXR1cm4gZW50aXR5U2NvcGVTZXQuY29udGFpbnNTY29wZVNldCh0YXJnZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3JlZGVudGlhbCdzIHRva2VuVHlwZSBvciBBdXRoZW50aWNhdGlvbiBTY2hlbWUgbWF0Y2hlcyB0aGUgb25lIGluIHRoZSByZXF1ZXN0LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gZW50aXR5XG4gICAgICogQHBhcmFtIHRva2VuVHlwZVxuICAgICAqL1xuICAgIHByaXZhdGUgbWF0Y2hUb2tlblR5cGUoXG4gICAgICAgIGVudGl0eTogQ3JlZGVudGlhbEVudGl0eSxcbiAgICAgICAgdG9rZW5UeXBlOiBBdXRoZW50aWNhdGlvblNjaGVtZVxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEoZW50aXR5LnRva2VuVHlwZSAmJiBlbnRpdHkudG9rZW5UeXBlID09PSB0b2tlblR5cGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3JlZGVudGlhbCdzIGtleUlkIG1hdGNoZXMgdGhlIG9uZSBpbiB0aGUgcmVxdWVzdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIGVudGl0eVxuICAgICAqIEBwYXJhbSBrZXlJZFxuICAgICAqL1xuICAgIHByaXZhdGUgbWF0Y2hLZXlJZChlbnRpdHk6IENyZWRlbnRpYWxFbnRpdHksIGtleUlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhKGVudGl0eS5rZXlJZCAmJiBlbnRpdHkua2V5SWQgPT09IGtleUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGlmIGEgZ2l2ZW4gY2FjaGUgZW50aXR5IGlzIG9mIHRoZSB0eXBlIGFwcG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIHByaXZhdGUgaXNBcHBNZXRhZGF0YShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4ga2V5LmluZGV4T2YoQVBQX01FVEFEQVRBKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBpZiBhIGdpdmVuIGNhY2hlIGVudGl0eSBpcyBvZiB0aGUgdHlwZSBhdXRob3JpdHltZXRhZGF0YVxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaXNBdXRob3JpdHlNZXRhZGF0YShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4ga2V5LmluZGV4T2YoQVVUSE9SSVRZX01FVEFEQVRBX0NPTlNUQU5UUy5DQUNIRV9LRVkpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGNhY2hlIGtleSB1c2VkIGZvciBjbG91ZCBpbnN0YW5jZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIGdlbmVyYXRlQXV0aG9yaXR5TWV0YWRhdGFDYWNoZUtleShhdXRob3JpdHk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtBVVRIT1JJVFlfTUVUQURBVEFfQ09OU1RBTlRTLkNBQ0hFX0tFWX0tJHt0aGlzLmNsaWVudElkfS0ke2F1dGhvcml0eX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBjb252ZXJ0IHNlcmlhbGl6ZWQgZGF0YSB0byBvYmplY3RcbiAgICAgKiBAcGFyYW0gb2JqXG4gICAgICogQHBhcmFtIGpzb25cbiAgICAgKi9cbiAgICBzdGF0aWMgdG9PYmplY3Q8VD4ob2JqOiBULCBqc29uOiBvYmplY3QpOiBUIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4ganNvbikge1xuICAgICAgICAgICAgb2JqW3Byb3BlcnR5TmFtZV0gPSBqc29uW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U3RvcmFnZUNsYXNzIGV4dGVuZHMgQ2FjaGVNYW5hZ2VyIHtcbiAgICBhc3luYyBzZXRBY2NvdW50KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICBnZXRBY2NvdW50KCk6IEFjY291bnRFbnRpdHkge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICBhc3luYyBzZXRJZFRva2VuQ3JlZGVudGlhbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0SWRUb2tlbkNyZWRlbnRpYWwoKTogSWRUb2tlbkVudGl0eSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfVxuICAgIGFzeW5jIHNldEFjY2Vzc1Rva2VuQ3JlZGVudGlhbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0QWNjZXNzVG9rZW5DcmVkZW50aWFsKCk6IEFjY2Vzc1Rva2VuRW50aXR5IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbCgpOiBSZWZyZXNoVG9rZW5FbnRpdHkge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICBzZXRBcHBNZXRhZGF0YSgpOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0QXBwTWV0YWRhdGEoKTogQXBwTWV0YWRhdGFFbnRpdHkge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICBzZXRTZXJ2ZXJUZWxlbWV0cnkoKTogdm9pZCB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfVxuICAgIGdldFNlcnZlclRlbGVtZXRyeSgpOiBTZXJ2ZXJUZWxlbWV0cnlFbnRpdHkge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICBzZXRBdXRob3JpdHlNZXRhZGF0YSgpOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0QXV0aG9yaXR5TWV0YWRhdGEoKTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkgfCBudWxsIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0QXV0aG9yaXR5TWV0YWRhdGFLZXlzKCk6IEFycmF5PHN0cmluZz4ge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICBzZXRUaHJvdHRsaW5nQ2FjaGUoKTogdm9pZCB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfVxuICAgIGdldFRocm90dGxpbmdDYWNoZSgpOiBUaHJvdHRsaW5nRW50aXR5IHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbSgpOiBib29sZWFuIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0S2V5cygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfVxuICAgIGdldEFjY291bnRLZXlzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgZ2V0VG9rZW5LZXlzKCk6IFRva2VuS2V5cyB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJTmV0d29ya01vZHVsZSB9IGZyb20gXCIuLi9uZXR3b3JrL0lOZXR3b3JrTW9kdWxlLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX0NSWVBUT19JTVBMRU1FTlRBVElPTiwgSUNyeXB0byB9IGZyb20gXCIuLi9jcnlwdG8vSUNyeXB0by5qc1wiO1xuaW1wb3J0IHsgSUxvZ2dlckNhbGxiYWNrLCBMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXIuanNcIjtcbmltcG9ydCB7XG4gICAgQ29uc3RhbnRzLFxuICAgIERFRkFVTFRfVE9LRU5fUkVORVdBTF9PRkZTRVRfU0VDLFxufSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL3BhY2thZ2VNZXRhZGF0YS5qc1wiO1xuaW1wb3J0IHsgQXV0aG9yaXR5IH0gZnJvbSBcIi4uL2F1dGhvcml0eS9BdXRob3JpdHkuanNcIjtcbmltcG9ydCB7IEF6dXJlQ2xvdWRJbnN0YW5jZSB9IGZyb20gXCIuLi9hdXRob3JpdHkvQXV0aG9yaXR5T3B0aW9ucy5qc1wiO1xuaW1wb3J0IHsgQ2FjaGVNYW5hZ2VyLCBEZWZhdWx0U3RvcmFnZUNsYXNzIH0gZnJvbSBcIi4uL2NhY2hlL0NhY2hlTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgU2VydmVyVGVsZW1ldHJ5TWFuYWdlciB9IGZyb20gXCIuLi90ZWxlbWV0cnkvc2VydmVyL1NlcnZlclRlbGVtZXRyeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IElDYWNoZVBsdWdpbiB9IGZyb20gXCIuLi9jYWNoZS9pbnRlcmZhY2UvSUNhY2hlUGx1Z2luLmpzXCI7XG5pbXBvcnQgeyBJU2VyaWFsaXphYmxlVG9rZW5DYWNoZSB9IGZyb20gXCIuLi9jYWNoZS9pbnRlcmZhY2UvSVNlcmlhbGl6YWJsZVRva2VuQ2FjaGUuanNcIjtcbmltcG9ydCB7IENsaWVudENyZWRlbnRpYWxzIH0gZnJvbSBcIi4uL2FjY291bnQvQ2xpZW50Q3JlZGVudGlhbHMuanNcIjtcbmltcG9ydCB7IFByb3RvY29sTW9kZSB9IGZyb20gXCIuLi9hdXRob3JpdHkvUHJvdG9jb2xNb2RlLmpzXCI7XG5pbXBvcnQge1xuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuXG4vKipcbiAqIFVzZSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gY29uZmlndXJlIE1TQUwgTW9kdWxlcyBhbmQgaW5pdGlhbGl6ZSB0aGUgYmFzZSBpbnRlcmZhY2VzIGZvciBNU0FMLlxuICpcbiAqIFRoaXMgb2JqZWN0IGFsbG93cyB5b3UgdG8gY29uZmlndXJlIGltcG9ydGFudCBlbGVtZW50cyBvZiBNU0FMIGZ1bmN0aW9uYWxpdHk6XG4gKiAtIGF1dGhPcHRpb25zICAgICAgICAgICAgICAgIC0gQXV0aGVudGljYXRpb24gZm9yIGFwcGxpY2F0aW9uXG4gKiAtIGNyeXB0b0ludGVyZmFjZSAgICAgICAgICAgIC0gSW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIGZ1bmN0aW9uc1xuICogLSBsaWJyYXJ5SW5mbyAgICAgICAgICAgICAgICAtIExpYnJhcnkgbWV0YWRhdGFcbiAqIC0gdGVsZW1ldHJ5ICAgICAgICAgICAgICAgICAgLSBUZWxlbWV0cnkgb3B0aW9ucyBhbmQgZGF0YVxuICogLSBsb2dnZXJPcHRpb25zICAgICAgICAgICAgICAtIExvZ2dpbmcgZm9yIGFwcGxpY2F0aW9uXG4gKiAtIG5ldHdvcmtJbnRlcmZhY2UgICAgICAgICAgIC0gTmV0d29yayBpbXBsZW1lbnRhdGlvblxuICogLSBzdG9yYWdlSW50ZXJmYWNlICAgICAgICAgICAtIFN0b3JhZ2UgaW1wbGVtZW50YXRpb25cbiAqIC0gc3lzdGVtT3B0aW9ucyAgICAgICAgICAgICAgLSBBZGRpdGlvbmFsIGxpYnJhcnkgb3B0aW9uc1xuICogLSBjbGllbnRDcmVkZW50aWFscyAgICAgICAgICAtIENyZWRlbnRpYWxzIG9wdGlvbnMgZm9yIGNvbmZpZGVudGlhbCBjbGllbnRzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgQ2xpZW50Q29uZmlndXJhdGlvbiA9IHtcbiAgICBhdXRoT3B0aW9uczogQXV0aE9wdGlvbnM7XG4gICAgc3lzdGVtT3B0aW9ucz86IFN5c3RlbU9wdGlvbnM7XG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnM7XG4gICAgY2FjaGVPcHRpb25zPzogQ2FjaGVPcHRpb25zO1xuICAgIHN0b3JhZ2VJbnRlcmZhY2U/OiBDYWNoZU1hbmFnZXI7XG4gICAgbmV0d29ya0ludGVyZmFjZT86IElOZXR3b3JrTW9kdWxlO1xuICAgIGNyeXB0b0ludGVyZmFjZT86IElDcnlwdG87XG4gICAgY2xpZW50Q3JlZGVudGlhbHM/OiBDbGllbnRDcmVkZW50aWFscztcbiAgICBsaWJyYXJ5SW5mbz86IExpYnJhcnlJbmZvO1xuICAgIHRlbGVtZXRyeT86IFRlbGVtZXRyeU9wdGlvbnM7XG4gICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcj86IFNlcnZlclRlbGVtZXRyeU1hbmFnZXIgfCBudWxsO1xuICAgIHBlcnNpc3RlbmNlUGx1Z2luPzogSUNhY2hlUGx1Z2luIHwgbnVsbDtcbiAgICBzZXJpYWxpemFibGVDYWNoZT86IElTZXJpYWxpemFibGVUb2tlbkNhY2hlIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIENvbW1vbkNsaWVudENvbmZpZ3VyYXRpb24gPSB7XG4gICAgYXV0aE9wdGlvbnM6IFJlcXVpcmVkPEF1dGhPcHRpb25zPjtcbiAgICBzeXN0ZW1PcHRpb25zOiBSZXF1aXJlZDxTeXN0ZW1PcHRpb25zPjtcbiAgICBsb2dnZXJPcHRpb25zOiBSZXF1aXJlZDxMb2dnZXJPcHRpb25zPjtcbiAgICBjYWNoZU9wdGlvbnM6IFJlcXVpcmVkPENhY2hlT3B0aW9ucz47XG4gICAgc3RvcmFnZUludGVyZmFjZTogQ2FjaGVNYW5hZ2VyO1xuICAgIG5ldHdvcmtJbnRlcmZhY2U6IElOZXR3b3JrTW9kdWxlO1xuICAgIGNyeXB0b0ludGVyZmFjZTogUmVxdWlyZWQ8SUNyeXB0bz47XG4gICAgbGlicmFyeUluZm86IExpYnJhcnlJbmZvO1xuICAgIHRlbGVtZXRyeTogUmVxdWlyZWQ8VGVsZW1ldHJ5T3B0aW9ucz47XG4gICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcjogU2VydmVyVGVsZW1ldHJ5TWFuYWdlciB8IG51bGw7XG4gICAgY2xpZW50Q3JlZGVudGlhbHM6IENsaWVudENyZWRlbnRpYWxzO1xuICAgIHBlcnNpc3RlbmNlUGx1Z2luOiBJQ2FjaGVQbHVnaW4gfCBudWxsO1xuICAgIHNlcmlhbGl6YWJsZUNhY2hlOiBJU2VyaWFsaXphYmxlVG9rZW5DYWNoZSB8IG51bGw7XG59O1xuXG4vKipcbiAqIFVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB0aGUgYXV0aCBvcHRpb25zIGluIHRoZSBDbGllbnRDb25maWd1cmF0aW9uIG9iamVjdFxuICpcbiAqIC0gY2xpZW50SWQgICAgICAgICAgICAgICAgICAgIC0gQ2xpZW50IElEIG9mIHlvdXIgYXBwIHJlZ2lzdGVyZWQgd2l0aCBvdXIgQXBwbGljYXRpb24gcmVnaXN0cmF0aW9uIHBvcnRhbCA6IGh0dHBzOi8vcG9ydGFsLmF6dXJlLmNvbS8jYmxhZGUvTWljcm9zb2Z0X0FBRF9JQU0vQWN0aXZlRGlyZWN0b3J5TWVudUJsYWRlL1JlZ2lzdGVyZWRBcHBzUHJldmlldyBpbiBNaWNyb3NvZnQgSWRlbnRpdHkgUGxhdGZvcm1cbiAqIC0gYXV0aG9yaXR5ICAgICAgICAgICAgICAgICAgIC0gWW91IGNhbiBjb25maWd1cmUgYSBzcGVjaWZpYyBhdXRob3JpdHksIGRlZmF1bHRzIHRvIFwiIFwiIG9yIFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vblwiXG4gKiAtIGtub3duQXV0aG9yaXRpZXMgICAgICAgICAgICAtIEFuIGFycmF5IG9mIFVSSXMgdGhhdCBhcmUga25vd24gdG8gYmUgdmFsaWQuIFVzZWQgaW4gQjJDIHNjZW5hcmlvcy5cbiAqIC0gY2xvdWREaXNjb3ZlcnlNZXRhZGF0YSAgICAgIC0gQSBzdHJpbmcgY29udGFpbmluZyB0aGUgY2xvdWQgZGlzY292ZXJ5IHJlc3BvbnNlLiBVc2VkIGluIEFBRCBzY2VuYXJpb3MuXG4gKiAtIGNsaWVudENhcGFiaWxpdGllcyAgICAgICAgICAtIEFycmF5IG9mIGNhcGFiaWxpdGllcyB3aGljaCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjbGFpbXMuYWNjZXNzX3Rva2VuLnhtc19jYyByZXF1ZXN0IHByb3BlcnR5IG9uIGV2ZXJ5IG5ldHdvcmsgcmVxdWVzdC5cbiAqIC0gcHJvdG9jb2xNb2RlICAgICAgICAgICAgICAgIC0gRW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb3RvY29sIHRoYXQgbXNhbCBmb2xsb3dzLiBVc2VkIGZvciBjb25maWd1cmluZyBwcm9wZXIgZW5kcG9pbnRzLlxuICogLSBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZSAgLSBBIGZsYWcgdG8gY2hvb3NlIHdoZXRoZXIgdG8gdXNlIG9yIG5vdCB1c2UgdGhlIGxvY2FsIG1ldGFkYXRhIGNhY2hlIGR1cmluZyBhdXRob3JpdHkgaW5pdGlhbGl6YXRpb24uIERlZmF1bHRzIHRvIGZhbHNlLlxuICogLSBpbnN0YW5jZUF3YXJlICAgICAgICAgICAgICAgLSBBIGZsYWcgb2Ygd2hldGhlciB0aGUgU1RTIHdpbGwgc2VuZCBiYWNrIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBzcGVjaWZ5IHdoZXJlIHRoZSB0b2tlbnMgc2hvdWxkIGJlIHJldHJpZXZlZCBmcm9tLlxuICogLSByZWRpcmVjdFVyaSAgICAgICAgICAgICAgICAgLSBUaGUgcmVkaXJlY3QgVVJJIHdoZXJlIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlcyBjYW4gYmUgcmVjZWl2ZWQgYnkgeW91ciBhcHBsaWNhdGlvbi4gSXQgbXVzdCBleGFjdGx5IG1hdGNoIG9uZSBvZiB0aGUgcmVkaXJlY3QgVVJJcyByZWdpc3RlcmVkIGluIHRoZSBBenVyZSBwb3J0YWwuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgQXV0aE9wdGlvbnMgPSB7XG4gICAgY2xpZW50SWQ6IHN0cmluZztcbiAgICBhdXRob3JpdHk6IEF1dGhvcml0eTtcbiAgICByZWRpcmVjdFVyaTogc3RyaW5nO1xuICAgIGNsaWVudENhcGFiaWxpdGllcz86IEFycmF5PHN0cmluZz47XG4gICAgYXp1cmVDbG91ZE9wdGlvbnM/OiBBenVyZUNsb3VkT3B0aW9ucztcbiAgICBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZT86IGJvb2xlYW47XG4gICAgaW5zdGFuY2VBd2FyZT86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIFVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB0b2tlbiByZW5ld2FsIGluZm8gaW4gdGhlIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKlxuICogLSB0b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzICAgIC0gU2V0cyB0aGUgd2luZG93IG9mIG9mZnNldCBuZWVkZWQgdG8gcmVuZXcgdGhlIHRva2VuIGJlZm9yZSBleHBpcnlcbiAqL1xuZXhwb3J0IHR5cGUgU3lzdGVtT3B0aW9ucyA9IHtcbiAgICB0b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzPzogbnVtYmVyO1xuICAgIHByZXZlbnRDb3JzUHJlZmxpZ2h0PzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogIFVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB0aGUgbG9nZ2luZyB0aGF0IE1TQUwgZG9lcywgYnkgY29uZmlndXJpbmcgbG9nZ2VyIG9wdGlvbnMgaW4gdGhlIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKlxuICogLSBsb2dnZXJDYWxsYmFjayAgICAgICAgICAgICAgICAtIENhbGxiYWNrIGZvciBsb2dnZXJcbiAqIC0gcGlpTG9nZ2luZ0VuYWJsZWQgICAgICAgICAgICAgLSBTZXRzIHdoZXRoZXIgcGlpIGxvZ2dpbmcgaXMgZW5hYmxlZFxuICogLSBsb2dMZXZlbCAgICAgICAgICAgICAgICAgICAgICAtIFNldHMgdGhlIGxldmVsIGF0IHdoaWNoIGxvZ2dpbmcgaGFwcGVuc1xuICogLSBjb3JyZWxhdGlvbklkICAgICAgICAgICAgICAgICAtIFNldHMgdGhlIGNvcnJlbGF0aW9uSWQgcHJpbnRlZCBieSB0aGUgbG9nZ2VyXG4gKi9cbmV4cG9ydCB0eXBlIExvZ2dlck9wdGlvbnMgPSB7XG4gICAgbG9nZ2VyQ2FsbGJhY2s/OiBJTG9nZ2VyQ2FsbGJhY2s7XG4gICAgcGlpTG9nZ2luZ0VuYWJsZWQ/OiBib29sZWFuO1xuICAgIGxvZ0xldmVsPzogTG9nTGV2ZWw7XG4gICAgY29ycmVsYXRpb25JZD86IHN0cmluZztcbn07XG5cbi8qKlxuICogIFVzZSB0aGlzIHRvIGNvbmZpZ3VyZSBjcmVkZW50aWFsIGNhY2hlIHByZWZlcmVuY2VzIGluIHRoZSBDbGllbnRDb25maWd1cmF0aW9uIG9iamVjdFxuICpcbiAqIC0gY2xhaW1zQmFzZWRDYWNoaW5nRW5hYmxlZCAgIC0gU2V0cyB3aGV0aGVyIHRva2VucyBzaG91bGQgYmUgY2FjaGVkIGJhc2VkIG9uIHRoZSBjbGFpbXMgaGFzaC4gRGVmYXVsdCBpcyBmYWxzZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2FjaGVPcHRpb25zID0ge1xuICAgIGNsYWltc0Jhc2VkQ2FjaGluZ0VuYWJsZWQ/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBMaWJyYXJ5LXNwZWNpZmljIG9wdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgTGlicmFyeUluZm8gPSB7XG4gICAgc2t1OiBzdHJpbmc7XG4gICAgdmVyc2lvbjogc3RyaW5nO1xuICAgIGNwdTogc3RyaW5nO1xuICAgIG9zOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEF6dXJlQ2xvdWRJbnN0YW5jZSBzcGVjaWZpYyBvcHRpb25zXG4gKlxuICogLSBhenVyZUNsb3VkSW5zdGFuY2UgICAgICAgICAgICAgLSBzdHJpbmcgZW51bSBwcm92aWRpbmcgc2hvcnQgbm90YXRpb24gZm9yIHNvdmVyaWduIGFuZCBwdWJsaWMgY2xvdWQgYXV0aG9yaXRpZXNcbiAqIC0gdGVuYW50ICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJvdmlzaW9uIHRvIHByb3ZpZGUgdGhlIHRlbmFudCBpbmZvXG4gKi9cbmV4cG9ydCB0eXBlIEF6dXJlQ2xvdWRPcHRpb25zID0ge1xuICAgIGF6dXJlQ2xvdWRJbnN0YW5jZTogQXp1cmVDbG91ZEluc3RhbmNlO1xuICAgIHRlbmFudD86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIFRlbGVtZXRyeU9wdGlvbnMgPSB7XG4gICAgYXBwbGljYXRpb246IEFwcGxpY2F0aW9uVGVsZW1ldHJ5O1xufTtcblxuLyoqXG4gKiBUZWxlbWV0cnkgaW5mb3JtYXRpb24gc2VudCBvbiByZXF1ZXN0XG4gKiAtIGFwcE5hbWU6IFVuaXF1ZSBzdHJpbmcgbmFtZSBvZiBhbiBhcHBsaWNhdGlvblxuICogLSBhcHBWZXJzaW9uOiBWZXJzaW9uIG9mIHRoZSBhcHBsaWNhdGlvbiB1c2luZyBNU0FMXG4gKi9cbmV4cG9ydCB0eXBlIEFwcGxpY2F0aW9uVGVsZW1ldHJ5ID0ge1xuICAgIGFwcE5hbWU6IHN0cmluZztcbiAgICBhcHBWZXJzaW9uOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TWVNURU1fT1BUSU9OUzogUmVxdWlyZWQ8U3lzdGVtT3B0aW9ucz4gPSB7XG4gICAgdG9rZW5SZW5ld2FsT2Zmc2V0U2Vjb25kczogREVGQVVMVF9UT0tFTl9SRU5FV0FMX09GRlNFVF9TRUMsXG4gICAgcHJldmVudENvcnNQcmVmbGlnaHQ6IGZhbHNlLFxufTtcblxuY29uc3QgREVGQVVMVF9MT0dHRVJfSU1QTEVNRU5UQVRJT046IFJlcXVpcmVkPExvZ2dlck9wdGlvbnM+ID0ge1xuICAgIGxvZ2dlckNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIC8vIGFsbG93IHVzZXJzIHRvIG5vdCBzZXQgbG9nZ2VyQ2FsbGJhY2tcbiAgICB9LFxuICAgIHBpaUxvZ2dpbmdFbmFibGVkOiBmYWxzZSxcbiAgICBsb2dMZXZlbDogTG9nTGV2ZWwuSW5mbyxcbiAgICBjb3JyZWxhdGlvbklkOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxufTtcblxuY29uc3QgREVGQVVMVF9DQUNIRV9PUFRJT05TOiBSZXF1aXJlZDxDYWNoZU9wdGlvbnM+ID0ge1xuICAgIGNsYWltc0Jhc2VkQ2FjaGluZ0VuYWJsZWQ6IGZhbHNlLFxufTtcblxuY29uc3QgREVGQVVMVF9ORVRXT1JLX0lNUExFTUVOVEFUSU9OOiBJTmV0d29ya01vZHVsZSA9IHtcbiAgICBhc3luYyBzZW5kR2V0UmVxdWVzdEFzeW5jPFQ+KCk6IFByb21pc2U8VD4ge1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQpO1xuICAgIH0sXG4gICAgYXN5bmMgc2VuZFBvc3RSZXF1ZXN0QXN5bmM8VD4oKTogUHJvbWlzZTxUPiB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCk7XG4gICAgfSxcbn07XG5cbmNvbnN0IERFRkFVTFRfTElCUkFSWV9JTkZPOiBMaWJyYXJ5SW5mbyA9IHtcbiAgICBza3U6IENvbnN0YW50cy5TS1UsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBjcHU6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgb3M6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG59O1xuXG5jb25zdCBERUZBVUxUX0NMSUVOVF9DUkVERU5USUFMUzogQ2xpZW50Q3JlZGVudGlhbHMgPSB7XG4gICAgY2xpZW50U2VjcmV0OiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgIGNsaWVudEFzc2VydGlvbjogdW5kZWZpbmVkLFxufTtcblxuY29uc3QgREVGQVVMVF9BWlVSRV9DTE9VRF9PUFRJT05TOiBBenVyZUNsb3VkT3B0aW9ucyA9IHtcbiAgICBhenVyZUNsb3VkSW5zdGFuY2U6IEF6dXJlQ2xvdWRJbnN0YW5jZS5Ob25lLFxuICAgIHRlbmFudDogYCR7Q29uc3RhbnRzLkRFRkFVTFRfQ09NTU9OX1RFTkFOVH1gLFxufTtcblxuY29uc3QgREVGQVVMVF9URUxFTUVUUllfT1BUSU9OUzogUmVxdWlyZWQ8VGVsZW1ldHJ5T3B0aW9ucz4gPSB7XG4gICAgYXBwbGljYXRpb246IHtcbiAgICAgICAgYXBwTmFtZTogXCJcIixcbiAgICAgICAgYXBwVmVyc2lvbjogXCJcIixcbiAgICB9LFxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aGVuIG5vdCBleHBsaWNpdGx5IGNvbmZpZ3VyZWQgZnJvbSBhcHAgZGV2ZWxvcGVyXG4gKlxuICogQHBhcmFtIENvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcmV0dXJucyBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENsaWVudENvbmZpZ3VyYXRpb24oe1xuICAgIGF1dGhPcHRpb25zOiB1c2VyQXV0aE9wdGlvbnMsXG4gICAgc3lzdGVtT3B0aW9uczogdXNlclN5c3RlbU9wdGlvbnMsXG4gICAgbG9nZ2VyT3B0aW9uczogdXNlckxvZ2dlck9wdGlvbixcbiAgICBjYWNoZU9wdGlvbnM6IHVzZXJDYWNoZU9wdGlvbnMsXG4gICAgc3RvcmFnZUludGVyZmFjZTogc3RvcmFnZUltcGxlbWVudGF0aW9uLFxuICAgIG5ldHdvcmtJbnRlcmZhY2U6IG5ldHdvcmtJbXBsZW1lbnRhdGlvbixcbiAgICBjcnlwdG9JbnRlcmZhY2U6IGNyeXB0b0ltcGxlbWVudGF0aW9uLFxuICAgIGNsaWVudENyZWRlbnRpYWxzOiBjbGllbnRDcmVkZW50aWFscyxcbiAgICBsaWJyYXJ5SW5mbzogbGlicmFyeUluZm8sXG4gICAgdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcjogc2VydmVyVGVsZW1ldHJ5TWFuYWdlcixcbiAgICBwZXJzaXN0ZW5jZVBsdWdpbjogcGVyc2lzdGVuY2VQbHVnaW4sXG4gICAgc2VyaWFsaXphYmxlQ2FjaGU6IHNlcmlhbGl6YWJsZUNhY2hlLFxufTogQ2xpZW50Q29uZmlndXJhdGlvbik6IENvbW1vbkNsaWVudENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0IGxvZ2dlck9wdGlvbnMgPSB7XG4gICAgICAgIC4uLkRFRkFVTFRfTE9HR0VSX0lNUExFTUVOVEFUSU9OLFxuICAgICAgICAuLi51c2VyTG9nZ2VyT3B0aW9uLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhdXRoT3B0aW9uczogYnVpbGRBdXRoT3B0aW9ucyh1c2VyQXV0aE9wdGlvbnMpLFxuICAgICAgICBzeXN0ZW1PcHRpb25zOiB7IC4uLkRFRkFVTFRfU1lTVEVNX09QVElPTlMsIC4uLnVzZXJTeXN0ZW1PcHRpb25zIH0sXG4gICAgICAgIGxvZ2dlck9wdGlvbnM6IGxvZ2dlck9wdGlvbnMsXG4gICAgICAgIGNhY2hlT3B0aW9uczogeyAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMsIC4uLnVzZXJDYWNoZU9wdGlvbnMgfSxcbiAgICAgICAgc3RvcmFnZUludGVyZmFjZTpcbiAgICAgICAgICAgIHN0b3JhZ2VJbXBsZW1lbnRhdGlvbiB8fFxuICAgICAgICAgICAgbmV3IERlZmF1bHRTdG9yYWdlQ2xhc3MoXG4gICAgICAgICAgICAgICAgdXNlckF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OLFxuICAgICAgICAgICAgICAgIG5ldyBMb2dnZXIobG9nZ2VyT3B0aW9ucylcbiAgICAgICAgICAgICksXG4gICAgICAgIG5ldHdvcmtJbnRlcmZhY2U6XG4gICAgICAgICAgICBuZXR3b3JrSW1wbGVtZW50YXRpb24gfHwgREVGQVVMVF9ORVRXT1JLX0lNUExFTUVOVEFUSU9OLFxuICAgICAgICBjcnlwdG9JbnRlcmZhY2U6IGNyeXB0b0ltcGxlbWVudGF0aW9uIHx8IERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OLFxuICAgICAgICBjbGllbnRDcmVkZW50aWFsczogY2xpZW50Q3JlZGVudGlhbHMgfHwgREVGQVVMVF9DTElFTlRfQ1JFREVOVElBTFMsXG4gICAgICAgIGxpYnJhcnlJbmZvOiB7IC4uLkRFRkFVTFRfTElCUkFSWV9JTkZPLCAuLi5saWJyYXJ5SW5mbyB9LFxuICAgICAgICB0ZWxlbWV0cnk6IHsgLi4uREVGQVVMVF9URUxFTUVUUllfT1BUSU9OUywgLi4udGVsZW1ldHJ5IH0sXG4gICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI6IHNlcnZlclRlbGVtZXRyeU1hbmFnZXIgfHwgbnVsbCxcbiAgICAgICAgcGVyc2lzdGVuY2VQbHVnaW46IHBlcnNpc3RlbmNlUGx1Z2luIHx8IG51bGwsXG4gICAgICAgIHNlcmlhbGl6YWJsZUNhY2hlOiBzZXJpYWxpemFibGVDYWNoZSB8fCBudWxsLFxuICAgIH07XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGF1dGhvcHRpb25zIGZyb20gdGhlIGNsaWVudCBhbmQgcGxhdGZvcm0gcGFzc2VkIHZhbHVlc1xuICogQHBhcmFtIGF1dGhPcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQXV0aE9wdGlvbnMoYXV0aE9wdGlvbnM6IEF1dGhPcHRpb25zKTogUmVxdWlyZWQ8QXV0aE9wdGlvbnM+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRDYXBhYmlsaXRpZXM6IFtdLFxuICAgICAgICBhenVyZUNsb3VkT3B0aW9uczogREVGQVVMVF9BWlVSRV9DTE9VRF9PUFRJT05TLFxuICAgICAgICBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZTogZmFsc2UsXG4gICAgICAgIGluc3RhbmNlQXdhcmU6IGZhbHNlLFxuICAgICAgICAuLi5hdXRoT3B0aW9ucyxcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBjb25maWcgaGFzIHByb3RvY29sTW9kZSBzZXQgdG8gUHJvdG9jb2xNb2RlLk9JREMsIGZhbHNlIG90aGVyd2lzZVxuICogQHBhcmFtIENsaWVudENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2lkY1Byb3RvY29sTW9kZShjb25maWc6IENsaWVudENvbmZpZ3VyYXRpb24pOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBjb25maWcuYXV0aE9wdGlvbnMuYXV0aG9yaXR5Lm9wdGlvbnMucHJvdG9jb2xNb2RlID09PSBQcm90b2NvbE1vZGUuT0lEQ1xuICAgICk7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB0eXBlIENjc0NyZWRlbnRpYWwgPSB7XG4gICAgY3JlZGVudGlhbDogc3RyaW5nO1xuICAgIHR5cGU6IENjc0NyZWRlbnRpYWxUeXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IENjc0NyZWRlbnRpYWxUeXBlID0ge1xuICAgIEhPTUVfQUNDT1VOVF9JRDogXCJob21lX2FjY291bnRfaWRcIixcbiAgICBVUE46IFwiVVBOXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgQ2NzQ3JlZGVudGlhbFR5cGUgPVxuICAgICh0eXBlb2YgQ2NzQ3JlZGVudGlhbFR5cGUpW2tleW9mIHR5cGVvZiBDY3NDcmVkZW50aWFsVHlwZV07XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBDTElFTlRfSUQgPSBcImNsaWVudF9pZFwiO1xuZXhwb3J0IGNvbnN0IFJFRElSRUNUX1VSSSA9IFwicmVkaXJlY3RfdXJpXCI7XG5leHBvcnQgY29uc3QgUkVTUE9OU0VfVFlQRSA9IFwicmVzcG9uc2VfdHlwZVwiO1xuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX01PREUgPSBcInJlc3BvbnNlX21vZGVcIjtcbmV4cG9ydCBjb25zdCBHUkFOVF9UWVBFID0gXCJncmFudF90eXBlXCI7XG5leHBvcnQgY29uc3QgQ0xBSU1TID0gXCJjbGFpbXNcIjtcbmV4cG9ydCBjb25zdCBTQ09QRSA9IFwic2NvcGVcIjtcbmV4cG9ydCBjb25zdCBFUlJPUiA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBFUlJPUl9ERVNDUklQVElPTiA9IFwiZXJyb3JfZGVzY3JpcHRpb25cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfVE9LRU4gPSBcImFjY2Vzc190b2tlblwiO1xuZXhwb3J0IGNvbnN0IElEX1RPS0VOID0gXCJpZF90b2tlblwiO1xuZXhwb3J0IGNvbnN0IFJFRlJFU0hfVE9LRU4gPSBcInJlZnJlc2hfdG9rZW5cIjtcbmV4cG9ydCBjb25zdCBFWFBJUkVTX0lOID0gXCJleHBpcmVzX2luXCI7XG5leHBvcnQgY29uc3QgUkVGUkVTSF9UT0tFTl9FWFBJUkVTX0lOID0gXCJyZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW5cIjtcbmV4cG9ydCBjb25zdCBTVEFURSA9IFwic3RhdGVcIjtcbmV4cG9ydCBjb25zdCBOT05DRSA9IFwibm9uY2VcIjtcbmV4cG9ydCBjb25zdCBQUk9NUFQgPSBcInByb21wdFwiO1xuZXhwb3J0IGNvbnN0IFNFU1NJT05fU1RBVEUgPSBcInNlc3Npb25fc3RhdGVcIjtcbmV4cG9ydCBjb25zdCBDTElFTlRfSU5GTyA9IFwiY2xpZW50X2luZm9cIjtcbmV4cG9ydCBjb25zdCBDT0RFID0gXCJjb2RlXCI7XG5leHBvcnQgY29uc3QgQ09ERV9DSEFMTEVOR0UgPSBcImNvZGVfY2hhbGxlbmdlXCI7XG5leHBvcnQgY29uc3QgQ09ERV9DSEFMTEVOR0VfTUVUSE9EID0gXCJjb2RlX2NoYWxsZW5nZV9tZXRob2RcIjtcbmV4cG9ydCBjb25zdCBDT0RFX1ZFUklGSUVSID0gXCJjb2RlX3ZlcmlmaWVyXCI7XG5leHBvcnQgY29uc3QgQ0xJRU5UX1JFUVVFU1RfSUQgPSBcImNsaWVudC1yZXF1ZXN0LWlkXCI7XG5leHBvcnQgY29uc3QgWF9DTElFTlRfU0tVID0gXCJ4LWNsaWVudC1TS1VcIjtcbmV4cG9ydCBjb25zdCBYX0NMSUVOVF9WRVIgPSBcIngtY2xpZW50LVZFUlwiO1xuZXhwb3J0IGNvbnN0IFhfQ0xJRU5UX09TID0gXCJ4LWNsaWVudC1PU1wiO1xuZXhwb3J0IGNvbnN0IFhfQ0xJRU5UX0NQVSA9IFwieC1jbGllbnQtQ1BVXCI7XG5leHBvcnQgY29uc3QgWF9DTElFTlRfQ1VSUl9URUxFTSA9IFwieC1jbGllbnQtY3VycmVudC10ZWxlbWV0cnlcIjtcbmV4cG9ydCBjb25zdCBYX0NMSUVOVF9MQVNUX1RFTEVNID0gXCJ4LWNsaWVudC1sYXN0LXRlbGVtZXRyeVwiO1xuZXhwb3J0IGNvbnN0IFhfTVNfTElCX0NBUEFCSUxJVFkgPSBcIngtbXMtbGliLWNhcGFiaWxpdHlcIjtcbmV4cG9ydCBjb25zdCBYX0FQUF9OQU1FID0gXCJ4LWFwcC1uYW1lXCI7XG5leHBvcnQgY29uc3QgWF9BUFBfVkVSID0gXCJ4LWFwcC12ZXJcIjtcbmV4cG9ydCBjb25zdCBQT1NUX0xPR09VVF9VUkkgPSBcInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaVwiO1xuZXhwb3J0IGNvbnN0IElEX1RPS0VOX0hJTlQgPSBcImlkX3Rva2VuX2hpbnRcIjtcbmV4cG9ydCBjb25zdCBERVZJQ0VfQ09ERSA9IFwiZGV2aWNlX2NvZGVcIjtcbmV4cG9ydCBjb25zdCBDTElFTlRfU0VDUkVUID0gXCJjbGllbnRfc2VjcmV0XCI7XG5leHBvcnQgY29uc3QgQ0xJRU5UX0FTU0VSVElPTiA9IFwiY2xpZW50X2Fzc2VydGlvblwiO1xuZXhwb3J0IGNvbnN0IENMSUVOVF9BU1NFUlRJT05fVFlQRSA9IFwiY2xpZW50X2Fzc2VydGlvbl90eXBlXCI7XG5leHBvcnQgY29uc3QgVE9LRU5fVFlQRSA9IFwidG9rZW5fdHlwZVwiO1xuZXhwb3J0IGNvbnN0IFJFUV9DTkYgPSBcInJlcV9jbmZcIjtcbmV4cG9ydCBjb25zdCBPQk9fQVNTRVJUSU9OID0gXCJhc3NlcnRpb25cIjtcbmV4cG9ydCBjb25zdCBSRVFVRVNURURfVE9LRU5fVVNFID0gXCJyZXF1ZXN0ZWRfdG9rZW5fdXNlXCI7XG5leHBvcnQgY29uc3QgT05fQkVIQUxGX09GID0gXCJvbl9iZWhhbGZfb2ZcIjtcbmV4cG9ydCBjb25zdCBGT0NJID0gXCJmb2NpXCI7XG5leHBvcnQgY29uc3QgQ0NTX0hFQURFUiA9IFwiWC1BbmNob3JNYWlsYm94XCI7XG5leHBvcnQgY29uc3QgUkVUVVJOX1NQQV9DT0RFID0gXCJyZXR1cm5fc3BhX2NvZGVcIjtcbmV4cG9ydCBjb25zdCBOQVRJVkVfQlJPS0VSID0gXCJuYXRpdmVicm9rZXJcIjtcbmV4cG9ydCBjb25zdCBMT0dPVVRfSElOVCA9IFwibG9nb3V0X2hpbnRcIjtcbmV4cG9ydCBjb25zdCBTSUQgPSBcInNpZFwiO1xuZXhwb3J0IGNvbnN0IExPR0lOX0hJTlQgPSBcImxvZ2luX2hpbnRcIjtcbmV4cG9ydCBjb25zdCBET01BSU5fSElOVCA9IFwiZG9tYWluX2hpbnRcIjtcbmV4cG9ydCBjb25zdCBYX0NMSUVOVF9FWFRSQV9TS1UgPSBcIngtY2xpZW50LXh0cmEtc2t1XCI7XG5leHBvcnQgY29uc3QgQlJPS0VSX0NMSUVOVF9JRCA9IFwiYnJrX2NsaWVudF9pZFwiO1xuZXhwb3J0IGNvbnN0IEJST0tFUl9SRURJUkVDVF9VUkkgPSBcImJya19yZWRpcmVjdF91cmlcIjtcbmV4cG9ydCBjb25zdCBJTlNUQU5DRV9BV0FSRSA9IFwiaW5zdGFuY2VfYXdhcmVcIjtcbmV4cG9ydCBjb25zdCBFQVJfSldLID0gXCJlYXJfandrXCI7XG5leHBvcnQgY29uc3QgRUFSX0pXRV9DUllQVE8gPSBcImVhcl9qd2VfY3J5cHRvXCI7XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgUmVzcG9uc2VNb2RlLFxuICAgIENMSUVOVF9JTkZPLFxuICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLFxuICAgIENsYWltc1JlcXVlc3RLZXlzLFxuICAgIFBhc3N3b3JkR3JhbnRDb25zdGFudHMsXG4gICAgT0lEQ19ERUZBVUxUX1NDT1BFUyxcbiAgICBUaHJvdHRsaW5nQ29uc3RhbnRzLFxuICAgIEhlYWRlck5hbWVzLFxuICAgIE9BdXRoUmVzcG9uc2VUeXBlLFxufSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgKiBhcyBBQURTZXJ2ZXJQYXJhbUtleXMgZnJvbSBcIi4uL2NvbnN0YW50cy9BQURTZXJ2ZXJQYXJhbUtleXMuanNcIjtcbmltcG9ydCB7IFNjb3BlU2V0IH0gZnJvbSBcIi4vU2NvcGVTZXQuanNcIjtcbmltcG9ydCB7XG4gICAgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLFxuICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmpzXCI7XG5pbXBvcnQgeyBTdHJpbmdEaWN0IH0gZnJvbSBcIi4uL3V0aWxzL01zYWxUeXBlcy5qc1wiO1xuaW1wb3J0IHtcbiAgICBBcHBsaWNhdGlvblRlbGVtZXRyeSxcbiAgICBMaWJyYXJ5SW5mbyxcbn0gZnJvbSBcIi4uL2NvbmZpZy9DbGllbnRDb25maWd1cmF0aW9uLmpzXCI7XG5pbXBvcnQgeyBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyIH0gZnJvbSBcIi4uL3RlbGVtZXRyeS9zZXJ2ZXIvU2VydmVyVGVsZW1ldHJ5TWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgQ2xpZW50SW5mbyB9IGZyb20gXCIuLi9hY2NvdW50L0NsaWVudEluZm8uanNcIjtcbmltcG9ydCB7IElQZXJmb3JtYW5jZUNsaWVudCB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvSVBlcmZvcm1hbmNlQ2xpZW50LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnN0cnVtZW50QnJva2VyUGFyYW1zKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgY29ycmVsYXRpb25JZD86IHN0cmluZyxcbiAgICBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudFxuKTogdm9pZCB7XG4gICAgaWYgKCFjb3JyZWxhdGlvbklkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjbGllbnRJZCA9IHBhcmFtZXRlcnMuZ2V0KEFBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSUQpO1xuICAgIGlmIChjbGllbnRJZCAmJiBwYXJhbWV0ZXJzLmhhcyhBQURTZXJ2ZXJQYXJhbUtleXMuQlJPS0VSX0NMSUVOVF9JRCkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbWJlZGRlZENsaWVudElkOiBjbGllbnRJZCxcbiAgICAgICAgICAgICAgICBlbWJlZGRlZFJlZGlyZWN0VXJpOiBwYXJhbWV0ZXJzLmdldChcbiAgICAgICAgICAgICAgICAgICAgQUFEU2VydmVyUGFyYW1LZXlzLlJFRElSRUNUX1VSSVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHJlc3BvbnNlX3R5cGVcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gcmVzcG9uc2VUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXNwb25zZVR5cGUoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICByZXNwb25zZVR5cGU6IE9BdXRoUmVzcG9uc2VUeXBlXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuUkVTUE9OU0VfVFlQRSwgcmVzcG9uc2VUeXBlKTtcbn1cblxuLyoqXG4gKiBhZGQgcmVzcG9uc2VfbW9kZS4gZGVmYXVsdHMgdG8gcXVlcnkuXG4gKiBAcGFyYW0gcmVzcG9uc2VNb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXNwb25zZU1vZGUoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICByZXNwb25zZU1vZGU/OiBSZXNwb25zZU1vZGVcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KFxuICAgICAgICBBQURTZXJ2ZXJQYXJhbUtleXMuUkVTUE9OU0VfTU9ERSxcbiAgICAgICAgcmVzcG9uc2VNb2RlID8gcmVzcG9uc2VNb2RlIDogUmVzcG9uc2VNb2RlLlFVRVJZXG4gICAgKTtcbn1cblxuLyoqXG4gKiBBZGQgZmxhZyB0byBpbmRpY2F0ZSBTVFMgc2hvdWxkIGF0dGVtcHQgdG8gdXNlIFdBTSBpZiBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZE5hdGl2ZUJyb2tlcihwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XG4gICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLk5BVElWRV9CUk9LRVIsIFwiMVwiKTtcbn1cblxuLyoqXG4gKiBhZGQgc2NvcGVzLiBzZXQgYWRkT2lkY1Njb3BlcyB0byBmYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgc2NvcGVzIGluIG5vbi11c2VyIHNjZW5hcmlvc1xuICogQHBhcmFtIHNjb3BlU2V0XG4gKiBAcGFyYW0gYWRkT2lkY1Njb3Blc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkU2NvcGVzKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgc2NvcGVzOiBzdHJpbmdbXSxcbiAgICBhZGRPaWRjU2NvcGVzOiBib29sZWFuID0gdHJ1ZSxcbiAgICBkZWZhdWx0U2NvcGVzOiBBcnJheTxzdHJpbmc+ID0gT0lEQ19ERUZBVUxUX1NDT1BFU1xuKTogdm9pZCB7XG4gICAgLy8gQWx3YXlzIGFkZCBvcGVuaWQgdG8gdGhlIHNjb3BlcyB3aGVuIGFkZGluZyBPSURDIHNjb3Blc1xuICAgIGlmIChcbiAgICAgICAgYWRkT2lkY1Njb3BlcyAmJlxuICAgICAgICAhZGVmYXVsdFNjb3Blcy5pbmNsdWRlcyhcIm9wZW5pZFwiKSAmJlxuICAgICAgICAhc2NvcGVzLmluY2x1ZGVzKFwib3BlbmlkXCIpXG4gICAgKSB7XG4gICAgICAgIGRlZmF1bHRTY29wZXMucHVzaChcIm9wZW5pZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdFNjb3BlcyA9IGFkZE9pZGNTY29wZXNcbiAgICAgICAgPyBbLi4uKHNjb3BlcyB8fCBbXSksIC4uLmRlZmF1bHRTY29wZXNdXG4gICAgICAgIDogc2NvcGVzIHx8IFtdO1xuICAgIGNvbnN0IHNjb3BlU2V0ID0gbmV3IFNjb3BlU2V0KHJlcXVlc3RTY29wZXMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5TQ09QRSwgc2NvcGVTZXQucHJpbnRTY29wZXMoKSk7XG59XG5cbi8qKlxuICogYWRkIGNsaWVudElkXG4gKiBAcGFyYW0gY2xpZW50SWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENsaWVudElkKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgY2xpZW50SWQ6IHN0cmluZ1xuKTogdm9pZCB7XG4gICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9JRCwgY2xpZW50SWQpO1xufVxuXG4vKipcbiAqIGFkZCByZWRpcmVjdF91cmlcbiAqIEBwYXJhbSByZWRpcmVjdFVyaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVkaXJlY3RVcmkoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICByZWRpcmVjdFVyaTogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuUkVESVJFQ1RfVVJJLCByZWRpcmVjdFVyaSk7XG59XG5cbi8qKlxuICogYWRkIHBvc3QgbG9nb3V0IHJlZGlyZWN0VXJpXG4gKiBAcGFyYW0gcmVkaXJlY3RVcmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFBvc3RMb2dvdXRSZWRpcmVjdFVyaShcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIHJlZGlyZWN0VXJpOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5QT1NUX0xPR09VVF9VUkksIHJlZGlyZWN0VXJpKTtcbn1cblxuLyoqXG4gKiBhZGQgaWRfdG9rZW5faGludCB0byBsb2dvdXQgcmVxdWVzdFxuICogQHBhcmFtIGlkVG9rZW5IaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRJZFRva2VuSGludChcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGlkVG9rZW5IaW50OiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5JRF9UT0tFTl9ISU5ULCBpZFRva2VuSGludCk7XG59XG5cbi8qKlxuICogYWRkIGRvbWFpbl9oaW50XG4gKiBAcGFyYW0gZG9tYWluSGludFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRG9tYWluSGludChcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGRvbWFpbkhpbnQ6IHN0cmluZ1xuKTogdm9pZCB7XG4gICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLkRPTUFJTl9ISU5ULCBkb21haW5IaW50KTtcbn1cblxuLyoqXG4gKiBhZGQgbG9naW5faGludFxuICogQHBhcmFtIGxvZ2luSGludFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9naW5IaW50KFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgbG9naW5IaW50OiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5MT0dJTl9ISU5ULCBsb2dpbkhpbnQpO1xufVxuXG4vKipcbiAqIEFkZHMgdGhlIENDUyAoQ2FjaGUgQ3JlZGVudGlhbCBTZXJ2aWNlKSBxdWVyeSBwYXJhbWV0ZXIgZm9yIGxvZ2luX2hpbnRcbiAqIEBwYXJhbSBsb2dpbkhpbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENjc1VwbihcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGxvZ2luSGludDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChIZWFkZXJOYW1lcy5DQ1NfSEVBREVSLCBgVVBOOiR7bG9naW5IaW50fWApO1xufVxuXG4vKipcbiAqIEFkZHMgdGhlIENDUyAoQ2FjaGUgQ3JlZGVudGlhbCBTZXJ2aWNlKSBxdWVyeSBwYXJhbWV0ZXIgZm9yIGFjY291bnQgb2JqZWN0XG4gKiBAcGFyYW0gbG9naW5IaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDY3NPaWQoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBjbGllbnRJbmZvOiBDbGllbnRJbmZvXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChcbiAgICAgICAgSGVhZGVyTmFtZXMuQ0NTX0hFQURFUixcbiAgICAgICAgYE9pZDoke2NsaWVudEluZm8udWlkfUAke2NsaWVudEluZm8udXRpZH1gXG4gICAgKTtcbn1cblxuLyoqXG4gKiBhZGQgc2lkXG4gKiBAcGFyYW0gc2lkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTaWQocGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPiwgc2lkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuU0lELCBzaWQpO1xufVxuXG4vKipcbiAqIGFkZCBjbGFpbXNcbiAqIEBwYXJhbSBjbGFpbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYWltcyhcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGNsYWltcz86IHN0cmluZyxcbiAgICBjbGllbnRDYXBhYmlsaXRpZXM/OiBBcnJheTxzdHJpbmc+XG4pOiB2b2lkIHtcbiAgICBjb25zdCBtZXJnZWRDbGFpbXMgPSBhZGRDbGllbnRDYXBhYmlsaXRpZXNUb0NsYWltcyhcbiAgICAgICAgY2xhaW1zLFxuICAgICAgICBjbGllbnRDYXBhYmlsaXRpZXNcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICAgIEpTT04ucGFyc2UobWVyZ2VkQ2xhaW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRDbGFpbXNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLkNMQUlNUywgbWVyZ2VkQ2xhaW1zKTtcbn1cblxuLyoqXG4gKiBhZGQgY29ycmVsYXRpb25JZFxuICogQHBhcmFtIGNvcnJlbGF0aW9uSWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvcnJlbGF0aW9uSWQoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBjb3JyZWxhdGlvbklkOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfUkVRVUVTVF9JRCwgY29ycmVsYXRpb25JZCk7XG59XG5cbi8qKlxuICogYWRkIGxpYnJhcnkgaW5mbyBxdWVyeSBwYXJhbXNcbiAqIEBwYXJhbSBsaWJyYXJ5SW5mb1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTGlicmFyeUluZm8oXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBsaWJyYXJ5SW5mbzogTGlicmFyeUluZm9cbik6IHZvaWQge1xuICAgIC8vIFRlbGVtZXRyeSBJbmZvXG4gICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX1NLVSwgbGlicmFyeUluZm8uc2t1KTtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuWF9DTElFTlRfVkVSLCBsaWJyYXJ5SW5mby52ZXJzaW9uKTtcbiAgICBpZiAobGlicmFyeUluZm8ub3MpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX09TLCBsaWJyYXJ5SW5mby5vcyk7XG4gICAgfVxuICAgIGlmIChsaWJyYXJ5SW5mby5jcHUpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX0NQVSwgbGlicmFyeUluZm8uY3B1KTtcbiAgICB9XG59XG5cbi8qKlxuICogQWRkIGNsaWVudCB0ZWxlbWV0cnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIGFwcFRlbGVtZXRyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQXBwbGljYXRpb25UZWxlbWV0cnkoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBhcHBUZWxlbWV0cnk6IEFwcGxpY2F0aW9uVGVsZW1ldHJ5XG4pOiB2b2lkIHtcbiAgICBpZiAoYXBwVGVsZW1ldHJ5Py5hcHBOYW1lKSB7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5YX0FQUF9OQU1FLCBhcHBUZWxlbWV0cnkuYXBwTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGFwcFRlbGVtZXRyeT8uYXBwVmVyc2lvbikge1xuICAgICAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuWF9BUFBfVkVSLCBhcHBUZWxlbWV0cnkuYXBwVmVyc2lvbik7XG4gICAgfVxufVxuXG4vKipcbiAqIGFkZCBwcm9tcHRcbiAqIEBwYXJhbSBwcm9tcHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb21wdChcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIHByb21wdDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuUFJPTVBULCBwcm9tcHQpO1xufVxuXG4vKipcbiAqIGFkZCBzdGF0ZVxuICogQHBhcmFtIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdGF0ZShwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LCBzdGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5TVEFURSwgc3RhdGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhZGQgbm9uY2VcbiAqIEBwYXJhbSBub25jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTm9uY2UocGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPiwgbm9uY2U6IHN0cmluZyk6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5OT05DRSwgbm9uY2UpO1xufVxuXG4vKipcbiAqIGFkZCBjb2RlX2NoYWxsZW5nZSBhbmQgY29kZV9jaGFsbGVuZ2VfbWV0aG9kXG4gKiAtIHRocm93IGlmIGVpdGhlciBvZiB0aGVtIGFyZSBub3QgcGFzc2VkXG4gKiBAcGFyYW0gY29kZUNoYWxsZW5nZVxuICogQHBhcmFtIGNvZGVDaGFsbGVuZ2VNZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvZGVDaGFsbGVuZ2VQYXJhbXMoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBjb2RlQ2hhbGxlbmdlPzogc3RyaW5nLFxuICAgIGNvZGVDaGFsbGVuZ2VNZXRob2Q/OiBzdHJpbmdcbik6IHZvaWQge1xuICAgIGlmIChjb2RlQ2hhbGxlbmdlICYmIGNvZGVDaGFsbGVuZ2VNZXRob2QpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLkNPREVfQ0hBTExFTkdFLCBjb2RlQ2hhbGxlbmdlKTtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoXG4gICAgICAgICAgICBBQURTZXJ2ZXJQYXJhbUtleXMuQ09ERV9DSEFMTEVOR0VfTUVUSE9ELFxuICAgICAgICAgICAgY29kZUNoYWxsZW5nZU1ldGhvZFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihcbiAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnBrY2VQYXJhbXNNaXNzaW5nXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIGFkZCB0aGUgYGF1dGhvcml6YXRpb25fY29kZWAgcGFzc2VkIGJ5IHRoZSB1c2VyIHRvIGV4Y2hhbmdlIGZvciBhIHRva2VuXG4gKiBAcGFyYW0gY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbkNvZGUoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBjb2RlOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5DT0RFLCBjb2RlKTtcbn1cblxuLyoqXG4gKiBhZGQgdGhlIGBhdXRob3JpemF0aW9uX2NvZGVgIHBhc3NlZCBieSB0aGUgdXNlciB0byBleGNoYW5nZSBmb3IgYSB0b2tlblxuICogQHBhcmFtIGNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERldmljZUNvZGUoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBjb2RlOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5ERVZJQ0VfQ09ERSwgY29kZSk7XG59XG5cbi8qKlxuICogYWRkIHRoZSBgcmVmcmVzaFRva2VuYCBwYXNzZWQgYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSByZWZyZXNoVG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJlZnJlc2hUb2tlbihcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIHJlZnJlc2hUb2tlbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuUkVGUkVTSF9UT0tFTiwgcmVmcmVzaFRva2VuKTtcbn1cblxuLyoqXG4gKiBhZGQgdGhlIGBjb2RlX3ZlcmlmaWVyYCBwYXNzZWQgYnkgdGhlIHVzZXIgdG8gZXhjaGFuZ2UgZm9yIGEgdG9rZW5cbiAqIEBwYXJhbSBjb2RlVmVyaWZpZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvZGVWZXJpZmllcihcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGNvZGVWZXJpZmllcjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuQ09ERV9WRVJJRklFUiwgY29kZVZlcmlmaWVyKTtcbn1cblxuLyoqXG4gKiBhZGQgY2xpZW50X3NlY3JldFxuICogQHBhcmFtIGNsaWVudFNlY3JldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xpZW50U2VjcmV0KFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgY2xpZW50U2VjcmV0OiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfU0VDUkVULCBjbGllbnRTZWNyZXQpO1xufVxuXG4vKipcbiAqIGFkZCBjbGllbnRBc3NlcnRpb24gZm9yIGNvbmZpZGVudGlhbCBjbGllbnQgZmxvd3NcbiAqIEBwYXJhbSBjbGllbnRBc3NlcnRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENsaWVudEFzc2VydGlvbihcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGNsaWVudEFzc2VydGlvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBpZiAoY2xpZW50QXNzZXJ0aW9uKSB7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfQVNTRVJUSU9OLCBjbGllbnRBc3NlcnRpb24pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhZGQgY2xpZW50QXNzZXJ0aW9uVHlwZSBmb3IgY29uZmlkZW50aWFsIGNsaWVudCBmbG93c1xuICogQHBhcmFtIGNsaWVudEFzc2VydGlvblR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENsaWVudEFzc2VydGlvblR5cGUoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBjbGllbnRBc3NlcnRpb25UeXBlOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIGlmIChjbGllbnRBc3NlcnRpb25UeXBlKSB7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KFxuICAgICAgICAgICAgQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9BU1NFUlRJT05fVFlQRSxcbiAgICAgICAgICAgIGNsaWVudEFzc2VydGlvblR5cGVcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogYWRkIE9CTyBhc3NlcnRpb24gZm9yIGNvbmZpZGVudGlhbCBjbGllbnQgZmxvd3NcbiAqIEBwYXJhbSBjbGllbnRBc3NlcnRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZE9ib0Fzc2VydGlvbihcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIG9ib0Fzc2VydGlvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuT0JPX0FTU0VSVElPTiwgb2JvQXNzZXJ0aW9uKTtcbn1cblxuLyoqXG4gKiBhZGQgZ3JhbnQgdHlwZVxuICogQHBhcmFtIGdyYW50VHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVxdWVzdFRva2VuVXNlKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgdG9rZW5Vc2U6IHN0cmluZ1xuKTogdm9pZCB7XG4gICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLlJFUVVFU1RFRF9UT0tFTl9VU0UsIHRva2VuVXNlKTtcbn1cblxuLyoqXG4gKiBhZGQgZ3JhbnQgdHlwZVxuICogQHBhcmFtIGdyYW50VHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkR3JhbnRUeXBlKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZ3JhbnRUeXBlOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5HUkFOVF9UWVBFLCBncmFudFR5cGUpO1xufVxuXG4vKipcbiAqIGFkZCBjbGllbnQgaW5mb1xuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENsaWVudEluZm8ocGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KENMSUVOVF9JTkZPLCBcIjFcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbnN0YW5jZUF3YXJlKHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcbiAgICBpZiAoIXBhcmFtZXRlcnMuaGFzKEFBRFNlcnZlclBhcmFtS2V5cy5JTlNUQU5DRV9BV0FSRSkpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLklOU1RBTkNFX0FXQVJFLCBcInRydWVcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIGFkZCBleHRyYVF1ZXJ5UGFyYW1zXG4gKiBAcGFyYW0gZVFQYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZVFQYXJhbXM6IFN0cmluZ0RpY3Rcbik6IHZvaWQge1xuICAgIE9iamVjdC5lbnRyaWVzKGVRUGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLmhhcyhrZXkpICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xpZW50Q2FwYWJpbGl0aWVzVG9DbGFpbXMoXG4gICAgY2xhaW1zPzogc3RyaW5nLFxuICAgIGNsaWVudENhcGFiaWxpdGllcz86IEFycmF5PHN0cmluZz5cbik6IHN0cmluZyB7XG4gICAgbGV0IG1lcmdlZENsYWltczogb2JqZWN0O1xuXG4gICAgLy8gUGFyc2UgcHJvdmlkZWQgY2xhaW1zIGludG8gSlNPTiBvYmplY3Qgb3IgaW5pdGlhbGl6ZSBlbXB0eSBvYmplY3RcbiAgICBpZiAoIWNsYWltcykge1xuICAgICAgICBtZXJnZWRDbGFpbXMgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWVyZ2VkQ2xhaW1zID0gSlNPTi5wYXJzZShjbGFpbXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZENsYWltc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGllbnRDYXBhYmlsaXRpZXMgJiYgY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCFtZXJnZWRDbGFpbXMuaGFzT3duUHJvcGVydHkoQ2xhaW1zUmVxdWVzdEtleXMuQUNDRVNTX1RPS0VOKSkge1xuICAgICAgICAgICAgLy8gQWRkIGFjY2Vzc190b2tlbiBrZXkgdG8gY2xhaW1zIG9iamVjdFxuICAgICAgICAgICAgbWVyZ2VkQ2xhaW1zW0NsYWltc1JlcXVlc3RLZXlzLkFDQ0VTU19UT0tFTl0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB4bXNfY2MgY2xhaW0gd2l0aCBwcm92aWRlZCBjbGllbnRDYXBhYmlsaXRpZXMgdG8gYWNjZXNzX3Rva2VuIGtleVxuICAgICAgICBtZXJnZWRDbGFpbXNbQ2xhaW1zUmVxdWVzdEtleXMuQUNDRVNTX1RPS0VOXVtDbGFpbXNSZXF1ZXN0S2V5cy5YTVNfQ0NdID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsaWVudENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lcmdlZENsYWltcyk7XG59XG5cbi8qKlxuICogYWRkcyBgdXNlcm5hbWVgIGZvciBQYXNzd29yZCBHcmFudCBmbG93XG4gKiBAcGFyYW0gdXNlcm5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFVzZXJuYW1lKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuKTogdm9pZCB7XG4gICAgcGFyYW1ldGVycy5zZXQoUGFzc3dvcmRHcmFudENvbnN0YW50cy51c2VybmFtZSwgdXNlcm5hbWUpO1xufVxuXG4vKipcbiAqIGFkZHMgYHBhc3N3b3JkYCBmb3IgUGFzc3dvcmQgR3JhbnQgZmxvd1xuICogQHBhcmFtIHBhc3N3b3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQYXNzd29yZChcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIHBhc3N3b3JkOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIHBhcmFtZXRlcnMuc2V0KFBhc3N3b3JkR3JhbnRDb25zdGFudHMucGFzc3dvcmQsIHBhc3N3b3JkKTtcbn1cblxuLyoqXG4gKiBhZGQgcG9wX2p3ayB0byBxdWVyeSBwYXJhbXNcbiAqIEBwYXJhbSBjbmZTdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFBvcFRva2VuKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgY25mU3RyaW5nOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIGlmIChjbmZTdHJpbmcpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLlRPS0VOX1RZUEUsIEF1dGhlbnRpY2F0aW9uU2NoZW1lLlBPUCk7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5SRVFfQ05GLCBjbmZTdHJpbmcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhZGQgU1NIIEpXSyBhbmQga2V5IElEIHRvIHF1ZXJ5IHBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkU3NoSndrKFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgc3NoSndrU3RyaW5nOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIGlmIChzc2hKd2tTdHJpbmcpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLlRPS0VOX1RZUEUsIEF1dGhlbnRpY2F0aW9uU2NoZW1lLlNTSCk7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KEFBRFNlcnZlclBhcmFtS2V5cy5SRVFfQ05GLCBzc2hKd2tTdHJpbmcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhZGQgc2VydmVyIHRlbGVtZXRyeSBmaWVsZHNcbiAqIEBwYXJhbSBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyOiBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChcbiAgICAgICAgQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX0NVUlJfVEVMRU0sXG4gICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXIuZ2VuZXJhdGVDdXJyZW50UmVxdWVzdEhlYWRlclZhbHVlKClcbiAgICApO1xuICAgIHBhcmFtZXRlcnMuc2V0KFxuICAgICAgICBBQURTZXJ2ZXJQYXJhbUtleXMuWF9DTElFTlRfTEFTVF9URUxFTSxcbiAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5nZW5lcmF0ZUxhc3RSZXF1ZXN0SGVhZGVyVmFsdWUoKVxuICAgICk7XG59XG5cbi8qKlxuICogQWRkcyBwYXJhbWV0ZXIgdGhhdCBpbmRpY2F0ZXMgdG8gdGhlIHNlcnZlciB0aGF0IHRocm90dGxpbmcgaXMgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUaHJvdHRsaW5nKHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChcbiAgICAgICAgQUFEU2VydmVyUGFyYW1LZXlzLlhfTVNfTElCX0NBUEFCSUxJVFksXG4gICAgICAgIFRocm90dGxpbmdDb25zdGFudHMuWF9NU19MSUJfQ0FQQUJJTElUWV9WQUxVRVxuICAgICk7XG59XG5cbi8qKlxuICogQWRkcyBsb2dvdXRfaGludCBwYXJhbWV0ZXIgZm9yIFwic2lsZW50XCIgbG9nb3V0IHdoaWNoIHByZXZlbnQgc2VydmVyIGFjY291bnQgcGlja2VyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRMb2dvdXRIaW50KFxuICAgIHBhcmFtZXRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gICAgbG9nb3V0SGludDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuTE9HT1VUX0hJTlQsIGxvZ291dEhpbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQnJva2VyUGFyYW1ldGVycyhcbiAgICBwYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGJyb2tlckNsaWVudElkOiBzdHJpbmcsXG4gICAgYnJva2VyUmVkaXJlY3RVcmk6IHN0cmluZ1xuKTogdm9pZCB7XG4gICAgaWYgKCFwYXJhbWV0ZXJzLmhhcyhBQURTZXJ2ZXJQYXJhbUtleXMuQlJPS0VSX0NMSUVOVF9JRCkpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLkJST0tFUl9DTElFTlRfSUQsIGJyb2tlckNsaWVudElkKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbWV0ZXJzLmhhcyhBQURTZXJ2ZXJQYXJhbUtleXMuQlJPS0VSX1JFRElSRUNUX1VSSSkpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoXG4gICAgICAgICAgICBBQURTZXJ2ZXJQYXJhbUtleXMuQlJPS0VSX1JFRElSRUNUX1VSSSxcbiAgICAgICAgICAgIGJyb2tlclJlZGlyZWN0VXJpXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBFQVIgKEVuY3J5cHRlZCBBdXRob3JpemUgUmVzcG9uc2UpIHJlcXVlc3QgcGFyYW1ldGVyc1xuICogQHBhcmFtIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBqd2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVBUlBhcmFtZXRlcnMoXG4gICAgcGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgICBqd2s6IHN0cmluZ1xuKTogdm9pZCB7XG4gICAgcGFyYW1ldGVycy5zZXQoQUFEU2VydmVyUGFyYW1LZXlzLkVBUl9KV0ssIGVuY29kZVVSSUNvbXBvbmVudChqd2spKTtcblxuICAgIC8vIGVhcl9qd2VfY3J5cHRvIHdpbGwgYWx3YXlzIGhhdmUgdmFsdWU6IHtcImFsZ1wiOlwiZGlyXCIsXCJlbmNcIjpcIkEyNTZHQ01cIn0gc28gd2UgY2FuIGhhcmRjb2RlIHRoaXNcbiAgICBjb25zdCBqd2VDcnlwdG9CNjRFbmNvZGVkID0gXCJleUpoYkdjaU9pSmthWElpTENKbGJtTWlPaUpCTWpVMlIwTk5JbjBcIjtcbiAgICBwYXJhbWV0ZXJzLnNldChBQURTZXJ2ZXJQYXJhbUtleXMuRUFSX0pXRV9DUllQVE8sIGp3ZUNyeXB0b0I2NEVuY29kZWQpO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRlbmFudCBEaXNjb3ZlcnkgUmVzcG9uc2Ugd2hpY2ggY29udGFpbnMgdGhlIHJlbGV2YW50IE9BdXRoIGVuZHBvaW50cyBhbmQgZGF0YSBuZWVkZWQgZm9yIGF1dGhlbnRpY2F0aW9uIGFuZCBhdXRob3JpemF0aW9uLlxuICovXG5leHBvcnQgdHlwZSBPcGVuSWRDb25maWdSZXNwb25zZSA9IHtcbiAgICBhdXRob3JpemF0aW9uX2VuZHBvaW50OiBzdHJpbmc7XG4gICAgdG9rZW5fZW5kcG9pbnQ6IHN0cmluZztcbiAgICBlbmRfc2Vzc2lvbl9lbmRwb2ludD86IHN0cmluZztcbiAgICBpc3N1ZXI6IHN0cmluZztcbiAgICBqd2tzX3VyaTogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlbklkQ29uZmlnUmVzcG9uc2UocmVzcG9uc2U6IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIHJlc3BvbnNlLmhhc093blByb3BlcnR5KFwiYXV0aG9yaXphdGlvbl9lbmRwb2ludFwiKSAmJlxuICAgICAgICByZXNwb25zZS5oYXNPd25Qcm9wZXJ0eShcInRva2VuX2VuZHBvaW50XCIpICYmXG4gICAgICAgIHJlc3BvbnNlLmhhc093blByb3BlcnR5KFwiaXNzdWVyXCIpICYmXG4gICAgICAgIHJlc3BvbnNlLmhhc093blByb3BlcnR5KFwiandrc191cmlcIilcbiAgICApO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDbG91ZERpc2NvdmVyeU1ldGFkYXRhIH0gZnJvbSBcIi4vQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YS5qc1wiO1xuXG4vKipcbiAqIFRoZSBPcGVuSUQgQ29uZmlndXJhdGlvbiBFbmRwb2ludCBSZXNwb25zZSB0eXBlLiBVc2VkIGJ5IHRoZSBhdXRob3JpdHkgY2xhc3MgdG8gZ2V0IHJlbGV2YW50IE9BdXRoIGVuZHBvaW50cy5cbiAqL1xuZXhwb3J0IHR5cGUgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlID0ge1xuICAgIHRlbmFudF9kaXNjb3ZlcnlfZW5kcG9pbnQ6IHN0cmluZztcbiAgICBtZXRhZGF0YTogQXJyYXk8Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YT47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2UocmVzcG9uc2U6IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIHJlc3BvbnNlLmhhc093blByb3BlcnR5KFwidGVuYW50X2Rpc2NvdmVyeV9lbmRwb2ludFwiKSAmJlxuICAgICAgICByZXNwb25zZS5oYXNPd25Qcm9wZXJ0eShcIm1ldGFkYXRhXCIpXG4gICAgKTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBUaGUgT3BlbklEIENvbmZpZ3VyYXRpb24gRW5kcG9pbnQgUmVzcG9uc2UgdHlwZS4gVXNlZCBieSB0aGUgYXV0aG9yaXR5IGNsYXNzIHRvIGdldCByZWxldmFudCBPQXV0aCBlbmRwb2ludHMuXG4gKi9cbmV4cG9ydCB0eXBlIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlID0ge1xuICAgIGVycm9yOiBTdHJpbmc7XG4gICAgZXJyb3JfZGVzY3JpcHRpb246IFN0cmluZztcbiAgICBlcnJvcl9jb2Rlcz86IEFycmF5PE51bWJlcj47XG4gICAgdGltZXN0YW1wPzogU3RyaW5nO1xuICAgIHRyYWNlX2lkPzogU3RyaW5nO1xuICAgIGNvcnJlbGF0aW9uX2lkPzogU3RyaW5nO1xuICAgIGVycm9yX3VyaT86IFN0cmluZztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlKFxuICAgIHJlc3BvbnNlOiBvYmplY3Rcbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIHJlc3BvbnNlLmhhc093blByb3BlcnR5KFwiZXJyb3JcIikgJiZcbiAgICAgICAgcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoXCJlcnJvcl9kZXNjcmlwdGlvblwiKVxuICAgICk7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRW51bWVyYXRpb24gb2Ygb3BlcmF0aW9ucyB0aGF0IGFyZSBpbnN0cnVtZW50ZWQgYnkgaGF2ZSB0aGVpciBwZXJmb3JtYW5jZSBtZWFzdXJlZCBieSB0aGUgUGVyZm9ybWFuY2VDbGllbnQuXG4gKlxuICogQGV4cG9ydFxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBlcmZvcm1hbmNlRXZlbnRzID0ge1xuICAgIC8qKlxuICAgICAqIGFjcXVpcmVUb2tlbkJ5Q29kZSBBUEkgKG1zYWwtYnJvd3NlciBhbmQgbXNhbC1ub2RlKS5cbiAgICAgKiBVc2VkIHRvIGFjcXVpcmUgdG9rZW5zIGJ5IHRyYWRpbmcgYW4gYXV0aG9yaXphdGlvbiBjb2RlIGFnYWluc3QgdGhlIHRva2VuIGVuZHBvaW50LlxuICAgICAqL1xuICAgIEFjcXVpcmVUb2tlbkJ5Q29kZTogXCJhY3F1aXJlVG9rZW5CeUNvZGVcIixcblxuICAgIC8qKlxuICAgICAqIGFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuIEFQSSAobXNhbC1icm93c2VyIGFuZCBtc2FsLW5vZGUpLlxuICAgICAqIFVzZWQgdG8gcmVuZXcgYW4gYWNjZXNzIHRva2VuIHVzaW5nIGEgcmVmcmVzaCB0b2tlbiBhZ2FpbnN0IHRoZSB0b2tlbiBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBBY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbjogXCJhY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlblwiLFxuXG4gICAgLyoqXG4gICAgICogYWNxdWlyZVRva2VuU2lsZW50IEFQSSAobXNhbC1icm93c2VyIGFuZCBtc2FsLW5vZGUpLlxuICAgICAqIFVzZWQgdG8gc2lsZW50bHkgYWNxdWlyZSBhIG5ldyBhY2Nlc3MgdG9rZW4gKGZyb20gdGhlIGNhY2hlIG9yIHRoZSBuZXR3b3JrKS5cbiAgICAgKi9cbiAgICBBY3F1aXJlVG9rZW5TaWxlbnQ6IFwiYWNxdWlyZVRva2VuU2lsZW50XCIsXG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlVG9rZW5TaWxlbnRBc3luYyAobXNhbC1icm93c2VyKS5cbiAgICAgKiBJbnRlcm5hbCBBUEkgZm9yIGFjcXVpcmVUb2tlblNpbGVudC5cbiAgICAgKi9cbiAgICBBY3F1aXJlVG9rZW5TaWxlbnRBc3luYzogXCJhY3F1aXJlVG9rZW5TaWxlbnRBc3luY1wiLFxuXG4gICAgLyoqXG4gICAgICogYWNxdWlyZVRva2VuUG9wdXAgKG1zYWwtYnJvd3NlcikuXG4gICAgICogVXNlZCB0byBhY3F1aXJlIGEgbmV3IGFjY2VzcyB0b2tlbiBpbnRlcmFjdGl2ZWx5IHRocm91Z2ggcG9wIHVwc1xuICAgICAqL1xuICAgIEFjcXVpcmVUb2tlblBvcHVwOiBcImFjcXVpcmVUb2tlblBvcHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlVG9rZW5QcmVSZWRpcmVjdCAobXNhbC1icm93c2VyKS5cbiAgICAgKiBGaXJzdCBwYXJ0IG9mIHRoZSByZWRpcmVjdCBmbG93LlxuICAgICAqIFVzZWQgdG8gYWNxdWlyZSBhIG5ldyBhY2Nlc3MgdG9rZW4gaW50ZXJhY3RpdmVseSB0aHJvdWdoIHJlZGlyZWN0cy5cbiAgICAgKi9cbiAgICBBY3F1aXJlVG9rZW5QcmVSZWRpcmVjdDogXCJhY3F1aXJlVG9rZW5QcmVSZWRpcmVjdFwiLFxuXG4gICAgLyoqXG4gICAgICogYWNxdWlyZVRva2VuUmVkaXJlY3QgKG1zYWwtYnJvd3NlcikuXG4gICAgICogU2Vjb25kIHBhcnQgb2YgdGhlIHJlZGlyZWN0IGZsb3cuXG4gICAgICogVXNlZCB0byBhY3F1aXJlIGEgbmV3IGFjY2VzcyB0b2tlbiBpbnRlcmFjdGl2ZWx5IHRocm91Z2ggcmVkaXJlY3RzLlxuICAgICAqL1xuICAgIEFjcXVpcmVUb2tlblJlZGlyZWN0OiBcImFjcXVpcmVUb2tlblJlZGlyZWN0XCIsXG5cbiAgICAvKipcbiAgICAgKiBnZXRQdWJsaWNLZXlUaHVtYnByaW50IEFQSSBpbiBDcnlwdG9PcHRzIGNsYXNzIChtc2FsLWJyb3dzZXIpLlxuICAgICAqIFVzZWQgdG8gZ2VuZXJhdGUgYSBwdWJsaWMvcHJpdmF0ZSBrZXlwYWlyIGFuZCBnZW5lcmF0ZSBhIHB1YmxpYyBrZXkgdGh1bWJwcmludCBmb3IgcG9wIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIENyeXB0b09wdHNHZXRQdWJsaWNLZXlUaHVtYnByaW50OiBcImNyeXB0b09wdHNHZXRQdWJsaWNLZXlUaHVtYnByaW50XCIsXG5cbiAgICAvKipcbiAgICAgKiBzaWduSnd0IEFQSSBpbiBDcnlwdG9PcHRzIGNsYXNzIChtc2FsLWJyb3dzZXIpLlxuICAgICAqIFVzZWQgdG8gc2lnbmVkIGEgcG9wIHRva2VuLlxuICAgICAqL1xuICAgIENyeXB0b09wdHNTaWduSnd0OiBcImNyeXB0b09wdHNTaWduSnd0XCIsXG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlVG9rZW4gQVBJIGluIHRoZSBTaWxlbnRDYWNoZUNsaWVudCBjbGFzcyAobXNhbC1icm93c2VyKS5cbiAgICAgKiBVc2VkIHRvIHJlYWQgYWNjZXNzIHRva2VucyBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKi9cbiAgICBTaWxlbnRDYWNoZUNsaWVudEFjcXVpcmVUb2tlbjogXCJzaWxlbnRDYWNoZUNsaWVudEFjcXVpcmVUb2tlblwiLFxuXG4gICAgLyoqXG4gICAgICogYWNxdWlyZVRva2VuIEFQSSBpbiB0aGUgU2lsZW50SWZyYW1lQ2xpZW50IGNsYXNzIChtc2FsLWJyb3dzZXIpLlxuICAgICAqIFVzZWQgdG8gYWNxdWlyZSBhIG5ldyBzZXQgb2YgdG9rZW5zIGZyb20gdGhlIGF1dGhvcml6ZSBlbmRwb2ludCBpbiBhIGhpZGRlbiBpZnJhbWUuXG4gICAgICovXG4gICAgU2lsZW50SWZyYW1lQ2xpZW50QWNxdWlyZVRva2VuOiBcInNpbGVudElmcmFtZUNsaWVudEFjcXVpcmVUb2tlblwiLFxuICAgIEF3YWl0Q29uY3VycmVudElmcmFtZTogXCJhd2FpdENvbmN1cnJlbnRJZnJhbWVcIiwgLy8gVGltZSBzcGVudCB3YWl0aW5nIGZvciBhIGNvbmN1cnJlbnQgaWZyYW1lIHRvIGNvbXBsZXRlXG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlVG9rZW4gQVBJIGluIFNpbGVudFJlcmVzaENsaWVudCAobXNhbC1icm93c2VyKS5cbiAgICAgKiBVc2VkIHRvIGFjcXVpcmUgYSBuZXcgc2V0IG9mIHRva2VucyBmcm9tIHRoZSB0b2tlbiBlbmRwb2ludCB1c2luZyBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgU2lsZW50UmVmcmVzaENsaWVudEFjcXVpcmVUb2tlbjogXCJzaWxlbnRSZWZyZXNoQ2xpZW50QWNxdWlyZVRva2VuXCIsXG5cbiAgICAvKipcbiAgICAgKiBzc29TaWxlbnQgQVBJIChtc2FsLWJyb3dzZXIpLlxuICAgICAqIFVzZWQgdG8gc2lsZW50bHkgYWNxdWlyZSBhbiBhdXRob3JpemF0aW9uIGNvZGUgYW5kIHNldCBvZiB0b2tlbnMgdXNpbmcgYSBoaWRkZW4gaWZyYW1lLlxuICAgICAqL1xuICAgIFNzb1NpbGVudDogXCJzc29TaWxlbnRcIixcblxuICAgIC8qKlxuICAgICAqIGdldERpc2NvdmVyZWRBdXRob3JpdHkgQVBJIGluIFN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnQgY2xhc3MgKG1zYWwtYnJvd3NlcikuXG4gICAgICogVXNlZCB0byBsb2FkIGF1dGhvcml0eSBtZXRhZGF0YSBmb3IgYSByZXF1ZXN0LlxuICAgICAqL1xuICAgIFN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRHZXREaXNjb3ZlcmVkQXV0aG9yaXR5OlxuICAgICAgICBcInN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRHZXREaXNjb3ZlcmVkQXV0aG9yaXR5XCIsXG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlVG9rZW4gQVBJcyBpbiBtc2FsLWJyb3dzZXIuXG4gICAgICogVXNlZCB0byBtYWtlIGFuIC9hdXRob3JpemUgZW5kcG9pbnQgY2FsbCB3aXRoIG5hdGl2ZSBicm9rZXJpbmcgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBGZXRjaEFjY291bnRJZFdpdGhOYXRpdmVCcm9rZXI6IFwiZmV0Y2hBY2NvdW50SWRXaXRoTmF0aXZlQnJva2VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlVG9rZW4gQVBJIGluIE5hdGl2ZUludGVyYWN0aW9uQ2xpZW50IGNsYXNzIChtc2FsLWJyb3dzZXIpLlxuICAgICAqIFVzZWQgdG8gYWNxdWlyZSBhIHRva2VuIGZyb20gTmF0aXZlIGNvbXBvbmVudCB3aGVuIG5hdGl2ZSBicm9rZXJpbmcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBOYXRpdmVJbnRlcmFjdGlvbkNsaWVudEFjcXVpcmVUb2tlbjogXCJuYXRpdmVJbnRlcmFjdGlvbkNsaWVudEFjcXVpcmVUb2tlblwiLFxuICAgIC8qKlxuICAgICAqIFRpbWUgc3BlbnQgY3JlYXRpbmcgZGVmYXVsdCBoZWFkZXJzIGZvciByZXF1ZXN0cyB0byB0b2tlbiBlbmRwb2ludFxuICAgICAqL1xuICAgIEJhc2VDbGllbnRDcmVhdGVUb2tlblJlcXVlc3RIZWFkZXJzOiBcImJhc2VDbGllbnRDcmVhdGVUb2tlblJlcXVlc3RIZWFkZXJzXCIsXG4gICAgLyoqXG4gICAgICogVGltZSBzcGVudCBzZW5kaW5nL3dhaXRpbmcgZm9yIHRoZSByZXNwb25zZSBvZiBhIHJlcXVlc3QgdG8gdGhlIHRva2VuIGVuZHBvaW50XG4gICAgICovXG4gICAgTmV0d29ya0NsaWVudFNlbmRQb3N0UmVxdWVzdEFzeW5jOiBcIm5ldHdvcmtDbGllbnRTZW5kUG9zdFJlcXVlc3RBc3luY1wiLFxuICAgIFJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50OlxuICAgICAgICBcInJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50XCIsXG4gICAgQXV0aG9yaXphdGlvbkNvZGVDbGllbnRFeGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludDpcbiAgICAgICAgXCJhdXRob3JpemF0aW9uQ29kZUNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50XCIsXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBtZWFzdXJlIHRoZSB0aW1lIHRha2VuIGZvciBjb21wbGV0aW5nIGVtYmVkZGVkLWJyb2tlciBoYW5kc2hha2UgKFBXLUJyb2tlcikuXG4gICAgICovXG4gICAgQnJva2VySGFuZGhzaGFrZTogXCJicm9rZXJIYW5kc2hha2VcIixcbiAgICAvKipcbiAgICAgKiBhY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbiBBUEkgaW4gQnJva2VyQ2xpZW50QXBwbGljYXRpb24gKFBXLUJyb2tlcikgLlxuICAgICAqL1xuICAgIEFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuSW5Ccm9rZXI6IFwiYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW5JbkJyb2tlclwiLFxuICAgIC8qKlxuICAgICAqIFRpbWUgdGFrZW4gZm9yIHRva2VuIGFjcXVpc2l0aW9uIGJ5IGJyb2tlclxuICAgICAqL1xuICAgIEFjcXVpcmVUb2tlbkJ5QnJva2VyOiBcImFjcXVpcmVUb2tlbkJ5QnJva2VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaW1lIHNwZW50IG9uIHRoZSBuZXR3b3JrIGZvciByZWZyZXNoIHRva2VuIGFjcXVpc2l0aW9uXG4gICAgICovXG4gICAgUmVmcmVzaFRva2VuQ2xpZW50RXhlY3V0ZVRva2VuUmVxdWVzdDpcbiAgICAgICAgXCJyZWZyZXNoVG9rZW5DbGllbnRFeGVjdXRlVG9rZW5SZXF1ZXN0XCIsXG5cbiAgICAvKipcbiAgICAgKiBUaW1lIHRha2VuIGZvciBhY3F1aXJpbmcgcmVmcmVzaCB0b2tlbiAsIHJlY29yZHMgUlQgc2l6ZVxuICAgICAqL1xuICAgIFJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbjogXCJyZWZyZXNoVG9rZW5DbGllbnRBY3F1aXJlVG9rZW5cIixcblxuICAgIC8qKlxuICAgICAqIFRpbWUgdGFrZW4gZm9yIGFjcXVpcmluZyBjYWNoZWQgcmVmcmVzaCB0b2tlblxuICAgICAqL1xuICAgIFJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbldpdGhDYWNoZWRSZWZyZXNoVG9rZW46XG4gICAgICAgIFwicmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlblwiLFxuXG4gICAgLyoqXG4gICAgICogYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW4gQVBJIGluIFJlZnJlc2hUb2tlbkNsaWVudCAobXNhbC1jb21tb24pLlxuICAgICAqL1xuICAgIFJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuOlxuICAgICAgICBcInJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuXCIsXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHRva2VuIHJlcXVlc3QgYm9keSBpbiBSZWZyZXNoVG9rZW5DbGllbnQgKG1zYWwtY29tbW9uKS5cbiAgICAgKi9cbiAgICBSZWZyZXNoVG9rZW5DbGllbnRDcmVhdGVUb2tlblJlcXVlc3RCb2R5OlxuICAgICAgICBcInJlZnJlc2hUb2tlbkNsaWVudENyZWF0ZVRva2VuUmVxdWVzdEJvZHlcIixcblxuICAgIC8qKlxuICAgICAqIGFjcXVpcmVUb2tlbkZyb21DYWNoZSAobXNhbC1icm93c2VyKS5cbiAgICAgKiBJbnRlcm5hbCBBUEkgZm9yIGFjcXVpcmluZyB0b2tlbiBmcm9tIGNhY2hlXG4gICAgICovXG4gICAgQWNxdWlyZVRva2VuRnJvbUNhY2hlOiBcImFjcXVpcmVUb2tlbkZyb21DYWNoZVwiLFxuICAgIFNpbGVudEZsb3dDbGllbnRBY3F1aXJlQ2FjaGVkVG9rZW46IFwic2lsZW50Rmxvd0NsaWVudEFjcXVpcmVDYWNoZWRUb2tlblwiLFxuICAgIFNpbGVudEZsb3dDbGllbnRHZW5lcmF0ZVJlc3VsdEZyb21DYWNoZVJlY29yZDpcbiAgICAgICAgXCJzaWxlbnRGbG93Q2xpZW50R2VuZXJhdGVSZXN1bHRGcm9tQ2FjaGVSZWNvcmRcIixcblxuICAgIC8qKlxuICAgICAqIGFjcXVpcmVUb2tlbkJ5U2lsZW50SWZyYW1lIChtc2FsLWJyb3dzZXIpLlxuICAgICAqIEludGVybmFsIEFQSSBmb3IgYWNxdWlyaW5nIHRva2VuIGJ5IHNpbGVudCBJZnJhbWVcbiAgICAgKi9cbiAgICBBY3F1aXJlVG9rZW5CeVNpbGVudElmcmFtZTogXCJhY3F1aXJlVG9rZW5CeVNpbGVudElmcmFtZVwiLFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgQVBJIGZvciBpbml0aWFsaXppbmcgYmFzZSByZXF1ZXN0IGluIEJhc2VJbnRlcmFjdGlvbkNsaWVudCAobXNhbC1icm93c2VyKVxuICAgICAqL1xuICAgIEluaXRpYWxpemVCYXNlUmVxdWVzdDogXCJpbml0aWFsaXplQmFzZVJlcXVlc3RcIixcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIEFQSSBmb3IgaW5pdGlhbGl6aW5nIHNpbGVudCByZXF1ZXN0IGluIFNpbGVudENhY2hlQ2xpZW50IChtc2FsLWJyb3dzZXIpXG4gICAgICovXG4gICAgSW5pdGlhbGl6ZVNpbGVudFJlcXVlc3Q6IFwiaW5pdGlhbGl6ZVNpbGVudFJlcXVlc3RcIixcblxuICAgIEluaXRpYWxpemVDbGllbnRBcHBsaWNhdGlvbjogXCJpbml0aWFsaXplQ2xpZW50QXBwbGljYXRpb25cIixcblxuICAgIEluaXRpYWxpemVDYWNoZTogXCJpbml0aWFsaXplQ2FjaGVcIixcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBpbiBTaWxlbnRJZnJhbWVDbGllbnQgY2xhc3MgKG1zYWwtYnJvd3NlcikuXG4gICAgICovXG4gICAgU2lsZW50SWZyYW1lQ2xpZW50VG9rZW5IZWxwZXI6IFwic2lsZW50SWZyYW1lQ2xpZW50VG9rZW5IZWxwZXJcIixcblxuICAgIC8qKlxuICAgICAqIFNpbGVudEhhbmRsZXJcbiAgICAgKi9cbiAgICBTaWxlbnRIYW5kbGVySW5pdGlhdGVBdXRoUmVxdWVzdDogXCJzaWxlbnRIYW5kbGVySW5pdGlhdGVBdXRoUmVxdWVzdFwiLFxuICAgIFNpbGVudEhhbmRsZXJNb25pdG9ySWZyYW1lRm9ySGFzaDogXCJzaWxlbnRIYW5kbGVyTW9uaXRvcklmcmFtZUZvckhhc2hcIixcbiAgICBTaWxlbnRIYW5kbGVyTG9hZEZyYW1lOiBcInNpbGVudEhhbmRsZXJMb2FkRnJhbWVcIixcbiAgICBTaWxlbnRIYW5kbGVyTG9hZEZyYW1lU3luYzogXCJzaWxlbnRIYW5kbGVyTG9hZEZyYW1lU3luY1wiLFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9ucyBpbiBTdGFuZGFyZEludGVyYWN0aW9uQ2xpZW50IGNsYXNzIChtc2FsLWJyb3dzZXIpXG4gICAgICovXG4gICAgU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudENyZWF0ZUF1dGhDb2RlQ2xpZW50OlxuICAgICAgICBcInN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRDcmVhdGVBdXRoQ29kZUNsaWVudFwiLFxuICAgIFN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRHZXRDbGllbnRDb25maWd1cmF0aW9uOlxuICAgICAgICBcInN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRHZXRDbGllbnRDb25maWd1cmF0aW9uXCIsXG4gICAgU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudEluaXRpYWxpemVBdXRob3JpemF0aW9uUmVxdWVzdDpcbiAgICAgICAgXCJzdGFuZGFyZEludGVyYWN0aW9uQ2xpZW50SW5pdGlhbGl6ZUF1dGhvcml6YXRpb25SZXF1ZXN0XCIsXG5cbiAgICAvKipcbiAgICAgKiBnZXRBdXRoQ29kZVVybCBBUEkgKG1zYWwtYnJvd3NlciBhbmQgbXNhbC1ub2RlKS5cbiAgICAgKi9cbiAgICBHZXRBdXRoQ29kZVVybDogXCJnZXRBdXRoQ29kZVVybFwiLFxuICAgIEdldFN0YW5kYXJkUGFyYW1zOiBcImdldFN0YW5kYXJkUGFyYW1zXCIsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbnMgZnJvbSBJbnRlcmFjdGlvbkhhbmRsZXIgKG1zYWwtYnJvd3NlcilcbiAgICAgKi9cbiAgICBIYW5kbGVDb2RlUmVzcG9uc2VGcm9tU2VydmVyOiBcImhhbmRsZUNvZGVSZXNwb25zZUZyb21TZXJ2ZXJcIixcbiAgICBIYW5kbGVDb2RlUmVzcG9uc2U6IFwiaGFuZGxlQ29kZVJlc3BvbnNlXCIsXG4gICAgSGFuZGxlUmVzcG9uc2VFYXI6IFwiaGFuZGxlUmVzcG9uc2VFYXJcIixcbiAgICBIYW5kbGVSZXNwb25zZVBsYXRmb3JtQnJva2VyOiBcImhhbmRsZVJlc3BvbnNlUGxhdGZvcm1Ccm9rZXJcIixcbiAgICBIYW5kbGVSZXNwb25zZUNvZGU6IFwiaGFuZGxlUmVzcG9uc2VDb2RlXCIsXG4gICAgVXBkYXRlVG9rZW5FbmRwb2ludEF1dGhvcml0eTogXCJ1cGRhdGVUb2tlbkVuZHBvaW50QXV0aG9yaXR5XCIsXG5cbiAgICAvKipcbiAgICAgKiBBUElzIGluIEF1dGhvcml6YXRpb24gQ29kZSBDbGllbnQgKG1zYWwtY29tbW9uKVxuICAgICAqL1xuICAgIEF1dGhDbGllbnRBY3F1aXJlVG9rZW46IFwiYXV0aENsaWVudEFjcXVpcmVUb2tlblwiLFxuICAgIEF1dGhDbGllbnRFeGVjdXRlVG9rZW5SZXF1ZXN0OiBcImF1dGhDbGllbnRFeGVjdXRlVG9rZW5SZXF1ZXN0XCIsXG4gICAgQXV0aENsaWVudENyZWF0ZVRva2VuUmVxdWVzdEJvZHk6IFwiYXV0aENsaWVudENyZWF0ZVRva2VuUmVxdWVzdEJvZHlcIixcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGZ1bmN0aW9ucyBpbiBQb3BUb2tlbkdlbmVyYXRvciAobXNhbC1jb21tb24pXG4gICAgICovXG4gICAgUG9wVG9rZW5HZW5lcmF0ZUNuZjogXCJwb3BUb2tlbkdlbmVyYXRlQ25mXCIsXG4gICAgUG9wVG9rZW5HZW5lcmF0ZUtpZDogXCJwb3BUb2tlbkdlbmVyYXRlS2lkXCIsXG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlIEFQSSBpbiBSZXNwb25zZUhhbmRsZXIgKG1zYWwtY29tbW9uKVxuICAgICAqL1xuICAgIEhhbmRsZVNlcnZlclRva2VuUmVzcG9uc2U6IFwiaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZVwiLFxuICAgIERlc2VyaWFsaXplUmVzcG9uc2U6IFwiZGVzZXJpYWxpemVSZXNwb25zZVwiLFxuXG4gICAgLyoqXG4gICAgICogQXV0aG9yaXR5IGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIEF1dGhvcml0eUZhY3RvcnlDcmVhdGVEaXNjb3ZlcmVkSW5zdGFuY2U6XG4gICAgICAgIFwiYXV0aG9yaXR5RmFjdG9yeUNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZVwiLFxuICAgIEF1dGhvcml0eVJlc29sdmVFbmRwb2ludHNBc3luYzogXCJhdXRob3JpdHlSZXNvbHZlRW5kcG9pbnRzQXN5bmNcIixcbiAgICBBdXRob3JpdHlSZXNvbHZlRW5kcG9pbnRzRnJvbUxvY2FsU291cmNlczpcbiAgICAgICAgXCJhdXRob3JpdHlSZXNvbHZlRW5kcG9pbnRzRnJvbUxvY2FsU291cmNlc1wiLFxuICAgIEF1dGhvcml0eUdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29yazpcbiAgICAgICAgXCJhdXRob3JpdHlHZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcmtcIixcbiAgICBBdXRob3JpdHlVcGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhOlxuICAgICAgICBcImF1dGhvcml0eVVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFcIixcbiAgICBBdXRob3JpdHlHZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcms6XG4gICAgICAgIFwiYXV0aG9yaXR5R2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrXCIsXG4gICAgQXV0aG9yaXR5VXBkYXRlRW5kcG9pbnRNZXRhZGF0YTogXCJhdXRob3JpdHlVcGRhdGVFbmRwb2ludE1ldGFkYXRhXCIsXG4gICAgQXV0aG9yaXR5VXBkYXRlTWV0YWRhdGFXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbjpcbiAgICAgICAgXCJhdXRob3JpdHlVcGRhdGVNZXRhZGF0YVdpdGhSZWdpb25hbEluZm9ybWF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZWdpb24gRGlzY292ZXJ5IGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIFJlZ2lvbkRpc2NvdmVyeURldGVjdFJlZ2lvbjogXCJyZWdpb25EaXNjb3ZlcnlEZXRlY3RSZWdpb25cIixcbiAgICBSZWdpb25EaXNjb3ZlcnlHZXRSZWdpb25Gcm9tSU1EUzogXCJyZWdpb25EaXNjb3ZlcnlHZXRSZWdpb25Gcm9tSU1EU1wiLFxuICAgIFJlZ2lvbkRpc2NvdmVyeUdldEN1cnJlbnRWZXJzaW9uOiBcInJlZ2lvbkRpc2NvdmVyeUdldEN1cnJlbnRWZXJzaW9uXCIsXG5cbiAgICBBY3F1aXJlVG9rZW5CeUNvZGVBc3luYzogXCJhY3F1aXJlVG9rZW5CeUNvZGVBc3luY1wiLFxuXG4gICAgR2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrOiBcImdldEVuZHBvaW50TWV0YWRhdGFGcm9tTmV0d29ya1wiLFxuICAgIEdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya01lYXN1cmVtZW50OlxuICAgICAgICBcImdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya01lYXN1cmVtZW50XCIsXG5cbiAgICBIYW5kbGVSZWRpcmVjdFByb21pc2VNZWFzdXJlbWVudDogXCJoYW5kbGVSZWRpcmVjdFByb21pc2VcIixcbiAgICBIYW5kbGVOYXRpdmVSZWRpcmVjdFByb21pc2VNZWFzdXJlbWVudDogXCJoYW5kbGVOYXRpdmVSZWRpcmVjdFByb21pc2VcIixcblxuICAgIFVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFNZWFzdXJlbWVudDpcbiAgICAgICAgXCJ1cGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhTWVhc3VyZW1lbnRcIixcblxuICAgIFVzZXJuYW1lUGFzc3dvcmRDbGllbnRBY3F1aXJlVG9rZW46IFwidXNlcm5hbWVQYXNzd29yZENsaWVudEFjcXVpcmVUb2tlblwiLFxuXG4gICAgTmF0aXZlTWVzc2FnZUhhbmRsZXJIYW5kc2hha2U6IFwibmF0aXZlTWVzc2FnZUhhbmRsZXJIYW5kc2hha2VcIixcblxuICAgIE5hdGl2ZUdlbmVyYXRlQXV0aFJlc3VsdDogXCJuYXRpdmVHZW5lcmF0ZUF1dGhSZXN1bHRcIixcblxuICAgIFJlbW92ZUhpZGRlbklmcmFtZTogXCJyZW1vdmVIaWRkZW5JZnJhbWVcIixcblxuICAgIC8qKlxuICAgICAqIENhY2hlIG9wZXJhdGlvbnNcbiAgICAgKi9cbiAgICBDbGVhclRva2Vuc0FuZEtleXNXaXRoQ2xhaW1zOiBcImNsZWFyVG9rZW5zQW5kS2V5c1dpdGhDbGFpbXNcIixcbiAgICBDYWNoZU1hbmFnZXJHZXRSZWZyZXNoVG9rZW46IFwiY2FjaGVNYW5hZ2VyR2V0UmVmcmVzaFRva2VuXCIsXG4gICAgSW1wb3J0RXhpc3RpbmdDYWNoZTogXCJpbXBvcnRFeGlzdGluZ0NhY2hlXCIsXG4gICAgU2V0VXNlckRhdGE6IFwic2V0VXNlckRhdGFcIixcbiAgICBMb2NhbFN0b3JhZ2VVcGRhdGVkOiBcImxvY2FsU3RvcmFnZVVwZGF0ZWRcIixcblxuICAgIC8qKlxuICAgICAqIENyeXB0byBPcGVyYXRpb25zXG4gICAgICovXG4gICAgR2VuZXJhdGVQa2NlQ29kZXM6IFwiZ2VuZXJhdGVQa2NlQ29kZXNcIixcbiAgICBHZW5lcmF0ZUNvZGVWZXJpZmllcjogXCJnZW5lcmF0ZUNvZGVWZXJpZmllclwiLFxuICAgIEdlbmVyYXRlQ29kZUNoYWxsZW5nZUZyb21WZXJpZmllcjogXCJnZW5lcmF0ZUNvZGVDaGFsbGVuZ2VGcm9tVmVyaWZpZXJcIixcbiAgICBTaGEyNTZEaWdlc3Q6IFwic2hhMjU2RGlnZXN0XCIsXG4gICAgR2V0UmFuZG9tVmFsdWVzOiBcImdldFJhbmRvbVZhbHVlc1wiLFxuICAgIEdlbmVyYXRlSEtERjogXCJnZW5lcmF0ZUhLREZcIixcbiAgICBHZW5lcmF0ZUJhc2VLZXk6IFwiZ2VuZXJhdGVCYXNlS2V5XCIsXG4gICAgQmFzZTY0RGVjb2RlOiBcImJhc2U2NERlY29kZVwiLFxuICAgIFVybEVuY29kZUFycjogXCJ1cmxFbmNvZGVBcnJcIixcbiAgICBFbmNyeXB0OiBcImVuY3J5cHRcIixcbiAgICBEZWNyeXB0OiBcImRlY3J5cHRcIixcbiAgICBHZW5lcmF0ZUVhcktleTogXCJnZW5lcmF0ZUVhcktleVwiLFxuICAgIERlY3J5cHRFYXJSZXNwb25zZTogXCJkZWNyeXB0RWFyUmVzcG9uc2VcIixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBQZXJmb3JtYW5jZUV2ZW50cyA9XG4gICAgKHR5cGVvZiBQZXJmb3JtYW5jZUV2ZW50cylba2V5b2YgdHlwZW9mIFBlcmZvcm1hbmNlRXZlbnRzXTtcblxuZXhwb3J0IGNvbnN0IFBlcmZvcm1hbmNlRXZlbnRBYmJyZXZpYXRpb25zOiBSZWFkb25seU1hcDxzdHJpbmcsIHN0cmluZz4gPVxuICAgIG5ldyBNYXAoW1xuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuQnlDb2RlLCBcIkFUQnlDb2RlXCJdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW4sIFwiQVRCeVJUXCJdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuU2lsZW50LCBcIkFUU1wiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlblNpbGVudEFzeW5jLCBcIkFUU0FzeW5jXCJdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuUG9wdXAsIFwiQVRQb3B1cFwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlblJlZGlyZWN0LCBcIkFUUmVkaXJlY3RcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkNyeXB0b09wdHNHZXRQdWJsaWNLZXlUaHVtYnByaW50LFxuICAgICAgICAgICAgXCJDcnlwdG9HZXRQS1RodW1iXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5DcnlwdG9PcHRzU2lnbkp3dCwgXCJDcnlwdG9TaWduSnd0XCJdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50Q2FjaGVDbGllbnRBY3F1aXJlVG9rZW4sIFwiU2x0Q2FjaGVDbGllbnRBVFwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlNpbGVudElmcmFtZUNsaWVudEFjcXVpcmVUb2tlbiwgXCJTbHRJZnJhbWVDbGllbnRBVFwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlNpbGVudFJlZnJlc2hDbGllbnRBY3F1aXJlVG9rZW4sIFwiU2x0UkNsaWVudEFUXCJdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuU3NvU2lsZW50LCBcIlNzb1NsdFwiXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudEdldERpc2NvdmVyZWRBdXRob3JpdHksXG4gICAgICAgICAgICBcIlN0ZEludENsaWVudEdldERpc2NBdXRoXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkZldGNoQWNjb3VudElkV2l0aE5hdGl2ZUJyb2tlcixcbiAgICAgICAgICAgIFwiRmV0Y2hBY2NJZFdpdGhOdHZCcm9rZXJcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuTmF0aXZlSW50ZXJhY3Rpb25DbGllbnRBY3F1aXJlVG9rZW4sXG4gICAgICAgICAgICBcIk50dkludENsaWVudEFUXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkJhc2VDbGllbnRDcmVhdGVUb2tlblJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgXCJCYXNlQ2xpZW50Q3JlYXRlVFJlcUhlYWRcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuTmV0d29ya0NsaWVudFNlbmRQb3N0UmVxdWVzdEFzeW5jLFxuICAgICAgICAgICAgXCJOZXRDbGllbnRTZW5kUG9zdFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRFeGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludCxcbiAgICAgICAgICAgIFwiUlRDbGllbnRFeGVjUG9zdFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpemF0aW9uQ29kZUNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50LFxuICAgICAgICAgICAgXCJBdXRoQ29kZUNsaWVudEV4ZWNQb3N0XCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5Ccm9rZXJIYW5kaHNoYWtlLCBcIkJyb2tlckhhbmRzaGFrZVwiXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW5JbkJyb2tlcixcbiAgICAgICAgICAgIFwiQVRCeVJUSW5Ccm9rZXJcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlbkJ5QnJva2VyLCBcIkFUQnlCcm9rZXJcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVUb2tlblJlcXVlc3QsXG4gICAgICAgICAgICBcIlJUQ2xpZW50RXhlY1RSZXFcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbiwgXCJSVENsaWVudEFUXCJdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRBY3F1aXJlVG9rZW5XaXRoQ2FjaGVkUmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgXCJSVENsaWVudEFUV2l0aENhY2hlZFJUXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgXCJSVENsaWVudEFUQnlSVFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRDcmVhdGVUb2tlblJlcXVlc3RCb2R5LFxuICAgICAgICAgICAgXCJSVENsaWVudENyZWF0ZVRSZXFCb2R5XCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5BY3F1aXJlVG9rZW5Gcm9tQ2FjaGUsIFwiQVRGcm9tQ2FjaGVcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlNpbGVudEZsb3dDbGllbnRBY3F1aXJlQ2FjaGVkVG9rZW4sXG4gICAgICAgICAgICBcIlNsdEZsb3dDbGllbnRBVENhY2hlZFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5TaWxlbnRGbG93Q2xpZW50R2VuZXJhdGVSZXN1bHRGcm9tQ2FjaGVSZWNvcmQsXG4gICAgICAgICAgICBcIlNsdEZsb3dDbGllbnRHZW5SZXNGcm9tQ2FjaGVcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlbkJ5U2lsZW50SWZyYW1lLCBcIkFUQnlTbHRJZnJhbWVcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5Jbml0aWFsaXplQmFzZVJlcXVlc3QsIFwiSW5pdEJhc2VSZXFcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5Jbml0aWFsaXplU2lsZW50UmVxdWVzdCwgXCJJbml0U2x0UmVxXCJdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5Jbml0aWFsaXplQ2xpZW50QXBwbGljYXRpb24sXG4gICAgICAgICAgICBcIkluaXRDbGllbnRBcHBsaWNhdGlvblwiLFxuICAgICAgICBdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuSW5pdGlhbGl6ZUNhY2hlLCBcIkluaXRDYWNoZVwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkltcG9ydEV4aXN0aW5nQ2FjaGUsIFwiaW1wb3J0Q2FjaGVcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5TZXRVc2VyRGF0YSwgXCJzZXRVc2VyRGF0YVwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkxvY2FsU3RvcmFnZVVwZGF0ZWQsIFwibG9jYWxTdG9yYWdlVXBkYXRlZFwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlNpbGVudElmcmFtZUNsaWVudFRva2VuSGVscGVyLCBcIlNJQ2xpZW50VEhlbHBlclwiXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50SGFuZGxlckluaXRpYXRlQXV0aFJlcXVlc3QsXG4gICAgICAgICAgICBcIlNIYW5kbGVySW5pdEF1dGhSZXFcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50SGFuZGxlck1vbml0b3JJZnJhbWVGb3JIYXNoLFxuICAgICAgICAgICAgXCJTbHRIYW5kbGVyTW9uaXRvcklmcmFtZUZvckhhc2hcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlNpbGVudEhhbmRsZXJMb2FkRnJhbWUsIFwiU0hhbmRsZXJMb2FkRnJhbWVcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5TaWxlbnRIYW5kbGVyTG9hZEZyYW1lU3luYywgXCJTSGFuZGxlckxvYWRGcmFtZVN5bmNcIl0sXG5cbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudENyZWF0ZUF1dGhDb2RlQ2xpZW50LFxuICAgICAgICAgICAgXCJTdGRJbnRDbGllbnRDcmVhdGVBdXRoQ29kZUNsaWVudFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5TdGFuZGFyZEludGVyYWN0aW9uQ2xpZW50R2V0Q2xpZW50Q29uZmlndXJhdGlvbixcbiAgICAgICAgICAgIFwiU3RkSW50Q2xpZW50R2V0Q2xpZW50Q29uZlwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5TdGFuZGFyZEludGVyYWN0aW9uQ2xpZW50SW5pdGlhbGl6ZUF1dGhvcml6YXRpb25SZXF1ZXN0LFxuICAgICAgICAgICAgXCJTdGRJbnRDbGllbnRJbml0QXV0aFJlcVwiLFxuICAgICAgICBdLFxuXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZXRBdXRoQ29kZVVybCwgXCJHZXRBdXRoQ29kZVVybFwiXSxcblxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5IYW5kbGVDb2RlUmVzcG9uc2VGcm9tU2VydmVyLFxuICAgICAgICAgICAgXCJIYW5kbGVDb2RlUmVzRnJvbVNlcnZlclwiLFxuICAgICAgICBdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlQ29kZVJlc3BvbnNlLCBcIkhhbmRsZUNvZGVSZXNwXCJdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlUmVzcG9uc2VFYXIsIFwiSGFuZGxlUmVzcEVhclwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkhhbmRsZVJlc3BvbnNlQ29kZSwgXCJIYW5kbGVSZXNwQ29kZVwiXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlUmVzcG9uc2VQbGF0Zm9ybUJyb2tlcixcbiAgICAgICAgICAgIFwiSGFuZGxlUmVzcFBsYXRCcm9rZXJcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlVwZGF0ZVRva2VuRW5kcG9pbnRBdXRob3JpdHksIFwiVXBkVEVuZHBvaW50QXV0aFwiXSxcblxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuQXV0aENsaWVudEFjcXVpcmVUb2tlbiwgXCJBdXRoQ2xpZW50QVRcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5BdXRoQ2xpZW50RXhlY3V0ZVRva2VuUmVxdWVzdCwgXCJBdXRoQ2xpZW50RXhlY1RSZXFcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhDbGllbnRDcmVhdGVUb2tlblJlcXVlc3RCb2R5LFxuICAgICAgICAgICAgXCJBdXRoQ2xpZW50Q3JlYXRlVFJlcUJvZHlcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlBvcFRva2VuR2VuZXJhdGVDbmYsIFwiUG9wVEdlbkNuZlwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlBvcFRva2VuR2VuZXJhdGVLaWQsIFwiUG9wVEdlbktpZFwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkhhbmRsZVNlcnZlclRva2VuUmVzcG9uc2UsIFwiSGFuZGxlU2VydmVyVFJlc1wiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkRlc2VyaWFsaXplUmVzcG9uc2UsIFwiRGVzZXJpYWxpemVSZXNcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eUZhY3RvcnlDcmVhdGVEaXNjb3ZlcmVkSW5zdGFuY2UsXG4gICAgICAgICAgICBcIkF1dGhGYWN0Q3JlYXRlRGlzY0luc3RcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5UmVzb2x2ZUVuZHBvaW50c0FzeW5jLFxuICAgICAgICAgICAgXCJBdXRoUmVzb2x2ZUVuZHBvaW50c0FzeW5jXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVJlc29sdmVFbmRwb2ludHNGcm9tTG9jYWxTb3VyY2VzLFxuICAgICAgICAgICAgXCJBdXRoUmVzb2x2ZUVuZHBvaW50c0Zyb21Mb2NhbFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlHZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcmssXG4gICAgICAgICAgICBcIkF1dGhHZXRDRE1ldGFGcm9tTmV0XCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEsXG4gICAgICAgICAgICBcIkF1dGhVcGRDRE1ldGFcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5R2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrLFxuICAgICAgICAgICAgXCJBdXRoVXBkQ0RNZXRhRnJvbU5ldFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlVcGRhdGVFbmRwb2ludE1ldGFkYXRhLFxuICAgICAgICAgICAgXCJBdXRoVXBkRW5kcG9pbnRNZXRhXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZU1ldGFkYXRhV2l0aFJlZ2lvbmFsSW5mb3JtYXRpb24sXG4gICAgICAgICAgICBcIkF1dGhVcGRNZXRhV2l0aFJlZ0luZm9cIixcbiAgICAgICAgXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeURldGVjdFJlZ2lvbiwgXCJSZWdEaXNjRGV0ZWN0UmVnXCJdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWdpb25EaXNjb3ZlcnlHZXRSZWdpb25Gcm9tSU1EUyxcbiAgICAgICAgICAgIFwiUmVnRGlzY0dldFJlZ0Zyb21JTURTXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeUdldEN1cnJlbnRWZXJzaW9uLFxuICAgICAgICAgICAgXCJSZWdEaXNjR2V0Q3VycmVudFZlclwiLFxuICAgICAgICBdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuQnlDb2RlQXN5bmMsIFwiQVRCeUNvZGVBc3luY1wiXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuR2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrLFxuICAgICAgICAgICAgXCJHZXRFbmRwb2ludE1ldGFGcm9tTmV0XCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya01lYXN1cmVtZW50LFxuICAgICAgICAgICAgXCJHZXRDRE1ldGFGcm9tTmV0XCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkhhbmRsZVJlZGlyZWN0UHJvbWlzZU1lYXN1cmVtZW50LFxuICAgICAgICAgICAgXCJIYW5kbGVSZWRpcmVjdFByb21pc2VcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlTmF0aXZlUmVkaXJlY3RQcm9taXNlTWVhc3VyZW1lbnQsXG4gICAgICAgICAgICBcIkhhbmRsZU50dlJlZGlyZWN0UHJvbWlzZVwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5VcGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhTWVhc3VyZW1lbnQsXG4gICAgICAgICAgICBcIlVwZGF0ZUNETWV0YVwiLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5Vc2VybmFtZVBhc3N3b3JkQ2xpZW50QWNxdWlyZVRva2VuLFxuICAgICAgICAgICAgXCJVc2VyUGFzc0NsaWVudEFUXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLk5hdGl2ZU1lc3NhZ2VIYW5kbGVySGFuZHNoYWtlLFxuICAgICAgICAgICAgXCJOdHZNc2dIYW5kbGVySGFuZHNoYWtlXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5OYXRpdmVHZW5lcmF0ZUF1dGhSZXN1bHQsIFwiTnR2R2VuQXV0aFJlc1wiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlJlbW92ZUhpZGRlbklmcmFtZSwgXCJSZW1vdmVIaWRkZW5JZnJhbWVcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkNsZWFyVG9rZW5zQW5kS2V5c1dpdGhDbGFpbXMsXG4gICAgICAgICAgICBcIkNsZWFyVEFuZEtleXNXaXRoQ2xhaW1zXCIsXG4gICAgICAgIF0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5DYWNoZU1hbmFnZXJHZXRSZWZyZXNoVG9rZW4sIFwiQ2FjaGVNYW5hZ2VyR2V0UlRcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZW5lcmF0ZVBrY2VDb2RlcywgXCJHZW5Qa2NlQ29kZXNcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZW5lcmF0ZUNvZGVWZXJpZmllciwgXCJHZW5Db2RlVmVyaWZpZXJcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkdlbmVyYXRlQ29kZUNoYWxsZW5nZUZyb21WZXJpZmllcixcbiAgICAgICAgICAgIFwiR2VuQ29kZUNoYWxsZW5nZUZyb21WZXJpZmllclwiLFxuICAgICAgICBdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuU2hhMjU2RGlnZXN0LCBcIlNoYTI1NkRpZ2VzdFwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkdldFJhbmRvbVZhbHVlcywgXCJHZXRSYW5kb21WYWx1ZXNcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZW5lcmF0ZUhLREYsIFwiZ2VuSEtERlwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLkdlbmVyYXRlQmFzZUtleSwgXCJnZW5CYXNlS2V5XCJdLFxuICAgICAgICBbUGVyZm9ybWFuY2VFdmVudHMuQmFzZTY0RGVjb2RlLCBcImI2NERlY29kZVwiXSxcbiAgICAgICAgW1BlcmZvcm1hbmNlRXZlbnRzLlVybEVuY29kZUFyciwgXCJ1cmxFbmNBcnJcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5FbmNyeXB0LCBcImVuY3J5cHRcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5EZWNyeXB0LCBcImRlY3J5cHRcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZW5lcmF0ZUVhcktleSwgXCJnZW5FYXJLZXlcIl0sXG4gICAgICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5EZWNyeXB0RWFyUmVzcG9uc2UsIFwiZGVjcnlwdEVhclJlc3BcIl0sXG4gICAgXSk7XG5cbi8qKlxuICogU3RhdGUgb2YgdGhlIHBlcmZvcm1hbmNlIGV2ZW50LlxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBQZXJmb3JtYW5jZUV2ZW50U3RhdHVzID0ge1xuICAgIE5vdFN0YXJ0ZWQ6IDAsXG4gICAgSW5Qcm9ncmVzczogMSxcbiAgICBDb21wbGV0ZWQ6IDIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgUGVyZm9ybWFuY2VFdmVudFN0YXR1cyA9XG4gICAgKHR5cGVvZiBQZXJmb3JtYW5jZUV2ZW50U3RhdHVzKVtrZXlvZiB0eXBlb2YgUGVyZm9ybWFuY2VFdmVudFN0YXR1c107XG5cbmV4cG9ydCB0eXBlIFN1Yk1lYXN1cmVtZW50ID0ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzdGFydFRpbWVNczogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtYW5jZSBtZWFzdXJlbWVudCB0YWtlbiBieSB0aGUgbGlicmFyeSwgaW5jbHVkaW5nIG1ldGFkYXRhIGFib3V0IHRoZSByZXF1ZXN0IGFuZCBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAdHlwZWRlZiB7UGVyZm9ybWFuY2VFdmVudH1cbiAqL1xuZXhwb3J0IHR5cGUgUGVyZm9ybWFuY2VFdmVudCA9IHtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgaWQgZm9yIHRoZSBldmVudFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBldmVudElkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTdGF0ZSBvZiB0aGUgcGVyZm9yYW5jZSBtZWFzdXJlLlxuICAgICAqXG4gICAgICogQHR5cGUge1BlcmZvcm1hbmNlRXZlbnRTdGF0dXN9XG4gICAgICovXG4gICAgc3RhdHVzOiBQZXJmb3JtYW5jZUV2ZW50U3RhdHVzO1xuXG4gICAgLyoqXG4gICAgICogTG9naW4gYXV0aG9yaXR5IHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGF1dGhvcml0eTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ2xpZW50IGlkIGZvciB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2xpZW50SWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENvcnJlbGF0aW9uIElEIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvcnJlbGF0aW9uSWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEVuZC10by1lbmQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBkYXRlIDMvMjIvMjAyMiAtIDM6NDA6MDUgUE1cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZHVyYXRpb25Ncz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFZpc2liaWxpdHkgb2YgdGhlIHBhZ2Ugd2hlbiB0aGUgZXZlbnQgY29tcGxldGVkLlxuICAgICAqIFJlYWQgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1BhZ2VfVmlzaWJpbGl0eV9BUElcbiAgICAgKlxuICAgICAqIEB0eXBlIHs/KHN0cmluZyB8IG51bGwpfVxuICAgICAqL1xuICAgIGVuZFBhZ2VWaXNpYmlsaXR5Pzogc3RyaW5nIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlc3VsdCB3YXMgcmV0cmlldmVkIGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHR5cGUgeyhib29sZWFuIHwgbnVsbCl9XG4gICAgICovXG4gICAgZnJvbUNhY2hlPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBuYW1lICh1c3VhbGx5IGluIHRoZSBmb3JtIG9mIGNsYXNzTmFtZUZ1bmN0aW9uTmFtZSlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVmlzaWJpbGl0eSBvZiB0aGUgcGFnZSB3aGVuIHRoZSBldmVudCBjb21wbGV0ZWQuXG4gICAgICogUmVhZCBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvUGFnZV9WaXNpYmlsaXR5X0FQSVxuICAgICAqXG4gICAgICogQHR5cGUgez8oc3RyaW5nIHwgbnVsbCl9XG4gICAgICovXG4gICAgc3RhcnRQYWdlVmlzaWJpbGl0eT86IHN0cmluZyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBVbml4IG1pbGxpc2Vjb25kIHRpbWVzdGFtcCB3aGVuIHRoZSBldmVudCB3YXMgaW5pdGlhdGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGFydFRpbWVNczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7KGJvb2xlYW4gfCBudWxsKX1cbiAgICAgKi9cbiAgICBzdWNjZXNzPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgc3BlY2lmaWMgZXJyb3IgY29kZSBpbiBjYXNlIG9mIGZhaWx1cmVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZXJyb3JDb2RlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQWRkIHNwZWNpZmljIHN1YiBlcnJvciBjb2RlIGluIGNhc2Ugb2YgZmFpbHVyZVxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdWJFcnJvckNvZGU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXJ2ZXIgZXJyb3IgbnVtYmVyXG4gICAgICovXG4gICAgc2VydmVyRXJyb3JObz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGxpYnJhcnkgdXNlZCBmb3IgdGhlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbGlicmFyeU5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFZlcnNpb24gb2YgdGhlIGxpYnJhcnkgdXNlZCBmb3IgdGhlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbGlicmFyeVZlcnNpb246IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlc3BvbnNlIGlzIGZyb20gYSBuYXRpdmUgY29tcG9uZW50IChlLmcuLCBXQU0pXG4gICAgICpcbiAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOYXRpdmVCcm9rZXI/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBJRCByZXR1cm5lZCBmcm9tIHRoZSByZXNwb25zZVxuICAgICAqXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdElkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgbG9va3VwIHBvbGljeVxuICAgICAqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgY2FjaGVMb29rdXBQb2xpY3k/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSBPdXRjb21lXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgY2FjaGVPdXRjb21lPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUgc3BlbnQgaW4gdGhlIEpTIHF1ZXVlIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHF1ZXVlZFRpbWVNcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFN1Yi1tZWFzdXJlbWVudHMgZm9yIGludGVybmFsIHVzZS4gVG8gYmUgZGVsZXRlZCBiZWZvcmUgZmx1c2hpbmcuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZVN1Yk1lYXN1cmVtZW50cz86IE1hcDxzdHJpbmcsIFN1Yk1lYXN1cmVtZW50PjtcblxuICAgIHZpc2liaWxpdHlDaGFuZ2VDb3VudD86IG51bWJlcjtcbiAgICBpbmNvbXBsZXRlU3Vic0NvdW50PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29ycmVsYXRpb25JZCBvZiB0aGUgaW4gcHJvZ3Jlc3MgaWZyYW1lIHJlcXVlc3QgdGhhdCB3YXMgYXdhaXRlZFxuICAgICAqL1xuICAgIGF3YWl0SWZyYW1lQ29ycmVsYXRpb25JZD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZXMgcXVldWVkIGluIHRoZSBKUyBldmVudCBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHF1ZXVlZENvdW50PzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBtYW51YWxseSBjb21wbGV0ZWQgcXVldWUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgcXVldWVkTWFudWFsbHlDb21wbGV0ZWRDb3VudD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgdGhlIGlkIHRva2VuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGlkVG9rZW5TaXplPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaXplIG9mIHRoZSBhY2Nlc3MgdG9rZW5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBhY2Nlc3NUb2tlblNpemU/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNpemUgb2YgdGhlIHJlZnJlc2ggdG9rZW5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICByZWZyZXNoVG9rZW5TaXplPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQXBwbGljYXRpb24gbmFtZSBhcyBzcGVjaWZpZWQgYnkgdGhlIGFwcC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIGFwcE5hbWU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWNhdGlvbiB2ZXJzaW9uIGFzIHNwZWNpZmllZCBieSB0aGUgYXBwLlxuICAgICAqXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgYXBwVmVyc2lvbj86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgYXJlIGZpZWxkcyB0aGF0IG1heSBiZSBlbWl0dGVkIGluIG5hdGl2ZSBicm9rZXIgc2NlbmFyaW9zXG4gICAgICovXG4gICAgZXh0ZW5zaW9uSWQ/OiBzdHJpbmc7XG4gICAgZXh0ZW5zaW9uVmVyc2lvbj86IHN0cmluZztcbiAgICBtYXRzQnJva2VyVmVyc2lvbj86IHN0cmluZztcbiAgICBtYXRzQWNjb3VudEpvaW5PblN0YXJ0Pzogc3RyaW5nO1xuICAgIG1hdHNBY2NvdW50Sm9pbk9uRW5kPzogc3RyaW5nO1xuICAgIG1hdHNEZXZpY2VKb2luPzogc3RyaW5nO1xuICAgIG1hdHNQcm9tcHRCZWhhdmlvcj86IHN0cmluZztcbiAgICBtYXRzQXBpRXJyb3JDb2RlPzogbnVtYmVyO1xuICAgIG1hdHNVaVZpc2libGU/OiBib29sZWFuO1xuICAgIG1hdHNTaWxlbnRDb2RlPzogbnVtYmVyO1xuICAgIG1hdHNTaWxlbnRCaVN1YkNvZGU/OiBudW1iZXI7XG4gICAgbWF0c1NpbGVudE1lc3NhZ2U/OiBzdHJpbmc7XG4gICAgbWF0c1NpbGVudFN0YXR1cz86IG51bWJlcjtcbiAgICBtYXRzSHR0cFN0YXR1cz86IG51bWJlcjtcbiAgICBtYXRzSHR0cEV2ZW50Q291bnQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBIdHRwIFBPU1QgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBodHRwVmVyVG9rZW4/OiBzdHJpbmc7XG4gICAgaHR0cFN0YXR1cz86IG51bWJlcjtcbiAgICBjb250ZW50VHlwZUhlYWRlcj86IHN0cmluZztcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUGxhdGZvcm0gYnJva2VyIGZpZWxkc1xuICAgICAqL1xuICAgIGFsbG93UGxhdGZvcm1Ccm9rZXI/OiBib29sZWFuO1xuICAgIGV4dGVuc2lvbkluc3RhbGxlZD86IGJvb2xlYW47XG4gICAgZXh0ZW5zaW9uSGFuZHNoYWtlVGltZW91dE1zPzogbnVtYmVyO1xuICAgIGV4dGVuc2lvbkhhbmRzaGFrZVRpbWVkT3V0PzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIE5lc3RlZCBBcHAgQXV0aCBGaWVsZHNcbiAgICAgKi9cbiAgICBuZXN0ZWRBcHBBdXRoUmVxdWVzdD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsZSBtYXRjaGVkIGFjY2Vzcy9pZC9yZWZyZXNoIHRva2VucyBpbiB0aGUgY2FjaGVcbiAgICAgKi9cbiAgICBtdWx0aU1hdGNoZWRBVD86IG51bWJlcjtcbiAgICBtdWx0aU1hdGNoZWRJRD86IG51bWJlcjtcbiAgICBtdWx0aU1hdGNoZWRSVD86IG51bWJlcjtcblxuICAgIGVycm9yTmFtZT86IHN0cmluZztcbiAgICBlcnJvclN0YWNrPzogc3RyaW5nW107XG5cbiAgICAvLyBFdmVudCBjb250ZXh0IGFzIEpTT04gc3RyaW5nXG4gICAgY29udGV4dD86IHN0cmluZztcblxuICAgIC8vIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGNhY2hlIHRvIGJlIHJlcG9ydGVkIHdoZW4gY2FjaGUgcXVvdGEgaXMgZXhjZWVkZWRcbiAgICBjYWNoZVJ0Q291bnQ/OiBudW1iZXI7XG4gICAgY2FjaGVJZENvdW50PzogbnVtYmVyO1xuICAgIGNhY2hlQXRDb3VudD86IG51bWJlcjtcblxuICAgIC8vIFNjZW5hcmlvIGlkIHRvIHRyYWNrIGN1c3RvbSB1c2VyIHByb21wdHNcbiAgICBzY2VuYXJpb0lkPzogc3RyaW5nO1xuXG4gICAgYWNjb3VudFR5cGU/OiBcIkFBRFwiIHwgXCJNU0FcIiB8IFwiQjJDXCI7XG5cbiAgICAvKipcbiAgICAgKiBTZXJ2ZXIgZXJyb3IgdGhhdCB0cmlnZ2VycyBhIHJlcXVlc3QgcmV0cnlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmV0cnlFcnJvcj86IHN0cmluZztcblxuICAgIGVtYmVkZGVkQ2xpZW50SWQ/OiBzdHJpbmc7XG4gICAgZW1iZWRkZWRSZWRpcmVjdFVyaT86IHN0cmluZztcblxuICAgIGlzQXN5bmNQb3B1cD86IGJvb2xlYW47XG5cbiAgICBydEV4cGlyZXNPbk1zPzogbnVtYmVyO1xuXG4gICAgc2lkRnJvbUNsYWltcz86IGJvb2xlYW47XG4gICAgc2lkRnJvbVJlcXVlc3Q/OiBib29sZWFuO1xuICAgIGxvZ2luSGludEZyb21SZXF1ZXN0PzogYm9vbGVhbjtcbiAgICBsb2dpbkhpbnRGcm9tVXBuPzogYm9vbGVhbjtcbiAgICBsb2dpbkhpbnRGcm9tQ2xhaW0/OiBib29sZWFuO1xuICAgIGRvbWFpbkhpbnRGcm9tUmVxdWVzdD86IGJvb2xlYW47XG5cbiAgICBwcm9tcHQ/OiBzdHJpbmc7XG5cbiAgICB1c2VQcmVHZW5lcmF0ZWRQa2NlPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFBlcmZvcm1hbmNlRXZlbnRDb250ZXh0ID0ge1xuICAgIGR1cj86IG51bWJlcjtcbiAgICBlcnI/OiBzdHJpbmc7XG4gICAgc3ViRXJyPzogc3RyaW5nO1xuICAgIGZhaWw/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBQZXJmb3JtYW5jZUV2ZW50U3RhY2tlZENvbnRleHQgPSBQZXJmb3JtYW5jZUV2ZW50Q29udGV4dCAmIHtcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIGNoaWxkRXJyPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGNvbnN0IEludEZpZWxkczogUmVhZG9ubHlTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoW1xuICAgIFwiYWNjZXNzVG9rZW5TaXplXCIsXG4gICAgXCJkdXJhdGlvbk1zXCIsXG4gICAgXCJpZFRva2VuU2l6ZVwiLFxuICAgIFwibWF0c1NpbGVudFN0YXR1c1wiLFxuICAgIFwibWF0c0h0dHBTdGF0dXNcIixcbiAgICBcInJlZnJlc2hUb2tlblNpemVcIixcbiAgICBcInF1ZXVlZFRpbWVNc1wiLFxuICAgIFwic3RhcnRUaW1lTXNcIixcbiAgICBcInN0YXR1c1wiLFxuICAgIFwibXVsdGlNYXRjaGVkQVRcIixcbiAgICBcIm11bHRpTWF0Y2hlZElEXCIsXG4gICAgXCJtdWx0aU1hdGNoZWRSVFwiLFxuICAgIFwidW5lbmNyeXB0ZWRDYWNoZUNvdW50XCIsXG4gICAgXCJlbmNyeXB0ZWRDYWNoZUV4cGlyZWRDb3VudFwiLFxuXSk7XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBJUGVyZm9ybWFuY2VDbGllbnQgfSBmcm9tIFwiLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL0lQZXJmb3JtYW5jZUNsaWVudC5qc1wiO1xuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50LlxuICogVXNhZ2U6IGludm9rZShmdW5jdGlvblRvQ2FsbCwgcGVyZm9ybWFuY2VDbGllbnQsIFwiRXZlbnROYW1lXCIsIFwiY29ycmVsYXRpb25JZFwiKSguLi5hcmdzVG9QYXNzVG9GdW5jdGlvbilcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHBhcmFtIGV2ZW50TmFtZVxuICogQHBhcmFtIGxvZ2dlclxuICogQHBhcmFtIHRlbGVtZXRyeUNsaWVudFxuICogQHBhcmFtIGNvcnJlbGF0aW9uSWRcbiAqIEByZXR1cm5zXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBjb25zdCBpbnZva2UgPSA8VCBleHRlbmRzIEFycmF5PGFueT4sIFU+KFxuICAgIGNhbGxiYWNrOiAoLi4uYXJnczogVCkgPT4gVSxcbiAgICBldmVudE5hbWU6IHN0cmluZyxcbiAgICBsb2dnZXI6IExvZ2dlcixcbiAgICB0ZWxlbWV0cnlDbGllbnQ/OiBJUGVyZm9ybWFuY2VDbGllbnQsXG4gICAgY29ycmVsYXRpb25JZD86IHN0cmluZ1xuKSA9PiB7XG4gICAgcmV0dXJuICguLi5hcmdzOiBUKTogVSA9PiB7XG4gICAgICAgIGxvZ2dlci50cmFjZShgRXhlY3V0aW5nIGZ1bmN0aW9uICR7ZXZlbnROYW1lfWApO1xuICAgICAgICBjb25zdCBpblByb2dyZXNzRXZlbnQgPSB0ZWxlbWV0cnlDbGllbnQ/LnN0YXJ0TWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjb3JyZWxhdGlvbklkKSB7XG4gICAgICAgICAgICAvLyBUcmFjayBudW1iZXIgb2YgdGltZXMgdGhpcyBBUEkgaXMgY2FsbGVkIGluIGEgc2luZ2xlIHJlcXVlc3RcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50Q291bnQgPSBldmVudE5hbWUgKyBcIkNhbGxDb3VudFwiO1xuICAgICAgICAgICAgdGVsZW1ldHJ5Q2xpZW50Py5pbmNyZW1lbnRGaWVsZHMoXG4gICAgICAgICAgICAgICAgeyBbZXZlbnRDb3VudF06IDEgfSxcbiAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgICAgICAgIGluUHJvZ3Jlc3NFdmVudD8uZW5kKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIudHJhY2UoYFJldHVybmluZyByZXN1bHQgZnJvbSAke2V2ZW50TmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50cmFjZShgRXJyb3Igb2NjdXJyZWQgaW4gJHtldmVudE5hbWV9YCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiVW5hYmxlIHRvIHByaW50IGVycm9yIG1lc3NhZ2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5Qcm9ncmVzc0V2ZW50Py5lbmQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogV3JhcHMgYW4gYXN5bmMgZnVuY3Rpb24gd2l0aCBhIHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50LlxuICogVXNhZ2U6IGludm9rZUFzeW5jKGZ1bmN0aW9uVG9DYWxsLCBwZXJmb3JtYW5jZUNsaWVudCwgXCJFdmVudE5hbWVcIiwgXCJjb3JyZWxhdGlvbklkXCIpKC4uLmFyZ3NUb1Bhc3NUb0Z1bmN0aW9uKVxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcGFyYW0gZXZlbnROYW1lXG4gKiBAcGFyYW0gbG9nZ2VyXG4gKiBAcGFyYW0gdGVsZW1ldHJ5Q2xpZW50XG4gKiBAcGFyYW0gY29ycmVsYXRpb25JZFxuICogQHJldHVybnNcbiAqIEBpbnRlcm5hbFxuICpcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBjb25zdCBpbnZva2VBc3luYyA9IDxUIGV4dGVuZHMgQXJyYXk8YW55PiwgVT4oXG4gICAgY2FsbGJhY2s6ICguLi5hcmdzOiBUKSA9PiBQcm9taXNlPFU+LFxuICAgIGV2ZW50TmFtZTogc3RyaW5nLFxuICAgIGxvZ2dlcjogTG9nZ2VyLFxuICAgIHRlbGVtZXRyeUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudCxcbiAgICBjb3JyZWxhdGlvbklkPzogc3RyaW5nXG4pID0+IHtcbiAgICByZXR1cm4gKC4uLmFyZ3M6IFQpOiBQcm9taXNlPFU+ID0+IHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKGBFeGVjdXRpbmcgZnVuY3Rpb24gJHtldmVudE5hbWV9YCk7XG4gICAgICAgIGNvbnN0IGluUHJvZ3Jlc3NFdmVudCA9IHRlbGVtZXRyeUNsaWVudD8uc3RhcnRNZWFzdXJlbWVudChcbiAgICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNvcnJlbGF0aW9uSWQpIHtcbiAgICAgICAgICAgIC8vIFRyYWNrIG51bWJlciBvZiB0aW1lcyB0aGlzIEFQSSBpcyBjYWxsZWQgaW4gYSBzaW5nbGUgcmVxdWVzdFxuICAgICAgICAgICAgY29uc3QgZXZlbnRDb3VudCA9IGV2ZW50TmFtZSArIFwiQ2FsbENvdW50XCI7XG4gICAgICAgICAgICB0ZWxlbWV0cnlDbGllbnQ/LmluY3JlbWVudEZpZWxkcyhcbiAgICAgICAgICAgICAgICB7IFtldmVudENvdW50XTogMSB9LFxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGVsZW1ldHJ5Q2xpZW50Py5zZXRQcmVRdWV1ZVRpbWUoZXZlbnROYW1lLCBjb3JyZWxhdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoYFJldHVybmluZyByZXN1bHQgZnJvbSAke2V2ZW50TmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpblByb2dyZXNzRXZlbnQ/LmVuZCh7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShgRXJyb3Igb2NjdXJyZWQgaW4gJHtldmVudE5hbWV9YCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlVuYWJsZSB0byBwcmludCBlcnJvciBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5Qcm9ncmVzc0V2ZW50Py5lbmQoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcbn07XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IElOZXR3b3JrTW9kdWxlIH0gZnJvbSBcIi4uL25ldHdvcmsvSU5ldHdvcmtNb2R1bGUuanNcIjtcbmltcG9ydCB7IE5ldHdvcmtSZXNwb25zZSB9IGZyb20gXCIuLi9uZXR3b3JrL05ldHdvcmtSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgSU1EU0JhZFJlc3BvbnNlIH0gZnJvbSBcIi4uL3Jlc3BvbnNlL0lNRFNCYWRSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBDb25zdGFudHMsXG4gICAgUmVnaW9uRGlzY292ZXJ5U291cmNlcyxcbiAgICBSZXNwb25zZUNvZGVzLFxufSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBSZWdpb25EaXNjb3ZlcnlNZXRhZGF0YSB9IGZyb20gXCIuL1JlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLmpzXCI7XG5pbXBvcnQgeyBJbWRzT3B0aW9ucyB9IGZyb20gXCIuL0ltZHNPcHRpb25zLmpzXCI7XG5pbXBvcnQgeyBJUGVyZm9ybWFuY2VDbGllbnQgfSBmcm9tIFwiLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL0lQZXJmb3JtYW5jZUNsaWVudC5qc1wiO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VFdmVudHMgfSBmcm9tIFwiLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL1BlcmZvcm1hbmNlRXZlbnQuanNcIjtcbmltcG9ydCB7IGludm9rZUFzeW5jIH0gZnJvbSBcIi4uL3V0aWxzL0Z1bmN0aW9uV3JhcHBlcnMuanNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyLmpzXCI7XG5cbmV4cG9ydCBjbGFzcyBSZWdpb25EaXNjb3Zlcnkge1xuICAgIC8vIE5ldHdvcmsgaW50ZXJmYWNlIHRvIG1ha2UgcmVxdWVzdHMgd2l0aC5cbiAgICBwcm90ZWN0ZWQgbmV0d29ya0ludGVyZmFjZTogSU5ldHdvcmtNb2R1bGU7XG4gICAgLy8gTG9nZ2VyXG4gICAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgICAvLyBQZXJmb3JtYW5jZSBjbGllbnRcbiAgICBwcm90ZWN0ZWQgcGVyZm9ybWFuY2VDbGllbnQ6IElQZXJmb3JtYW5jZUNsaWVudCB8IHVuZGVmaW5lZDtcbiAgICAvLyBDb3JyZWxhdGlvbklkXG4gICAgcHJvdGVjdGVkIGNvcnJlbGF0aW9uSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvLyBPcHRpb25zIGZvciB0aGUgSU1EUyBlbmRwb2ludCByZXF1ZXN0XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBJTURTX09QVElPTlM6IEltZHNPcHRpb25zID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBNZXRhZGF0YTogXCJ0cnVlXCIsXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBuZXR3b3JrSW50ZXJmYWNlOiBJTmV0d29ya01vZHVsZSxcbiAgICAgICAgbG9nZ2VyOiBMb2dnZXIsXG4gICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50PzogSVBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICBjb3JyZWxhdGlvbklkPzogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIHRoaXMubmV0d29ya0ludGVyZmFjZSA9IG5ldHdvcmtJbnRlcmZhY2U7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50ID0gcGVyZm9ybWFuY2VDbGllbnQ7XG4gICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IHRoZSByZWdpb24gZnJvbSB0aGUgYXBwbGljYXRpb24ncyBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8c3RyaW5nIHwgbnVsbD5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZGV0ZWN0UmVnaW9uKFxuICAgICAgICBlbnZpcm9ubWVudFJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YTogUmVnaW9uRGlzY292ZXJ5TWV0YWRhdGFcbiAgICApOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeURldGVjdFJlZ2lvbixcbiAgICAgICAgICAgIHRoaXMuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYXV0byBkZXRlY3RlZCByZWdpb24gd2l0aCB0aGUgcmVnaW9uIGZyb20gdGhlIGVudnJpb25tZW50XG4gICAgICAgIGxldCBhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lID0gZW52aXJvbm1lbnRSZWdpb247XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSByZWdpb24gd2FzIGRldGVjdGVkIGZyb20gdGhlIGVudmlyb25tZW50LCBpZiBub3QsIGF0dGVtcHQgdG8gZ2V0IHRoZSByZWdpb24gZnJvbSBJTURTXG4gICAgICAgIGlmICghYXV0b2RldGVjdGVkUmVnaW9uTmFtZSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFJlZ2lvbkRpc2NvdmVyeS5JTURTX09QVElPTlM7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxJTURTVmVyc2lvblJlc3BvbnNlID0gYXdhaXQgaW52b2tlQXN5bmMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UmVnaW9uRnJvbUlNRFMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5R2V0UmVnaW9uRnJvbUlNRFMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICAgICApKENvbnN0YW50cy5JTURTX1ZFUlNJT04sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxJTURTVmVyc2lvblJlc3BvbnNlLnN0YXR1cyA9PT1cbiAgICAgICAgICAgICAgICAgICAgUmVzcG9uc2VDb2Rlcy5odHRwU3VjY2Vzc1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lID0gbG9jYWxJTURTVmVyc2lvblJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9zb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgUmVnaW9uRGlzY292ZXJ5U291cmNlcy5JTURTO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXNwb25zZSB1c2luZyB0aGUgbG9jYWwgSU1EUyB2ZXJzaW9uIGZhaWxlZCwgdHJ5IHRvIGZldGNoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgSU1EUyBhbmQgcmV0cnkuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBsb2NhbElNRFNWZXJzaW9uUmVzcG9uc2Uuc3RhdHVzID09PVxuICAgICAgICAgICAgICAgICAgICBSZXNwb25zZUNvZGVzLmh0dHBCYWRSZXF1ZXN0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJTURTVmVyc2lvbiA9IGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDdXJyZW50VmVyc2lvbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5R2V0Q3VycmVudFZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICAgICAgICAgKShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50SU1EU1ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9zb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZ2lvbkRpc2NvdmVyeVNvdXJjZXMuRkFJTEVEX0FVVE9fREVURUNUSU9OO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SU1EU1ZlcnNpb25SZXNwb25zZSA9IGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRSZWdpb25Gcm9tSU1EUy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5R2V0UmVnaW9uRnJvbUlNRFMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICAgICAgICAgKShjdXJyZW50SU1EU1ZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SU1EU1ZlcnNpb25SZXNwb25zZS5zdGF0dXMgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBSZXNwb25zZUNvZGVzLmh0dHBTdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b2RldGVjdGVkUmVnaW9uTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudElNRFNWZXJzaW9uUmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9zb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZ2lvbkRpc2NvdmVyeVNvdXJjZXMuSU1EUztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgUmVnaW9uRGlzY292ZXJ5U291cmNlcy5GQUlMRURfQVVUT19ERVRFQ1RJT047XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fc291cmNlID1cbiAgICAgICAgICAgICAgICBSZWdpb25EaXNjb3ZlcnlTb3VyY2VzLkVOVklST05NRU5UX1ZBUklBQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcmVnaW9uIHdhcyBhdXRvIGRldGVjdGVkIGZyb20gdGhlIGVudmlyb25tZW50IG9yIGZyb20gdGhlIElNRFMgZW5kcG9pbnQsIG1hcmsgdGhlIGF0dGVtcHQgYXMgYSBGQUlMRURfQVVUT19ERVRFQ1RJT05cbiAgICAgICAgaWYgKCFhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lKSB7XG4gICAgICAgICAgICByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fc291cmNlID1cbiAgICAgICAgICAgICAgICBSZWdpb25EaXNjb3ZlcnlTb3VyY2VzLkZBSUxFRF9BVVRPX0RFVEVDVElPTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgY2FsbCB0byB0aGUgSU1EUyBlbmRwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIGltZHNFbmRwb2ludFVybFxuICAgICAqIEByZXR1cm5zIFByb21pc2U8TmV0d29ya1Jlc3BvbnNlPHN0cmluZz4+XG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRSZWdpb25Gcm9tSU1EUyhcbiAgICAgICAgdmVyc2lvbjogc3RyaW5nLFxuICAgICAgICBvcHRpb25zOiBJbWRzT3B0aW9uc1xuICAgICk6IFByb21pc2U8TmV0d29ya1Jlc3BvbnNlPHN0cmluZz4+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeUdldFJlZ2lvbkZyb21JTURTLFxuICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtJbnRlcmZhY2Uuc2VuZEdldFJlcXVlc3RBc3luYzxzdHJpbmc+KFxuICAgICAgICAgICAgYCR7Q29uc3RhbnRzLklNRFNfRU5EUE9JTlR9P2FwaS12ZXJzaW9uPSR7dmVyc2lvbn0mZm9ybWF0PXRleHRgLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIENvbnN0YW50cy5JTURTX1RJTUVPVVRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgdGhlIElNRFMgZW5kcG9pbnQgYXZhaWxhYmxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPHN0cmluZyB8IG51bGw+XG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRDdXJyZW50VmVyc2lvbihcbiAgICAgICAgb3B0aW9uczogSW1kc09wdGlvbnNcbiAgICApOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeUdldEN1cnJlbnRWZXJzaW9uLFxuICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uZXR3b3JrSW50ZXJmYWNlLnNlbmRHZXRSZXF1ZXN0QXN5bmM8SU1EU0JhZFJlc3BvbnNlPihcbiAgICAgICAgICAgICAgICAgICAgYCR7Q29uc3RhbnRzLklNRFNfRU5EUE9JTlR9P2Zvcm1hdD1qc29uYCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gSU1EUyBlbmRwb2ludCBpcyBjYWxsZWQgd2l0aG91dCB0aGUgYXBpIHZlcnNpb24gcXVlcnkgcGFyYW0sIGJhZCByZXF1ZXN0IHJlc3BvbnNlIGNvbWVzIGJhY2sgd2l0aCBsYXRlc3QgdmVyc2lvbi5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXMgPT09IFJlc3BvbnNlQ29kZXMuaHR0cEJhZFJlcXVlc3QgJiZcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ICYmXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keVtcIm5ld2VzdC12ZXJzaW9uc1wiXSAmJlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHlbXCJuZXdlc3QtdmVyc2lvbnNcIl0ubGVuZ3RoID4gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHlbXCJuZXdlc3QtdmVyc2lvbnNcIl1bMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aG9yaXR5VHlwZSB9IGZyb20gXCIuL0F1dGhvcml0eVR5cGUuanNcIjtcbmltcG9ydCB7XG4gICAgaXNPcGVuSWRDb25maWdSZXNwb25zZSxcbiAgICBPcGVuSWRDb25maWdSZXNwb25zZSxcbn0gZnJvbSBcIi4vT3BlbklkQ29uZmlnUmVzcG9uc2UuanNcIjtcbmltcG9ydCB7IFVybFN0cmluZyB9IGZyb20gXCIuLi91cmwvVXJsU3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBJVXJpIH0gZnJvbSBcIi4uL3VybC9JVXJpLmpzXCI7XG5pbXBvcnQge1xuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbiAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcyxcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgSU5ldHdvcmtNb2R1bGUgfSBmcm9tIFwiLi4vbmV0d29yay9JTmV0d29ya01vZHVsZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBBQURBdXRob3JpdHlDb25zdGFudHMsXG4gICAgQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UsXG4gICAgQ29uc3RhbnRzLFxuICAgIFJlZ2lvbkRpc2NvdmVyeU91dGNvbWVzLFxufSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge1xuICAgIEVuZHBvaW50TWV0YWRhdGEsXG4gICAgZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXMsXG4gICAgZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrUmVzcG9uc2UsXG4gICAgSW5zdGFuY2VEaXNjb3ZlcnlNZXRhZGF0YUFsaWFzZXMsXG59IGZyb20gXCIuL0F1dGhvcml0eU1ldGFkYXRhLmpzXCI7XG5pbXBvcnQge1xuICAgIGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcixcbiAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcyxcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvci5qc1wiO1xuaW1wb3J0IHsgUHJvdG9jb2xNb2RlIH0gZnJvbSBcIi4vUHJvdG9jb2xNb2RlLmpzXCI7XG5pbXBvcnQgeyBJQ2FjaGVNYW5hZ2VyIH0gZnJvbSBcIi4uL2NhY2hlL2ludGVyZmFjZS9JQ2FjaGVNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpdHlNZXRhZGF0YUVudGl0eSB9IGZyb20gXCIuLi9jYWNoZS9lbnRpdGllcy9BdXRob3JpdHlNZXRhZGF0YUVudGl0eS5qc1wiO1xuaW1wb3J0IHtcbiAgICBBdXRob3JpdHlPcHRpb25zLFxuICAgIEF6dXJlQ2xvdWRJbnN0YW5jZSxcbiAgICBTdGF0aWNBdXRob3JpdHlPcHRpb25zLFxufSBmcm9tIFwiLi9BdXRob3JpdHlPcHRpb25zLmpzXCI7XG5pbXBvcnQge1xuICAgIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZSxcbiAgICBpc0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZSxcbn0gZnJvbSBcIi4vQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlLmpzXCI7XG5pbXBvcnQge1xuICAgIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlLFxuICAgIGlzQ2xvdWRJbnN0YW5jZURpc2NvdmVyeUVycm9yUmVzcG9uc2UsXG59IGZyb20gXCIuL0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlLmpzXCI7XG5pbXBvcnQgeyBDbG91ZERpc2NvdmVyeU1ldGFkYXRhIH0gZnJvbSBcIi4vQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YS5qc1wiO1xuaW1wb3J0IHsgUmVnaW9uRGlzY292ZXJ5IH0gZnJvbSBcIi4vUmVnaW9uRGlzY292ZXJ5LmpzXCI7XG5pbXBvcnQgeyBSZWdpb25EaXNjb3ZlcnlNZXRhZGF0YSB9IGZyb20gXCIuL1JlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLmpzXCI7XG5pbXBvcnQgeyBJbWRzT3B0aW9ucyB9IGZyb20gXCIuL0ltZHNPcHRpb25zLmpzXCI7XG5pbXBvcnQgeyBBenVyZUNsb3VkT3B0aW9ucyB9IGZyb20gXCIuLi9jb25maWcvQ2xpZW50Q29uZmlndXJhdGlvbi5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXIuanNcIjtcbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gXCIuLi9lcnJvci9BdXRoRXJyb3IuanNcIjtcbmltcG9ydCB7IElQZXJmb3JtYW5jZUNsaWVudCB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvSVBlcmZvcm1hbmNlQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZUV2ZW50cyB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC5qc1wiO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMgfSBmcm9tIFwiLi4vdXRpbHMvRnVuY3Rpb25XcmFwcGVycy5qc1wiO1xuaW1wb3J0ICogYXMgQ2FjaGVIZWxwZXJzIGZyb20gXCIuLi9jYWNoZS91dGlscy9DYWNoZUhlbHBlcnMuanNcIjtcblxuLyoqXG4gKiBUaGUgYXV0aG9yaXR5IGNsYXNzIHZhbGlkYXRlcyB0aGUgYXV0aG9yaXR5IFVSSXMgdXNlZCBieSB0aGUgdXNlciwgYW5kIHJldHJpZXZlcyB0aGUgT3BlbklEIENvbmZpZ3VyYXRpb24gRGF0YSBmcm9tIHRoZVxuICogZW5kcG9pbnQuIEl0IHdpbGwgc3RvcmUgdGhlIHBlcnRpbmVudCBjb25maWcgZGF0YSBpbiB0aGlzIG9iamVjdCBmb3IgdXNlIGR1cmluZyB0b2tlbiBjYWxscy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQXV0aG9yaXR5IHtcbiAgICAvLyBDYW5vbmljYWwgYXV0aG9yaXR5IHVybCBzdHJpbmdcbiAgICBwcml2YXRlIF9jYW5vbmljYWxBdXRob3JpdHk6IFVybFN0cmluZztcbiAgICAvLyBDYW5vbmljYWx5IGF1dGhvcml0eSB1cmwgY29tcG9uZW50c1xuICAgIHByaXZhdGUgX2Nhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHM6IElVcmkgfCBudWxsO1xuICAgIC8vIE5ldHdvcmsgaW50ZXJmYWNlIHRvIG1ha2UgcmVxdWVzdHMgd2l0aC5cbiAgICBwcm90ZWN0ZWQgbmV0d29ya0ludGVyZmFjZTogSU5ldHdvcmtNb2R1bGU7XG4gICAgLy8gQ2FjaGUgTWFuYWdlciB0byBjYWNoZSBuZXR3b3JrIHJlc3BvbnNlc1xuICAgIHByb3RlY3RlZCBjYWNoZU1hbmFnZXI6IElDYWNoZU1hbmFnZXI7XG4gICAgLy8gUHJvdG9jb2wgbW9kZSB0byBjb25zdHJ1Y3QgZW5kcG9pbnRzXG4gICAgcHJpdmF0ZSBhdXRob3JpdHlPcHRpb25zOiBBdXRob3JpdHlPcHRpb25zO1xuICAgIC8vIEF1dGhvcml0eSBtZXRhZGF0YVxuICAgIHByaXZhdGUgbWV0YWRhdGE6IEF1dGhvcml0eU1ldGFkYXRhRW50aXR5O1xuICAgIC8vIFJlZ2lvbiBkaXNjb3Zlcnkgc2VydmljZVxuICAgIHByaXZhdGUgcmVnaW9uRGlzY292ZXJ5OiBSZWdpb25EaXNjb3Zlcnk7XG4gICAgLy8gUmVnaW9uIGRpc2NvdmVyeSBtZXRhZGF0YVxuICAgIHB1YmxpYyByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YTogUmVnaW9uRGlzY292ZXJ5TWV0YWRhdGE7XG4gICAgLy8gTG9nZ2VyIG9iamVjdFxuICAgIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XG4gICAgLy8gUGVyZm9ybWFuY2UgY2xpZW50XG4gICAgcHJvdGVjdGVkIHBlcmZvcm1hbmNlQ2xpZW50OiBJUGVyZm9ybWFuY2VDbGllbnQgfCB1bmRlZmluZWQ7XG4gICAgLy8gQ29ycmVsYXRpb24gSWRcbiAgICBwcm90ZWN0ZWQgY29ycmVsYXRpb25JZDogc3RyaW5nO1xuICAgIC8vIEluZGljYXRlcyBpZiB0aGUgYXV0aG9yaXR5IGlzIGZha2UsIGZvciB0aGUgcHVycG9zZSBvZiBhIE1hbmFnZWQgSWRlbnRpdHkgQXBwbGljYXRpb25cbiAgICBwcml2YXRlIG1hbmFnZWRJZGVudGl0eTogYm9vbGVhbjtcbiAgICAvLyBSZXNlcnZlZCB0ZW5hbnQgZG9tYWluIG5hbWVzIHRoYXQgd2lsbCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0ZW5hbnQgaWRcbiAgICBwcml2YXRlIHN0YXRpYyByZXNlcnZlZFRlbmFudERvbWFpbnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChbXG4gICAgICAgIFwie3RlbmFudH1cIixcbiAgICAgICAgXCJ7dGVuYW50aWR9XCIsXG4gICAgICAgIEFBREF1dGhvcml0eUNvbnN0YW50cy5DT01NT04sXG4gICAgICAgIEFBREF1dGhvcml0eUNvbnN0YW50cy5DT05TVU1FUlMsXG4gICAgICAgIEFBREF1dGhvcml0eUNvbnN0YW50cy5PUkdBTklaQVRJT05TLFxuICAgIF0pO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGF1dGhvcml0eTogc3RyaW5nLFxuICAgICAgICBuZXR3b3JrSW50ZXJmYWNlOiBJTmV0d29ya01vZHVsZSxcbiAgICAgICAgY2FjaGVNYW5hZ2VyOiBJQ2FjaGVNYW5hZ2VyLFxuICAgICAgICBhdXRob3JpdHlPcHRpb25zOiBBdXRob3JpdHlPcHRpb25zLFxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICAgICAgY29ycmVsYXRpb25JZDogc3RyaW5nLFxuICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgbWFuYWdlZElkZW50aXR5PzogYm9vbGVhblxuICAgICkge1xuICAgICAgICB0aGlzLmNhbm9uaWNhbEF1dGhvcml0eSA9IGF1dGhvcml0eTtcbiAgICAgICAgdGhpcy5fY2Fub25pY2FsQXV0aG9yaXR5LnZhbGlkYXRlQXNVcmkoKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrSW50ZXJmYWNlID0gbmV0d29ya0ludGVyZmFjZTtcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIgPSBjYWNoZU1hbmFnZXI7XG4gICAgICAgIHRoaXMuYXV0aG9yaXR5T3B0aW9ucyA9IGF1dGhvcml0eU9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEgPSB7XG4gICAgICAgICAgICByZWdpb25fdXNlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVnaW9uX3NvdXJjZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVnaW9uX291dGNvbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQgPSBwZXJmb3JtYW5jZUNsaWVudDtcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gY29ycmVsYXRpb25JZDtcbiAgICAgICAgdGhpcy5tYW5hZ2VkSWRlbnRpdHkgPSBtYW5hZ2VkSWRlbnRpdHkgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5ID0gbmV3IFJlZ2lvbkRpc2NvdmVyeShcbiAgICAgICAgICAgIG5ldHdvcmtJbnRlcmZhY2UsXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQge0BsaW5rIEF1dGhvcml0eVR5cGV9XG4gICAgICogQHBhcmFtIGF1dGhvcml0eVVyaSB7QGxpbmsgSVVyaX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0QXV0aG9yaXR5VHlwZShhdXRob3JpdHlVcmk6IElVcmkpOiBBdXRob3JpdHlUeXBlIHtcbiAgICAgICAgLy8gQ0lBTSBhdXRoIHVybCBwYXR0ZXJuIGlzIGJlaW5nIHN0YW5kYXJkaXplZCBhczogPHRlbmFudD4uY2lhbWxvZ2luLmNvbVxuICAgICAgICBpZiAoYXV0aG9yaXR5VXJpLkhvc3ROYW1lQW5kUG9ydC5lbmRzV2l0aChDb25zdGFudHMuQ0lBTV9BVVRIX1VSTCkpIHtcbiAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHlUeXBlLkNpYW07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXRoU2VnbWVudHMgPSBhdXRob3JpdHlVcmkuUGF0aFNlZ21lbnRzO1xuICAgICAgICBpZiAocGF0aFNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXRoU2VnbWVudHNbMF0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLkFERlM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHlUeXBlLkFkZnM7XG4gICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuRFNUUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eVR5cGUuRHN0cztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXV0aG9yaXR5VHlwZS5EZWZhdWx0O1xuICAgIH1cblxuICAgIC8vIFNlZSBhYm92ZSBmb3IgQXV0aG9yaXR5VHlwZVxuICAgIHB1YmxpYyBnZXQgYXV0aG9yaXR5VHlwZSgpOiBBdXRob3JpdHlUeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXV0aG9yaXR5VHlwZSh0aGlzLmNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3RvY29sTW9kZSBlbnVtIHJlcHJlc2VudGluZyB0aGUgd2F5IGVuZHBvaW50cyBhcmUgY29uc3RydWN0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwcm90b2NvbE1vZGUoKTogUHJvdG9jb2xNb2RlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5wcm90b2NvbE1vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhdXRob3JpdHlPcHRpb25zIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlaW5zdGFudGlhdGUgYSBuZXcgYXV0aG9yaXR5IGluc3RhbmNlXG4gICAgICovXG4gICAgcHVibGljIGdldCBvcHRpb25zKCk6IEF1dGhvcml0eU9wdGlvbnMge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpdHlPcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgVVJMIHRoYXQgaXMgdGhlIGF1dGhvcml0eSBzZXQgYnkgdGhlIGRldmVsb3BlclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY2Fub25pY2FsQXV0aG9yaXR5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHkudXJsU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgY2Fub25pY2FsIGF1dGhvcml0eS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGNhbm9uaWNhbEF1dGhvcml0eSh1cmw6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHkgPSBuZXcgVXJsU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eS52YWxpZGF0ZUFzVXJpKCk7XG4gICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhdXRob3JpdHkgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMoKTogSVVyaSB7XG4gICAgICAgIGlmICghdGhpcy5fY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cykge1xuICAgICAgICAgICAgdGhpcy5fY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2Fub25pY2FsQXV0aG9yaXR5LmdldFVybENvbXBvbmVudHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBob3N0bmFtZSBhbmQgcG9ydCBpLmUuIGxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb21cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhvc3RuYW1lQW5kUG9ydCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzLkhvc3ROYW1lQW5kUG9ydC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0ZW5hbnQgZm9yIGF1dGhvcml0eS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRlbmFudCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzLlBhdGhTZWdtZW50c1swXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPQXV0aCAvYXV0aG9yaXplIGVuZHBvaW50IGZvciByZXF1ZXN0c1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYXV0aG9yaXphdGlvbkVuZHBvaW50KCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VQYXRoKHRoaXMubWV0YWRhdGEuYXV0aG9yaXphdGlvbl9lbmRwb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPQXV0aCAvdG9rZW4gZW5kcG9pbnQgZm9yIHJlcXVlc3RzXG4gICAgICovXG4gICAgcHVibGljIGdldCB0b2tlbkVuZHBvaW50KCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VQYXRoKHRoaXMubWV0YWRhdGEudG9rZW5fZW5kcG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmVuZHBvaW50UmVzb2x1dGlvbkVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBkZXZpY2VDb2RlRW5kcG9pbnQoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVBhdGgoXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS50b2tlbl9lbmRwb2ludC5yZXBsYWNlKFwiL3Rva2VuXCIsIFwiL2RldmljZWNvZGVcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPQXV0aCBsb2dvdXQgZW5kcG9pbnQgZm9yIHJlcXVlc3RzXG4gICAgICovXG4gICAgcHVibGljIGdldCBlbmRTZXNzaW9uRW5kcG9pbnQoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xuICAgICAgICAgICAgLy8gUk9QQyBwb2xpY2llcyBtYXkgbm90IGhhdmUgZW5kX3Nlc3Npb25fZW5kcG9pbnQgc2V0XG4gICAgICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEuZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmVuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlUGF0aCh0aGlzLm1ldGFkYXRhLmVuZF9zZXNzaW9uX2VuZHBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5lbmRwb2ludFJlc29sdXRpb25FcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9BdXRoIGlzc3VlciBmb3IgcmVxdWVzdHNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNlbGZTaWduZWRKd3RBdWRpZW5jZSgpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5kaXNjb3ZlcnlDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlUGF0aCh0aGlzLm1ldGFkYXRhLmlzc3Vlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKd2tzX3VyaSBmb3IgdG9rZW4gc2lnbmluZyBrZXlzXG4gICAgICovXG4gICAgcHVibGljIGdldCBqd2tzVXJpKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VQYXRoKHRoaXMubWV0YWRhdGEuandrc191cmkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmVuZHBvaW50UmVzb2x1dGlvbkVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRlbmFudCBuYW1lIGNhbiBiZSByZXBsYWNlZCBpbiBhdXRob3JpdHkge0BsaW5rIElVcml9XG4gICAgICogQHBhcmFtIGF1dGhvcml0eVVyaSB7QGxpbmsgSVVyaX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgY2FuUmVwbGFjZVRlbmFudChhdXRob3JpdHlVcmk6IElVcmkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGF1dGhvcml0eVVyaS5QYXRoU2VnbWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAhQXV0aG9yaXR5LnJlc2VydmVkVGVuYW50RG9tYWlucy5oYXMoXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5VXJpLlBhdGhTZWdtZW50c1swXVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRBdXRob3JpdHlUeXBlKGF1dGhvcml0eVVyaSkgPT09IEF1dGhvcml0eVR5cGUuRGVmYXVsdCAmJlxuICAgICAgICAgICAgdGhpcy5wcm90b2NvbE1vZGUgIT09IFByb3RvY29sTW9kZS5PSURDXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGVuYW50IGluIHVybCBwYXRoIHdpdGggY3VycmVudCB0ZW5hbnQuIERlZmF1bHRzIHRvIGNvbW1vbi5cbiAgICAgKiBAcGFyYW0gdXJsU3RyaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXBsYWNlVGVuYW50KHVybFN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHVybFN0cmluZy5yZXBsYWNlKC97dGVuYW50fXx7dGVuYW50aWR9L2csIHRoaXMudGVuYW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBwYXRoIHN1Y2ggYXMgdGVuYW50IG9yIHBvbGljeSB3aXRoIHRoZSBjdXJyZW50IHRlbmFudCBvciBwb2xpY3kuXG4gICAgICogQHBhcmFtIHVybFN0cmluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgcmVwbGFjZVBhdGgodXJsU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBsZXQgZW5kcG9pbnQgPSB1cmxTdHJpbmc7XG4gICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml0eVVybCA9IG5ldyBVcmxTdHJpbmcoXG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmNhbm9uaWNhbF9hdXRob3JpdHlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXR5VXJsQ29tcG9uZW50cyA9XG4gICAgICAgICAgICBjYWNoZWRBdXRob3JpdHlVcmwuZ2V0VXJsQ29tcG9uZW50cygpO1xuICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpdHlQYXJ0cyA9IGNhY2hlZEF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzO1xuICAgICAgICBjb25zdCBjdXJyZW50QXV0aG9yaXR5UGFydHMgPVxuICAgICAgICAgICAgdGhpcy5jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzLlBhdGhTZWdtZW50cztcblxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5UGFydHMuZm9yRWFjaCgoY3VycmVudFBhcnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkUGFydCA9IGNhY2hlZEF1dGhvcml0eVBhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpbmRleCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2FuUmVwbGFjZVRlbmFudChjYWNoZWRBdXRob3JpdHlVcmxDb21wb25lbnRzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVuYW50SWQgPSBuZXcgVXJsU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmF1dGhvcml6YXRpb25fZW5kcG9pbnRcbiAgICAgICAgICAgICAgICApLmdldFVybENvbXBvbmVudHMoKS5QYXRoU2VnbWVudHNbMF07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2sgaWYgQUFEIGNhbm9uaWNhbCBhdXRob3JpdHkgY29udGFpbnMgdGVuYW50IGRvbWFpbiBuYW1lLCBmb3IgZXhhbXBsZSBcInRlc3Rkb21haW4ub25taWNyb3NvZnQuY29tXCIsXG4gICAgICAgICAgICAgICAgICogYnkgY29tcGFyaW5nIGl0cyBmaXJzdCBwYXRoIHNlZ21lbnQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXV0aG9yaXphdGlvbiBlbmRwb2ludCBwYXRoIHNlZ21lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAgICAgICogYWx3YXlzIHJlc29sdmVkIHdpdGggdGVuYW50IGlkIGJ5IE9JREMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFBhcnQgIT09IHRlbmFudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBgUmVwbGFjaW5nIHRlbmFudCBkb21haW4gbmFtZSAke2NhY2hlZFBhcnR9IHdpdGggaWQgJHt0ZW5hbnRJZH1gXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFBhcnQgPSB0ZW5hbnRJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgIT09IGNhY2hlZFBhcnQpIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludCA9IGVuZHBvaW50LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIGAvJHtjYWNoZWRQYXJ0fS9gLFxuICAgICAgICAgICAgICAgICAgICBgLyR7Y3VycmVudFBhcnR9L2BcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlVGVuYW50KGVuZHBvaW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBvcGVuIGlkIGNvbmZpZ3VyYXRpb24gZW5kcG9pbnQgZm9yIGFueSBjYW5vbmljYWwgYXV0aG9yaXR5LlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXQgZGVmYXVsdE9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjYW5vbmljYWxBdXRob3JpdHlIb3N0ID0gdGhpcy5ob3N0bmFtZUFuZFBvcnQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5LmVuZHNXaXRoKFwidjIuMC9cIikgfHxcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5VHlwZSA9PT0gQXV0aG9yaXR5VHlwZS5BZGZzIHx8XG4gICAgICAgICAgICAodGhpcy5wcm90b2NvbE1vZGUgPT09IFByb3RvY29sTW9kZS5PSURDICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNBbGlhc09mS25vd25NaWNyb3NvZnRBdXRob3JpdHkoY2Fub25pY2FsQXV0aG9yaXR5SG9zdCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuY2Fub25pY2FsQXV0aG9yaXR5fS53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jYW5vbmljYWxBdXRob3JpdHl9djIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbmA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm9vbGVhbiB0aGF0IHJldHVybnMgd2hldGhlciBvciBub3QgdGVuYW50IGRpc2NvdmVyeSBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZGlzY292ZXJ5Q29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMubWV0YWRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBlbmRwb2ludCBkaXNjb3ZlcnkgdG8gZGlzY292ZXIgYWxpYXNlcywgcHJlZmVycmVkX2NhY2hlLCBwcmVmZXJyZWRfbmV0d29ya1xuICAgICAqIGFuZCB0aGUgL2F1dGhvcml6ZSwgL3Rva2VuIGFuZCBsb2dvdXQgZW5kcG9pbnRzLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyByZXNvbHZlRW5kcG9pbnRzQXN5bmMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlSZXNvbHZlRW5kcG9pbnRzQXN5bmMsXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtZXRhZGF0YUVudGl0eSA9IHRoaXMuZ2V0Q3VycmVudE1ldGFkYXRhRW50aXR5KCk7XG5cbiAgICAgICAgY29uc3QgY2xvdWREaXNjb3ZlcnlTb3VyY2UgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5VXBkYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgIHRoaXMuY29ycmVsYXRpb25JZFxuICAgICAgICApKG1ldGFkYXRhRW50aXR5KTtcbiAgICAgICAgdGhpcy5jYW5vbmljYWxBdXRob3JpdHkgPSB0aGlzLmNhbm9uaWNhbEF1dGhvcml0eS5yZXBsYWNlKFxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZUFuZFBvcnQsXG4gICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5wcmVmZXJyZWRfbmV0d29ya1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBlbmRwb2ludFNvdXJjZSA9IGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRwb2ludE1ldGFkYXRhLmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlVcGRhdGVFbmRwb2ludE1ldGFkYXRhLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkXG4gICAgICAgICkobWV0YWRhdGFFbnRpdHkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZE1ldGFkYXRhKG1ldGFkYXRhRW50aXR5LCBjbG91ZERpc2NvdmVyeVNvdXJjZSwge1xuICAgICAgICAgICAgc291cmNlOiBlbmRwb2ludFNvdXJjZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbG91ZERpc2NvdmVyeVNvdXJjZTogY2xvdWREaXNjb3ZlcnlTb3VyY2UsXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5RW5kcG9pbnRTb3VyY2U6IGVuZHBvaW50U291cmNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWV0YWRhdGEgZW50aXR5IGZyb20gY2FjaGUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2VyIHJldHVybnMgYSBuZXcgbWV0YWRhdGEgZW50aXR5IGJ1aWx0XG4gICAgICogZnJvbSB0aGUgY29uZmlndXJlZCBjYW5vbmljYWwgYXV0aG9yaXR5XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEN1cnJlbnRNZXRhZGF0YUVudGl0eSgpOiBBdXRob3JpdHlNZXRhZGF0YUVudGl0eSB7XG4gICAgICAgIGxldCBtZXRhZGF0YUVudGl0eTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkgfCBudWxsID1cbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLmdldEF1dGhvcml0eU1ldGFkYXRhQnlBbGlhcyh0aGlzLmhvc3RuYW1lQW5kUG9ydCk7XG5cbiAgICAgICAgaWYgKCFtZXRhZGF0YUVudGl0eSkge1xuICAgICAgICAgICAgbWV0YWRhdGFFbnRpdHkgPSB7XG4gICAgICAgICAgICAgICAgYWxpYXNlczogW10sXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkX2NhY2hlOiB0aGlzLmhvc3RuYW1lQW5kUG9ydCxcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfbmV0d29yazogdGhpcy5ob3N0bmFtZUFuZFBvcnQsXG4gICAgICAgICAgICAgICAgY2Fub25pY2FsX2F1dGhvcml0eTogdGhpcy5jYW5vbmljYWxBdXRob3JpdHksXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbl9lbmRwb2ludDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbl9lbmRwb2ludDogXCJcIixcbiAgICAgICAgICAgICAgICBlbmRfc2Vzc2lvbl9lbmRwb2ludDogXCJcIixcbiAgICAgICAgICAgICAgICBpc3N1ZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgYWxpYXNlc0Zyb21OZXR3b3JrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludHNGcm9tTmV0d29yazogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0OiBDYWNoZUhlbHBlcnMuZ2VuZXJhdGVBdXRob3JpdHlNZXRhZGF0YUV4cGlyZXNBdCgpLFxuICAgICAgICAgICAgICAgIGp3a3NfdXJpOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YWRhdGFFbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjYWNoZWQgbWV0YWRhdGEgYmFzZWQgb24gbWV0YWRhdGEgc291cmNlIGFuZCBzZXRzIHRoZSBpbnN0YW5jZSdzIG1ldGFkYXRhXG4gICAgICogcHJvcGVydHkgdG8gdGhlIHNhbWUgdmFsdWVcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFFbnRpdHlcbiAgICAgKiBAcGFyYW0gY2xvdWREaXNjb3ZlcnlTb3VyY2VcbiAgICAgKiBAcGFyYW0gZW5kcG9pbnRNZXRhZGF0YVJlc3VsdFxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlQ2FjaGVkTWV0YWRhdGEoXG4gICAgICAgIG1ldGFkYXRhRW50aXR5OiBBdXRob3JpdHlNZXRhZGF0YUVudGl0eSxcbiAgICAgICAgY2xvdWREaXNjb3ZlcnlTb3VyY2U6IEF1dGhvcml0eU1ldGFkYXRhU291cmNlIHwgbnVsbCxcbiAgICAgICAgZW5kcG9pbnRNZXRhZGF0YVJlc3VsdDoge1xuICAgICAgICAgICAgc291cmNlOiBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZTtcbiAgICAgICAgICAgIG1ldGFkYXRhPzogT3BlbklkQ29uZmlnUmVzcG9uc2U7XG4gICAgICAgIH0gfCBudWxsXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNsb3VkRGlzY292ZXJ5U291cmNlICE9PSBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZS5DQUNIRSAmJlxuICAgICAgICAgICAgZW5kcG9pbnRNZXRhZGF0YVJlc3VsdD8uc291cmNlICE9PSBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZS5DQUNIRVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBleHBpcmF0aW9uIHRpbWUgdW5sZXNzIGJvdGggdmFsdWVzIGNhbWUgZnJvbSBhIHN1Y2Nlc3NmdWwgY2FjaGUgbG9va3VwXG4gICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5leHBpcmVzQXQgPVxuICAgICAgICAgICAgICAgIENhY2hlSGVscGVycy5nZW5lcmF0ZUF1dGhvcml0eU1ldGFkYXRhRXhwaXJlc0F0KCk7XG4gICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5jYW5vbmljYWxfYXV0aG9yaXR5ID0gdGhpcy5jYW5vbmljYWxBdXRob3JpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY2FjaGVNYW5hZ2VyLmdlbmVyYXRlQXV0aG9yaXR5TWV0YWRhdGFDYWNoZUtleShcbiAgICAgICAgICAgIG1ldGFkYXRhRW50aXR5LnByZWZlcnJlZF9jYWNoZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5zZXRBdXRob3JpdHlNZXRhZGF0YShjYWNoZUtleSwgbWV0YWRhdGFFbnRpdHkpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGFFbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIEF1dGhvcml0eU1ldGFkYXRhRW50aXR5IHdpdGggbmV3IGVuZHBvaW50cyBhbmQgcmV0dXJuIHdoZXJlIHRoZSBpbmZvcm1hdGlvbiBjYW1lIGZyb21cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFFbnRpdHlcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIHVwZGF0ZUVuZHBvaW50TWV0YWRhdGEoXG4gICAgICAgIG1ldGFkYXRhRW50aXR5OiBBdXRob3JpdHlNZXRhZGF0YUVudGl0eVxuICAgICk6IFByb21pc2U8QXV0aG9yaXR5TWV0YWRhdGFTb3VyY2U+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZUVuZHBvaW50TWV0YWRhdGEsXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBsb2NhbE1ldGFkYXRhID1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kcG9pbnRNZXRhZGF0YUZyb21Mb2NhbFNvdXJjZXMobWV0YWRhdGFFbnRpdHkpO1xuXG4gICAgICAgIC8vIEZ1cnRoZXIgdXBkYXRlIG1heSBiZSByZXF1aXJlZCBmb3IgaGFyZGNvZGVkIG1ldGFkYXRhIGlmIHJlZ2lvbmFsIG1ldGFkYXRhIGlzIHByZWZlcnJlZFxuICAgICAgICBpZiAobG9jYWxNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGxvY2FsTWV0YWRhdGEuc291cmNlID09PVxuICAgICAgICAgICAgICAgIEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkhBUkRDT0RFRF9WQUxVRVNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHByZWZlcnMgdG8gdXNlIGFuIGF6dXJlIHJlZ2lvbiByZXBsYWNlIHRoZSBnbG9iYWwgZW5kcG9pbnRzIHdpdGggcmVnaW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhvcml0eU9wdGlvbnMuYXp1cmVSZWdpb25Db25maWd1cmF0aW9uPy5henVyZVJlZ2lvblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxNZXRhZGF0YS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFyZGNvZGVkTWV0YWRhdGEgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGFkYXRhV2l0aFJlZ2lvbmFsSW5mb3JtYXRpb24uYmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5VXBkYXRlTWV0YWRhdGFXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICAgICAgICAgKShsb2NhbE1ldGFkYXRhLm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIENhY2hlSGVscGVycy51cGRhdGVBdXRob3JpdHlFbmRwb2ludE1ldGFkYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhRW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcmRjb2RlZE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFFbnRpdHkuY2Fub25pY2FsX2F1dGhvcml0eSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5vbmljYWxBdXRob3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxNZXRhZGF0YS5zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbWV0YWRhdGEgZnJvbSBuZXR3b3JrIGlmIGxvY2FsIHNvdXJjZXMgYXJlbid0IGF2YWlsYWJsZVxuICAgICAgICBsZXQgbWV0YWRhdGEgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgIHRoaXMuZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrLmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlHZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcmssXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKSgpO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHByZWZlcnMgdG8gdXNlIGFuIGF6dXJlIHJlZ2lvbiByZXBsYWNlIHRoZSBnbG9iYWwgZW5kcG9pbnRzIHdpdGggcmVnaW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRob3JpdHlPcHRpb25zLmF6dXJlUmVnaW9uQ29uZmlndXJhdGlvbj8uYXp1cmVSZWdpb24pIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGFkYXRhV2l0aFJlZ2lvbmFsSW5mb3JtYXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5VXBkYXRlTWV0YWRhdGFXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICkobWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBDYWNoZUhlbHBlcnMudXBkYXRlQXV0aG9yaXR5RW5kcG9pbnRNZXRhZGF0YShcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUVudGl0eSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eU1ldGFkYXRhU291cmNlLk5FVFdPUks7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNZXRhZGF0YSBjb3VsZCBub3QgYmUgb2J0YWluZWQgZnJvbSB0aGUgY29uZmlnLCBjYWNoZSwgbmV0d29yayBvciBoYXJkY29kZWQgdmFsdWVzXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMub3BlbklkQ29uZmlnRXJyb3IsXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0T3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBlbmRwb2ludCBtZXRhZGF0YSBmcm9tIGxvY2FsIHNvdXJjZXMgYW5kIHJldHVybnMgd2hlcmUgdGhlIGluZm9ybWF0aW9uIHdhcyByZXRyaWV2ZWQgZnJvbSBhbmQgdGhlIG1ldGFkYXRhIGNvbmZpZ1xuICAgICAqIHJlc3BvbnNlIGlmIHRoZSBzb3VyY2UgaXMgaGFyZGNvZGVkIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIG1ldGFkYXRhRW50aXR5XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUVuZHBvaW50TWV0YWRhdGFGcm9tTG9jYWxTb3VyY2VzKFxuICAgICAgICBtZXRhZGF0YUVudGl0eTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHlcbiAgICApOiB7XG4gICAgICAgIHNvdXJjZTogQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2U7XG4gICAgICAgIG1ldGFkYXRhPzogT3BlbklkQ29uZmlnUmVzcG9uc2U7XG4gICAgfSB8IG51bGwge1xuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIGdldCBlbmRwb2ludCBtZXRhZGF0YSBmcm9tIGF1dGhvcml0eSBjb25maWd1cmF0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29uZmlnTWV0YWRhdGEgPSB0aGlzLmdldEVuZHBvaW50TWV0YWRhdGFGcm9tQ29uZmlnKCk7XG4gICAgICAgIGlmIChjb25maWdNZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIkZvdW5kIGVuZHBvaW50IG1ldGFkYXRhIGluIGF1dGhvcml0eSBjb25maWd1cmF0aW9uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBDYWNoZUhlbHBlcnMudXBkYXRlQXV0aG9yaXR5RW5kcG9pbnRNZXRhZGF0YShcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUVudGl0eSxcbiAgICAgICAgICAgICAgICBjb25maWdNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZS5DT05GSUcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgIFwiRGlkIG5vdCBmaW5kIGVuZHBvaW50IG1ldGFkYXRhIGluIHRoZSBjb25maWcuLi4gQXR0ZW1wdGluZyB0byBnZXQgZW5kcG9pbnQgbWV0YWRhdGEgZnJvbSB0aGUgaGFyZGNvZGVkIHZhbHVlcy5cIlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNraXBBdXRob3JpdHlNZXRhZGF0YUNhY2hlIGlzIHVzZWQgdG8gYnlwYXNzIGhhcmRjb2RlZCBhdXRob3JpdHkgbWV0YWRhdGEgYW5kIGZvcmNlIGEgbmV0d29yayBtZXRhZGF0YSBjYWNoZSBsb29rdXAgYW5kIG5ldHdvcmsgbWV0YWRhdGEgcmVxdWVzdCBpZiBubyBjYWNoZWQgcmVzcG9uc2UgaXMgYXZhaWxhYmxlLlxuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHlPcHRpb25zLnNraXBBdXRob3JpdHlNZXRhZGF0YUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIFwiU2tpcHBpbmcgaGFyZGNvZGVkIG1ldGFkYXRhIGNhY2hlIHNpbmNlIHNraXBBdXRob3JpdHlNZXRhZGF0YUNhY2hlIGlzIHNldCB0byB0cnVlLiBBdHRlbXB0aW5nIHRvIGdldCBlbmRwb2ludCBtZXRhZGF0YSBmcm9tIHRoZSBuZXR3b3JrIG1ldGFkYXRhIGNhY2hlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFyZGNvZGVkTWV0YWRhdGEgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXMoKTtcbiAgICAgICAgICAgIGlmIChoYXJkY29kZWRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIENhY2hlSGVscGVycy51cGRhdGVBdXRob3JpdHlFbmRwb2ludE1ldGFkYXRhKFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgaGFyZGNvZGVkTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkhBUkRDT0RFRF9WQUxVRVMsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBoYXJkY29kZWRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcIkRpZCBub3QgZmluZCBlbmRwb2ludCBtZXRhZGF0YSBpbiBoYXJkY29kZWQgdmFsdWVzLi4uIEF0dGVtcHRpbmcgdG8gZ2V0IGVuZHBvaW50IG1ldGFkYXRhIGZyb20gdGhlIG5ldHdvcmsgbWV0YWRhdGEgY2FjaGUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FjaGVkIG1ldGFkYXRhIGVudGl0eSBleHBpcmF0aW9uIHN0YXR1c1xuICAgICAgICBjb25zdCBtZXRhZGF0YUVudGl0eUV4cGlyZWQgPVxuICAgICAgICAgICAgQ2FjaGVIZWxwZXJzLmlzQXV0aG9yaXR5TWV0YWRhdGFFeHBpcmVkKG1ldGFkYXRhRW50aXR5KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc0F1dGhvcml0eVNhbWVUeXBlKG1ldGFkYXRhRW50aXR5KSAmJlxuICAgICAgICAgICAgbWV0YWRhdGFFbnRpdHkuZW5kcG9pbnRzRnJvbU5ldHdvcmsgJiZcbiAgICAgICAgICAgICFtZXRhZGF0YUVudGl0eUV4cGlyZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIkZvdW5kIGVuZHBvaW50IG1ldGFkYXRhIGluIHRoZSBjYWNoZS5cIik7XG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2U6IEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkNBQ0hFIH07XG4gICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGFFbnRpdHlFeHBpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiVGhlIG1ldGFkYXRhIGVudGl0eSBpcyBleHBpcmVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoZSBudW1iZXIgb2YgdXJsIGNvbXBvbmVudHMgYWZ0ZXIgdGhlIGRvbWFpbiB0byBkZXRlcm1pbmUgaWYgdGhlIGNhY2hlZFxuICAgICAqIGF1dGhvcml0eSBtZXRhZGF0YSBjYW4gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RlZCBhdXRob3JpdHkuIFByb3RlY3RzIGFnYWluc3Qgc2FtZSBkb21haW4gZGlmZmVyZW50XG4gICAgICogYXV0aG9yaXR5IHN1Y2ggYXMgbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS90ZW5hbnQgYW5kIGxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vdGZwL3RlbmFudC9wb2xpY3lcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFFbnRpdHlcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzQXV0aG9yaXR5U2FtZVR5cGUoXG4gICAgICAgIG1ldGFkYXRhRW50aXR5OiBBdXRob3JpdHlNZXRhZGF0YUVudGl0eVxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpdHlVcmwgPSBuZXcgVXJsU3RyaW5nKFxuICAgICAgICAgICAgbWV0YWRhdGFFbnRpdHkuY2Fub25pY2FsX2F1dGhvcml0eVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjYWNoZWRQYXJ0cyA9IGNhY2hlZEF1dGhvcml0eVVybC5nZXRVcmxDb21wb25lbnRzKCkuUGF0aFNlZ21lbnRzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjYWNoZWRQYXJ0cy5sZW5ndGggPT09XG4gICAgICAgICAgICB0aGlzLmNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzLmxlbmd0aFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGF1dGhvcml0eU1ldGFkYXRhIGNvbmZpZyBvcHRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEVuZHBvaW50TWV0YWRhdGFGcm9tQ29uZmlnKCk6IE9wZW5JZENvbmZpZ1Jlc3BvbnNlIHwgbnVsbCB7XG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eU9wdGlvbnMuYXV0aG9yaXR5TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5hdXRob3JpdHlNZXRhZGF0YVxuICAgICAgICAgICAgICAgICkgYXMgT3BlbklkQ29uZmlnUmVzcG9uc2U7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQXV0aG9yaXR5TWV0YWRhdGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBPQXV0aCBlbmRwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gT3BlbklEIGNvbmZpZ3VyYXRpb24gZW5kcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFzSGFyZGNvZGVkTWV0YWRhdGEgYm9vbGVhblxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrKCk6IFByb21pc2U8T3BlbklkQ29uZmlnUmVzcG9uc2UgfCBudWxsPiB7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlHZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcmssXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBvcHRpb25zOiBJbWRzT3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRPRE86IEFkZCBhIHRpbWVvdXQgaWYgdGhlIGF1dGhvcml0eSBleGlzdHMgaW4gb3VyIGxpYnJhcnknc1xuICAgICAgICAgKiBoYXJkY29kZWQgbGlzdCBvZiBtZXRhZGF0YVxuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdCBvcGVuSWRDb25maWd1cmF0aW9uRW5kcG9pbnQgPVxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0T3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50O1xuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgYEF1dGhvcml0eS5nZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcms6IGF0dGVtcHRpbmcgdG8gcmV0cmlldmUgT0F1dGggZW5kcG9pbnRzIGZyb20gJHtvcGVuSWRDb25maWd1cmF0aW9uRW5kcG9pbnR9YFxuICAgICAgICApO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uZXR3b3JrSW50ZXJmYWNlLnNlbmRHZXRSZXF1ZXN0QXN5bmM8T3BlbklkQ29uZmlnUmVzcG9uc2U+KFxuICAgICAgICAgICAgICAgICAgICBvcGVuSWRDb25maWd1cmF0aW9uRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFJlc3BvbnNlID0gaXNPcGVuSWRDb25maWdSZXNwb25zZShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICAgICAgYEF1dGhvcml0eS5nZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcms6IGNvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBhcyBPcGVuSUQgY29uZmlndXJhdGlvbmBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIGBBdXRob3JpdHkuZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrOiAke2V9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IE9BdXRoIGVuZHBvaW50cyBmb3IgY29tbW9uIGF1dGhvcml0aWVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXMoKTogT3BlbklkQ29uZmlnUmVzcG9uc2UgfCBudWxsIHtcbiAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWVBbmRQb3J0IGluIEVuZHBvaW50TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBFbmRwb2ludE1ldGFkYXRhW3RoaXMuaG9zdG5hbWVBbmRQb3J0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcmV0cmlldmVkIG1ldGFkYXRhIHdpdGggcmVnaW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICogVXNlciBzZWxlY3RlZCBBenVyZSByZWdpb24gd2lsbCBiZSB1c2VkIGlmIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVNZXRhZGF0YVdpdGhSZWdpb25hbEluZm9ybWF0aW9uKFxuICAgICAgICBtZXRhZGF0YTogT3BlbklkQ29uZmlnUmVzcG9uc2VcbiAgICApOiBQcm9taXNlPE9wZW5JZENvbmZpZ1Jlc3BvbnNlPiB7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlVcGRhdGVNZXRhZGF0YVdpdGhSZWdpb25hbEluZm9ybWF0aW9uLFxuICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgdXNlckNvbmZpZ3VyZWRBenVyZVJlZ2lvbiA9XG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eU9wdGlvbnMuYXp1cmVSZWdpb25Db25maWd1cmF0aW9uPy5henVyZVJlZ2lvbjtcblxuICAgICAgICBpZiAodXNlckNvbmZpZ3VyZWRBenVyZVJlZ2lvbikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHVzZXJDb25maWd1cmVkQXp1cmVSZWdpb24gIT09XG4gICAgICAgICAgICAgICAgQ29uc3RhbnRzLkFaVVJFX1JFR0lPTl9BVVRPX0RJU0NPVkVSX0ZMQUdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX291dGNvbWUgPVxuICAgICAgICAgICAgICAgICAgICBSZWdpb25EaXNjb3ZlcnlPdXRjb21lcy5DT05GSUdVUkVEX05PX0FVVE9fREVURUNUSU9OO1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX3VzZWQgPVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlndXJlZEF6dXJlUmVnaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHkucmVwbGFjZVdpdGhSZWdpb25hbEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZ3VyZWRBenVyZVJlZ2lvblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGF1dG9kZXRlY3RlZFJlZ2lvbk5hbWUgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbkRpc2NvdmVyeS5kZXRlY3RSZWdpb24uYmluZCh0aGlzLnJlZ2lvbkRpc2NvdmVyeSksXG4gICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5RGV0ZWN0UmVnaW9uLFxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApKFxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5henVyZVJlZ2lvbkNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgPy5lbnZpcm9ubWVudFJlZ2lvbixcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoYXV0b2RldGVjdGVkUmVnaW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX291dGNvbWUgPVxuICAgICAgICAgICAgICAgICAgICBSZWdpb25EaXNjb3ZlcnlPdXRjb21lcy5BVVRPX0RFVEVDVElPTl9SRVFVRVNURURfU1VDQ0VTU0ZVTDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl91c2VkID1cbiAgICAgICAgICAgICAgICAgICAgYXV0b2RldGVjdGVkUmVnaW9uTmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5LnJlcGxhY2VXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbihcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9kZXRlY3RlZFJlZ2lvbk5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9vdXRjb21lID1cbiAgICAgICAgICAgICAgICBSZWdpb25EaXNjb3ZlcnlPdXRjb21lcy5BVVRPX0RFVEVDVElPTl9SRVFVRVNURURfRkFJTEVEO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIEF1dGhvcml0eU1ldGFkYXRhRW50aXR5IHdpdGggbmV3IGFsaWFzZXMsIHByZWZlcnJlZF9uZXR3b3JrIGFuZCBwcmVmZXJyZWRfY2FjaGVcbiAgICAgKiBhbmQgcmV0dXJucyB3aGVyZSB0aGUgaW5mb3JtYXRpb24gd2FzIHJldHJpZXZlZCBmcm9tXG4gICAgICogQHBhcmFtIG1ldGFkYXRhRW50aXR5XG4gICAgICogQHJldHVybnMgQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIHVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEoXG4gICAgICAgIG1ldGFkYXRhRW50aXR5OiBBdXRob3JpdHlNZXRhZGF0YUVudGl0eVxuICAgICk6IFByb21pc2U8QXV0aG9yaXR5TWV0YWRhdGFTb3VyY2U+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEsXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbG9jYWxNZXRhZGF0YVNvdXJjZSA9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTG9jYWxTb3VyY2VzKG1ldGFkYXRhRW50aXR5KTtcbiAgICAgICAgaWYgKGxvY2FsTWV0YWRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbE1ldGFkYXRhU291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gbmV0d29yayBhcyBtZXRhZGF0YSBzb3VyY2VcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrLmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlHZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcmssXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKSgpO1xuXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgQ2FjaGVIZWxwZXJzLnVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFFbnRpdHksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZS5ORVRXT1JLO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWV0YWRhdGEgY291bGQgbm90IGJlIG9idGFpbmVkIGZyb20gdGhlIGNvbmZpZywgY2FjaGUsIG5ldHdvcmsgb3IgaGFyZGNvZGVkIHZhbHVlc1xuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy51bnRydXN0ZWRBdXRob3JpdHlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTG9jYWxTb3VyY2VzKFxuICAgICAgICBtZXRhZGF0YUVudGl0eTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHlcbiAgICApOiBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZSB8IG51bGwge1xuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIGdldCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgIGZyb20gYXV0aG9yaXR5IGNvbmZpZ3VyYXRpb25cIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlUGlpKFxuICAgICAgICAgICAgYEtub3duIEF1dGhvcml0aWVzOiAke1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5rbm93bkF1dGhvcml0aWVzIHx8XG4gICAgICAgICAgICAgICAgQ29uc3RhbnRzLk5PVF9BUFBMSUNBQkxFXG4gICAgICAgICAgICB9YFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlUGlpKFxuICAgICAgICAgICAgYEF1dGhvcml0eSBNZXRhZGF0YTogJHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhvcml0eU9wdGlvbnMuYXV0aG9yaXR5TWV0YWRhdGEgfHxcbiAgICAgICAgICAgICAgICBDb25zdGFudHMuTk9UX0FQUExJQ0FCTEVcbiAgICAgICAgICAgIH1gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2VQaWkoXG4gICAgICAgICAgICBgQ2Fub25pY2FsIEF1dGhvcml0eTogJHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5jYW5vbmljYWxfYXV0aG9yaXR5IHx8IENvbnN0YW50cy5OT1RfQVBQTElDQUJMRVxuICAgICAgICAgICAgfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tQ29uZmlnKCk7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIkZvdW5kIGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBpbiBhdXRob3JpdHkgY29uZmlndXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgQ2FjaGVIZWxwZXJzLnVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFFbnRpdHksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuQ09ORklHO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGNhY2hlZCBtZXRhZGF0YSBjYW1lIGZyb20gY29uZmlnIGJ1dCB0aGF0IGNvbmZpZyB3YXMgbm90IHBhc3NlZCB0byB0aGlzIGluc3RhbmNlLCB3ZSBtdXN0IGdvIHRvIGhhcmRjb2RlZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgIFwiRGlkIG5vdCBmaW5kIGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBpbiB0aGUgY29uZmlnLi4uIEF0dGVtcHRpbmcgdG8gZ2V0IGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBmcm9tIHRoZSBoYXJkY29kZWQgdmFsdWVzLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIlNraXBwaW5nIGhhcmRjb2RlZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgY2FjaGUgc2luY2Ugc2tpcEF1dGhvcml0eU1ldGFkYXRhQ2FjaGUgaXMgc2V0IHRvIHRydWUuIEF0dGVtcHRpbmcgdG8gZ2V0IGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBmcm9tIHRoZSBuZXR3b3JrIG1ldGFkYXRhIGNhY2hlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFyZGNvZGVkTWV0YWRhdGEgPVxuICAgICAgICAgICAgICAgIGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tSGFyZGNvZGVkVmFsdWVzKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lQW5kUG9ydFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaGFyZGNvZGVkTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcIkZvdW5kIGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBmcm9tIGhhcmRjb2RlZCB2YWx1ZXMuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIENhY2hlSGVscGVycy51cGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhKFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgaGFyZGNvZGVkTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuSEFSRENPREVEX1ZBTFVFUztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIkRpZCBub3QgZmluZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgaW4gaGFyZGNvZGVkIHZhbHVlcy4uLiBBdHRlbXB0aW5nIHRvIGdldCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgZnJvbSB0aGUgbmV0d29yayBtZXRhZGF0YSBjYWNoZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhRW50aXR5RXhwaXJlZCA9XG4gICAgICAgICAgICBDYWNoZUhlbHBlcnMuaXNBdXRob3JpdHlNZXRhZGF0YUV4cGlyZWQobWV0YWRhdGFFbnRpdHkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzQXV0aG9yaXR5U2FtZVR5cGUobWV0YWRhdGFFbnRpdHkpICYmXG4gICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5hbGlhc2VzRnJvbU5ldHdvcmsgJiZcbiAgICAgICAgICAgICFtZXRhZGF0YUVudGl0eUV4cGlyZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiRm91bmQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGluIHRoZSBjYWNoZS5cIik7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHVwZGF0ZVxuICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkNBQ0hFO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhRW50aXR5RXhwaXJlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlRoZSBtZXRhZGF0YSBlbnRpdHkgaXMgZXhwaXJlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBjbG91ZERpc2NvdmVyeU1ldGFkYXRhIGNvbmZpZyBvciBjaGVjayBrbm93bkF1dGhvcml0aWVzXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbUNvbmZpZygpOiBDbG91ZERpc2NvdmVyeU1ldGFkYXRhIHwgbnVsbCB7XG4gICAgICAgIC8vIENJQU0gZG9lcyBub3Qgc3VwcG9ydCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGFcbiAgICAgICAgaWYgKHRoaXMuYXV0aG9yaXR5VHlwZSA9PT0gQXV0aG9yaXR5VHlwZS5DaWFtKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIFwiQ0lBTSBhdXRob3JpdGllcyBkbyBub3Qgc3VwcG9ydCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEsIGdlbmVyYXRlIHRoZSBhbGlhc2VzIGZyb20gYXV0aG9yaXR5IGhvc3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5LmNyZWF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tSG9zdChcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lQW5kUG9ydFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIG5ldHdvcmsgcmVzcG9uc2Ugd2FzIHByb3ZpZGVkIGluIGNvbmZpZ1xuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHlPcHRpb25zLmNsb3VkRGlzY292ZXJ5TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgXCJUaGUgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGhhcyBiZWVuIHByb3ZpZGVkIGFzIGEgbmV0d29yayByZXNwb25zZSwgaW4gdGhlIGNvbmZpZy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIHBhcnNlIHRoZSBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRob3JpdHlPcHRpb25zLmNsb3VkRGlzY292ZXJ5TWV0YWRhdGFcbiAgICAgICAgICAgICAgICApIGFzIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya1Jlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZS5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZUFuZFBvcnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJQYXJzZWQgdGhlIGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YS5cIik7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIGlzIHJldHVybmFibGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHBhcnNlZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIGlzIG5vIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBwYXJzZWQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgIFwiVW5hYmxlIHRvIHBhcnNlIHRoZSBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEuIFRocm93aW5nIEludmFsaWQgQ2xvdWQgRGlzY292ZXJ5IE1ldGFkYXRhIEVycm9yLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNsb3VkRGlzY292ZXJ5TWV0YWRhdGEgaXMgZW1wdHkgb3IgZG9lcyBub3QgY29udGFpbiB0aGUgaG9zdCwgY2hlY2sga25vd25BdXRob3JpdGllc1xuICAgICAgICBpZiAodGhpcy5pc0luS25vd25BdXRob3JpdGllcygpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIFwiVGhlIGhvc3QgaXMgaW5jbHVkZWQgaW4ga25vd25BdXRob3JpdGllcy4gQ3JlYXRpbmcgbmV3IGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBmcm9tIHRoZSBob3N0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eS5jcmVhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbUhvc3QoXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZUFuZFBvcnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gZ2V0IG1ldGFkYXRhIGZyb20gbmV0d29yayBpZiBDbG91ZERpc2NvdmVyeU1ldGFkYXRhIHdhcyBub3QgcG9wdWxhdGVkIGJ5IGNvbmZpZ1xuICAgICAqXG4gICAgICogQHBhcmFtIGhhc0hhcmRjb2RlZE1ldGFkYXRhIGJvb2xlYW5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29yaygpOiBQcm9taXNlPENsb3VkRGlzY292ZXJ5TWV0YWRhdGEgfCBudWxsPiB7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlHZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcmssXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VEaXNjb3ZlcnlFbmRwb2ludCA9IGAke0NvbnN0YW50cy5BQURfSU5TVEFOQ0VfRElTQ09WRVJZX0VORFBUfSR7dGhpcy5jYW5vbmljYWxBdXRob3JpdHl9b2F1dGgyL3YyLjAvYXV0aG9yaXplYDtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSW1kc09wdGlvbnMgPSB7fTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBUT0RPOiBBZGQgYSB0aW1lb3V0IGlmIHRoZSBhdXRob3JpdHkgZXhpc3RzIGluIG91ciBsaWJyYXJ5J3NcbiAgICAgICAgICogaGFyZGNvZGVkIGxpc3Qgb2YgbWV0YWRhdGFcbiAgICAgICAgICovXG5cbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5uZXR3b3JrSW50ZXJmYWNlLnNlbmRHZXRSZXF1ZXN0QXN5bmM8XG4gICAgICAgICAgICAgICAgfCBDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2VcbiAgICAgICAgICAgICAgICB8IENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlXG4gICAgICAgICAgICA+KGluc3RhbmNlRGlzY292ZXJ5RW5kcG9pbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbGV0IHR5cGVkUmVzcG9uc2VCb2R5OlxuICAgICAgICAgICAgICAgIHwgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlXG4gICAgICAgICAgICAgICAgfCBDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZTtcbiAgICAgICAgICAgIGxldCBtZXRhZGF0YTogQXJyYXk8Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YT47XG4gICAgICAgICAgICBpZiAoaXNDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2UocmVzcG9uc2UuYm9keSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlZFJlc3BvbnNlQm9keSA9XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgYXMgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gdHlwZWRSZXNwb25zZUJvZHkubWV0YWRhdGE7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlUGlpKFxuICAgICAgICAgICAgICAgICAgICBgdGVuYW50X2Rpc2NvdmVyeV9lbmRwb2ludCBpczogJHt0eXBlZFJlc3BvbnNlQm9keS50ZW5hbnRfZGlzY292ZXJ5X2VuZHBvaW50fWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlKHJlc3BvbnNlLmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhcbiAgICAgICAgICAgICAgICAgICAgYEEgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeUVycm9yUmVzcG9uc2Ugd2FzIHJldHVybmVkLiBUaGUgY2xvdWQgaW5zdGFuY2UgZGlzY292ZXJ5IG5ldHdvcmsgcmVxdWVzdCdzIHN0YXR1cyBjb2RlIGlzOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHR5cGVkUmVzcG9uc2VCb2R5ID1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSBhcyBDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZWRSZXNwb25zZUJvZHkuZXJyb3IgPT09IENvbnN0YW50cy5JTlZBTElEX0lOU1RBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeUVycm9yUmVzcG9uc2UgZXJyb3IgaXMgaW52YWxpZF9pbnN0YW5jZS5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuaW5nKFxuICAgICAgICAgICAgICAgICAgICBgVGhlIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlIGVycm9yIGlzICR7dHlwZWRSZXNwb25zZUJvZHkuZXJyb3J9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhcbiAgICAgICAgICAgICAgICAgICAgYFRoZSBDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZSBlcnJvciBkZXNjcmlwdGlvbiBpcyAke3R5cGVkUmVzcG9uc2VCb2R5LmVycm9yX2Rlc2NyaXB0aW9ufWBcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhcbiAgICAgICAgICAgICAgICAgICAgXCJTZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhIChyZXR1cm5lZCBmcm9tIHRoZSBuZXR3b3JrKSB0byBbXVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBQUQgZGlkIG5vdCByZXR1cm4gYSBDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2Ugb3IgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeUVycm9yUmVzcG9uc2VcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIGZpbmQgYSBtYXRjaCBiZXR3ZWVuIHRoZSBkZXZlbG9wZXIncyBhdXRob3JpdHkgYW5kIHRoZSBDbG91ZEluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgbmV0d29yayByZXF1ZXN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWF0Y2ggPSBnZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcmtSZXNwb25zZShcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lQW5kUG9ydFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgVGhlcmUgd2FzIGEgbmV0d29yayBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGdldCB0aGUgY2xvdWQgZGlzY292ZXJ5IGluc3RhbmNlIG1ldGFkYXRhLlxcbkVycm9yOiAke2Vycm9yLmVycm9yQ29kZX1cXG5FcnJvciBEZXNjcmlwdGlvbjogJHtlcnJvci5lcnJvck1lc3NhZ2V9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkRXJyb3IgPSBlcnJvciBhcyBFcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYEEgbm9uLU1TQUxKUyBlcnJvciB3YXMgdGhyb3duIHdoaWxlIGF0dGVtcHRpbmcgdG8gZ2V0IHRoZSBjbG91ZCBpbnN0YW5jZSBkaXNjb3ZlcnkgbWV0YWRhdGEuXFxuRXJyb3I6ICR7dHlwZWRFcnJvci5uYW1lfVxcbkVycm9yIERlc2NyaXB0aW9uOiAke3R5cGVkRXJyb3IubWVzc2FnZX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gRG9tYWluIHNjZW5hcmlvLCBob3N0IGlzIHRydXN0ZWQgYmVjYXVzZSBJbnN0YW5jZSBEaXNjb3ZlcnkgY2FsbCBzdWNjZWVkZWRcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhcbiAgICAgICAgICAgICAgICBcIlRoZSBkZXZlbG9wZXIncyBhdXRob3JpdHkgd2FzIG5vdCBmb3VuZCB3aXRoaW4gdGhlIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlNZXRhZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBuZXR3b3JrIHJlcXVlc3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIFwiQ3JlYXRpbmcgY3VzdG9tIEF1dGhvcml0eSBmb3IgY3VzdG9tIGRvbWFpbiBzY2VuYXJpby5cIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbWF0Y2ggPSBBdXRob3JpdHkuY3JlYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21Ib3N0KFxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWVBbmRQb3J0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaG9zdCBpcyBpbmNsdWRlZCBpbiB0aGUga25vd25BdXRob3JpdGllcyBjb25maWcgb3B0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0luS25vd25BdXRob3JpdGllcygpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5rbm93bkF1dGhvcml0aWVzLmZpbHRlcihcbiAgICAgICAgICAgIChhdXRob3JpdHkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBhdXRob3JpdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgVXJsU3RyaW5nLmdldERvbWFpbkZyb21VcmwoYXV0aG9yaXR5KS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZUFuZFBvcnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhlbHBlciBmdW5jdGlvbiB0byBwb3B1bGF0ZSB0aGUgYXV0aG9yaXR5IGJhc2VkIG9uIGF6dXJlQ2xvdWRPcHRpb25zXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVN0cmluZ1xuICAgICAqIEBwYXJhbSBhenVyZUNsb3VkT3B0aW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZUF1dGhvcml0eShcbiAgICAgICAgYXV0aG9yaXR5U3RyaW5nOiBzdHJpbmcsXG4gICAgICAgIGF6dXJlQ2xvdWRPcHRpb25zPzogQXp1cmVDbG91ZE9wdGlvbnNcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBsZXQgYXV0aG9yaXR5QXp1cmVDbG91ZEluc3RhbmNlO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGF6dXJlQ2xvdWRPcHRpb25zICYmXG4gICAgICAgICAgICBhenVyZUNsb3VkT3B0aW9ucy5henVyZUNsb3VkSW5zdGFuY2UgIT09IEF6dXJlQ2xvdWRJbnN0YW5jZS5Ob25lXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgdGVuYW50ID0gYXp1cmVDbG91ZE9wdGlvbnMudGVuYW50XG4gICAgICAgICAgICAgICAgPyBhenVyZUNsb3VkT3B0aW9ucy50ZW5hbnRcbiAgICAgICAgICAgICAgICA6IENvbnN0YW50cy5ERUZBVUxUX0NPTU1PTl9URU5BTlQ7XG4gICAgICAgICAgICBhdXRob3JpdHlBenVyZUNsb3VkSW5zdGFuY2UgPSBgJHthenVyZUNsb3VkT3B0aW9ucy5henVyZUNsb3VkSW5zdGFuY2V9LyR7dGVuYW50fS9gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1dGhvcml0eUF6dXJlQ2xvdWRJbnN0YW5jZVxuICAgICAgICAgICAgPyBhdXRob3JpdHlBenVyZUNsb3VkSW5zdGFuY2VcbiAgICAgICAgICAgIDogYXV0aG9yaXR5U3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIG9iamVjdCBmcm9tIGEgZ2l2ZW4gaG9zdFxuICAgICAqIEBwYXJhbSBob3N0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tSG9zdChcbiAgICAgICAgaG9zdDogc3RyaW5nXG4gICAgKTogQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmZXJyZWRfbmV0d29yazogaG9zdCxcbiAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogaG9zdCxcbiAgICAgICAgICAgIGFsaWFzZXM6IFtob3N0XSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgZW52aXJvbm1lbnQgZnJvbSBhdXRob3JpdHkgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0UHJlZmVycmVkQ2FjaGUoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlZElkZW50aXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RhbnRzLkRFRkFVTFRfQVVUSE9SSVRZX0hPU1Q7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXNjb3ZlcnlDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5wcmVmZXJyZWRfY2FjaGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCBob3N0IGlzIGFuIGFsaWFzIG9mIHRoaXMgYXV0aG9yaXR5IGluc3RhbmNlXG4gICAgICogQHBhcmFtIGhvc3RcbiAgICAgKi9cbiAgICBpc0FsaWFzKGhvc3Q6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5hbGlhc2VzLmluZGV4T2YoaG9zdCkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCBob3N0IGlzIGFuIGFsaWFzIG9mIGEga25vd24gTWljcm9zb2Z0IGF1dGhvcml0eSBmb3IgcHVycG9zZXMgb2YgZW5kcG9pbnQgZGlzY292ZXJ5XG4gICAgICogQHBhcmFtIGhvc3RcbiAgICAgKi9cbiAgICBpc0FsaWFzT2ZLbm93bk1pY3Jvc29mdEF1dGhvcml0eShob3N0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGFBbGlhc2VzLmhhcyhob3N0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgaG9zdCBpcyB0aGF0IG9mIGEgcHVibGljIGNsb3VkIGF1dGhvcml0eVxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGhvcml0eSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBib29sXG4gICAgICovXG4gICAgc3RhdGljIGlzUHVibGljQ2xvdWRBdXRob3JpdHkoaG9zdDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBDb25zdGFudHMuS05PV05fUFVCTElDX0NMT1VEUy5pbmRleE9mKGhvc3QpID49IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVidWlsZCB0aGUgYXV0aG9yaXR5IHN0cmluZyB3aXRoIHRoZSByZWdpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBob3N0IHN0cmluZ1xuICAgICAqIEBwYXJhbSByZWdpb24gc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkUmVnaW9uYWxBdXRob3JpdHlTdHJpbmcoXG4gICAgICAgIGhvc3Q6IHN0cmluZyxcbiAgICAgICAgcmVnaW9uOiBzdHJpbmcsXG4gICAgICAgIHF1ZXJ5U3RyaW5nPzogc3RyaW5nXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCB2YWxpZGF0ZSBhIFVybCBzdHJpbmcgb2JqZWN0IHdpdGggdGhlIGluaXRpYWwgYXV0aG9yaXR5IHN0cmluZ1xuICAgICAgICBjb25zdCBhdXRob3JpdHlVcmxJbnN0YW5jZSA9IG5ldyBVcmxTdHJpbmcoaG9zdCk7XG4gICAgICAgIGF1dGhvcml0eVVybEluc3RhbmNlLnZhbGlkYXRlQXNVcmkoKTtcblxuICAgICAgICBjb25zdCBhdXRob3JpdHlVcmxQYXJ0cyA9IGF1dGhvcml0eVVybEluc3RhbmNlLmdldFVybENvbXBvbmVudHMoKTtcblxuICAgICAgICBsZXQgaG9zdE5hbWVBbmRQb3J0ID0gYCR7cmVnaW9ufS4ke2F1dGhvcml0eVVybFBhcnRzLkhvc3ROYW1lQW5kUG9ydH1gO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUHVibGljQ2xvdWRBdXRob3JpdHkoYXV0aG9yaXR5VXJsUGFydHMuSG9zdE5hbWVBbmRQb3J0KSkge1xuICAgICAgICAgICAgaG9zdE5hbWVBbmRQb3J0ID0gYCR7cmVnaW9ufS4ke0NvbnN0YW50cy5SRUdJT05BTF9BVVRIX1BVQkxJQ19DTE9VRF9TVUZGSVh9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY2x1ZGUgdGhlIHF1ZXJ5IHN0cmluZyBwb3J0aW9uIG9mIHRoZSB1cmxcbiAgICAgICAgY29uc3QgdXJsID0gVXJsU3RyaW5nLmNvbnN0cnVjdEF1dGhvcml0eVVyaUZyb21PYmplY3Qoe1xuICAgICAgICAgICAgLi4uYXV0aG9yaXR5VXJsSW5zdGFuY2UuZ2V0VXJsQ29tcG9uZW50cygpLFxuICAgICAgICAgICAgSG9zdE5hbWVBbmRQb3J0OiBob3N0TmFtZUFuZFBvcnQsXG4gICAgICAgIH0pLnVybFN0cmluZztcblxuICAgICAgICAvLyBBZGQgdGhlIHF1ZXJ5IHN0cmluZyBpZiBhIHF1ZXJ5IHN0cmluZyB3YXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKHF1ZXJ5U3RyaW5nKSByZXR1cm4gYCR7dXJsfT8ke3F1ZXJ5U3RyaW5nfWA7XG5cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSBlbmRwb2ludHMgaW4gdGhlIG1ldGFkYXRhIG9iamVjdCB3aXRoIHRoZWlyIHJlZ2lvbmFsIGVxdWl2YWxlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIE9wZW5JZENvbmZpZ1Jlc3BvbnNlXG4gICAgICogQHBhcmFtIGF6dXJlUmVnaW9uIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlV2l0aFJlZ2lvbmFsSW5mb3JtYXRpb24oXG4gICAgICAgIG1ldGFkYXRhOiBPcGVuSWRDb25maWdSZXNwb25zZSxcbiAgICAgICAgYXp1cmVSZWdpb246IHN0cmluZ1xuICAgICk6IE9wZW5JZENvbmZpZ1Jlc3BvbnNlIHtcbiAgICAgICAgY29uc3QgcmVnaW9uYWxNZXRhZGF0YSA9IHsgLi4ubWV0YWRhdGEgfTtcbiAgICAgICAgcmVnaW9uYWxNZXRhZGF0YS5hdXRob3JpemF0aW9uX2VuZHBvaW50ID1cbiAgICAgICAgICAgIEF1dGhvcml0eS5idWlsZFJlZ2lvbmFsQXV0aG9yaXR5U3RyaW5nKFxuICAgICAgICAgICAgICAgIHJlZ2lvbmFsTWV0YWRhdGEuYXV0aG9yaXphdGlvbl9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBhenVyZVJlZ2lvblxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZWdpb25hbE1ldGFkYXRhLnRva2VuX2VuZHBvaW50ID1cbiAgICAgICAgICAgIEF1dGhvcml0eS5idWlsZFJlZ2lvbmFsQXV0aG9yaXR5U3RyaW5nKFxuICAgICAgICAgICAgICAgIHJlZ2lvbmFsTWV0YWRhdGEudG9rZW5fZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgYXp1cmVSZWdpb25cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKHJlZ2lvbmFsTWV0YWRhdGEuZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHJlZ2lvbmFsTWV0YWRhdGEuZW5kX3Nlc3Npb25fZW5kcG9pbnQgPVxuICAgICAgICAgICAgICAgIEF1dGhvcml0eS5idWlsZFJlZ2lvbmFsQXV0aG9yaXR5U3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICByZWdpb25hbE1ldGFkYXRhLmVuZF9zZXNzaW9uX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICBhenVyZVJlZ2lvblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnaW9uYWxNZXRhZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gQ0lBTV9BVVRIT1JJWSBhcyBwZXIgdGhlIGJlbG93IHJ1bGVzOlxuICAgICAqIElmIG5vIHBhdGggc2VnbWVudHMgZm91bmQgYW5kIGl0IGlzIGEgQ0lBTSBhdXRob3JpdHkgKGhvc3RuYW1lIGVuZHMgd2l0aCAuY2lhbWxvZ2luLmNvbSksIHRoZW4gdHJhbnNmb3JtIGl0XG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGUgdHJhbnNmb3JtYXRpb24gcGF0aCBzaG91bGQgZ28gYXdheSBvbmNlIFNUUyBzdXBwb3J0cyBDSUFNIHdpdGggdGhlIGZvcm1hdDogYHRlbmFudElkb3JEb21haW4uY2lhbWxvZ2luLmNvbWBcbiAgICAgKiBgY2lhbWxvZ2luLmNvbWAgY2FuIGFsc28gY2hhbmdlIGluIHRoZSBmdXR1cmUgYW5kIHdlIHNob3VsZCBhY2NvbW1vZGF0ZSB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2Zvcm1DSUFNQXV0aG9yaXR5KGF1dGhvcml0eTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGNpYW1BdXRob3JpdHkgPSBhdXRob3JpdHk7XG4gICAgICAgIGNvbnN0IGF1dGhvcml0eVVybCA9IG5ldyBVcmxTdHJpbmcoYXV0aG9yaXR5KTtcbiAgICAgICAgY29uc3QgYXV0aG9yaXR5VXJsQ29tcG9uZW50cyA9IGF1dGhvcml0eVVybC5nZXRVcmxDb21wb25lbnRzKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdHJhbnNmb3JtYXRpb24gaXMgbmVlZGVkXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgYXV0aG9yaXR5VXJsQ29tcG9uZW50cy5Ib3N0TmFtZUFuZFBvcnQuZW5kc1dpdGgoXG4gICAgICAgICAgICAgICAgQ29uc3RhbnRzLkNJQU1fQVVUSF9VUkxcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZE9yRG9tYWluID1cbiAgICAgICAgICAgICAgICBhdXRob3JpdHlVcmxDb21wb25lbnRzLkhvc3ROYW1lQW5kUG9ydC5zcGxpdChcIi5cIilbMF07XG4gICAgICAgICAgICBjaWFtQXV0aG9yaXR5ID0gYCR7Y2lhbUF1dGhvcml0eX0ke3RlbmFudElkT3JEb21haW59JHtDb25zdGFudHMuQUFEX1RFTkFOVF9ET01BSU5fU1VGRklYfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2lhbUF1dGhvcml0eTtcbiAgICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCB0ZW5hbnRJZCBmcm9tIGF1dGhvcml0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVuYW50RnJvbUF1dGhvcml0eVN0cmluZyhcbiAgICBhdXRob3JpdHk6IHN0cmluZ1xuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBhdXRob3JpdHlVcmwgPSBuZXcgVXJsU3RyaW5nKGF1dGhvcml0eSk7XG4gICAgY29uc3QgYXV0aG9yaXR5VXJsQ29tcG9uZW50cyA9IGF1dGhvcml0eVVybC5nZXRVcmxDb21wb25lbnRzKCk7XG4gICAgLyoqXG4gICAgICogRm9yIGNyZWRlbnRpYWwgbWF0Y2hpbmcgcHVycG9zZXMsIHRlbmFudElkIGlzIHRoZSBsYXN0IHBhdGggc2VnbWVudCBvZiB0aGUgYXV0aG9yaXR5IFVSTDpcbiAgICAgKiAgQUFEIEF1dGhvcml0eSAtIGRvbWFpbi90ZW5hbnRJZCAtPiBDcmVkZW50aWFscyBhcmUgY2FjaGVkIHdpdGggcmVhbG0gPSB0ZW5hbnRJZFxuICAgICAqICBCMkMgQXV0aG9yaXR5IC0gZG9tYWluL3t0ZW5hbnRJZH0/Ly4uLi9wb2xpY3kgLT4gQ3JlZGVudGlhbHMgYXJlIGNhY2hlZCB3aXRoIHJlYWxtID0gcG9saWN5XG4gICAgICogIHRlbmFudElkIGlzIGRvd25jYXNlZCBiZWNhdXNlIEIyQyBwb2xpY2llcyBjYW4gaGF2ZSBtaXhlZCBjYXNlIGJ1dCB0ZnAgY2xhaW0gaXMgZG93bmNhc2VkXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2UgbWF5IG5vdCBoYXZlIGFueSBwYXRoIHNlZ21lbnRzIGluIGNlcnRhaW4gT0lEQyBzY2VuYXJpb3MuXG4gICAgICovXG4gICAgY29uc3QgdGVuYW50SWQgPVxuICAgICAgICBhdXRob3JpdHlVcmxDb21wb25lbnRzLlBhdGhTZWdtZW50cy5zbGljZSgtMSlbMF0/LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBzd2l0Y2ggKHRlbmFudElkKSB7XG4gICAgICAgIGNhc2UgQUFEQXV0aG9yaXR5Q29uc3RhbnRzLkNPTU1PTjpcbiAgICAgICAgY2FzZSBBQURBdXRob3JpdHlDb25zdGFudHMuT1JHQU5JWkFUSU9OUzpcbiAgICAgICAgY2FzZSBBQURBdXRob3JpdHlDb25zdGFudHMuQ09OU1VNRVJTOlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0ZW5hbnRJZDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBdXRob3JpdHlVcmkoYXV0aG9yaXR5VXJpOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBhdXRob3JpdHlVcmkuZW5kc1dpdGgoQ29uc3RhbnRzLkZPUldBUkRfU0xBU0gpXG4gICAgICAgID8gYXV0aG9yaXR5VXJpXG4gICAgICAgIDogYCR7YXV0aG9yaXR5VXJpfSR7Q29uc3RhbnRzLkZPUldBUkRfU0xBU0h9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU3RhdGljQXV0aG9yaXR5T3B0aW9ucyhcbiAgICBhdXRoT3B0aW9uczogUGFydGlhbDxBdXRob3JpdHlPcHRpb25zPlxuKTogU3RhdGljQXV0aG9yaXR5T3B0aW9ucyB7XG4gICAgY29uc3QgcmF3Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YSA9IGF1dGhPcHRpb25zLmNsb3VkRGlzY292ZXJ5TWV0YWRhdGE7XG4gICAgbGV0IGNsb3VkRGlzY292ZXJ5TWV0YWRhdGE6IENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZSB8IHVuZGVmaW5lZCA9XG4gICAgICAgIHVuZGVmaW5lZDtcbiAgICBpZiAocmF3Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xvdWREaXNjb3ZlcnlNZXRhZGF0YSA9IEpTT04ucGFyc2UocmF3Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjYW5vbmljYWxBdXRob3JpdHk6IGF1dGhPcHRpb25zLmF1dGhvcml0eVxuICAgICAgICAgICAgPyBmb3JtYXRBdXRob3JpdHlVcmkoYXV0aE9wdGlvbnMuYXV0aG9yaXR5KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGtub3duQXV0aG9yaXRpZXM6IGF1dGhPcHRpb25zLmtub3duQXV0aG9yaXRpZXMsXG4gICAgICAgIGNsb3VkRGlzY292ZXJ5TWV0YWRhdGE6IGNsb3VkRGlzY292ZXJ5TWV0YWRhdGEsXG4gICAgfTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aG9yaXR5LCBmb3JtYXRBdXRob3JpdHlVcmkgfSBmcm9tIFwiLi9BdXRob3JpdHkuanNcIjtcbmltcG9ydCB7IElOZXR3b3JrTW9kdWxlIH0gZnJvbSBcIi4uL25ldHdvcmsvSU5ldHdvcmtNb2R1bGUuanNcIjtcbmltcG9ydCB7XG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLmpzXCI7XG5pbXBvcnQgeyBJQ2FjaGVNYW5hZ2VyIH0gZnJvbSBcIi4uL2NhY2hlL2ludGVyZmFjZS9JQ2FjaGVNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpdHlPcHRpb25zIH0gZnJvbSBcIi4vQXV0aG9yaXR5T3B0aW9ucy5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXIuanNcIjtcbmltcG9ydCB7IElQZXJmb3JtYW5jZUNsaWVudCB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvSVBlcmZvcm1hbmNlQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZUV2ZW50cyB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC5qc1wiO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMgfSBmcm9tIFwiLi4vdXRpbHMvRnVuY3Rpb25XcmFwcGVycy5qc1wiO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhdXRob3JpdHkgb2JqZWN0IG9mIHRoZSBjb3JyZWN0IHR5cGUgYmFzZWQgb24gdGhlIHVybFxuICogUGVyZm9ybXMgYmFzaWMgYXV0aG9yaXR5IHZhbGlkYXRpb24gLSBjaGVja3MgdG8gc2VlIGlmIHRoZSBhdXRob3JpdHkgaXMgb2YgYSB2YWxpZCB0eXBlIChpLmUuIGFhZCwgYjJjLCBhZGZzKVxuICpcbiAqIEFsc28gcGVyZm9ybXMgZW5kcG9pbnQgZGlzY292ZXJ5LlxuICpcbiAqIEBwYXJhbSBhdXRob3JpdHlVcmlcbiAqIEBwYXJhbSBuZXR3b3JrQ2xpZW50XG4gKiBAcGFyYW0gcHJvdG9jb2xNb2RlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZShcbiAgICBhdXRob3JpdHlVcmk6IHN0cmluZyxcbiAgICBuZXR3b3JrQ2xpZW50OiBJTmV0d29ya01vZHVsZSxcbiAgICBjYWNoZU1hbmFnZXI6IElDYWNoZU1hbmFnZXIsXG4gICAgYXV0aG9yaXR5T3B0aW9uczogQXV0aG9yaXR5T3B0aW9ucyxcbiAgICBsb2dnZXI6IExvZ2dlcixcbiAgICBjb3JyZWxhdGlvbklkOiBzdHJpbmcsXG4gICAgcGVyZm9ybWFuY2VDbGllbnQ/OiBJUGVyZm9ybWFuY2VDbGllbnRcbik6IFByb21pc2U8QXV0aG9yaXR5PiB7XG4gICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eUZhY3RvcnlDcmVhdGVEaXNjb3ZlcmVkSW5zdGFuY2UsXG4gICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICApO1xuICAgIGNvbnN0IGF1dGhvcml0eVVyaUZpbmFsID0gQXV0aG9yaXR5LnRyYW5zZm9ybUNJQU1BdXRob3JpdHkoXG4gICAgICAgIGZvcm1hdEF1dGhvcml0eVVyaShhdXRob3JpdHlVcmkpXG4gICAgKTtcblxuICAgIC8vIEluaXRpYWxpemUgYXV0aG9yaXR5IGFuZCBwZXJmb3JtIGRpc2NvdmVyeSBlbmRwb2ludCBjaGVjay5cbiAgICBjb25zdCBhY3F1aXJlVG9rZW5BdXRob3JpdHk6IEF1dGhvcml0eSA9IG5ldyBBdXRob3JpdHkoXG4gICAgICAgIGF1dGhvcml0eVVyaUZpbmFsLFxuICAgICAgICBuZXR3b3JrQ2xpZW50LFxuICAgICAgICBjYWNoZU1hbmFnZXIsXG4gICAgICAgIGF1dGhvcml0eU9wdGlvbnMsXG4gICAgICAgIGxvZ2dlcixcbiAgICAgICAgY29ycmVsYXRpb25JZCxcbiAgICAgICAgcGVyZm9ybWFuY2VDbGllbnRcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgaW52b2tlQXN5bmMoXG4gICAgICAgICAgICBhY3F1aXJlVG9rZW5BdXRob3JpdHkucmVzb2x2ZUVuZHBvaW50c0FzeW5jLmJpbmQoXG4gICAgICAgICAgICAgICAgYWNxdWlyZVRva2VuQXV0aG9yaXR5XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5UmVzb2x2ZUVuZHBvaW50c0FzeW5jLFxuICAgICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICkoKTtcbiAgICAgICAgcmV0dXJuIGFjcXVpcmVUb2tlbkF1dGhvcml0eTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmVuZHBvaW50UmVzb2x1dGlvbkVycm9yXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiLi9BdXRoRXJyb3IuanNcIjtcblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGVyZSBpcyBhbiBlcnJvciB3aXRoIHRoZSBzZXJ2ZXIgY29kZSwgZm9yIGV4YW1wbGUsIHVuYXZhaWxhYmlsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgU2VydmVyRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIFNlcnZlciBlcnJvciBudW1iZXI7XG4gICAgICovXG4gICAgcmVhZG9ubHkgZXJyb3JObz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEh0dHAgc3RhdHVzIG51bWJlcjtcbiAgICAgKi9cbiAgICByZWFkb25seSBzdGF0dXM/OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgZXJyb3JDb2RlPzogc3RyaW5nLFxuICAgICAgICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG4gICAgICAgIHN1YkVycm9yPzogc3RyaW5nLFxuICAgICAgICBlcnJvck5vPzogc3RyaW5nLFxuICAgICAgICBzdGF0dXM/OiBudW1iZXJcbiAgICApIHtcbiAgICAgICAgc3VwZXIoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIHN1YkVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTZXJ2ZXJFcnJvclwiO1xuICAgICAgICB0aGlzLmVycm9yTm8gPSBlcnJvck5vO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcblxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgU2VydmVyRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFNock9wdGlvbnMgfSBmcm9tIFwiLi4vY3J5cHRvL1NpZ25lZEh0dHBSZXF1ZXN0LmpzXCI7XG5pbXBvcnQgeyBCYXNlQXV0aFJlcXVlc3QgfSBmcm9tIFwiLi4vcmVxdWVzdC9CYXNlQXV0aFJlcXVlc3QuanNcIjtcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uU2NoZW1lIH0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuXG4vKipcbiAqIFR5cGUgcmVwcmVzZW50aW5nIGEgdW5pcXVlIHJlcXVlc3QgdGh1bWJwcmludC5cbiAqL1xuZXhwb3J0IHR5cGUgUmVxdWVzdFRodW1icHJpbnQgPSB7XG4gICAgY2xpZW50SWQ6IHN0cmluZztcbiAgICBhdXRob3JpdHk6IHN0cmluZztcbiAgICBzY29wZXM6IEFycmF5PHN0cmluZz47XG4gICAgaG9tZUFjY291bnRJZGVudGlmaWVyPzogc3RyaW5nO1xuICAgIGNsYWltcz86IHN0cmluZztcbiAgICBhdXRoZW50aWNhdGlvblNjaGVtZT86IEF1dGhlbnRpY2F0aW9uU2NoZW1lO1xuICAgIHJlc291cmNlUmVxdWVzdE1ldGhvZD86IHN0cmluZztcbiAgICByZXNvdXJjZVJlcXVlc3RVcmk/OiBzdHJpbmc7XG4gICAgc2hyQ2xhaW1zPzogc3RyaW5nO1xuICAgIHNzaEtpZD86IHN0cmluZztcbiAgICBzaHJPcHRpb25zPzogU2hyT3B0aW9ucztcbiAgICBlbWJlZGRlZENsaWVudElkPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RUaHVtYnByaW50KFxuICAgIGNsaWVudElkOiBzdHJpbmcsXG4gICAgcmVxdWVzdDogQmFzZUF1dGhSZXF1ZXN0LFxuICAgIGhvbWVBY2NvdW50SWQ/OiBzdHJpbmdcbik6IFJlcXVlc3RUaHVtYnByaW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRJZDogY2xpZW50SWQsXG4gICAgICAgIGF1dGhvcml0eTogcmVxdWVzdC5hdXRob3JpdHksXG4gICAgICAgIHNjb3BlczogcmVxdWVzdC5zY29wZXMsXG4gICAgICAgIGhvbWVBY2NvdW50SWRlbnRpZmllcjogaG9tZUFjY291bnRJZCxcbiAgICAgICAgY2xhaW1zOiByZXF1ZXN0LmNsYWltcyxcbiAgICAgICAgYXV0aGVudGljYXRpb25TY2hlbWU6IHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUsXG4gICAgICAgIHJlc291cmNlUmVxdWVzdE1ldGhvZDogcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RNZXRob2QsXG4gICAgICAgIHJlc291cmNlUmVxdWVzdFVyaTogcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RVcmksXG4gICAgICAgIHNockNsYWltczogcmVxdWVzdC5zaHJDbGFpbXMsXG4gICAgICAgIHNzaEtpZDogcmVxdWVzdC5zc2hLaWQsXG4gICAgICAgIGVtYmVkZGVkQ2xpZW50SWQ6XG4gICAgICAgICAgICByZXF1ZXN0LmVtYmVkZGVkQ2xpZW50SWQgfHwgcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzPy5jbGllbnRJZCxcbiAgICB9O1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBOZXR3b3JrUmVzcG9uc2UgfSBmcm9tIFwiLi9OZXR3b3JrUmVzcG9uc2UuanNcIjtcbmltcG9ydCB7IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlIH0gZnJvbSBcIi4uL3Jlc3BvbnNlL1NlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlLmpzXCI7XG5pbXBvcnQge1xuICAgIEhlYWRlck5hbWVzLFxuICAgIFRocm90dGxpbmdDb25zdGFudHMsXG4gICAgQ29uc3RhbnRzLFxufSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBDYWNoZU1hbmFnZXIgfSBmcm9tIFwiLi4vY2FjaGUvQ2FjaGVNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBTZXJ2ZXJFcnJvciB9IGZyb20gXCIuLi9lcnJvci9TZXJ2ZXJFcnJvci5qc1wiO1xuaW1wb3J0IHtcbiAgICBnZXRSZXF1ZXN0VGh1bWJwcmludCxcbiAgICBSZXF1ZXN0VGh1bWJwcmludCxcbn0gZnJvbSBcIi4vUmVxdWVzdFRodW1icHJpbnQuanNcIjtcbmltcG9ydCB7IFRocm90dGxpbmdFbnRpdHkgfSBmcm9tIFwiLi4vY2FjaGUvZW50aXRpZXMvVGhyb3R0bGluZ0VudGl0eS5qc1wiO1xuaW1wb3J0IHsgQmFzZUF1dGhSZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQmFzZUF1dGhSZXF1ZXN0LmpzXCI7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBUaHJvdHRsaW5nVXRpbHMge1xuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgUmVxdWVzdFRodW1icHJpbnQgdG8gYmUgc3RvcmVkIGFzIGEga2V5LlxuICAgICAqIEBwYXJhbSB0aHVtYnByaW50XG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlVGhyb3R0bGluZ1N0b3JhZ2VLZXkodGh1bWJwcmludDogUmVxdWVzdFRodW1icHJpbnQpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7VGhyb3R0bGluZ0NvbnN0YW50cy5USFJPVFRMSU5HX1BSRUZJWH0uJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHRodW1icHJpbnRcbiAgICAgICAgKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIG5lY2Vzc2FyeSB0aHJvdHRsaW5nIGNoZWNrcyBiZWZvcmUgYSBuZXR3b3JrIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGNhY2hlTWFuYWdlclxuICAgICAqIEBwYXJhbSB0aHVtYnByaW50XG4gICAgICovXG4gICAgc3RhdGljIHByZVByb2Nlc3MoXG4gICAgICAgIGNhY2hlTWFuYWdlcjogQ2FjaGVNYW5hZ2VyLFxuICAgICAgICB0aHVtYnByaW50OiBSZXF1ZXN0VGh1bWJwcmludFxuICAgICk6IHZvaWQge1xuICAgICAgICBjb25zdCBrZXkgPSBUaHJvdHRsaW5nVXRpbHMuZ2VuZXJhdGVUaHJvdHRsaW5nU3RvcmFnZUtleSh0aHVtYnByaW50KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjYWNoZU1hbmFnZXIuZ2V0VGhyb3R0bGluZ0NhY2hlKGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudGhyb3R0bGVUaW1lIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlTWFuYWdlci5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKFxuICAgICAgICAgICAgICAgIHZhbHVlLmVycm9yQ29kZXM/LmpvaW4oXCIgXCIpIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgICAgICAgICAgICAgdmFsdWUuZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHZhbHVlLnN1YkVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbmVjZXNzYXJ5IHRocm90dGxpbmcgY2hlY2tzIGFmdGVyIGEgbmV0d29yayByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBjYWNoZU1hbmFnZXJcbiAgICAgKiBAcGFyYW0gdGh1bWJwcmludFxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqL1xuICAgIHN0YXRpYyBwb3N0UHJvY2VzcyhcbiAgICAgICAgY2FjaGVNYW5hZ2VyOiBDYWNoZU1hbmFnZXIsXG4gICAgICAgIHRodW1icHJpbnQ6IFJlcXVlc3RUaHVtYnByaW50LFxuICAgICAgICByZXNwb25zZTogTmV0d29ya1Jlc3BvbnNlPFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlPlxuICAgICk6IHZvaWQge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBUaHJvdHRsaW5nVXRpbHMuY2hlY2tSZXNwb25zZVN0YXR1cyhyZXNwb25zZSkgfHxcbiAgICAgICAgICAgIFRocm90dGxpbmdVdGlscy5jaGVja1Jlc3BvbnNlRm9yUmV0cnlBZnRlcihyZXNwb25zZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB0aHVtYnByaW50VmFsdWU6IFRocm90dGxpbmdFbnRpdHkgPSB7XG4gICAgICAgICAgICAgICAgdGhyb3R0bGVUaW1lOiBUaHJvdHRsaW5nVXRpbHMuY2FsY3VsYXRlVGhyb3R0bGVUaW1lKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzW0hlYWRlck5hbWVzLlJFVFJZX0FGVEVSXSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGVycm9yOiByZXNwb25zZS5ib2R5LmVycm9yLFxuICAgICAgICAgICAgICAgIGVycm9yQ29kZXM6IHJlc3BvbnNlLmJvZHkuZXJyb3JfY29kZXMsXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiByZXNwb25zZS5ib2R5LmVycm9yX2Rlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN1YkVycm9yOiByZXNwb25zZS5ib2R5LnN1YmVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhY2hlTWFuYWdlci5zZXRUaHJvdHRsaW5nQ2FjaGUoXG4gICAgICAgICAgICAgICAgVGhyb3R0bGluZ1V0aWxzLmdlbmVyYXRlVGhyb3R0bGluZ1N0b3JhZ2VLZXkodGh1bWJwcmludCksXG4gICAgICAgICAgICAgICAgdGh1bWJwcmludFZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGEgTmV0d29ya1Jlc3BvbnNlIG9iamVjdCdzIHN0YXR1cyBjb2RlcyBhZ2FpbnN0IDQyOSBvciA1eHhcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hlY2tSZXNwb25zZVN0YXR1cyhcbiAgICAgICAgcmVzcG9uc2U6IE5ldHdvcmtSZXNwb25zZTxTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZT5cbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5IHx8XG4gICAgICAgICAgICAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGEgTmV0d29ya1Jlc3BvbnNlIG9iamVjdCdzIFJldHJ5QWZ0ZXIgaGVhZGVyXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICovXG4gICAgc3RhdGljIGNoZWNrUmVzcG9uc2VGb3JSZXRyeUFmdGVyKFxuICAgICAgICByZXNwb25zZTogTmV0d29ya1Jlc3BvbnNlPFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlPlxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmhhc093blByb3BlcnR5KEhlYWRlck5hbWVzLlJFVFJZX0FGVEVSKSAmJlxuICAgICAgICAgICAgICAgIChyZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDMwMClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIFVuaXgtdGltZSB2YWx1ZSBmb3IgYSB0aHJvdHRsZSB0byBleHBpcmUgZ2l2ZW4gdGhyb3R0bGVUaW1lIGluIHNlY29uZHMuXG4gICAgICogQHBhcmFtIHRocm90dGxlVGltZVxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUaHJvdHRsZVRpbWUodGhyb3R0bGVUaW1lOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB0aW1lID0gdGhyb3R0bGVUaW1lIDw9IDAgPyAwIDogdGhyb3R0bGVUaW1lO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWNvbmRzID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgY3VycmVudFNlY29uZHMgK1xuICAgICAgICAgICAgICAgICAgICAodGltZSB8fCBUaHJvdHRsaW5nQ29uc3RhbnRzLkRFRkFVTFRfVEhST1RUTEVfVElNRV9TRUNPTkRTKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50U2Vjb25kcyArXG4gICAgICAgICAgICAgICAgICAgIFRocm90dGxpbmdDb25zdGFudHMuREVGQVVMVF9NQVhfVEhST1RUTEVfVElNRV9TRUNPTkRTXG4gICAgICAgICAgICApICogMTAwMFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmVUaHJvdHRsZShcbiAgICAgICAgY2FjaGVNYW5hZ2VyOiBDYWNoZU1hbmFnZXIsXG4gICAgICAgIGNsaWVudElkOiBzdHJpbmcsXG4gICAgICAgIHJlcXVlc3Q6IEJhc2VBdXRoUmVxdWVzdCxcbiAgICAgICAgaG9tZUFjY291bnRJZGVudGlmaWVyPzogc3RyaW5nXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRodW1icHJpbnQgPSBnZXRSZXF1ZXN0VGh1bWJwcmludChcbiAgICAgICAgICAgIGNsaWVudElkLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWRlbnRpZmllclxuICAgICAgICApO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdlbmVyYXRlVGhyb3R0bGluZ1N0b3JhZ2VLZXkodGh1bWJwcmludCk7XG4gICAgICAgIGNhY2hlTWFuYWdlci5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiLi9BdXRoRXJyb3IuanNcIjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIG5ldHdvcmsgcmVsYXRlZCBlcnJvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgZXJyb3I6IEF1dGhFcnJvcjtcbiAgICBodHRwU3RhdHVzPzogbnVtYmVyO1xuICAgIHJlc3BvbnNlSGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgZXJyb3I6IEF1dGhFcnJvcixcbiAgICAgICAgaHR0cFN0YXR1cz86IG51bWJlcixcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICkge1xuICAgICAgICBzdXBlcihlcnJvci5lcnJvckNvZGUsIGVycm9yLmVycm9yTWVzc2FnZSwgZXJyb3Iuc3ViRXJyb3IpO1xuXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBOZXR3b3JrRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOZXR3b3JrRXJyb3JcIjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmh0dHBTdGF0dXMgPSBodHRwU3RhdHVzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBOZXR3b3JrRXJyb3Igb2JqZWN0IGZvciBhIGZhaWxlZCBuZXR3b3JrIHJlcXVlc3RcbiAqIEBwYXJhbSBlcnJvciAtIEVycm9yIHRvIGJlIHRocm93biBiYWNrIHRvIHRoZSBjYWxsZXJcbiAqIEBwYXJhbSBodHRwU3RhdHVzIC0gU3RhdHVzIGNvZGUgb2YgdGhlIG5ldHdvcmsgcmVxdWVzdFxuICogQHBhcmFtIHJlc3BvbnNlSGVhZGVycyAtIFJlc3BvbnNlIGhlYWRlcnMgb2YgdGhlIG5ldHdvcmsgcmVxdWVzdCwgd2hlbiBhdmFpbGFibGVcbiAqIEByZXR1cm5zIE5ldHdvcmtFcnJvciBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5ldHdvcmtFcnJvcihcbiAgICBlcnJvcjogQXV0aEVycm9yLFxuICAgIGh0dHBTdGF0dXM/OiBudW1iZXIsXG4gICAgcmVzcG9uc2VIZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogTmV0d29ya0Vycm9yIHtcbiAgICByZXR1cm4gbmV3IE5ldHdvcmtFcnJvcihlcnJvciwgaHR0cFN0YXR1cywgcmVzcG9uc2VIZWFkZXJzKTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBDbGllbnRDb25maWd1cmF0aW9uLFxuICAgIGJ1aWxkQ2xpZW50Q29uZmlndXJhdGlvbixcbiAgICBDb21tb25DbGllbnRDb25maWd1cmF0aW9uLFxufSBmcm9tIFwiLi4vY29uZmlnL0NsaWVudENvbmZpZ3VyYXRpb24uanNcIjtcbmltcG9ydCB7XG4gICAgSU5ldHdvcmtNb2R1bGUsXG4gICAgTmV0d29ya1JlcXVlc3RPcHRpb25zLFxufSBmcm9tIFwiLi4vbmV0d29yay9JTmV0d29ya01vZHVsZS5qc1wiO1xuaW1wb3J0IHsgTmV0d29ya1Jlc3BvbnNlIH0gZnJvbSBcIi4uL25ldHdvcmsvTmV0d29ya1Jlc3BvbnNlLmpzXCI7XG5pbXBvcnQgeyBJQ3J5cHRvIH0gZnJvbSBcIi4uL2NyeXB0by9JQ3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpdHkgfSBmcm9tIFwiLi4vYXV0aG9yaXR5L0F1dGhvcml0eS5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXIuanNcIjtcbmltcG9ydCB7IENvbnN0YW50cywgSGVhZGVyTmFtZXMgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZSB9IGZyb20gXCIuLi9yZXNwb25zZS9TZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgQ2FjaGVNYW5hZ2VyIH0gZnJvbSBcIi4uL2NhY2hlL0NhY2hlTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgU2VydmVyVGVsZW1ldHJ5TWFuYWdlciB9IGZyb20gXCIuLi90ZWxlbWV0cnkvc2VydmVyL1NlcnZlclRlbGVtZXRyeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IFJlcXVlc3RUaHVtYnByaW50IH0gZnJvbSBcIi4uL25ldHdvcmsvUmVxdWVzdFRodW1icHJpbnQuanNcIjtcbmltcG9ydCB7IHZlcnNpb24sIG5hbWUgfSBmcm9tIFwiLi4vcGFja2FnZU1ldGFkYXRhLmpzXCI7XG5pbXBvcnQgeyBDY3NDcmVkZW50aWFsLCBDY3NDcmVkZW50aWFsVHlwZSB9IGZyb20gXCIuLi9hY2NvdW50L0Njc0NyZWRlbnRpYWwuanNcIjtcbmltcG9ydCB7IGJ1aWxkQ2xpZW50SW5mb0Zyb21Ib21lQWNjb3VudElkIH0gZnJvbSBcIi4uL2FjY291bnQvQ2xpZW50SW5mby5qc1wiO1xuaW1wb3J0IHsgSVBlcmZvcm1hbmNlQ2xpZW50IH0gZnJvbSBcIi4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9JUGVyZm9ybWFuY2VDbGllbnQuanNcIjtcbmltcG9ydCAqIGFzIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyIGZyb20gXCIuLi9yZXF1ZXN0L1JlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBVcmxVdGlscyBmcm9tIFwiLi4vdXRpbHMvVXJsVXRpbHMuanNcIjtcbmltcG9ydCB7IEJhc2VBdXRoUmVxdWVzdCB9IGZyb20gXCIuLi9yZXF1ZXN0L0Jhc2VBdXRoUmVxdWVzdC5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlRGlzY292ZXJlZEluc3RhbmNlIH0gZnJvbSBcIi4uL2F1dGhvcml0eS9BdXRob3JpdHlGYWN0b3J5LmpzXCI7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZUV2ZW50cyB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC5qc1wiO1xuaW1wb3J0IHsgVGhyb3R0bGluZ1V0aWxzIH0gZnJvbSBcIi4uL25ldHdvcmsvVGhyb3R0bGluZ1V0aWxzLmpzXCI7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3IvQXV0aEVycm9yLmpzXCI7XG5pbXBvcnQge1xuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgTmV0d29ya0Vycm9yIH0gZnJvbSBcIi4uL2Vycm9yL05ldHdvcmtFcnJvci5qc1wiO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMgfSBmcm9tIFwiLi4vdXRpbHMvRnVuY3Rpb25XcmFwcGVycy5qc1wiO1xuXG4vKipcbiAqIEJhc2UgYXBwbGljYXRpb24gY2xhc3Mgd2hpY2ggd2lsbCBjb25zdHJ1Y3QgcmVxdWVzdHMgdG8gc2VuZCB0byBhbmQgaGFuZGxlIHJlc3BvbnNlcyBmcm9tIHRoZSBNaWNyb3NvZnQgU1RTIHVzaW5nIHRoZSBhdXRob3JpemF0aW9uIGNvZGUgZmxvdy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNsaWVudCB7XG4gICAgLy8gTG9nZ2VyIG9iamVjdFxuICAgIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcblxuICAgIC8vIEFwcGxpY2F0aW9uIGNvbmZpZ1xuICAgIHByb3RlY3RlZCBjb25maWc6IENvbW1vbkNsaWVudENvbmZpZ3VyYXRpb247XG5cbiAgICAvLyBDcnlwdG8gSW50ZXJmYWNlXG4gICAgcHJvdGVjdGVkIGNyeXB0b1V0aWxzOiBJQ3J5cHRvO1xuXG4gICAgLy8gU3RvcmFnZSBJbnRlcmZhY2VcbiAgICBwcm90ZWN0ZWQgY2FjaGVNYW5hZ2VyOiBDYWNoZU1hbmFnZXI7XG5cbiAgICAvLyBOZXR3b3JrIEludGVyZmFjZVxuICAgIHByb3RlY3RlZCBuZXR3b3JrQ2xpZW50OiBJTmV0d29ya01vZHVsZTtcblxuICAgIC8vIFNlcnZlciBUZWxlbWV0cnkgTWFuYWdlclxuICAgIHByb3RlY3RlZCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyOiBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyIHwgbnVsbDtcblxuICAgIC8vIERlZmF1bHQgYXV0aG9yaXR5IG9iamVjdFxuICAgIHB1YmxpYyBhdXRob3JpdHk6IEF1dGhvcml0eTtcblxuICAgIC8vIFBlcmZvcm1hbmNlIHRlbGVtZXRyeSBjbGllbnRcbiAgICBwcm90ZWN0ZWQgcGVyZm9ybWFuY2VDbGllbnQ/OiBJUGVyZm9ybWFuY2VDbGllbnQ7XG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IENsaWVudENvbmZpZ3VyYXRpb24sXG4gICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50PzogSVBlcmZvcm1hbmNlQ2xpZW50XG4gICAgKSB7XG4gICAgICAgIC8vIFNldCB0aGUgY29uZmlndXJhdGlvblxuICAgICAgICB0aGlzLmNvbmZpZyA9IGJ1aWxkQ2xpZW50Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBsb2dnZXJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2VyKHRoaXMuY29uZmlnLmxvZ2dlck9wdGlvbnMsIG5hbWUsIHZlcnNpb24pO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3J5cHRvXG4gICAgICAgIHRoaXMuY3J5cHRvVXRpbHMgPSB0aGlzLmNvbmZpZy5jcnlwdG9JbnRlcmZhY2U7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzdG9yYWdlIGludGVyZmFjZVxuICAgICAgICB0aGlzLmNhY2hlTWFuYWdlciA9IHRoaXMuY29uZmlnLnN0b3JhZ2VJbnRlcmZhY2U7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBuZXR3b3JrIGludGVyZmFjZVxuICAgICAgICB0aGlzLm5ldHdvcmtDbGllbnQgPSB0aGlzLmNvbmZpZy5uZXR3b3JrSW50ZXJmYWNlO1xuXG4gICAgICAgIC8vIFNldCBUZWxlbWV0cnlNYW5hZ2VyXG4gICAgICAgIHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlciA9IHRoaXMuY29uZmlnLnNlcnZlclRlbGVtZXRyeU1hbmFnZXI7XG5cbiAgICAgICAgLy8gc2V0IEF1dGhvcml0eVxuICAgICAgICB0aGlzLmF1dGhvcml0eSA9IHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmF1dGhvcml0eTtcblxuICAgICAgICAvLyBzZXQgcGVyZm9ybWFuY2UgdGVsZW1ldHJ5IGNsaWVudFxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50ID0gcGVyZm9ybWFuY2VDbGllbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBkZWZhdWx0IGhlYWRlcnMgZm9yIHJlcXVlc3RzIHRvIHRva2VuIGVuZHBvaW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRva2VuUmVxdWVzdEhlYWRlcnMoXG4gICAgICAgIGNjc0NyZWQ/OiBDY3NDcmVkZW50aWFsXG4gICAgKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICAgICAgaGVhZGVyc1tIZWFkZXJOYW1lcy5DT05URU5UX1RZUEVdID0gQ29uc3RhbnRzLlVSTF9GT1JNX0NPTlRFTlRfVFlQRTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5zeXN0ZW1PcHRpb25zLnByZXZlbnRDb3JzUHJlZmxpZ2h0ICYmIGNjc0NyZWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2NzQ3JlZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDY3NDcmVkZW50aWFsVHlwZS5IT01FX0FDQ09VTlRfSUQ6XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvRnJvbUhvbWVBY2NvdW50SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2NzQ3JlZC5jcmVkZW50aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJOYW1lcy5DQ1NfSEVBREVSXG4gICAgICAgICAgICAgICAgICAgICAgICBdID0gYE9pZDoke2NsaWVudEluZm8udWlkfUAke2NsaWVudEluZm8udXRpZH1gO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ291bGQgbm90IHBhcnNlIGhvbWUgYWNjb3VudCBJRCBmb3IgQ0NTIEhlYWRlcjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ2NzQ3JlZGVudGlhbFR5cGUuVVBOOlxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1xuICAgICAgICAgICAgICAgICAgICAgICAgSGVhZGVyTmFtZXMuQ0NTX0hFQURFUlxuICAgICAgICAgICAgICAgICAgICBdID0gYFVQTjogJHtjY3NDcmVkLmNyZWRlbnRpYWx9YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSHR0cCBwb3N0IHRvIHRva2VuIGVuZHBvaW50XG4gICAgICogQHBhcmFtIHRva2VuRW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gcXVlcnlTdHJpbmdcbiAgICAgKiBAcGFyYW0gaGVhZGVyc1xuICAgICAqIEBwYXJhbSB0aHVtYnByaW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFzeW5jIGV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50KFxuICAgICAgICB0b2tlbkVuZHBvaW50OiBzdHJpbmcsXG4gICAgICAgIHF1ZXJ5U3RyaW5nOiBzdHJpbmcsXG4gICAgICAgIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgICAgIHRodW1icHJpbnQ6IFJlcXVlc3RUaHVtYnByaW50LFxuICAgICAgICBjb3JyZWxhdGlvbklkOiBzdHJpbmcsXG4gICAgICAgIHF1ZXVlZEV2ZW50Pzogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxOZXR3b3JrUmVzcG9uc2U8U2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2U+PiB7XG4gICAgICAgIGlmIChxdWV1ZWRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgICAgICBxdWV1ZWRFdmVudCxcbiAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kUG9zdFJlcXVlc3Q8U2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2U+KFxuICAgICAgICAgICAgICAgIHRodW1icHJpbnQsXG4gICAgICAgICAgICAgICAgdG9rZW5FbmRwb2ludCxcbiAgICAgICAgICAgICAgICB7IGJvZHk6IHF1ZXJ5U3RyaW5nLCBoZWFkZXJzOiBoZWFkZXJzIH0sXG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyICYmXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMgPCA1MDAgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyAhPT0gNDI5XG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gVGVsZW1ldHJ5IGRhdGEgc3VjY2Vzc2Z1bGx5IGxvZ2dlZCBieSBzZXJ2ZXIsIGNsZWFyIFRlbGVtZXRyeSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5jb25maWcuc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5jbGVhclRlbGVtZXRyeUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgc2VuZFBvc3RSZXF1ZXN0QXN5bmMgd2l0aCBuZWNlc3NhcnkgcHJlZmxpZ2h0IGFuZCBwb3N0ZmxpZ2h0IGxvZ2ljXG4gICAgICogQHBhcmFtIHRodW1icHJpbnQgLSBSZXF1ZXN0IHRodW1icHJpbnQgZm9yIHRocm90dGxpbmdcbiAgICAgKiBAcGFyYW0gdG9rZW5FbmRwb2ludCAtIEVuZHBvaW50IHRvIG1ha2UgdGhlIFBPU1QgdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEJvZHkgYW5kIEhlYWRlcnMgdG8gaW5jbHVkZSBvbiB0aGUgUE9TVCByZXF1ZXN0XG4gICAgICogQHBhcmFtIGNvcnJlbGF0aW9uSWQgLSBDb3JyZWxhdGlvbklkIGZvciB0ZWxlbWV0cnlcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kUG9zdFJlcXVlc3Q8VCBleHRlbmRzIFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlPihcbiAgICAgICAgdGh1bWJwcmludDogUmVxdWVzdFRodW1icHJpbnQsXG4gICAgICAgIHRva2VuRW5kcG9pbnQ6IHN0cmluZyxcbiAgICAgICAgb3B0aW9uczogTmV0d29ya1JlcXVlc3RPcHRpb25zLFxuICAgICAgICBjb3JyZWxhdGlvbklkOiBzdHJpbmdcbiAgICApOiBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxUPj4ge1xuICAgICAgICBUaHJvdHRsaW5nVXRpbHMucHJlUHJvY2Vzcyh0aGlzLmNhY2hlTWFuYWdlciwgdGh1bWJwcmludCk7XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtDbGllbnQuc2VuZFBvc3RSZXF1ZXN0QXN5bmMuYmluZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrQ2xpZW50XG4gICAgICAgICAgICAgICAgKTxUPixcbiAgICAgICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5OZXR3b3JrQ2xpZW50U2VuZFBvc3RSZXF1ZXN0QXN5bmMsXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApKHRva2VuRW5kcG9pbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlblNpemU6IHJlc3BvbnNlLmJvZHkucmVmcmVzaF90b2tlbj8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBWZXJUb2tlbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1tIZWFkZXJOYW1lcy5YX01TX0hUVFBfVkVSU0lPTl0gfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzW0hlYWRlck5hbWVzLlhfTVNfUkVRVUVTVF9JRF0gfHwgXCJcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZS5yZXNwb25zZUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFZlclRva2VuOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJOYW1lcy5YX01TX0hUVFBfVkVSU0lPTlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbSGVhZGVyTmFtZXMuWF9NU19SRVFVRVNUX0lEXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlSGVhZGVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbSGVhZGVyTmFtZXMuQ09OVEVOVF9UWVBFXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aEhlYWRlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzW0hlYWRlck5hbWVzLkNPTlRFTlRfTEVOR1RIXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFN0YXR1czogZS5odHRwU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQXV0aEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm5ldHdvcmtFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBUaHJvdHRsaW5nVXRpbHMucG9zdFByb2Nlc3ModGhpcy5jYWNoZU1hbmFnZXIsIHRodW1icHJpbnQsIHJlc3BvbnNlKTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXR5IG9iamVjdCBvZiB0aGUgY2xpZW50LiBFbmRwb2ludCBkaXNjb3ZlcnkgbXVzdCBiZSBjb21wbGV0ZWQuXG4gICAgICogQHBhcmFtIHVwZGF0ZWRBdXRob3JpdHlcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVBdXRob3JpdHkoXG4gICAgICAgIGNsb3VkSW5zdGFuY2VIb3N0bmFtZTogc3RyaW5nLFxuICAgICAgICBjb3JyZWxhdGlvbklkOiBzdHJpbmdcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlVwZGF0ZVRva2VuRW5kcG9pbnRBdXRob3JpdHksXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNsb3VkSW5zdGFuY2VBdXRob3JpdHlVcmkgPSBgaHR0cHM6Ly8ke2Nsb3VkSW5zdGFuY2VIb3N0bmFtZX0vJHt0aGlzLmF1dGhvcml0eS50ZW5hbnR9L2A7XG4gICAgICAgIGNvbnN0IGNsb3VkSW5zdGFuY2VBdXRob3JpdHkgPSBhd2FpdCBjcmVhdGVEaXNjb3ZlcmVkSW5zdGFuY2UoXG4gICAgICAgICAgICBjbG91ZEluc3RhbmNlQXV0aG9yaXR5VXJpLFxuICAgICAgICAgICAgdGhpcy5uZXR3b3JrQ2xpZW50LFxuICAgICAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIsXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eS5vcHRpb25zLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmF1dGhvcml0eSA9IGNsb3VkSW5zdGFuY2VBdXRob3JpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBxdWVyeSBzdHJpbmcgZm9yIHRoZSAvdG9rZW4gcmVxdWVzdFxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICovXG4gICAgY3JlYXRlVG9rZW5RdWVyeVBhcmFtZXRlcnMocmVxdWVzdDogQmFzZUF1dGhSZXF1ZXN0KTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuZW1iZWRkZWRDbGllbnRJZCkge1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQnJva2VyUGFyYW1ldGVycyhcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QudG9rZW5RdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50b2tlblF1ZXJ5UGFyYW1ldGVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENvcnJlbGF0aW9uSWQoXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuaW5zdHJ1bWVudEJyb2tlclBhcmFtcyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLy8gQ29kZXMgZGVmaW5lZCBieSBNU0FMXG5leHBvcnQgY29uc3Qgbm9Ub2tlbnNGb3VuZCA9IFwibm9fdG9rZW5zX2ZvdW5kXCI7XG5leHBvcnQgY29uc3QgbmF0aXZlQWNjb3VudFVuYXZhaWxhYmxlID0gXCJuYXRpdmVfYWNjb3VudF91bmF2YWlsYWJsZVwiO1xuZXhwb3J0IGNvbnN0IHJlZnJlc2hUb2tlbkV4cGlyZWQgPSBcInJlZnJlc2hfdG9rZW5fZXhwaXJlZFwiO1xuXG4vLyBDb2RlcyBwb3RlbnRpYWxseSByZXR1cm5lZCBieSBzZXJ2ZXJcbmV4cG9ydCBjb25zdCBpbnRlcmFjdGlvblJlcXVpcmVkID0gXCJpbnRlcmFjdGlvbl9yZXF1aXJlZFwiO1xuZXhwb3J0IGNvbnN0IGNvbnNlbnRSZXF1aXJlZCA9IFwiY29uc2VudF9yZXF1aXJlZFwiO1xuZXhwb3J0IGNvbnN0IGxvZ2luUmVxdWlyZWQgPSBcImxvZ2luX3JlcXVpcmVkXCI7XG5leHBvcnQgY29uc3QgYmFkVG9rZW4gPSBcImJhZF90b2tlblwiO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiLi9BdXRoRXJyb3IuanNcIjtcbmltcG9ydCAqIGFzIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2RlcyBmcm9tIFwiLi9JbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMuanNcIjtcbmV4cG9ydCB7IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2RlcyB9O1xuXG4vKipcbiAqIEludGVyYWN0aW9uUmVxdWlyZWRTZXJ2ZXJFcnJvck1lc3NhZ2UgY29udGFpbnMgc3RyaW5nIGNvbnN0YW50cyB1c2VkIGJ5IGVycm9yIGNvZGVzIGFuZCBtZXNzYWdlcyByZXR1cm5lZCBieSB0aGUgc2VydmVyIGluZGljYXRpbmcgaW50ZXJhY3Rpb24gaXMgcmVxdWlyZWRcbiAqL1xuZXhwb3J0IGNvbnN0IEludGVyYWN0aW9uUmVxdWlyZWRTZXJ2ZXJFcnJvck1lc3NhZ2UgPSBbXG4gICAgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLmludGVyYWN0aW9uUmVxdWlyZWQsXG4gICAgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLmNvbnNlbnRSZXF1aXJlZCxcbiAgICBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMubG9naW5SZXF1aXJlZCxcbiAgICBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMuYmFkVG9rZW4sXG5dO1xuXG5leHBvcnQgY29uc3QgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhTdWJFcnJvck1lc3NhZ2UgPSBbXG4gICAgXCJtZXNzYWdlX29ubHlcIixcbiAgICBcImFkZGl0aW9uYWxfYWN0aW9uXCIsXG4gICAgXCJiYXNpY19hY3Rpb25cIixcbiAgICBcInVzZXJfcGFzc3dvcmRfZXhwaXJlZFwiLFxuICAgIFwiY29uc2VudF9yZXF1aXJlZFwiLFxuICAgIFwiYmFkX3Rva2VuXCIsXG5dO1xuXG5jb25zdCBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yTWVzc2FnZXMgPSB7XG4gICAgW0ludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5ub1Rva2Vuc0ZvdW5kXTpcbiAgICAgICAgXCJObyByZWZyZXNoIHRva2VuIGZvdW5kIGluIHRoZSBjYWNoZS4gUGxlYXNlIHNpZ24taW4uXCIsXG4gICAgW0ludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5uYXRpdmVBY2NvdW50VW5hdmFpbGFibGVdOlxuICAgICAgICBcIlRoZSByZXF1ZXN0ZWQgYWNjb3VudCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBuYXRpdmUgYnJva2VyLiBJdCBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgb3IgbG9nZ2VkIG91dC4gUGxlYXNlIHNpZ24taW4gYWdhaW4gdXNpbmcgYW4gaW50ZXJhY3RpdmUgQVBJLlwiLFxuICAgIFtJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMucmVmcmVzaFRva2VuRXhwaXJlZF06XG4gICAgICAgIFwiUmVmcmVzaCB0b2tlbiBoYXMgZXhwaXJlZC5cIixcbiAgICBbSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLmJhZFRva2VuXTpcbiAgICAgICAgXCJJZGVudGl0eSBwcm92aWRlciByZXR1cm5lZCBiYWRfdG9rZW4gZHVlIHRvIGFuIGV4cGlyZWQgb3IgaW52YWxpZCByZWZyZXNoIHRva2VuLiBQbGVhc2UgaW52b2tlIGFuIGludGVyYWN0aXZlIEFQSSB0byByZXNvbHZlLlwiLFxufTtcblxuLyoqXG4gKiBJbnRlcmFjdGlvbiByZXF1aXJlZCBlcnJvcnMgZGVmaW5lZCBieSB0aGUgU0RLXG4gKiBAZGVwcmVjYXRlZCBVc2UgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzIGluc3RlYWRcbiAqL1xuZXhwb3J0IGNvbnN0IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JNZXNzYWdlID0ge1xuICAgIG5vVG9rZW5zRm91bmRFcnJvcjoge1xuICAgICAgICBjb2RlOiBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMubm9Ub2tlbnNGb3VuZCxcbiAgICAgICAgZGVzYzogSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvck1lc3NhZ2VzW1xuICAgICAgICAgICAgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLm5vVG9rZW5zRm91bmRcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIG5hdGl2ZV9hY2NvdW50X3VuYXZhaWxhYmxlOiB7XG4gICAgICAgIGNvZGU6IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5uYXRpdmVBY2NvdW50VW5hdmFpbGFibGUsXG4gICAgICAgIGRlc2M6IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5uYXRpdmVBY2NvdW50VW5hdmFpbGFibGVcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGJhZF90b2tlbjoge1xuICAgICAgICBjb2RlOiBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMuYmFkVG9rZW4sXG4gICAgICAgIGRlc2M6IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JNZXNzYWdlc1tcbiAgICAgICAgICAgIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5iYWRUb2tlblxuICAgICAgICBdLFxuICAgIH0sXG59O1xuXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHVzZXIgaW50ZXJhY3Rpb24gaXMgcmVxdWlyZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSB0aGUgZXJyb3Igb2NjdXJlZCBhdFxuICAgICAqL1xuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2VJZCBhc3NvY2lhdGVkIHdpdGggdGhlIGVycm9yXG4gICAgICovXG4gICAgdHJhY2VJZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL0F6dXJlQUQvbWljcm9zb2Z0LWF1dGhlbnRpY2F0aW9uLWxpYnJhcnktZm9yLWpzL2Jsb2IvZGV2L2xpYi9tc2FsLWNvbW1vbi9kb2NzL2NsYWltcy1jaGFsbGVuZ2UubWRcbiAgICAgKlxuICAgICAqIEEgc3RyaW5nIHdpdGggZXh0cmEgY2xhaW1zIG5lZWRlZCBmb3IgdGhlIHRva2VuIHJlcXVlc3QgdG8gc3VjY2VlZFxuICAgICAqIHdlYiBzaXRlOiByZWRpcmVjdCB0aGUgdXNlciB0byB0aGUgYXV0aG9yaXphdGlvbiBwYWdlIGFuZCBzZXQgdGhlIGV4dHJhIGNsYWltc1xuICAgICAqIHdlYiBhcGk6IGluY2x1ZGUgdGhlIGNsYWltcyBpbiB0aGUgV1dXLUF1dGhlbnRpY2F0ZSBoZWFkZXIgdGhhdCBhcmUgc2VudCBiYWNrIHRvIHRoZSBjbGllbnQgc28gdGhhdCBpdCBrbm93cyB0byByZXF1ZXN0IGEgdG9rZW4gd2l0aCB0aGUgZXh0cmEgY2xhaW1zXG4gICAgICogZGVza3RvcCBhcHBsaWNhdGlvbiBvciBicm93c2VyIGNvbnRleHQ6IGluY2x1ZGUgdGhlIGNsYWltcyB3aGVuIGFjcXVpcmluZyB0aGUgdG9rZW4gaW50ZXJhY3RpdmVseVxuICAgICAqIGFwcCB0byBhcHAgY29udGV4dCAoY2xpZW50X2NyZWRlbnRpYWxzKTogaW5jbHVkZSB0aGUgY2xhaW1zIGluIHRoZSBBY3F1aXJlVG9rZW5CeUNsaWVudENyZWRlbnRpYWwgcmVxdWVzdFxuICAgICAqL1xuICAgIGNsYWltczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2VydmVyIGVycm9yIG51bWJlcjtcbiAgICAgKi9cbiAgICByZWFkb25seSBlcnJvck5vPzogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGVycm9yQ29kZT86IHN0cmluZyxcbiAgICAgICAgZXJyb3JNZXNzYWdlPzogc3RyaW5nLFxuICAgICAgICBzdWJFcnJvcj86IHN0cmluZyxcbiAgICAgICAgdGltZXN0YW1wPzogc3RyaW5nLFxuICAgICAgICB0cmFjZUlkPzogc3RyaW5nLFxuICAgICAgICBjb3JyZWxhdGlvbklkPzogc3RyaW5nLFxuICAgICAgICBjbGFpbXM/OiBzdHJpbmcsXG4gICAgICAgIGVycm9yTm8/OiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgc3VwZXIoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIHN1YkVycm9yKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IucHJvdG90eXBlKTtcblxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuICAgICAgICB0aGlzLnRyYWNlSWQgPSB0cmFjZUlkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG4gICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgdGhpcy5jbGFpbXMgPSBjbGFpbXMgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yXCI7XG4gICAgICAgIHRoaXMuZXJyb3JObyA9IGVycm9yTm87XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciB0aHJvd24gYnkgdGhlIHNlcnZlciByZXF1aXJlcyBpbnRlcmFjdGlvbiB0byByZXNvbHZlXG4gKiBAcGFyYW0gZXJyb3JDb2RlXG4gKiBAcGFyYW0gZXJyb3JTdHJpbmdcbiAqIEBwYXJhbSBzdWJFcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcmFjdGlvblJlcXVpcmVkRXJyb3IoXG4gICAgZXJyb3JDb2RlPzogc3RyaW5nLFxuICAgIGVycm9yU3RyaW5nPzogc3RyaW5nLFxuICAgIHN1YkVycm9yPzogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgICBjb25zdCBpc0ludGVyYWN0aW9uUmVxdWlyZWRFcnJvckNvZGUgPVxuICAgICAgICAhIWVycm9yQ29kZSAmJlxuICAgICAgICBJbnRlcmFjdGlvblJlcXVpcmVkU2VydmVyRXJyb3JNZXNzYWdlLmluZGV4T2YoZXJyb3JDb2RlKSA+IC0xO1xuICAgIGNvbnN0IGlzSW50ZXJhY3Rpb25SZXF1aXJlZFN1YkVycm9yID1cbiAgICAgICAgISFzdWJFcnJvciAmJlxuICAgICAgICBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aFN1YkVycm9yTWVzc2FnZS5pbmRleE9mKHN1YkVycm9yKSA+IC0xO1xuICAgIGNvbnN0IGlzSW50ZXJhY3Rpb25SZXF1aXJlZEVycm9yRGVzYyA9XG4gICAgICAgICEhZXJyb3JTdHJpbmcgJiZcbiAgICAgICAgSW50ZXJhY3Rpb25SZXF1aXJlZFNlcnZlckVycm9yTWVzc2FnZS5zb21lKChpckVycm9yQ29kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yU3RyaW5nLmluZGV4T2YoaXJFcnJvckNvZGUpID4gLTE7XG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgaXNJbnRlcmFjdGlvblJlcXVpcmVkRXJyb3JDb2RlIHx8XG4gICAgICAgIGlzSW50ZXJhY3Rpb25SZXF1aXJlZEVycm9yRGVzYyB8fFxuICAgICAgICBpc0ludGVyYWN0aW9uUmVxdWlyZWRTdWJFcnJvclxuICAgICk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yKFxuICAgIGVycm9yQ29kZTogc3RyaW5nXG4pOiBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yIHtcbiAgICByZXR1cm4gbmV3IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IoXG4gICAgICAgIGVycm9yQ29kZSxcbiAgICAgICAgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV1cbiAgICApO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tIFwiLi9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7IElDcnlwdG8gfSBmcm9tIFwiLi4vY3J5cHRvL0lDcnlwdG8uanNcIjtcbmltcG9ydCB7XG4gICAgQ2xpZW50QXV0aEVycm9yQ29kZXMsXG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLmpzXCI7XG5cbi8qKlxuICogVHlwZSB3aGljaCBkZWZpbmVzIHRoZSBvYmplY3QgdGhhdCBpcyBzdHJpbmdpZmllZCwgZW5jb2RlZCBhbmQgc2VudCBpbiB0aGUgc3RhdGUgdmFsdWUuXG4gKiBDb250YWlucyB0aGUgZm9sbG93aW5nOlxuICogLSBpZCAtIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHJlcXVlc3RcbiAqIC0gdHMgLSB0aW1lc3RhbXAgZm9yIHRoZSB0aW1lIHRoZSByZXF1ZXN0IHdhcyBtYWRlLiBVc2VkIHRvIGVuc3VyZSB0aGF0IHRva2VuIGV4cGlyYXRpb24gaXMgbm90IGNhbGN1bGF0ZWQgaW5jb3JyZWN0bHkuXG4gKiAtIHBsYXRmb3JtU3RhdGUgLSBzdHJpbmcgdmFsdWUgc2VudCBmcm9tIHRoZSBwbGF0Zm9ybS5cbiAqL1xuZXhwb3J0IHR5cGUgTGlicmFyeVN0YXRlT2JqZWN0ID0ge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbWV0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59O1xuXG4vKipcbiAqIFR5cGUgd2hpY2ggZGVmaW5lcyB0aGUgc3RyaW5naWZpZWQgYW5kIGVuY29kZWQgb2JqZWN0IHNlbnQgdG8gdGhlIHNlcnZpY2UgaW4gdGhlIGF1dGhvcml6ZSByZXF1ZXN0LlxuICovXG5leHBvcnQgdHlwZSBSZXF1ZXN0U3RhdGVPYmplY3QgPSB7XG4gICAgdXNlclJlcXVlc3RTdGF0ZTogc3RyaW5nO1xuICAgIGxpYnJhcnlTdGF0ZTogTGlicmFyeVN0YXRlT2JqZWN0O1xufTtcblxuLyoqXG4gKiBDbGFzcyB3aGljaCBwcm92aWRlcyBoZWxwZXJzIGZvciBPQXV0aCAyLjAgcHJvdG9jb2wgc3BlY2lmaWMgdmFsdWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm90b2NvbFV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHVzZXIgc3RhdGUgd2l0aCByYW5kb20gZ3VpZCwgb3IgcmV0dXJucyByYW5kb20gZ3VpZC5cbiAgICAgKiBAcGFyYW0gdXNlclN0YXRlXG4gICAgICogQHBhcmFtIHJhbmRvbUd1aWRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0UmVxdWVzdFN0YXRlKFxuICAgICAgICBjcnlwdG9PYmo6IElDcnlwdG8sXG4gICAgICAgIHVzZXJTdGF0ZT86IHN0cmluZyxcbiAgICAgICAgbWV0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICApOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBsaWJyYXJ5U3RhdGUgPSBQcm90b2NvbFV0aWxzLmdlbmVyYXRlTGlicmFyeVN0YXRlKFxuICAgICAgICAgICAgY3J5cHRvT2JqLFxuICAgICAgICAgICAgbWV0YVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdXNlclN0YXRlXG4gICAgICAgICAgICA/IGAke2xpYnJhcnlTdGF0ZX0ke0NvbnN0YW50cy5SRVNPVVJDRV9ERUxJTX0ke3VzZXJTdGF0ZX1gXG4gICAgICAgICAgICA6IGxpYnJhcnlTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHN0YXRlIHZhbHVlIHVzZWQgYnkgdGhlIGNvbW1vbiBsaWJyYXJ5LlxuICAgICAqIEBwYXJhbSByYW5kb21HdWlkXG4gICAgICogQHBhcmFtIGNyeXB0b09ialxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZUxpYnJhcnlTdGF0ZShcbiAgICAgICAgY3J5cHRvT2JqOiBJQ3J5cHRvLFxuICAgICAgICBtZXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGlmICghY3J5cHRvT2JqKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubm9DcnlwdG9PYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc3RhdGUgb2JqZWN0IGNvbnRhaW5pbmcgYSB1bmlxdWUgaWQgYW5kIHRoZSB0aW1lc3RhbXAgb2YgdGhlIHJlcXVlc3QgY3JlYXRpb25cbiAgICAgICAgY29uc3Qgc3RhdGVPYmo6IExpYnJhcnlTdGF0ZU9iamVjdCA9IHtcbiAgICAgICAgICAgIGlkOiBjcnlwdG9PYmouY3JlYXRlTmV3R3VpZCgpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBzdGF0ZU9iai5tZXRhID0gbWV0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXRlU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoc3RhdGVPYmopO1xuXG4gICAgICAgIHJldHVybiBjcnlwdG9PYmouYmFzZTY0RW5jb2RlKHN0YXRlU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHN0YXRlIGludG8gdGhlIFJlcXVlc3RTdGF0ZU9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIExpYnJhcnlTdGF0ZSBpbmZvIGFuZCB0aGUgc3RhdGUgcGFzc2VkIGJ5IHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBzdGF0ZVxuICAgICAqIEBwYXJhbSBjcnlwdG9PYmpcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VSZXF1ZXN0U3RhdGUoXG4gICAgICAgIGNyeXB0b09iajogSUNyeXB0byxcbiAgICAgICAgc3RhdGU6IHN0cmluZ1xuICAgICk6IFJlcXVlc3RTdGF0ZU9iamVjdCB7XG4gICAgICAgIGlmICghY3J5cHRvT2JqKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubm9DcnlwdG9PYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHN0YXRlIGJldHdlZW4gbGlicmFyeSBzdGF0ZSBhbmQgdXNlciBwYXNzZWQgc3RhdGUgYW5kIGRlY29kZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0U3RhdGUgPSBzdGF0ZS5zcGxpdChDb25zdGFudHMuUkVTT1VSQ0VfREVMSU0pO1xuICAgICAgICAgICAgY29uc3QgbGlicmFyeVN0YXRlID0gc3BsaXRTdGF0ZVswXTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJTdGF0ZSA9XG4gICAgICAgICAgICAgICAgc3BsaXRTdGF0ZS5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgID8gc3BsaXRTdGF0ZS5zbGljZSgxKS5qb2luKENvbnN0YW50cy5SRVNPVVJDRV9ERUxJTSlcbiAgICAgICAgICAgICAgICAgICAgOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuICAgICAgICAgICAgY29uc3QgbGlicmFyeVN0YXRlU3RyaW5nID0gY3J5cHRvT2JqLmJhc2U2NERlY29kZShsaWJyYXJ5U3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgbGlicmFyeVN0YXRlT2JqID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICBsaWJyYXJ5U3RhdGVTdHJpbmdcbiAgICAgICAgICAgICkgYXMgTGlicmFyeVN0YXRlT2JqZWN0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VyUmVxdWVzdFN0YXRlOiB1c2VyU3RhdGUgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgICAgICBsaWJyYXJ5U3RhdGU6IGxpYnJhcnlTdGF0ZU9iaixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJQ3J5cHRvLCBTaWduZWRIdHRwUmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tIFwiLi9JQ3J5cHRvLmpzXCI7XG5pbXBvcnQgKiBhcyBUaW1lVXRpbHMgZnJvbSBcIi4uL3V0aWxzL1RpbWVVdGlscy5qc1wiO1xuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSBcIi4uL3VybC9VcmxTdHJpbmcuanNcIjtcbmltcG9ydCB7IElQZXJmb3JtYW5jZUNsaWVudCB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvSVBlcmZvcm1hbmNlQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZUV2ZW50cyB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC5qc1wiO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMgfSBmcm9tIFwiLi4vdXRpbHMvRnVuY3Rpb25XcmFwcGVycy5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXIuanNcIjtcblxuLyoqXG4gKiBTZWUgZVNUUyBkb2NzIGZvciBtb3JlIGluZm8uXG4gKiAtIEEga2lkIGVsZW1lbnQsIHdpdGggdGhlIHZhbHVlIGNvbnRhaW5pbmcgYW4gUkZDIDc2MzgtY29tcGxpYW50IEpXSyB0aHVtYnByaW50IHRoYXQgaXMgYmFzZTY0IGVuY29kZWQuXG4gKiAtICB4bXNfa3NsIGVsZW1lbnQsIHJlcHJlc2VudGluZyB0aGUgc3RvcmFnZSBsb2NhdGlvbiBvZiB0aGUga2V5J3Mgc2VjcmV0IGNvbXBvbmVudCBvbiB0aGUgY2xpZW50IGRldmljZS4gT25lIG9mIHR3byB2YWx1ZXM6XG4gKiAgICAgIC0gc3c6IHNvZnR3YXJlIHN0b3JhZ2VcbiAqICAgICAgLSB1aHc6IGhhcmR3YXJlIHN0b3JhZ2VcbiAqL1xudHlwZSBSZXFDbmYgPSB7XG4gICAga2lkOiBzdHJpbmc7XG4gICAgeG1zX2tzbDogS2V5TG9jYXRpb247XG59O1xuXG5leHBvcnQgdHlwZSBSZXFDbmZEYXRhID0ge1xuICAgIGtpZDogc3RyaW5nO1xuICAgIHJlcUNuZlN0cmluZzogc3RyaW5nO1xufTtcblxuY29uc3QgS2V5TG9jYXRpb24gPSB7XG4gICAgU1c6IFwic3dcIixcbiAgICBVSFc6IFwidWh3XCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgS2V5TG9jYXRpb24gPSAodHlwZW9mIEtleUxvY2F0aW9uKVtrZXlvZiB0eXBlb2YgS2V5TG9jYXRpb25dO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgUG9wVG9rZW5HZW5lcmF0b3Ige1xuICAgIHByaXZhdGUgY3J5cHRvVXRpbHM6IElDcnlwdG87XG4gICAgcHJpdmF0ZSBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudDtcblxuICAgIGNvbnN0cnVjdG9yKGNyeXB0b1V0aWxzOiBJQ3J5cHRvLCBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudCkge1xuICAgICAgICB0aGlzLmNyeXB0b1V0aWxzID0gY3J5cHRvVXRpbHM7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQgPSBwZXJmb3JtYW5jZUNsaWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHJlcV9jbmYgdmFsaWRhdGVkIGF0IHRoZSBSUCBpbiB0aGUgUE9QIHByb3RvY29sIGZvciBTSFIgcGFyYW1ldGVyc1xuICAgICAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXlpZCwgdGhlIGZ1bGwgcmVxX2NuZiBzdHJpbmcgYW5kIHRoZSByZXFfY25mIHN0cmluZyBoYXNoXG4gICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlQ25mKFxuICAgICAgICByZXF1ZXN0OiBTaWduZWRIdHRwUmVxdWVzdFBhcmFtZXRlcnMsXG4gICAgICAgIGxvZ2dlcjogTG9nZ2VyXG4gICAgKTogUHJvbWlzZTxSZXFDbmZEYXRhPiB7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5Qb3BUb2tlbkdlbmVyYXRlQ25mLFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVxQ25mID0gYXdhaXQgaW52b2tlQXN5bmMoXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlS2lkLmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5Qb3BUb2tlbkdlbmVyYXRlQ25mLFxuICAgICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCByZXFDbmZTdHJpbmc6IHN0cmluZyA9IHRoaXMuY3J5cHRvVXRpbHMuYmFzZTY0VXJsRW5jb2RlKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocmVxQ25mKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraWQ6IHJlcUNuZi5raWQsXG4gICAgICAgICAgICByZXFDbmZTdHJpbmcsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGtleV9pZCBmb3IgYSBTSFIgdG9rZW4gcmVxdWVzdFxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUtpZChyZXF1ZXN0OiBTaWduZWRIdHRwUmVxdWVzdFBhcmFtZXRlcnMpOiBQcm9taXNlPFJlcUNuZj4ge1xuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUG9wVG9rZW5HZW5lcmF0ZUtpZCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGtpZFRodW1icHJpbnQgPSBhd2FpdCB0aGlzLmNyeXB0b1V0aWxzLmdldFB1YmxpY0tleVRodW1icHJpbnQoXG4gICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpZDoga2lkVGh1bWJwcmludCxcbiAgICAgICAgICAgIHhtc19rc2w6IEtleUxvY2F0aW9uLlNXLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBQT1AgYWNjZXNzX3Rva2VuIHdpdGggdGhlIGxvY2FsIGdlbmVyYXRlZCBrZXktcGFpclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlblxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBzaWduUG9wVG9rZW4oXG4gICAgICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmcsXG4gICAgICAgIGtleUlkOiBzdHJpbmcsXG4gICAgICAgIHJlcXVlc3Q6IFNpZ25lZEh0dHBSZXF1ZXN0UGFyYW1ldGVyc1xuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25QYXlsb2FkKGFjY2Vzc1Rva2VuLCBrZXlJZCwgcmVxdWVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgc2lnbmVkIEpXVCBmb3IgYW4gYWNjZXNzX3Rva2VuXG4gICAgICogQHBhcmFtIHBheWxvYWRcbiAgICAgKiBAcGFyYW0ga2lkXG4gICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gY2xhaW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBzaWduUGF5bG9hZChcbiAgICAgICAgcGF5bG9hZDogc3RyaW5nLFxuICAgICAgICBrZXlJZDogc3RyaW5nLFxuICAgICAgICByZXF1ZXN0OiBTaWduZWRIdHRwUmVxdWVzdFBhcmFtZXRlcnMsXG4gICAgICAgIGNsYWltcz86IG9iamVjdFxuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIC8vIERlY29uc3RydWN0IHJlcXVlc3QgdG8gZXh0cmFjdCBTSFIgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RVcmksXG4gICAgICAgICAgICBzaHJDbGFpbXMsXG4gICAgICAgICAgICBzaHJOb25jZSxcbiAgICAgICAgICAgIHNock9wdGlvbnMsXG4gICAgICAgIH0gPSByZXF1ZXN0O1xuXG4gICAgICAgIGNvbnN0IHJlc291cmNlVXJsU3RyaW5nID0gcmVzb3VyY2VSZXF1ZXN0VXJpXG4gICAgICAgICAgICA/IG5ldyBVcmxTdHJpbmcocmVzb3VyY2VSZXF1ZXN0VXJpKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc291cmNlVXJsQ29tcG9uZW50cyA9IHJlc291cmNlVXJsU3RyaW5nPy5nZXRVcmxDb21wb25lbnRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyeXB0b1V0aWxzLnNpZ25Kd3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgdHM6IFRpbWVVdGlscy5ub3dTZWNvbmRzKCksXG4gICAgICAgICAgICAgICAgbTogcmVzb3VyY2VSZXF1ZXN0TWV0aG9kPy50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIHU6IHJlc291cmNlVXJsQ29tcG9uZW50cz8uSG9zdE5hbWVBbmRQb3J0LFxuICAgICAgICAgICAgICAgIG5vbmNlOiBzaHJOb25jZSB8fCB0aGlzLmNyeXB0b1V0aWxzLmNyZWF0ZU5ld0d1aWQoKSxcbiAgICAgICAgICAgICAgICBwOiByZXNvdXJjZVVybENvbXBvbmVudHM/LkFic29sdXRlUGF0aCxcbiAgICAgICAgICAgICAgICBxOiByZXNvdXJjZVVybENvbXBvbmVudHM/LlF1ZXJ5U3RyaW5nXG4gICAgICAgICAgICAgICAgICAgID8gW1tdLCByZXNvdXJjZVVybENvbXBvbmVudHMuUXVlcnlTdHJpbmddXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNsaWVudF9jbGFpbXM6IHNockNsYWltcyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLi4uY2xhaW1zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleUlkLFxuICAgICAgICAgICAgc2hyT3B0aW9ucyxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSVNlcmlhbGl6YWJsZVRva2VuQ2FjaGUgfSBmcm9tIFwiLi4vaW50ZXJmYWNlL0lTZXJpYWxpemFibGVUb2tlbkNhY2hlLmpzXCI7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpbnN0YW5jZSBoZWxwcyB0cmFjayB0aGUgbWVtb3J5IGNoYW5nZXMgZmFjaWxpdGF0aW5nXG4gKiBkZWNpc2lvbnMgdG8gcmVhZCBmcm9tIGFuZCB3cml0ZSB0byB0aGUgcGVyc2lzdGVudCBjYWNoZVxuICovIGV4cG9ydCBjbGFzcyBUb2tlbkNhY2hlQ29udGV4dCB7XG4gICAgLyoqXG4gICAgICogYm9vbGVhbiBpbmRpY2F0aW5nIGNhY2hlIGNoYW5nZVxuICAgICAqL1xuICAgIGhhc0NoYW5nZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogc2VyaWFsaXphYmxlIHRva2VuIGNhY2hlIGludGVyZmFjZVxuICAgICAqL1xuICAgIGNhY2hlOiBJU2VyaWFsaXphYmxlVG9rZW5DYWNoZTtcblxuICAgIGNvbnN0cnVjdG9yKHRva2VuQ2FjaGU6IElTZXJpYWxpemFibGVUb2tlbkNhY2hlLCBoYXNDaGFuZ2VkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB0b2tlbkNhY2hlO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJvb2xlYW4gd2hpY2ggaW5kaWNhdGVzIHRoZSBjaGFuZ2VzIGluIGNhY2hlXG4gICAgICovXG4gICAgZ2V0IGNhY2hlSGFzQ2hhbmdlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgdG9rZW4gY2FjaGVcbiAgICAgKi9cbiAgICBnZXQgdG9rZW5DYWNoZSgpOiBJU2VyaWFsaXphYmxlVG9rZW5DYWNoZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2UgfSBmcm9tIFwiLi9TZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgSUNyeXB0byB9IGZyb20gXCIuLi9jcnlwdG8vSUNyeXB0by5qc1wiO1xuaW1wb3J0IHtcbiAgICBDbGllbnRBdXRoRXJyb3JDb2RlcyxcbiAgICBjcmVhdGVDbGllbnRBdXRoRXJyb3IsXG59IGZyb20gXCIuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IuanNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBTZXJ2ZXJFcnJvciB9IGZyb20gXCIuLi9lcnJvci9TZXJ2ZXJFcnJvci5qc1wiO1xuaW1wb3J0IHsgU2NvcGVTZXQgfSBmcm9tIFwiLi4vcmVxdWVzdC9TY29wZVNldC5qc1wiO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb25SZXN1bHQgfSBmcm9tIFwiLi9BdXRoZW50aWNhdGlvblJlc3VsdC5qc1wiO1xuaW1wb3J0IHsgQWNjb3VudEVudGl0eSB9IGZyb20gXCIuLi9jYWNoZS9lbnRpdGllcy9BY2NvdW50RW50aXR5LmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpdHkgfSBmcm9tIFwiLi4vYXV0aG9yaXR5L0F1dGhvcml0eS5qc1wiO1xuaW1wb3J0IHsgSWRUb2tlbkVudGl0eSB9IGZyb20gXCIuLi9jYWNoZS9lbnRpdGllcy9JZFRva2VuRW50aXR5LmpzXCI7XG5pbXBvcnQgeyBBY2Nlc3NUb2tlbkVudGl0eSB9IGZyb20gXCIuLi9jYWNoZS9lbnRpdGllcy9BY2Nlc3NUb2tlbkVudGl0eS5qc1wiO1xuaW1wb3J0IHsgUmVmcmVzaFRva2VuRW50aXR5IH0gZnJvbSBcIi4uL2NhY2hlL2VudGl0aWVzL1JlZnJlc2hUb2tlbkVudGl0eS5qc1wiO1xuaW1wb3J0IHtcbiAgICBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yLFxuICAgIGlzSW50ZXJhY3Rpb25SZXF1aXJlZEVycm9yLFxufSBmcm9tIFwiLi4vZXJyb3IvSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgQ2FjaGVSZWNvcmQgfSBmcm9tIFwiLi4vY2FjaGUvZW50aXRpZXMvQ2FjaGVSZWNvcmQuanNcIjtcbmltcG9ydCB7IENhY2hlTWFuYWdlciB9IGZyb20gXCIuLi9jYWNoZS9DYWNoZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IFByb3RvY29sVXRpbHMsIFJlcXVlc3RTdGF0ZU9iamVjdCB9IGZyb20gXCIuLi91dGlscy9Qcm90b2NvbFV0aWxzLmpzXCI7XG5pbXBvcnQge1xuICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLFxuICAgIENvbnN0YW50cyxcbiAgICBUSEVfRkFNSUxZX0lELFxuICAgIEh0dHBTdGF0dXMsXG59IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7IFBvcFRva2VuR2VuZXJhdG9yIH0gZnJvbSBcIi4uL2NyeXB0by9Qb3BUb2tlbkdlbmVyYXRvci5qc1wiO1xuaW1wb3J0IHsgQXBwTWV0YWRhdGFFbnRpdHkgfSBmcm9tIFwiLi4vY2FjaGUvZW50aXRpZXMvQXBwTWV0YWRhdGFFbnRpdHkuanNcIjtcbmltcG9ydCB7IElDYWNoZVBsdWdpbiB9IGZyb20gXCIuLi9jYWNoZS9pbnRlcmZhY2UvSUNhY2hlUGx1Z2luLmpzXCI7XG5pbXBvcnQgeyBUb2tlbkNhY2hlQ29udGV4dCB9IGZyb20gXCIuLi9jYWNoZS9wZXJzaXN0ZW5jZS9Ub2tlbkNhY2hlQ29udGV4dC5qc1wiO1xuaW1wb3J0IHsgSVNlcmlhbGl6YWJsZVRva2VuQ2FjaGUgfSBmcm9tIFwiLi4vY2FjaGUvaW50ZXJmYWNlL0lTZXJpYWxpemFibGVUb2tlbkNhY2hlLmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpemF0aW9uQ29kZVBheWxvYWQgfSBmcm9tIFwiLi9BdXRob3JpemF0aW9uQ29kZVBheWxvYWQuanNcIjtcbmltcG9ydCB7IEJhc2VBdXRoUmVxdWVzdCB9IGZyb20gXCIuLi9yZXF1ZXN0L0Jhc2VBdXRoUmVxdWVzdC5qc1wiO1xuaW1wb3J0IHsgSVBlcmZvcm1hbmNlQ2xpZW50IH0gZnJvbSBcIi4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9JUGVyZm9ybWFuY2VDbGllbnQuanNcIjtcbmltcG9ydCB7IFBlcmZvcm1hbmNlRXZlbnRzIH0gZnJvbSBcIi4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9QZXJmb3JtYW5jZUV2ZW50LmpzXCI7XG5pbXBvcnQgeyBjaGVja01heEFnZSwgZXh0cmFjdFRva2VuQ2xhaW1zIH0gZnJvbSBcIi4uL2FjY291bnQvQXV0aFRva2VuLmpzXCI7XG5pbXBvcnQge1xuICAgIFRva2VuQ2xhaW1zLFxuICAgIGdldFRlbmFudElkRnJvbUlkVG9rZW5DbGFpbXMsXG59IGZyb20gXCIuLi9hY2NvdW50L1Rva2VuQ2xhaW1zLmpzXCI7XG5pbXBvcnQge1xuICAgIEFjY291bnRJbmZvLFxuICAgIGJ1aWxkVGVuYW50UHJvZmlsZSxcbiAgICB1cGRhdGVBY2NvdW50VGVuYW50UHJvZmlsZURhdGEsXG59IGZyb20gXCIuLi9hY2NvdW50L0FjY291bnRJbmZvLmpzXCI7XG5pbXBvcnQgKiBhcyBDYWNoZUhlbHBlcnMgZnJvbSBcIi4uL2NhY2hlL3V0aWxzL0NhY2hlSGVscGVycy5qc1wiO1xuaW1wb3J0ICogYXMgVGltZVV0aWxzIGZyb20gXCIuLi91dGlscy9UaW1lVXRpbHMuanNcIjtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IGhhbmRsZXMgcmVzcG9uc2UgcGFyc2luZy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgUmVzcG9uc2VIYW5kbGVyIHtcbiAgICBwcml2YXRlIGNsaWVudElkOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjYWNoZVN0b3JhZ2U6IENhY2hlTWFuYWdlcjtcbiAgICBwcml2YXRlIGNyeXB0b09iajogSUNyeXB0bztcbiAgICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyO1xuICAgIHByaXZhdGUgaG9tZUFjY291bnRJZGVudGlmaWVyOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBzZXJpYWxpemFibGVDYWNoZTogSVNlcmlhbGl6YWJsZVRva2VuQ2FjaGUgfCBudWxsO1xuICAgIHByaXZhdGUgcGVyc2lzdGVuY2VQbHVnaW46IElDYWNoZVBsdWdpbiB8IG51bGw7XG4gICAgcHJpdmF0ZSBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgICAgICBjYWNoZVN0b3JhZ2U6IENhY2hlTWFuYWdlcixcbiAgICAgICAgY3J5cHRvT2JqOiBJQ3J5cHRvLFxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICAgICAgc2VyaWFsaXphYmxlQ2FjaGU6IElTZXJpYWxpemFibGVUb2tlbkNhY2hlIHwgbnVsbCxcbiAgICAgICAgcGVyc2lzdGVuY2VQbHVnaW46IElDYWNoZVBsdWdpbiB8IG51bGwsXG4gICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50PzogSVBlcmZvcm1hbmNlQ2xpZW50XG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5jYWNoZVN0b3JhZ2UgPSBjYWNoZVN0b3JhZ2U7XG4gICAgICAgIHRoaXMuY3J5cHRvT2JqID0gY3J5cHRvT2JqO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5zZXJpYWxpemFibGVDYWNoZSA9IHNlcmlhbGl6YWJsZUNhY2hlO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlUGx1Z2luID0gcGVyc2lzdGVuY2VQbHVnaW47XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQgPSBwZXJmb3JtYW5jZUNsaWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCB2YWxpZGF0ZXMgc2VydmVyIGF1dGhvcml6YXRpb24gdG9rZW4gcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHNlcnZlclJlc3BvbnNlXG4gICAgICogQHBhcmFtIHJlZnJlc2hBY2Nlc3NUb2tlblxuICAgICAqL1xuICAgIHZhbGlkYXRlVG9rZW5SZXNwb25zZShcbiAgICAgICAgc2VydmVyUmVzcG9uc2U6IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlLFxuICAgICAgICByZWZyZXNoQWNjZXNzVG9rZW4/OiBib29sZWFuXG4gICAgKTogdm9pZCB7XG4gICAgICAgIC8vIENoZWNrIGZvciBlcnJvclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5lcnJvciB8fFxuICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuZXJyb3JfZGVzY3JpcHRpb24gfHxcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgZXJyU3RyaW5nID0gYEVycm9yKHMpOiAke1xuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yX2NvZGVzIHx8IENvbnN0YW50cy5OT1RfQVZBSUxBQkxFXG4gICAgICAgICAgICB9IC0gVGltZXN0YW1wOiAke1xuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnRpbWVzdGFtcCB8fCBDb25zdGFudHMuTk9UX0FWQUlMQUJMRVxuICAgICAgICAgICAgfSAtIERlc2NyaXB0aW9uOiAke1xuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uIHx8IENvbnN0YW50cy5OT1RfQVZBSUxBQkxFXG4gICAgICAgICAgICB9IC0gQ29ycmVsYXRpb24gSUQ6ICR7XG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuY29ycmVsYXRpb25faWQgfHwgQ29uc3RhbnRzLk5PVF9BVkFJTEFCTEVcbiAgICAgICAgICAgIH0gLSBUcmFjZSBJRDogJHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS50cmFjZV9pZCB8fCBDb25zdGFudHMuTk9UX0FWQUlMQUJMRVxuICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJFcnJvck5vID0gc2VydmVyUmVzcG9uc2UuZXJyb3JfY29kZXM/Lmxlbmd0aFxuICAgICAgICAgICAgICAgID8gc2VydmVyUmVzcG9uc2UuZXJyb3JfY29kZXNbMF1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckVycm9yID0gbmV3IFNlcnZlckVycm9yKFxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yLFxuICAgICAgICAgICAgICAgIGVyclN0cmluZyxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5zdWJlcnJvcixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvck5vLFxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgNTAwIGVycm9yXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcmVmcmVzaEFjY2Vzc1Rva2VuICYmXG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3RhdHVzID49IEh0dHBTdGF0dXMuU0VSVkVSX0VSUk9SX1JBTkdFX1NUQVJUICYmXG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3RhdHVzIDw9IEh0dHBTdGF0dXMuU0VSVkVSX0VSUk9SX1JBTkdFX0VORFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhcbiAgICAgICAgICAgICAgICAgICAgYGV4ZWN1dGVUb2tlblJlcXVlc3Q6dmFsaWRhdGVUb2tlblJlc3BvbnNlIC0gQUFEIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZSBhbmQgdGhlIGFjY2VzcyB0b2tlbiBpcyB1bmFibGUgdG8gYmUgcmVmcmVzaGVkLlxcbiR7c2VydmVyRXJyb3J9YFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCB0aHJvdyBhbiBleGNlcHRpb24sIGJ1dCBhbGVydCB0aGUgdXNlciB2aWEgYSBsb2cgdGhhdCB0aGUgdG9rZW4gd2FzIHVuYWJsZSB0byBiZSByZWZyZXNoZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgNDAwIGVycm9yXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHJlZnJlc2hBY2Nlc3NUb2tlbiAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN0YXR1cyA+PSBIdHRwU3RhdHVzLkNMSUVOVF9FUlJPUl9SQU5HRV9TVEFSVCAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN0YXR1cyA8PSBIdHRwU3RhdHVzLkNMSUVOVF9FUlJPUl9SQU5HRV9FTkRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm5pbmcoXG4gICAgICAgICAgICAgICAgICAgIGBleGVjdXRlVG9rZW5SZXF1ZXN0OnZhbGlkYXRlVG9rZW5SZXNwb25zZSAtIEFBRCBpcyBjdXJyZW50bHkgYXZhaWxhYmxlIGJ1dCBpcyB1bmFibGUgdG8gcmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuLlxcbiR7c2VydmVyRXJyb3J9YFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCB0aHJvdyBhbiBleGNlcHRpb24sIGJ1dCBhbGVydCB0aGUgdXNlciB2aWEgYSBsb2cgdGhhdCB0aGUgdG9rZW4gd2FzIHVuYWJsZSB0byBiZSByZWZyZXNoZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc0ludGVyYWN0aW9uUmVxdWlyZWRFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5zdWJlcnJvclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuZXJyb3JfZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS50aW1lc3RhbXAgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UudHJhY2VfaWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuY29ycmVsYXRpb25faWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuY2xhaW1zIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yTm9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBzZXJ2ZXJFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb25zdHJ1Y3RlZCB0b2tlbiByZXNwb25zZSBiYXNlZCBvbiBnaXZlbiBzdHJpbmcuIEFsc28gbWFuYWdlcyB0aGUgY2FjaGUgdXBkYXRlcyBhbmQgY2xlYW51cHMuXG4gICAgICogQHBhcmFtIHNlcnZlclRva2VuUmVzcG9uc2VcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5XG4gICAgICovXG4gICAgYXN5bmMgaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZShcbiAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZTogU2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2UsXG4gICAgICAgIGF1dGhvcml0eTogQXV0aG9yaXR5LFxuICAgICAgICByZXFUaW1lc3RhbXA6IG51bWJlcixcbiAgICAgICAgcmVxdWVzdDogQmFzZUF1dGhSZXF1ZXN0LFxuICAgICAgICBhdXRoQ29kZVBheWxvYWQ/OiBBdXRob3JpemF0aW9uQ29kZVBheWxvYWQsXG4gICAgICAgIHVzZXJBc3NlcnRpb25IYXNoPzogc3RyaW5nLFxuICAgICAgICBoYW5kbGluZ1JlZnJlc2hUb2tlblJlc3BvbnNlPzogYm9vbGVhbixcbiAgICAgICAgZm9yY2VDYWNoZVJlZnJlc2hUb2tlblJlc3BvbnNlPzogYm9vbGVhbixcbiAgICAgICAgc2VydmVyUmVxdWVzdElkPzogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxBdXRoZW50aWNhdGlvblJlc3VsdD4ge1xuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZSxcbiAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2UuY29ycmVsYXRpb25faWRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gaWRUb2tlbiBvYmplY3QgKG5vdCBlbnRpdHkpXG4gICAgICAgIGxldCBpZFRva2VuQ2xhaW1zOiBUb2tlbkNsYWltcyB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNlcnZlclRva2VuUmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMgPSBleHRyYWN0VG9rZW5DbGFpbXMoXG4gICAgICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5pZF90b2tlbiB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICAgICAgICAgIHRoaXMuY3J5cHRvT2JqLmJhc2U2NERlY29kZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gdG9rZW4gbm9uY2UgY2hlY2sgKFRPRE86IEFkZCBhIHdhcm5pbmcgaWYgbm8gbm9uY2UgaXMgZ2l2ZW4/KVxuICAgICAgICAgICAgaWYgKGF1dGhDb2RlUGF5bG9hZCAmJiBhdXRoQ29kZVBheWxvYWQubm9uY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWRUb2tlbkNsYWltcy5ub25jZSAhPT0gYXV0aENvZGVQYXlsb2FkLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLm5vbmNlTWlzbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRva2VuIG1heF9hZ2UgY2hlY2tcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1heEFnZSB8fCByZXF1ZXN0Lm1heEFnZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhUaW1lID0gaWRUb2tlbkNsYWltcy5hdXRoX3RpbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFhdXRoVGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5hdXRoVGltZU5vdEZvdW5kXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hlY2tNYXhBZ2UoYXV0aFRpbWUsIHJlcXVlc3QubWF4QWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdlbmVyYXRlIGhvbWVBY2NvdW50SWRcbiAgICAgICAgdGhpcy5ob21lQWNjb3VudElkZW50aWZpZXIgPSBBY2NvdW50RW50aXR5LmdlbmVyYXRlSG9tZUFjY291bnRJZChcbiAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2UuY2xpZW50X2luZm8gfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgIGF1dGhvcml0eS5hdXRob3JpdHlUeXBlLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLmNyeXB0b09iaixcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXNcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzYXZlIHRoZSByZXNwb25zZSB0b2tlbnNcbiAgICAgICAgbGV0IHJlcXVlc3RTdGF0ZU9iajogUmVxdWVzdFN0YXRlT2JqZWN0IHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoISFhdXRoQ29kZVBheWxvYWQgJiYgISFhdXRoQ29kZVBheWxvYWQuc3RhdGUpIHtcbiAgICAgICAgICAgIHJlcXVlc3RTdGF0ZU9iaiA9IFByb3RvY29sVXRpbHMucGFyc2VSZXF1ZXN0U3RhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5jcnlwdG9PYmosXG4gICAgICAgICAgICAgICAgYXV0aENvZGVQYXlsb2FkLnN0YXRlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGtleUlkIGZyb20gcmVxdWVzdCB0byBzZXJ2ZXJUb2tlblJlc3BvbnNlIGlmIGRlZmluZWRcbiAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5rZXlfaWQgPVxuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5rZXlfaWQgfHwgcmVxdWVzdC5zc2hLaWQgfHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlUmVjb3JkID0gdGhpcy5nZW5lcmF0ZUNhY2hlUmVjb3JkKFxuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZSxcbiAgICAgICAgICAgIGF1dGhvcml0eSxcbiAgICAgICAgICAgIHJlcVRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zLFxuICAgICAgICAgICAgdXNlckFzc2VydGlvbkhhc2gsXG4gICAgICAgICAgICBhdXRoQ29kZVBheWxvYWRcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGNhY2hlQ29udGV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlUGx1Z2luICYmIHRoaXMuc2VyaWFsaXphYmxlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcIlBlcnNpc3RlbmNlIGVuYWJsZWQsIGNhbGxpbmcgYmVmb3JlQ2FjaGVBY2Nlc3NcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY2FjaGVDb250ZXh0ID0gbmV3IFRva2VuQ2FjaGVDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6YWJsZUNhY2hlLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlUGx1Z2luLmJlZm9yZUNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogV2hlbiBzYXZpbmcgYSByZWZyZXNoZWQgdG9rZW5zIHRvIHRoZSBjYWNoZSwgaXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgYWNjb3VudCB0aGF0IHdhcyB1c2VkIGlzIHByZXNlbnQgaW4gdGhlIGNhY2hlLlxuICAgICAgICAgICAgICogSWYgbm90IHByZXNlbnQsIHdlIHNob3VsZCByZXR1cm4gbnVsbCwgYXMgaXQncyB0aGUgY2FzZSB0aGF0IGFub3RoZXIgYXBwbGljYXRpb24gY2FsbGVkIHJlbW92ZUFjY291bnQgaW4gYmV0d2VlblxuICAgICAgICAgICAgICogdGhlIGNhbGxzIHRvIGdldEFsbEFjY291bnRzIGFuZCBhY3F1aXJlVG9rZW5TaWxlbnQuIFdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIHRoYXQgcmVtb3ZhbCwgdW5sZXNzIGV4cGxpY2l0bHkgZmxhZ2dlZCBieVxuICAgICAgICAgICAgICogdGhlIGRldmVsb3BlciwgYXMgaW4gdGhlIGNhc2Ugb2YgcmVmcmVzaCB0b2tlbiBmbG93IHVzZWQgaW4gQURBTCBOb2RlIHRvIE1TQUwgTm9kZSBtaWdyYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYW5kbGluZ1JlZnJlc2hUb2tlblJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgIWZvcmNlQ2FjaGVSZWZyZXNoVG9rZW5SZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgIGNhY2hlUmVjb3JkLmFjY291bnRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNhY2hlUmVjb3JkLmFjY291bnQuZ2VuZXJhdGVBY2NvdW50S2V5KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IHRoaXMuY2FjaGVTdG9yYWdlLmdldEFjY291bnQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQWNjb3VudCB1c2VkIHRvIHJlZnJlc2ggdG9rZW5zIG5vdCBpbiBwZXJzaXN0ZW5jZSwgcmVmcmVzaGVkIHRva2VucyB3aWxsIG5vdCBiZSBzdG9yZWQgaW4gdGhlIGNhY2hlXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFJlc3BvbnNlSGFuZGxlci5nZW5lcmF0ZUF1dGhlbnRpY2F0aW9uUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcnlwdG9PYmosXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0U3RhdGVPYmosXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXF1ZXN0SWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhY2hlU3RvcmFnZS5zYXZlQ2FjaGVSZWNvcmQoXG4gICAgICAgICAgICAgICAgY2FjaGVSZWNvcmQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3RvcmVJbkNhY2hlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VQbHVnaW4gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6YWJsZUNhY2hlICYmXG4gICAgICAgICAgICAgICAgY2FjaGVDb250ZXh0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcIlBlcnNpc3RlbmNlIGVuYWJsZWQsIGNhbGxpbmcgYWZ0ZXJDYWNoZUFjY2Vzc1wiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlUGx1Z2luLmFmdGVyQ2FjaGVBY2Nlc3MoY2FjaGVDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZXNwb25zZUhhbmRsZXIuZ2VuZXJhdGVBdXRoZW50aWNhdGlvblJlc3VsdChcbiAgICAgICAgICAgIHRoaXMuY3J5cHRvT2JqLFxuICAgICAgICAgICAgYXV0aG9yaXR5LFxuICAgICAgICAgICAgY2FjaGVSZWNvcmQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zLFxuICAgICAgICAgICAgcmVxdWVzdFN0YXRlT2JqLFxuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZSxcbiAgICAgICAgICAgIHNlcnZlclJlcXVlc3RJZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBDYWNoZVJlY29yZFxuICAgICAqIEBwYXJhbSBzZXJ2ZXJUb2tlblJlc3BvbnNlXG4gICAgICogQHBhcmFtIGlkVG9rZW5PYmpcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUNhY2hlUmVjb3JkKFxuICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlOiBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZSxcbiAgICAgICAgYXV0aG9yaXR5OiBBdXRob3JpdHksXG4gICAgICAgIHJlcVRpbWVzdGFtcDogbnVtYmVyLFxuICAgICAgICByZXF1ZXN0OiBCYXNlQXV0aFJlcXVlc3QsXG4gICAgICAgIGlkVG9rZW5DbGFpbXM/OiBUb2tlbkNsYWltcyxcbiAgICAgICAgdXNlckFzc2VydGlvbkhhc2g/OiBzdHJpbmcsXG4gICAgICAgIGF1dGhDb2RlUGF5bG9hZD86IEF1dGhvcml6YXRpb25Db2RlUGF5bG9hZFxuICAgICk6IENhY2hlUmVjb3JkIHtcbiAgICAgICAgY29uc3QgZW52ID0gYXV0aG9yaXR5LmdldFByZWZlcnJlZENhY2hlKCk7XG4gICAgICAgIGlmICghZW52KSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuaW52YWxpZENhY2hlRW52aXJvbm1lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGFpbXNUZW5hbnRJZCA9IGdldFRlbmFudElkRnJvbUlkVG9rZW5DbGFpbXMoaWRUb2tlbkNsYWltcyk7XG5cbiAgICAgICAgLy8gSWRUb2tlbjogbm9uIEFBRCBzY2VuYXJpb3MgY2FuIGhhdmUgZW1wdHkgcmVhbG1cbiAgICAgICAgbGV0IGNhY2hlZElkVG9rZW46IElkVG9rZW5FbnRpdHkgfCB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjYWNoZWRBY2NvdW50OiBBY2NvdW50RW50aXR5IHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc2VydmVyVG9rZW5SZXNwb25zZS5pZF90b2tlbiAmJiAhIWlkVG9rZW5DbGFpbXMpIHtcbiAgICAgICAgICAgIGNhY2hlZElkVG9rZW4gPSBDYWNoZUhlbHBlcnMuY3JlYXRlSWRUb2tlbkVudGl0eShcbiAgICAgICAgICAgICAgICB0aGlzLmhvbWVBY2NvdW50SWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5pZF90b2tlbixcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIGNsYWltc1RlbmFudElkIHx8IFwiXCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNhY2hlZEFjY291bnQgPSBidWlsZEFjY291bnRUb0NhY2hlKFxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTdG9yYWdlLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICB0aGlzLmhvbWVBY2NvdW50SWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b09iai5iYXNlNjREZWNvZGUsXG4gICAgICAgICAgICAgICAgaWRUb2tlbkNsYWltcyxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlLmNsaWVudF9pbmZvLFxuICAgICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgICBjbGFpbXNUZW5hbnRJZCxcbiAgICAgICAgICAgICAgICBhdXRoQ29kZVBheWxvYWQsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCAvLyBuYXRpdmVBY2NvdW50SWRcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjY2Vzc1Rva2VuXG4gICAgICAgIGxldCBjYWNoZWRBY2Nlc3NUb2tlbjogQWNjZXNzVG9rZW5FbnRpdHkgfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKHNlcnZlclRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBJZiBzY29wZXMgbm90IHJldHVybmVkIGluIHNlcnZlciByZXNwb25zZSwgdXNlIHJlcXVlc3Qgc2NvcGVzXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVNjb3BlcyA9IHNlcnZlclRva2VuUmVzcG9uc2Uuc2NvcGVcbiAgICAgICAgICAgICAgICA/IFNjb3BlU2V0LmZyb21TdHJpbmcoc2VydmVyVG9rZW5SZXNwb25zZS5zY29wZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBTY29wZVNldChyZXF1ZXN0LnNjb3BlcyB8fCBbXSk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBVc2UgdGltZXN0YW1wIGNhbGN1bGF0ZWQgYmVmb3JlIHJlcXVlc3RcbiAgICAgICAgICAgICAqIFNlcnZlciBtYXkgcmV0dXJuIHRpbWVzdGFtcHMgYXMgc3RyaW5ncywgcGFyc2UgdG8gbnVtYmVycyBpZiBzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luOiBudW1iZXIgPVxuICAgICAgICAgICAgICAgICh0eXBlb2Ygc2VydmVyVG9rZW5SZXNwb25zZS5leHBpcmVzX2luID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoc2VydmVyVG9rZW5SZXNwb25zZS5leHBpcmVzX2luLCAxMClcbiAgICAgICAgICAgICAgICAgICAgOiBzZXJ2ZXJUb2tlblJlc3BvbnNlLmV4cGlyZXNfaW4pIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBleHRFeHBpcmVzSW46IG51bWJlciA9XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBzZXJ2ZXJUb2tlblJlc3BvbnNlLmV4dF9leHBpcmVzX2luID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoc2VydmVyVG9rZW5SZXNwb25zZS5leHRfZXhwaXJlc19pbiwgMTApXG4gICAgICAgICAgICAgICAgICAgIDogc2VydmVyVG9rZW5SZXNwb25zZS5leHRfZXhwaXJlc19pbikgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hJbjogbnVtYmVyIHwgdW5kZWZpbmVkID1cbiAgICAgICAgICAgICAgICAodHlwZW9mIHNlcnZlclRva2VuUmVzcG9uc2UucmVmcmVzaF9pbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSW50KHNlcnZlclRva2VuUmVzcG9uc2UucmVmcmVzaF9pbiwgMTApXG4gICAgICAgICAgICAgICAgICAgIDogc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX2luKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkV4cGlyYXRpb25TZWNvbmRzID0gcmVxVGltZXN0YW1wICsgZXhwaXJlc0luO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWRUb2tlbkV4cGlyYXRpb25TZWNvbmRzID1cbiAgICAgICAgICAgICAgICB0b2tlbkV4cGlyYXRpb25TZWNvbmRzICsgZXh0RXhwaXJlc0luO1xuICAgICAgICAgICAgY29uc3QgcmVmcmVzaE9uU2Vjb25kcyA9XG4gICAgICAgICAgICAgICAgcmVmcmVzaEluICYmIHJlZnJlc2hJbiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyByZXFUaW1lc3RhbXAgKyByZWZyZXNoSW5cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIG5vbiBBQUQgc2NlbmFyaW9zIGNhbiBoYXZlIGVtcHR5IHJlYWxtXG4gICAgICAgICAgICBjYWNoZWRBY2Nlc3NUb2tlbiA9IENhY2hlSGVscGVycy5jcmVhdGVBY2Nlc3NUb2tlbkVudGl0eShcbiAgICAgICAgICAgICAgICB0aGlzLmhvbWVBY2NvdW50SWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICBjbGFpbXNUZW5hbnRJZCB8fCBhdXRob3JpdHkudGVuYW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VTY29wZXMucHJpbnRTY29wZXMoKSxcbiAgICAgICAgICAgICAgICB0b2tlbkV4cGlyYXRpb25TZWNvbmRzLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkVG9rZW5FeHBpcmF0aW9uU2Vjb25kcyxcbiAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b09iai5iYXNlNjREZWNvZGUsXG4gICAgICAgICAgICAgICAgcmVmcmVzaE9uU2Vjb25kcyxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlLnRva2VuX3R5cGUsXG4gICAgICAgICAgICAgICAgdXNlckFzc2VydGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5rZXlfaWQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jbGFpbXMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXF1ZXN0ZWRDbGFpbXNIYXNoXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVmcmVzaFRva2VuXG4gICAgICAgIGxldCBjYWNoZWRSZWZyZXNoVG9rZW46IFJlZnJlc2hUb2tlbkVudGl0eSB8IG51bGwgPSBudWxsO1xuICAgICAgICBpZiAoc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICBsZXQgcnRFeHBpcmVzT246IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJUb2tlblJlc3BvbnNlLnJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ0RXhwaXJlc0luOiBudW1iZXIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4gPT09XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlLnJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW47XG4gICAgICAgICAgICAgICAgcnRFeHBpcmVzT24gPSByZXFUaW1lc3RhbXAgKyBydEV4cGlyZXNJbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlZFJlZnJlc2hUb2tlbiA9IENhY2hlSGVscGVycy5jcmVhdGVSZWZyZXNoVG9rZW5FbnRpdHkoXG4gICAgICAgICAgICAgICAgdGhpcy5ob21lQWNjb3VudElkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2UucmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2UuZm9jaSxcbiAgICAgICAgICAgICAgICB1c2VyQXNzZXJ0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICBydEV4cGlyZXNPblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcE1ldGFkYXRhXG4gICAgICAgIGxldCBjYWNoZWRBcHBNZXRhZGF0YTogQXBwTWV0YWRhdGFFbnRpdHkgfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKHNlcnZlclRva2VuUmVzcG9uc2UuZm9jaSkge1xuICAgICAgICAgICAgY2FjaGVkQXBwTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGVudixcbiAgICAgICAgICAgICAgICBmYW1pbHlJZDogc2VydmVyVG9rZW5SZXNwb25zZS5mb2NpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50OiBjYWNoZWRBY2NvdW50LFxuICAgICAgICAgICAgaWRUb2tlbjogY2FjaGVkSWRUb2tlbixcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBjYWNoZWRBY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbjogY2FjaGVkUmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgYXBwTWV0YWRhdGE6IGNhY2hlZEFwcE1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQEF1dGhlbnRpY2F0aW9uUmVzdWx0IGZyb20gQENhY2hlUmVjb3JkICwgQElkVG9rZW4gLCBhbmQgYSBib29sZWFuIHRoYXQgc3RhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSByZXN1bHQgaXMgZnJvbSBjYWNoZS5cbiAgICAgKlxuICAgICAqIE9wdGlvbmFsbHkgdGFrZXMgYSBzdGF0ZSBzdHJpbmcgdGhhdCBpcyBzZXQgYXMtaXMgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhY2hlUmVjb3JkXG4gICAgICogQHBhcmFtIGlkVG9rZW5PYmpcbiAgICAgKiBAcGFyYW0gZnJvbVRva2VuQ2FjaGVcbiAgICAgKiBAcGFyYW0gc3RhdGVTdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVBdXRoZW50aWNhdGlvblJlc3VsdChcbiAgICAgICAgY3J5cHRvT2JqOiBJQ3J5cHRvLFxuICAgICAgICBhdXRob3JpdHk6IEF1dGhvcml0eSxcbiAgICAgICAgY2FjaGVSZWNvcmQ6IENhY2hlUmVjb3JkLFxuICAgICAgICBmcm9tVG9rZW5DYWNoZTogYm9vbGVhbixcbiAgICAgICAgcmVxdWVzdDogQmFzZUF1dGhSZXF1ZXN0LFxuICAgICAgICBpZFRva2VuQ2xhaW1zPzogVG9rZW5DbGFpbXMsXG4gICAgICAgIHJlcXVlc3RTdGF0ZT86IFJlcXVlc3RTdGF0ZU9iamVjdCxcbiAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZT86IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlLFxuICAgICAgICByZXF1ZXN0SWQ/OiBzdHJpbmdcbiAgICApOiBQcm9taXNlPEF1dGhlbnRpY2F0aW9uUmVzdWx0PiB7XG4gICAgICAgIGxldCBhY2Nlc3NUb2tlbjogc3RyaW5nID0gQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgbGV0IHJlc3BvbnNlU2NvcGVzOiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGxldCBleHBpcmVzT246IERhdGUgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGV4dEV4cGlyZXNPbjogRGF0ZSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlZnJlc2hPbjogRGF0ZSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGZhbWlseUlkOiBzdHJpbmcgPSBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuXG4gICAgICAgIGlmIChjYWNoZVJlY29yZC5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGlmIHRoZSByZXF1ZXN0IG9iamVjdCBoYXMgYHBvcEtpZGAgcHJvcGVydHksIGBzaWduUG9wVG9rZW5gIHdpbGwgYmUgc2V0IHRvIGZhbHNlIGFuZFxuICAgICAgICAgICAgICogdGhlIHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgdW5zaWduZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLnRva2VuVHlwZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgQXV0aGVudGljYXRpb25TY2hlbWUuUE9QICYmXG4gICAgICAgICAgICAgICAgIXJlcXVlc3QucG9wS2lkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3BUb2tlbkdlbmVyYXRvcjogUG9wVG9rZW5HZW5lcmF0b3IgPVxuICAgICAgICAgICAgICAgICAgICBuZXcgUG9wVG9rZW5HZW5lcmF0b3IoY3J5cHRvT2JqKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlY3JldCwga2V5SWQgfSA9IGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFrZXlJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5rZXlJZE1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IGF3YWl0IHBvcFRva2VuR2VuZXJhdG9yLnNpZ25Qb3BUb2tlbihcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICBrZXlJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gY2FjaGVSZWNvcmQuYWNjZXNzVG9rZW4uc2VjcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VTY29wZXMgPSBTY29wZVNldC5mcm9tU3RyaW5nKFxuICAgICAgICAgICAgICAgIGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLnRhcmdldFxuICAgICAgICAgICAgKS5hc0FycmF5KCk7XG4gICAgICAgICAgICAvLyBBY2Nlc3MgdG9rZW4gZXhwaXJlc09uIGNhY2hlZCBpbiBzZWNvbmRzLCBjb252ZXJ0aW5nIHRvIERhdGUgZm9yIEF1dGhlbnRpY2F0aW9uUmVzdWx0XG4gICAgICAgICAgICBleHBpcmVzT24gPSBUaW1lVXRpbHMudG9EYXRlRnJvbVNlY29uZHMoXG4gICAgICAgICAgICAgICAgY2FjaGVSZWNvcmQuYWNjZXNzVG9rZW4uZXhwaXJlc09uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXh0RXhwaXJlc09uID0gVGltZVV0aWxzLnRvRGF0ZUZyb21TZWNvbmRzKFxuICAgICAgICAgICAgICAgIGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLmV4dGVuZGVkRXhwaXJlc09uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLnJlZnJlc2hPbikge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hPbiA9IFRpbWVVdGlscy50b0RhdGVGcm9tU2Vjb25kcyhcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWNvcmQuYWNjZXNzVG9rZW4ucmVmcmVzaE9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWNoZVJlY29yZC5hcHBNZXRhZGF0YSkge1xuICAgICAgICAgICAgZmFtaWx5SWQgPVxuICAgICAgICAgICAgICAgIGNhY2hlUmVjb3JkLmFwcE1ldGFkYXRhLmZhbWlseUlkID09PSBUSEVfRkFNSUxZX0lEXG4gICAgICAgICAgICAgICAgICAgID8gVEhFX0ZBTUlMWV9JRFxuICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdWlkID0gaWRUb2tlbkNsYWltcz8ub2lkIHx8IGlkVG9rZW5DbGFpbXM/LnN1YiB8fCBcIlwiO1xuICAgICAgICBjb25zdCB0aWQgPSBpZFRva2VuQ2xhaW1zPy50aWQgfHwgXCJcIjtcblxuICAgICAgICAvLyBmb3IgaHlicmlkICsgbmF0aXZlIGJyaWRnZSBlbmFibGVtZW50LCBzZW5kIGJhY2sgdGhlIG5hdGl2ZSBhY2NvdW50IElkXG4gICAgICAgIGlmIChzZXJ2ZXJUb2tlblJlc3BvbnNlPy5zcGFfYWNjb3VudGlkICYmICEhY2FjaGVSZWNvcmQuYWNjb3VudCkge1xuICAgICAgICAgICAgY2FjaGVSZWNvcmQuYWNjb3VudC5uYXRpdmVBY2NvdW50SWQgPVxuICAgICAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2U/LnNwYV9hY2NvdW50aWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhY2NvdW50SW5mbzogQWNjb3VudEluZm8gfCBudWxsID0gY2FjaGVSZWNvcmQuYWNjb3VudFxuICAgICAgICAgICAgPyB1cGRhdGVBY2NvdW50VGVuYW50UHJvZmlsZURhdGEoXG4gICAgICAgICAgICAgICAgICBjYWNoZVJlY29yZC5hY2NvdW50LmdldEFjY291bnRJbmZvKCksXG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIC8vIHRlbmFudFByb2ZpbGUgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMsXG4gICAgICAgICAgICAgICAgICBjYWNoZVJlY29yZC5pZFRva2VuPy5zZWNyZXRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRob3JpdHk6IGF1dGhvcml0eS5jYW5vbmljYWxBdXRob3JpdHksXG4gICAgICAgICAgICB1bmlxdWVJZDogdWlkLFxuICAgICAgICAgICAgdGVuYW50SWQ6IHRpZCxcbiAgICAgICAgICAgIHNjb3BlczogcmVzcG9uc2VTY29wZXMsXG4gICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50SW5mbyxcbiAgICAgICAgICAgIGlkVG9rZW46IGNhY2hlUmVjb3JkPy5pZFRva2VuPy5zZWNyZXQgfHwgXCJcIixcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXM6IGlkVG9rZW5DbGFpbXMgfHwge30sXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBmcm9tQ2FjaGU6IGZyb21Ub2tlbkNhY2hlLFxuICAgICAgICAgICAgZXhwaXJlc09uOiBleHBpcmVzT24sXG4gICAgICAgICAgICBleHRFeHBpcmVzT246IGV4dEV4cGlyZXNPbixcbiAgICAgICAgICAgIHJlZnJlc2hPbjogcmVmcmVzaE9uLFxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgIGZhbWlseUlkOiBmYW1pbHlJZCxcbiAgICAgICAgICAgIHRva2VuVHlwZTpcbiAgICAgICAgICAgICAgICBjYWNoZVJlY29yZC5hY2Nlc3NUb2tlbj8udG9rZW5UeXBlIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgICAgICAgICBzdGF0ZTogcmVxdWVzdFN0YXRlXG4gICAgICAgICAgICAgICAgPyByZXF1ZXN0U3RhdGUudXNlclJlcXVlc3RTdGF0ZVxuICAgICAgICAgICAgICAgIDogQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgIGNsb3VkR3JhcGhIb3N0TmFtZTpcbiAgICAgICAgICAgICAgICBjYWNoZVJlY29yZC5hY2NvdW50Py5jbG91ZEdyYXBoSG9zdE5hbWUgfHxcbiAgICAgICAgICAgICAgICBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICAgICAgbXNHcmFwaEhvc3Q6XG4gICAgICAgICAgICAgICAgY2FjaGVSZWNvcmQuYWNjb3VudD8ubXNHcmFwaEhvc3QgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICAgICAgICAgIGNvZGU6IHNlcnZlclRva2VuUmVzcG9uc2U/LnNwYV9jb2RlLFxuICAgICAgICAgICAgZnJvbU5hdGl2ZUJyb2tlcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBY2NvdW50VG9DYWNoZShcbiAgICBjYWNoZVN0b3JhZ2U6IENhY2hlTWFuYWdlcixcbiAgICBhdXRob3JpdHk6IEF1dGhvcml0eSxcbiAgICBob21lQWNjb3VudElkOiBzdHJpbmcsXG4gICAgYmFzZTY0RGVjb2RlOiAoaW5wdXQ6IHN0cmluZykgPT4gc3RyaW5nLFxuICAgIGlkVG9rZW5DbGFpbXM/OiBUb2tlbkNsYWltcyxcbiAgICBjbGllbnRJbmZvPzogc3RyaW5nLFxuICAgIGVudmlyb25tZW50Pzogc3RyaW5nLFxuICAgIGNsYWltc1RlbmFudElkPzogc3RyaW5nIHwgbnVsbCxcbiAgICBhdXRoQ29kZVBheWxvYWQ/OiBBdXRob3JpemF0aW9uQ29kZVBheWxvYWQsXG4gICAgbmF0aXZlQWNjb3VudElkPzogc3RyaW5nLFxuICAgIGxvZ2dlcj86IExvZ2dlclxuKTogQWNjb3VudEVudGl0eSB7XG4gICAgbG9nZ2VyPy52ZXJib3NlKFwic2V0Q2FjaGVkQWNjb3VudCBjYWxsZWRcIik7XG5cbiAgICAvLyBDaGVjayBpZiBiYXNlIGFjY291bnQgaXMgYWxyZWFkeSBjYWNoZWRcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IGNhY2hlU3RvcmFnZS5nZXRBY2NvdW50S2V5cygpO1xuICAgIGNvbnN0IGJhc2VBY2NvdW50S2V5ID0gYWNjb3VudEtleXMuZmluZCgoYWNjb3VudEtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBhY2NvdW50S2V5LnN0YXJ0c1dpdGgoaG9tZUFjY291bnRJZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgY2FjaGVkQWNjb3VudDogQWNjb3VudEVudGl0eSB8IG51bGwgPSBudWxsO1xuICAgIGlmIChiYXNlQWNjb3VudEtleSkge1xuICAgICAgICBjYWNoZWRBY2NvdW50ID0gY2FjaGVTdG9yYWdlLmdldEFjY291bnQoYmFzZUFjY291bnRLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VBY2NvdW50ID1cbiAgICAgICAgY2FjaGVkQWNjb3VudCB8fFxuICAgICAgICBBY2NvdW50RW50aXR5LmNyZWF0ZUFjY291bnQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaG9tZUFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBpZFRva2VuQ2xhaW1zLFxuICAgICAgICAgICAgICAgIGNsaWVudEluZm8sXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgY2xvdWRHcmFwaEhvc3ROYW1lOiBhdXRoQ29kZVBheWxvYWQ/LmNsb3VkX2dyYXBoX2hvc3RfbmFtZSxcbiAgICAgICAgICAgICAgICBtc0dyYXBoSG9zdDogYXV0aENvZGVQYXlsb2FkPy5tc2dyYXBoX2hvc3QsXG4gICAgICAgICAgICAgICAgbmF0aXZlQWNjb3VudElkOiBuYXRpdmVBY2NvdW50SWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXV0aG9yaXR5LFxuICAgICAgICAgICAgYmFzZTY0RGVjb2RlXG4gICAgICAgICk7XG5cbiAgICBjb25zdCB0ZW5hbnRQcm9maWxlcyA9IGJhc2VBY2NvdW50LnRlbmFudFByb2ZpbGVzIHx8IFtdO1xuICAgIGNvbnN0IHRlbmFudElkID0gY2xhaW1zVGVuYW50SWQgfHwgYmFzZUFjY291bnQucmVhbG07XG4gICAgaWYgKFxuICAgICAgICB0ZW5hbnRJZCAmJlxuICAgICAgICAhdGVuYW50UHJvZmlsZXMuZmluZCgodGVuYW50UHJvZmlsZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRlbmFudFByb2ZpbGUudGVuYW50SWQgPT09IHRlbmFudElkO1xuICAgICAgICB9KVxuICAgICkge1xuICAgICAgICBjb25zdCBuZXdUZW5hbnRQcm9maWxlID0gYnVpbGRUZW5hbnRQcm9maWxlKFxuICAgICAgICAgICAgaG9tZUFjY291bnRJZCxcbiAgICAgICAgICAgIGJhc2VBY2NvdW50LmxvY2FsQWNjb3VudElkLFxuICAgICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zXG4gICAgICAgICk7XG4gICAgICAgIHRlbmFudFByb2ZpbGVzLnB1c2gobmV3VGVuYW50UHJvZmlsZSk7XG4gICAgfVxuICAgIGJhc2VBY2NvdW50LnRlbmFudFByb2ZpbGVzID0gdGVuYW50UHJvZmlsZXM7XG5cbiAgICByZXR1cm4gYmFzZUFjY291bnQ7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLFxuICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmpzXCI7XG5pbXBvcnQgeyBQcm9tcHRWYWx1ZSwgQ29kZUNoYWxsZW5nZU1ldGhvZFZhbHVlcyB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgc2VydmVyIGNvbnN1bWFibGUgcGFyYW1zIGZyb20gdGhlIFwicmVxdWVzdFwiIG9iamVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlcXVlc3RWYWxpZGF0b3Ige1xuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gY2hlY2sgaWYgdGhlIGByZWRpcmVjdFVyaWAgaW4gdGhlIHJlcXVlc3QgaXMgYSBub24tbnVsbCB2YWx1ZVxuICAgICAqIEBwYXJhbSByZWRpcmVjdFVyaVxuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZGF0ZVJlZGlyZWN0VXJpKHJlZGlyZWN0VXJpOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFyZWRpcmVjdFVyaSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnJlZGlyZWN0VXJpRW1wdHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIHZhbGlkYXRlIHByb21wdCBzZW50IGJ5IHRoZSB1c2VyIGluIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHByb21wdFxuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZGF0ZVByb21wdChwcm9tcHQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBwcm9tcHRWYWx1ZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIGluIFByb21wdFZhbHVlKSB7XG4gICAgICAgICAgICBwcm9tcHRWYWx1ZXMucHVzaChQcm9tcHRWYWx1ZVt2YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21wdFZhbHVlcy5pbmRleE9mKHByb21wdCkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZFByb21wdFZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHZhbGlkYXRlQ2xhaW1zKGNsYWltczogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBKU09OLnBhcnNlKGNsYWltcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ2xhaW1zXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byB2YWxpZGF0ZSBjb2RlX2NoYWxsZW5nZSBhbmQgY29kZV9jaGFsbGVuZ2VfbWV0aG9kXG4gICAgICogQHBhcmFtIGNvZGVDaGFsbGVuZ2VcbiAgICAgKiBAcGFyYW0gY29kZUNoYWxsZW5nZU1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZGF0ZUNvZGVDaGFsbGVuZ2VQYXJhbXMoXG4gICAgICAgIGNvZGVDaGFsbGVuZ2U6IHN0cmluZyxcbiAgICAgICAgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGlmICghY29kZUNoYWxsZW5nZSB8fCAhY29kZUNoYWxsZW5nZU1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnBrY2VQYXJhbXNNaXNzaW5nXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvZGVDaGFsbGVuZ2VNZXRob2QoY29kZUNoYWxsZW5nZU1ldGhvZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIHZhbGlkYXRlIGNvZGVfY2hhbGxlbmdlX21ldGhvZFxuICAgICAqIEBwYXJhbSBjb2RlQ2hhbGxlbmdlTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlQ29kZUNoYWxsZW5nZU1ldGhvZChjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIENvZGVDaGFsbGVuZ2VNZXRob2RWYWx1ZXMuUExBSU4sXG4gICAgICAgICAgICAgICAgQ29kZUNoYWxsZW5nZU1ldGhvZFZhbHVlcy5TMjU2LFxuICAgICAgICAgICAgXS5pbmRleE9mKGNvZGVDaGFsbGVuZ2VNZXRob2QpIDwgMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBDbGllbnRBc3NlcnRpb25DYWxsYmFjayxcbiAgICBDbGllbnRBc3NlcnRpb25Db25maWcsXG59IGZyb20gXCIuLi9hY2NvdW50L0NsaWVudENyZWRlbnRpYWxzLmpzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDbGllbnRBc3NlcnRpb24oXG4gICAgY2xpZW50QXNzZXJ0aW9uOiBzdHJpbmcgfCBDbGllbnRBc3NlcnRpb25DYWxsYmFjayxcbiAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgIHRva2VuRW5kcG9pbnQ/OiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKHR5cGVvZiBjbGllbnRBc3NlcnRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudEFzc2VydGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb25maWc6IENsaWVudEFzc2VydGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcbiAgICAgICAgICAgIHRva2VuRW5kcG9pbnQ6IHRva2VuRW5kcG9pbnQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb24oY29uZmlnKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEJhc2VDbGllbnQgfSBmcm9tIFwiLi9CYXNlQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBDb21tb25BdXRob3JpemF0aW9uQ29kZVJlcXVlc3QgfSBmcm9tIFwiLi4vcmVxdWVzdC9Db21tb25BdXRob3JpemF0aW9uQ29kZVJlcXVlc3QuanNcIjtcbmltcG9ydCB7IEF1dGhvcml0eSB9IGZyb20gXCIuLi9hdXRob3JpdHkvQXV0aG9yaXR5LmpzXCI7XG5pbXBvcnQgKiBhcyBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlciBmcm9tIFwiLi4vcmVxdWVzdC9SZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5qc1wiO1xuaW1wb3J0ICogYXMgVXJsVXRpbHMgZnJvbSBcIi4uL3V0aWxzL1VybFV0aWxzLmpzXCI7XG5pbXBvcnQge1xuICAgIEdyYW50VHlwZSxcbiAgICBBdXRoZW50aWNhdGlvblNjaGVtZSxcbiAgICBTZXBhcmF0b3JzLFxuICAgIEhlYWRlck5hbWVzLFxufSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgKiBhcyBBQURTZXJ2ZXJQYXJhbUtleXMgZnJvbSBcIi4uL2NvbnN0YW50cy9BQURTZXJ2ZXJQYXJhbUtleXMuanNcIjtcbmltcG9ydCB7XG4gICAgQ2xpZW50Q29uZmlndXJhdGlvbixcbiAgICBpc09pZGNQcm90b2NvbE1vZGUsXG59IGZyb20gXCIuLi9jb25maWcvQ2xpZW50Q29uZmlndXJhdGlvbi5qc1wiO1xuaW1wb3J0IHsgU2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2UgfSBmcm9tIFwiLi4vcmVzcG9uc2UvU2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2UuanNcIjtcbmltcG9ydCB7IE5ldHdvcmtSZXNwb25zZSB9IGZyb20gXCIuLi9uZXR3b3JrL05ldHdvcmtSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgUmVzcG9uc2VIYW5kbGVyIH0gZnJvbSBcIi4uL3Jlc3BvbnNlL1Jlc3BvbnNlSGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb25SZXN1bHQgfSBmcm9tIFwiLi4vcmVzcG9uc2UvQXV0aGVudGljYXRpb25SZXN1bHQuanNcIjtcbmltcG9ydCB7IFN0cmluZ1V0aWxzIH0gZnJvbSBcIi4uL3V0aWxzL1N0cmluZ1V0aWxzLmpzXCI7XG5pbXBvcnQge1xuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSBcIi4uL3VybC9VcmxTdHJpbmcuanNcIjtcbmltcG9ydCB7IENvbW1vbkVuZFNlc3Npb25SZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQ29tbW9uRW5kU2Vzc2lvblJlcXVlc3QuanNcIjtcbmltcG9ydCB7IFBvcFRva2VuR2VuZXJhdG9yIH0gZnJvbSBcIi4uL2NyeXB0by9Qb3BUb2tlbkdlbmVyYXRvci5qc1wiO1xuaW1wb3J0IHsgQXV0aG9yaXphdGlvbkNvZGVQYXlsb2FkIH0gZnJvbSBcIi4uL3Jlc3BvbnNlL0F1dGhvcml6YXRpb25Db2RlUGF5bG9hZC5qc1wiO1xuaW1wb3J0ICogYXMgVGltZVV0aWxzIGZyb20gXCIuLi91dGlscy9UaW1lVXRpbHMuanNcIjtcbmltcG9ydCB7XG4gICAgYnVpbGRDbGllbnRJbmZvRnJvbUhvbWVBY2NvdW50SWQsXG4gICAgYnVpbGRDbGllbnRJbmZvLFxufSBmcm9tIFwiLi4vYWNjb3VudC9DbGllbnRJbmZvLmpzXCI7XG5pbXBvcnQgeyBDY3NDcmVkZW50aWFsVHlwZSwgQ2NzQ3JlZGVudGlhbCB9IGZyb20gXCIuLi9hY2NvdW50L0Njc0NyZWRlbnRpYWwuanNcIjtcbmltcG9ydCB7XG4gICAgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLFxuICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmpzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0VmFsaWRhdG9yIH0gZnJvbSBcIi4uL3JlcXVlc3QvUmVxdWVzdFZhbGlkYXRvci5qc1wiO1xuaW1wb3J0IHsgSVBlcmZvcm1hbmNlQ2xpZW50IH0gZnJvbSBcIi4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9JUGVyZm9ybWFuY2VDbGllbnQuanNcIjtcbmltcG9ydCB7IFBlcmZvcm1hbmNlRXZlbnRzIH0gZnJvbSBcIi4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9QZXJmb3JtYW5jZUV2ZW50LmpzXCI7XG5pbXBvcnQgeyBpbnZva2VBc3luYyB9IGZyb20gXCIuLi91dGlscy9GdW5jdGlvbldyYXBwZXJzLmpzXCI7XG5pbXBvcnQgeyBDbGllbnRBc3NlcnRpb24gfSBmcm9tIFwiLi4vYWNjb3VudC9DbGllbnRDcmVkZW50aWFscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q2xpZW50QXNzZXJ0aW9uIH0gZnJvbSBcIi4uL3V0aWxzL0NsaWVudEFzc2VydGlvblV0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRSZXF1ZXN0VGh1bWJwcmludCB9IGZyb20gXCIuLi9uZXR3b3JrL1JlcXVlc3RUaHVtYnByaW50LmpzXCI7XG5cbi8qKlxuICogT2F1dGgyLjAgQXV0aG9yaXphdGlvbiBDb2RlIGNsaWVudFxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uQ29kZUNsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIC8vIEZsYWcgdG8gaW5kaWNhdGUgaWYgY2xpZW50IGlzIGZvciBoeWJyaWQgc3BhIGF1dGggY29kZSByZWRlbXB0aW9uXG4gICAgcHJvdGVjdGVkIGluY2x1ZGVSZWRpcmVjdFVyaTogYm9vbGVhbiA9IHRydWU7XG4gICAgcHJpdmF0ZSBvaWRjRGVmYXVsdFNjb3BlcztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjb25maWd1cmF0aW9uOiBDbGllbnRDb25maWd1cmF0aW9uLFxuICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudFxuICAgICkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uLCBwZXJmb3JtYW5jZUNsaWVudCk7XG4gICAgICAgIHRoaXMub2lkY0RlZmF1bHRTY29wZXMgPVxuICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuYXV0aG9yaXR5Lm9wdGlvbnMuT0lEQ09wdGlvbnM/LmRlZmF1bHRTY29wZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQVBJIHRvIGFjcXVpcmUgYSB0b2tlbiBpbiBleGNoYW5nZSBvZiAnYXV0aG9yaXphdGlvbl9jb2RlYCBhY3F1aXJlZCBieSB0aGUgdXNlciBpbiB0aGUgZmlyc3QgbGVnIG9mIHRoZVxuICAgICAqIGF1dGhvcml6YXRpb25fY29kZV9ncmFudFxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuKFxuICAgICAgICByZXF1ZXN0OiBDb21tb25BdXRob3JpemF0aW9uQ29kZVJlcXVlc3QsXG4gICAgICAgIGF1dGhDb2RlUGF5bG9hZD86IEF1dGhvcml6YXRpb25Db2RlUGF5bG9hZFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQ+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhDbGllbnRBY3F1aXJlVG9rZW4sXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlcXVlc3QuY29kZSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLnJlcXVlc3RDYW5ub3RCZU1hZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXFUaW1lc3RhbXAgPSBUaW1lVXRpbHMubm93U2Vjb25kcygpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgdGhpcy5leGVjdXRlVG9rZW5SZXF1ZXN0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRoQ2xpZW50RXhlY3V0ZVRva2VuUmVxdWVzdCxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApKHRoaXMuYXV0aG9yaXR5LCByZXF1ZXN0KTtcblxuICAgICAgICAvLyBSZXRyaWV2ZSByZXF1ZXN0SWQgZnJvbSByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlc3BvbnNlLmhlYWRlcnM/LltIZWFkZXJOYW1lcy5YX01TX1JFUVVFU1RfSURdO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IG5ldyBSZXNwb25zZUhhbmRsZXIoXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLFxuICAgICAgICAgICAgdGhpcy5jcnlwdG9VdGlscyxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuc2VyaWFsaXphYmxlQ2FjaGUsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5wZXJzaXN0ZW5jZVBsdWdpbixcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSByZXNwb25zZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3MgYSBzZXJ2ZXIgZXJyb3IgaWYgYW4gZXJyb3IgaXMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnZhbGlkYXRlVG9rZW5SZXNwb25zZShyZXNwb25zZS5ib2R5KTtcblxuICAgICAgICByZXR1cm4gaW52b2tlQXN5bmMoXG4gICAgICAgICAgICByZXNwb25zZUhhbmRsZXIuaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZS5iaW5kKHJlc3BvbnNlSGFuZGxlciksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5IYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICkoXG4gICAgICAgICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHksXG4gICAgICAgICAgICByZXFUaW1lc3RhbXAsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgYXV0aENvZGVQYXlsb2FkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBsb2cgb3V0IHRoZSBjdXJyZW50IHVzZXIsIGFuZCByZWRpcmVjdCB0aGUgdXNlciB0byB0aGUgcG9zdExvZ291dFJlZGlyZWN0VXJpLlxuICAgICAqIERlZmF1bHQgYmVoYXZpb3VyIGlzIHRvIHJlZGlyZWN0IHRoZSB1c2VyIHRvIGB3aW5kb3cubG9jYXRpb24uaHJlZmAuXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVVyaVxuICAgICAqL1xuICAgIGdldExvZ291dFVyaShsb2dvdXRSZXF1ZXN0OiBDb21tb25FbmRTZXNzaW9uUmVxdWVzdCk6IHN0cmluZyB7XG4gICAgICAgIC8vIFRocm93IGVycm9yIGlmIGxvZ291dFJlcXVlc3QgaXMgbnVsbC91bmRlZmluZWRcbiAgICAgICAgaWYgKCFsb2dvdXRSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubG9nb3V0UmVxdWVzdEVtcHR5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdGhpcy5jcmVhdGVMb2dvdXRVcmxRdWVyeVN0cmluZyhsb2dvdXRSZXF1ZXN0KTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgbG9nb3V0IFVSSVxuICAgICAgICByZXR1cm4gVXJsU3RyaW5nLmFwcGVuZFF1ZXJ5U3RyaW5nKFxuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkuZW5kU2Vzc2lvbkVuZHBvaW50LFxuICAgICAgICAgICAgcXVlcnlTdHJpbmdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBQT1NUIHJlcXVlc3QgdG8gdG9rZW4gZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5XG4gICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGV4ZWN1dGVUb2tlblJlcXVlc3QoXG4gICAgICAgIGF1dGhvcml0eTogQXV0aG9yaXR5LFxuICAgICAgICByZXF1ZXN0OiBDb21tb25BdXRob3JpemF0aW9uQ29kZVJlcXVlc3RcbiAgICApOiBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZT4+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhDbGllbnRFeGVjdXRlVG9rZW5SZXF1ZXN0LFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5jcmVhdGVUb2tlblF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBVcmxTdHJpbmcuYXBwZW5kUXVlcnlTdHJpbmcoXG4gICAgICAgICAgICBhdXRob3JpdHkudG9rZW5FbmRwb2ludCxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1N0cmluZ1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gYXdhaXQgaW52b2tlQXN5bmMoXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdEJvZHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhDbGllbnRDcmVhdGVUb2tlblJlcXVlc3RCb2R5LFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICkocmVxdWVzdCk7XG5cbiAgICAgICAgbGV0IGNjc0NyZWRlbnRpYWw6IENjc0NyZWRlbnRpYWwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXF1ZXN0LmNsaWVudEluZm8pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mbyhcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b1V0aWxzLmJhc2U2NERlY29kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY2NzQ3JlZGVudGlhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbDogYCR7Y2xpZW50SW5mby51aWR9JHtTZXBhcmF0b3JzLkNMSUVOVF9JTkZPX1NFUEFSQVRPUn0ke2NsaWVudEluZm8udXRpZH1gLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDY3NDcmVkZW50aWFsVHlwZS5IT01FX0FDQ09VTlRfSUQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcIkNvdWxkIG5vdCBwYXJzZSBjbGllbnQgaW5mbyBmb3IgQ0NTIEhlYWRlcjogXCIgKyBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gdGhpcy5jcmVhdGVUb2tlblJlcXVlc3RIZWFkZXJzKFxuICAgICAgICAgICAgY2NzQ3JlZGVudGlhbCB8fCByZXF1ZXN0LmNjc0NyZWRlbnRpYWxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB0aHVtYnByaW50ID0gZ2V0UmVxdWVzdFRodW1icHJpbnQoXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gaW52b2tlQXN5bmMoXG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpemF0aW9uQ29kZUNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50LFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICkoXG4gICAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHRodW1icHJpbnQsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpemF0aW9uQ29kZUNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbWFwIGZvciBhbGwgdGhlIHBhcmFtcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRva2VuUmVxdWVzdEJvZHkoXG4gICAgICAgIHJlcXVlc3Q6IENvbW1vbkF1dGhvcml6YXRpb25Db2RlUmVxdWVzdFxuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRoQ2xpZW50Q3JlYXRlVG9rZW5SZXF1ZXN0Qm9keSxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudElkKFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJlcXVlc3QuZW1iZWRkZWRDbGllbnRJZCB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3QudG9rZW5Cb2R5UGFyYW1ldGVycz8uW0FBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSURdIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWRcbiAgICAgICAgKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBGb3IgaHlicmlkIHNwYSBmbG93LCB0aGVyZSB3aWxsIGJlIGEgY29kZSBidXQgbm8gdmVyaWZpZXJcbiAgICAgICAgICogSW4gdGhpcyBzY2VuYXJpbywgZG9uJ3QgaW5jbHVkZSByZWRpcmVjdCB1cmkgYXMgYXV0aCBjb2RlIHdpbGwgbm90IGJlIGJvdW5kIHRvIHJlZGlyZWN0IFVSSVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVSZWRpcmVjdFVyaSkge1xuICAgICAgICAgICAgLy8gSnVzdCB2YWxpZGF0ZVxuICAgICAgICAgICAgUmVxdWVzdFZhbGlkYXRvci52YWxpZGF0ZVJlZGlyZWN0VXJpKHJlcXVlc3QucmVkaXJlY3RVcmkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgYW5kIGluY2x1ZGUgcmVkaXJlY3QgdXJpXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRSZWRpcmVjdFVyaShcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3RVcmlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgc2NvcGUgYXJyYXksIHBhcmFtZXRlciBidWlsZGVyIHdpbGwgYWRkIGRlZmF1bHQgc2NvcGVzIGFuZCBkZWR1cGVcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU2NvcGVzKFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJlcXVlc3Quc2NvcGVzLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHRoaXMub2lkY0RlZmF1bHRTY29wZXNcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgY29kZTogdXNlciBzZXQsIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQXV0aG9yaXphdGlvbkNvZGUocGFyYW1ldGVycywgcmVxdWVzdC5jb2RlKTtcblxuICAgICAgICAvLyBBZGQgbGlicmFyeSBtZXRhZGF0YVxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMaWJyYXJ5SW5mbyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5saWJyYXJ5SW5mb1xuICAgICAgICApO1xuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRBcHBsaWNhdGlvblRlbGVtZXRyeShcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy50ZWxlbWV0cnkuYXBwbGljYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyICYmICFpc09pZGNQcm90b2NvbE1vZGUodGhpcy5jb25maWcpKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgY29kZV92ZXJpZmllciBpZiBwYXNzZWRcbiAgICAgICAgaWYgKHJlcXVlc3QuY29kZVZlcmlmaWVyKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDb2RlVmVyaWZpZXIoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNvZGVWZXJpZmllclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXQpIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudFNlY3JldChcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudFNlY3JldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRBc3NlcnRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEFzc2VydGlvbjogQ2xpZW50QXNzZXJ0aW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRBc3NlcnRpb247XG5cbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEFzc2VydGlvbihcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGF3YWl0IGdldENsaWVudEFzc2VydGlvbihcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEFzc2VydGlvblR5cGUoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBjbGllbnRBc3NlcnRpb24uYXNzZXJ0aW9uVHlwZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEdyYW50VHlwZShcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICBHcmFudFR5cGUuQVVUSE9SSVpBVElPTl9DT0RFX0dSQU5UXG4gICAgICAgICk7XG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEluZm8ocGFyYW1ldGVycyk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgPT09IEF1dGhlbnRpY2F0aW9uU2NoZW1lLlBPUCkge1xuICAgICAgICAgICAgY29uc3QgcG9wVG9rZW5HZW5lcmF0b3IgPSBuZXcgUG9wVG9rZW5HZW5lcmF0b3IoXG4gICAgICAgICAgICAgICAgdGhpcy5jcnlwdG9VdGlscyxcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgcmVxQ25mRGF0YTtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdC5wb3BLaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRSZXFDbmZEYXRhID0gYXdhaXQgaW52b2tlQXN5bmMoXG4gICAgICAgICAgICAgICAgICAgIHBvcFRva2VuR2VuZXJhdG9yLmdlbmVyYXRlQ25mLmJpbmQocG9wVG9rZW5HZW5lcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5Qb3BUb2tlbkdlbmVyYXRlQ25mLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICAgICAgKShyZXF1ZXN0LCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICAgICAgcmVxQ25mRGF0YSA9IGdlbmVyYXRlZFJlcUNuZkRhdGEucmVxQ25mU3RyaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXFDbmZEYXRhID0gdGhpcy5jcnlwdG9VdGlscy5lbmNvZGVLaWQocmVxdWVzdC5wb3BLaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTUEEgUG9QIHJlcXVpcmVzIGZ1bGwgQmFzZTY0VXJsIGVuY29kZWQgcmVxX2NuZiBzdHJpbmcgKHVuaGFzaGVkKVxuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUG9wVG9rZW4ocGFyYW1ldGVycywgcmVxQ25mRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSA9PT0gQXV0aGVudGljYXRpb25TY2hlbWUuU1NIKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zc2hKd2spIHtcbiAgICAgICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTc2hKd2socGFyYW1ldGVycywgcmVxdWVzdC5zc2hKd2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1pc3NpbmdTc2hKd2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIVN0cmluZ1V0aWxzLmlzRW1wdHlPYmoocmVxdWVzdC5jbGFpbXMpIHx8XG4gICAgICAgICAgICAodGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xhaW1zKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jbGFpbXMsXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNjc0NyZWQ6IENjc0NyZWRlbnRpYWwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXF1ZXN0LmNsaWVudEluZm8pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mbyhcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b1V0aWxzLmJhc2U2NERlY29kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY2NzQ3JlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbDogYCR7Y2xpZW50SW5mby51aWR9JHtTZXBhcmF0b3JzLkNMSUVOVF9JTkZPX1NFUEFSQVRPUn0ke2NsaWVudEluZm8udXRpZH1gLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDY3NDcmVkZW50aWFsVHlwZS5IT01FX0FDQ09VTlRfSUQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcIkNvdWxkIG5vdCBwYXJzZSBjbGllbnQgaW5mbyBmb3IgQ0NTIEhlYWRlcjogXCIgKyBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNjc0NyZWQgPSByZXF1ZXN0LmNjc0NyZWRlbnRpYWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRzIHRoZXNlIGFzIHBhcmFtZXRlcnMgaW4gdGhlIHJlcXVlc3QgaW5zdGVhZCBvZiBoZWFkZXJzIHRvIHByZXZlbnQgQ09SUyBwcmVmbGlnaHQgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy5wcmV2ZW50Q29yc1ByZWZsaWdodCAmJiBjY3NDcmVkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNjc0NyZWQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ2NzQ3JlZGVudGlhbFR5cGUuSE9NRV9BQ0NPVU5UX0lEOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mb0Zyb21Ib21lQWNjb3VudElkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjc0NyZWQuY3JlZGVudGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc09pZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb3VsZCBub3QgcGFyc2UgaG9tZSBhY2NvdW50IElEIGZvciBDQ1MgSGVhZGVyOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDY3NDcmVkZW50aWFsVHlwZS5VUE46XG4gICAgICAgICAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc1VwbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjY3NDcmVkLmNyZWRlbnRpYWxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5lbWJlZGRlZENsaWVudElkKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRCcm9rZXJQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRFeHRyYVF1ZXJ5UGFyYW1ldGVycyhcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QudG9rZW5Cb2R5UGFyYW1ldGVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBoeWJyaWQgc3BhIHBhcmFtZXRlcnMgaWYgbm90IGFscmVhZHkgcHJvdmlkZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVxdWVzdC5lbmFibGVTcGFBdXRob3JpemF0aW9uQ29kZSAmJlxuICAgICAgICAgICAgKCFyZXF1ZXN0LnRva2VuQm9keVBhcmFtZXRlcnMgfHxcbiAgICAgICAgICAgICAgICAhcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzW1xuICAgICAgICAgICAgICAgICAgICBBQURTZXJ2ZXJQYXJhbUtleXMuUkVUVVJOX1NQQV9DT0RFXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRFeHRyYVF1ZXJ5UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICAgICAgW0FBRFNlcnZlclBhcmFtS2V5cy5SRVRVUk5fU1BBX0NPREVdOiBcIjFcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuaW5zdHJ1bWVudEJyb2tlclBhcmFtcyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgQVBJIHZhbGlkYXRlcyB0aGUgYEVuZFNlc3Npb25SZXF1ZXN0YCBhbmQgY3JlYXRlcyBhIFVSTFxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBjcmVhdGVMb2dvdXRVcmxRdWVyeVN0cmluZyhcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uRW5kU2Vzc2lvblJlcXVlc3RcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblxuICAgICAgICBpZiAocmVxdWVzdC5wb3N0TG9nb3V0UmVkaXJlY3RVcmkpIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFBvc3RMb2dvdXRSZWRpcmVjdFVyaShcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucG9zdExvZ291dFJlZGlyZWN0VXJpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuY29ycmVsYXRpb25JZCkge1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ29ycmVsYXRpb25JZChcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1ZXN0LmlkVG9rZW5IaW50KSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRJZFRva2VuSGludChcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuaWRUb2tlbkhpbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0ZSkge1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU3RhdGUocGFyYW1ldGVycywgcmVxdWVzdC5zdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5sb2dvdXRIaW50KSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMb2dvdXRIaW50KFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5sb2dvdXRIaW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuZXh0cmFRdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5leHRyYVF1ZXJ5UGFyYW1ldGVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5pbnN0YW5jZUF3YXJlKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRJbnN0YW5jZUF3YXJlKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFVybFV0aWxzLm1hcFRvUXVlcnlTdHJpbmcocGFyYW1ldGVycyk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIENsaWVudENvbmZpZ3VyYXRpb24sXG4gICAgaXNPaWRjUHJvdG9jb2xNb2RlLFxufSBmcm9tIFwiLi4vY29uZmlnL0NsaWVudENvbmZpZ3VyYXRpb24uanNcIjtcbmltcG9ydCB7IEJhc2VDbGllbnQgfSBmcm9tIFwiLi9CYXNlQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBDb21tb25SZWZyZXNoVG9rZW5SZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQ29tbW9uUmVmcmVzaFRva2VuUmVxdWVzdC5qc1wiO1xuaW1wb3J0IHsgQXV0aG9yaXR5IH0gZnJvbSBcIi4uL2F1dGhvcml0eS9BdXRob3JpdHkuanNcIjtcbmltcG9ydCB7IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlIH0gZnJvbSBcIi4uL3Jlc3BvbnNlL1NlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlLmpzXCI7XG5pbXBvcnQgKiBhcyBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlciBmcm9tIFwiLi4vcmVxdWVzdC9SZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5qc1wiO1xuaW1wb3J0ICogYXMgVXJsVXRpbHMgZnJvbSBcIi4uL3V0aWxzL1VybFV0aWxzLmpzXCI7XG5pbXBvcnQge1xuICAgIEdyYW50VHlwZSxcbiAgICBBdXRoZW50aWNhdGlvblNjaGVtZSxcbiAgICBFcnJvcnMsXG4gICAgSGVhZGVyTmFtZXMsXG59IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcbmltcG9ydCAqIGFzIEFBRFNlcnZlclBhcmFtS2V5cyBmcm9tIFwiLi4vY29uc3RhbnRzL0FBRFNlcnZlclBhcmFtS2V5cy5qc1wiO1xuaW1wb3J0IHsgUmVzcG9uc2VIYW5kbGVyIH0gZnJvbSBcIi4uL3Jlc3BvbnNlL1Jlc3BvbnNlSGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb25SZXN1bHQgfSBmcm9tIFwiLi4vcmVzcG9uc2UvQXV0aGVudGljYXRpb25SZXN1bHQuanNcIjtcbmltcG9ydCB7IFBvcFRva2VuR2VuZXJhdG9yIH0gZnJvbSBcIi4uL2NyeXB0by9Qb3BUb2tlbkdlbmVyYXRvci5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvU3RyaW5nVXRpbHMuanNcIjtcbmltcG9ydCB7IE5ldHdvcmtSZXNwb25zZSB9IGZyb20gXCIuLi9uZXR3b3JrL05ldHdvcmtSZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgQ29tbW9uU2lsZW50Rmxvd1JlcXVlc3QgfSBmcm9tIFwiLi4vcmVxdWVzdC9Db21tb25TaWxlbnRGbG93UmVxdWVzdC5qc1wiO1xuaW1wb3J0IHtcbiAgICBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IsXG4gICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMsXG59IGZyb20gXCIuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3IuanNcIjtcbmltcG9ydCB7XG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxufSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLmpzXCI7XG5pbXBvcnQgeyBTZXJ2ZXJFcnJvciB9IGZyb20gXCIuLi9lcnJvci9TZXJ2ZXJFcnJvci5qc1wiO1xuaW1wb3J0ICogYXMgVGltZVV0aWxzIGZyb20gXCIuLi91dGlscy9UaW1lVXRpbHMuanNcIjtcbmltcG9ydCB7IFVybFN0cmluZyB9IGZyb20gXCIuLi91cmwvVXJsU3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBDY3NDcmVkZW50aWFsVHlwZSB9IGZyb20gXCIuLi9hY2NvdW50L0Njc0NyZWRlbnRpYWwuanNcIjtcbmltcG9ydCB7IGJ1aWxkQ2xpZW50SW5mb0Zyb21Ib21lQWNjb3VudElkIH0gZnJvbSBcIi4uL2FjY291bnQvQ2xpZW50SW5mby5qc1wiO1xuaW1wb3J0IHtcbiAgICBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yLFxuICAgIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2RlcyxcbiAgICBjcmVhdGVJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yLFxufSBmcm9tIFwiLi4vZXJyb3IvSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VFdmVudHMgfSBmcm9tIFwiLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL1BlcmZvcm1hbmNlRXZlbnQuanNcIjtcbmltcG9ydCB7IElQZXJmb3JtYW5jZUNsaWVudCB9IGZyb20gXCIuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvSVBlcmZvcm1hbmNlQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBpbnZva2UsIGludm9rZUFzeW5jIH0gZnJvbSBcIi4uL3V0aWxzL0Z1bmN0aW9uV3JhcHBlcnMuanNcIjtcbmltcG9ydCB7IGdlbmVyYXRlQ3JlZGVudGlhbEtleSB9IGZyb20gXCIuLi9jYWNoZS91dGlscy9DYWNoZUhlbHBlcnMuanNcIjtcbmltcG9ydCB7IENsaWVudEFzc2VydGlvbiB9IGZyb20gXCIuLi9hY2NvdW50L0NsaWVudENyZWRlbnRpYWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRDbGllbnRBc3NlcnRpb24gfSBmcm9tIFwiLi4vdXRpbHMvQ2xpZW50QXNzZXJ0aW9uVXRpbHMuanNcIjtcbmltcG9ydCB7IGdldFJlcXVlc3RUaHVtYnByaW50IH0gZnJvbSBcIi4uL25ldHdvcmsvUmVxdWVzdFRodW1icHJpbnQuanNcIjtcblxuY29uc3QgREVGQVVMVF9SRUZSRVNIX1RPS0VOX0VYUElSQVRJT05fT0ZGU0VUX1NFQ09ORFMgPSAzMDA7IC8vIDUgTWludXRlc1xuXG4vKipcbiAqIE9BdXRoMi4wIHJlZnJlc2ggdG9rZW4gY2xpZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZnJlc2hUb2tlbkNsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjb25maWd1cmF0aW9uOiBDbGllbnRDb25maWd1cmF0aW9uLFxuICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD86IElQZXJmb3JtYW5jZUNsaWVudFxuICAgICkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uLCBwZXJmb3JtYW5jZUNsaWVudCk7XG4gICAgfVxuICAgIHB1YmxpYyBhc3luYyBhY3F1aXJlVG9rZW4oXG4gICAgICAgIHJlcXVlc3Q6IENvbW1vblJlZnJlc2hUb2tlblJlcXVlc3RcbiAgICApOiBQcm9taXNlPEF1dGhlbnRpY2F0aW9uUmVzdWx0PiB7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRBY3F1aXJlVG9rZW4sXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXFUaW1lc3RhbXAgPSBUaW1lVXRpbHMubm93U2Vjb25kcygpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgdGhpcy5leGVjdXRlVG9rZW5SZXF1ZXN0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRFeGVjdXRlVG9rZW5SZXF1ZXN0LFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICkocmVxdWVzdCwgdGhpcy5hdXRob3JpdHkpO1xuXG4gICAgICAgIC8vIFJldHJpZXZlIHJlcXVlc3RJZCBmcm9tIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVzcG9uc2UuaGVhZGVycz8uW0hlYWRlck5hbWVzLlhfTVNfUkVRVUVTVF9JRF07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IG5ldyBSZXNwb25zZUhhbmRsZXIoXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLFxuICAgICAgICAgICAgdGhpcy5jcnlwdG9VdGlscyxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuc2VyaWFsaXphYmxlQ2FjaGUsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5wZXJzaXN0ZW5jZVBsdWdpblxuICAgICAgICApO1xuICAgICAgICByZXNwb25zZUhhbmRsZXIudmFsaWRhdGVUb2tlblJlc3BvbnNlKHJlc3BvbnNlLmJvZHkpO1xuXG4gICAgICAgIHJldHVybiBpbnZva2VBc3luYyhcbiAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlci5oYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlLmJpbmQocmVzcG9uc2VIYW5kbGVyKSxcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkhhbmRsZVNlcnZlclRva2VuUmVzcG9uc2UsXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKShcbiAgICAgICAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eSxcbiAgICAgICAgICAgIHJlcVRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgcmVxdWVzdC5mb3JjZUNhY2hlLFxuICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWNoZWQgcmVmcmVzaCB0b2tlbiBhbmQgYXR0YWNoZXMgdG8gcmVxdWVzdCwgdGhlbiBjYWxscyBhY3F1aXJlVG9rZW4gQVBJXG4gICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW4oXG4gICAgICAgIHJlcXVlc3Q6IENvbW1vblNpbGVudEZsb3dSZXF1ZXN0XG4gICAgKTogUHJvbWlzZTxBdXRoZW50aWNhdGlvblJlc3VsdD4ge1xuICAgICAgICAvLyBDYW5ub3QgcmVuZXcgdG9rZW4gaWYgbm8gcmVxdWVzdCBvYmplY3QgaXMgZ2l2ZW4uXG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnRva2VuUmVxdWVzdEVtcHR5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gV2UgY3VycmVudGx5IGRvIG5vdCBzdXBwb3J0IHNpbGVudCBmbG93IGZvciBhY2NvdW50ID09PSBudWxsIHVzZSBjYXNlczsgVGhpcyB3aWxsIGJlIHJldmlzaXRlZCBmb3IgY29uZmlkZW50aWFsIGZsb3cgdXNlY2FzZXNcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub0FjY291bnRJblNpbGVudFJlcXVlc3RcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgY2hlY2tpbmcgaWYgRk9DSSBpcyBlbmFibGVkIGZvciB0aGUgZ2l2ZW4gYXBwbGljYXRpb25cbiAgICAgICAgY29uc3QgaXNGT0NJID0gdGhpcy5jYWNoZU1hbmFnZXIuaXNBcHBNZXRhZGF0YUZPQ0koXG4gICAgICAgICAgICByZXF1ZXN0LmFjY291bnQuZW52aXJvbm1lbnRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBpZiB0aGUgYXBwIGlzIHBhcnQgb2YgdGhlIGZhbWlseSwgcmV0cml2ZSBhIEZhbWlseSByZWZyZXNoIHRva2VuIGlmIHByZXNlbnQgYW5kIG1ha2UgYSByZWZyZXNoVG9rZW5SZXF1ZXN0XG4gICAgICAgIGlmIChpc0ZPQ0kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjcXVpcmVUb2tlbldpdGhDYWNoZWRSZWZyZXNoVG9rZW4uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICkocmVxdWVzdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9GYW1pbHlSVEluQ2FjaGUgPVxuICAgICAgICAgICAgICAgICAgICBlIGluc3RhbmNlb2YgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmVycm9yQ29kZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5ub1Rva2Vuc0ZvdW5kO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudE1pc21hdGNoRXJyb3JXaXRoRmFtaWx5UlQgPVxuICAgICAgICAgICAgICAgICAgICBlIGluc3RhbmNlb2YgU2VydmVyRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5lcnJvckNvZGUgPT09IEVycm9ycy5JTlZBTElEX0dSQU5UX0VSUk9SICYmXG4gICAgICAgICAgICAgICAgICAgIGUuc3ViRXJyb3IgPT09IEVycm9ycy5DTElFTlRfTUlTTUFUQ0hfRVJST1I7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBmYW1pbHkgUmVmcmVzaCBUb2tlbiAoRlJUKSBjYWNoZSBhY3F1aXNpdGlvbiBmYWlscyBvciBpZiBjbGllbnRfbWlzbWF0Y2ggZXJyb3IgaXMgc2VlbiB3aXRoIEZSVCwgcmVhdHRlbXB0IHdpdGggYXBwbGljYXRpb24gUmVmcmVzaCBUb2tlbiAoQVJUKVxuICAgICAgICAgICAgICAgIGlmIChub0ZhbWlseVJUSW5DYWNoZSB8fCBjbGllbnRNaXNtYXRjaEVycm9yV2l0aEZhbWlseVJUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2VBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICAgICApKHJlcXVlc3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGFwcGxpY2F0aW9uIHJlZnJlc2ggdG9rZW4gYWNxdWlzaXRpb25cbiAgICAgICAgcmV0dXJuIGludm9rZUFzeW5jKFxuICAgICAgICAgICAgdGhpcy5hY3F1aXJlVG9rZW5XaXRoQ2FjaGVkUmVmcmVzaFRva2VuLmJpbmQodGhpcyksXG4gICAgICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRBY3F1aXJlVG9rZW5XaXRoQ2FjaGVkUmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICkocmVxdWVzdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2VzIGEgbmV0d29yayBjYWxsIHRvIGFjcXVpcmUgdG9rZW5zIGJ5IGV4Y2hhbmdpbmcgUmVmcmVzaFRva2VuIGF2YWlsYWJsZSBpbiB1c2VyQ2FjaGU7IHRocm93cyBpZiByZWZyZXNoIHRva2VuIGlzIG5vdCBjYWNoZWRcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgYWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbihcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uU2lsZW50Rmxvd1JlcXVlc3QsXG4gICAgICAgIGZvY2k6IGJvb2xlYW5cbiAgICApIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbldpdGhDYWNoZWRSZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBmZXRjaGVzIGZhbWlseSBSVCBvciBhcHBsaWNhdGlvbiBSVCBiYXNlZCBvbiBGT0NJIHZhbHVlXG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGludm9rZShcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLmdldFJlZnJlc2hUb2tlbi5iaW5kKHRoaXMuY2FjaGVNYW5hZ2VyKSxcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkNhY2hlTWFuYWdlckdldFJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApKFxuICAgICAgICAgICAgcmVxdWVzdC5hY2NvdW50LFxuICAgICAgICAgICAgZm9jaSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMubm9Ub2tlbnNGb3VuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbi5leHBpcmVzT24gJiZcbiAgICAgICAgICAgIFRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZChcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW4uZXhwaXJlc09uLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVmcmVzaFRva2VuRXhwaXJhdGlvbk9mZnNldFNlY29uZHMgfHxcbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9SRUZSRVNIX1RPS0VOX0VYUElSQVRJT05fT0ZGU0VUX1NFQ09ORFNcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoXG4gICAgICAgICAgICAgICAgeyBydEV4cGlyZXNPbk1zOiBOdW1iZXIocmVmcmVzaFRva2VuLmV4cGlyZXNPbikgfSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5yZWZyZXNoVG9rZW5FeHBpcmVkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBjYWNoZWQgUlQgc2l6ZSB0byB0aGUgY3VycmVudCBtZWFzdXJlbWVudFxuXG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlblJlcXVlc3Q6IENvbW1vblJlZnJlc2hUb2tlblJlcXVlc3QgPSB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiByZWZyZXNoVG9rZW4uc2VjcmV0LFxuICAgICAgICAgICAgYXV0aGVudGljYXRpb25TY2hlbWU6XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSB8fCBBdXRoZW50aWNhdGlvblNjaGVtZS5CRUFSRVIsXG4gICAgICAgICAgICBjY3NDcmVkZW50aWFsOiB7XG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbDogcmVxdWVzdC5hY2NvdW50LmhvbWVBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgdHlwZTogQ2NzQ3JlZGVudGlhbFR5cGUuSE9NRV9BQ0NPVU5UX0lELFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGludm9rZUFzeW5jKFxuICAgICAgICAgICAgICAgIHRoaXMuYWNxdWlyZVRva2VuLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuLFxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApKHJlZnJlc2hUb2tlblJlcXVlc3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoXG4gICAgICAgICAgICAgICAgICAgIHsgcnRFeHBpcmVzT25NczogTnVtYmVyKHJlZnJlc2hUb2tlbi5leHBpcmVzT24pIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZS5zdWJFcnJvciA9PT0gSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLmJhZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBiYWQgcmVmcmVzaCB0b2tlbiBmcm9tIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFjcXVpcmVUb2tlbldpdGhSZWZyZXNoVG9rZW46IGJhZCByZWZyZXNoIHRva2VuLCByZW1vdmluZyBmcm9tIGNhY2hlXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFkUmVmcmVzaFRva2VuS2V5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQ3JlZGVudGlhbEtleShyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5yZW1vdmVSZWZyZXNoVG9rZW4oYmFkUmVmcmVzaFRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIHRoZSBuZXR3b3JrIG1lc3NhZ2UgYW5kIG1ha2VzIGEgTlcgY2FsbCB0byB0aGUgdW5kZXJseWluZyBzZWN1cmUgdG9rZW4gc2VydmljZVxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGF1dGhvcml0eVxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgZXhlY3V0ZVRva2VuUmVxdWVzdChcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uUmVmcmVzaFRva2VuUmVxdWVzdCxcbiAgICAgICAgYXV0aG9yaXR5OiBBdXRob3JpdHlcbiAgICApOiBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZT4+IHtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVUb2tlblJlcXVlc3QsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnNTdHJpbmcgPSB0aGlzLmNyZWF0ZVRva2VuUXVlcnlQYXJhbWV0ZXJzKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyhcbiAgICAgICAgICAgIGF1dGhvcml0eS50b2tlbkVuZHBvaW50LFxuICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50Q3JlYXRlVG9rZW5SZXF1ZXN0Qm9keSxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gdGhpcy5jcmVhdGVUb2tlblJlcXVlc3RIZWFkZXJzKFxuICAgICAgICAgICAgcmVxdWVzdC5jY3NDcmVkZW50aWFsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgdGh1bWJwcmludCA9IGdldFJlcXVlc3RUaHVtYnByaW50KFxuICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGludm9rZUFzeW5jKFxuICAgICAgICAgICAgdGhpcy5leGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50RXhlY3V0ZVBvc3RUb1Rva2VuRW5kcG9pbnQsXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKShcbiAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgcmVxdWVzdEJvZHksXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgdGh1bWJwcmludCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgdG9rZW4gcmVxdWVzdCBib2R5XG4gICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRva2VuUmVxdWVzdEJvZHkoXG4gICAgICAgIHJlcXVlc3Q6IENvbW1vblJlZnJlc2hUb2tlblJlcXVlc3RcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50Q3JlYXRlVG9rZW5SZXF1ZXN0Qm9keSxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudElkKFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJlcXVlc3QuZW1iZWRkZWRDbGllbnRJZCB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3QudG9rZW5Cb2R5UGFyYW1ldGVycz8uW0FBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSURdIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdFVyaSkge1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUmVkaXJlY3RVcmkoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlZGlyZWN0VXJpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU2NvcGVzKFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJlcXVlc3Quc2NvcGVzLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmF1dGhvcml0eS5vcHRpb25zLk9JRENPcHRpb25zPy5kZWZhdWx0U2NvcGVzXG4gICAgICAgICk7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkR3JhbnRUeXBlKFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgIEdyYW50VHlwZS5SRUZSRVNIX1RPS0VOX0dSQU5UXG4gICAgICAgICk7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMaWJyYXJ5SW5mbyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5saWJyYXJ5SW5mb1xuICAgICAgICApO1xuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRBcHBsaWNhdGlvblRlbGVtZXRyeShcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy50ZWxlbWV0cnkuYXBwbGljYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyICYmICFpc09pZGNQcm90b2NvbE1vZGUodGhpcy5jb25maWcpKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRSZWZyZXNoVG9rZW4oXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcmVxdWVzdC5yZWZyZXNoVG9rZW5cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRTZWNyZXQoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50QXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb246IENsaWVudEFzc2VydGlvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50QXNzZXJ0aW9uO1xuXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb24oXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhd2FpdCBnZXRDbGllbnRBc3NlcnRpb24oXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEFzc2VydGlvbi5hc3NlcnRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc291cmNlUmVxdWVzdFVyaVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb25UeXBlKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvblR5cGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSA9PT0gQXV0aGVudGljYXRpb25TY2hlbWUuUE9QKSB7XG4gICAgICAgICAgICBjb25zdCBwb3BUb2tlbkdlbmVyYXRvciA9IG5ldyBQb3BUb2tlbkdlbmVyYXRvcihcbiAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b1V0aWxzLFxuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCByZXFDbmZEYXRhO1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LnBvcEtpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFJlcUNuZkRhdGEgPSBhd2FpdCBpbnZva2VBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgcG9wVG9rZW5HZW5lcmF0b3IuZ2VuZXJhdGVDbmYuYmluZChwb3BUb2tlbkdlbmVyYXRvciksXG4gICAgICAgICAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlBvcFRva2VuR2VuZXJhdGVDbmYsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICAgICApKHJlcXVlc3QsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAgICAgICAgIHJlcUNuZkRhdGEgPSBnZW5lcmF0ZWRSZXFDbmZEYXRhLnJlcUNuZlN0cmluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxQ25mRGF0YSA9IHRoaXMuY3J5cHRvVXRpbHMuZW5jb2RlS2lkKHJlcXVlc3QucG9wS2lkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU1BBIFBvUCByZXF1aXJlcyBmdWxsIEJhc2U2NFVybCBlbmNvZGVkIHJlcV9jbmYgc3RyaW5nICh1bmhhc2hlZClcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFBvcFRva2VuKHBhcmFtZXRlcnMsIHJlcUNuZkRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgPT09IEF1dGhlbnRpY2F0aW9uU2NoZW1lLlNTSCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3NoSndrKSB7XG4gICAgICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU3NoSndrKHBhcmFtZXRlcnMsIHJlcXVlc3Quc3NoSndrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5taXNzaW5nU3NoSndrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFTdHJpbmdVdGlscy5pc0VtcHR5T2JqKHJlcXVlc3QuY2xhaW1zKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcy5sZW5ndGggPiAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsYWltcyhcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xhaW1zLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnN5c3RlbU9wdGlvbnMucHJldmVudENvcnNQcmVmbGlnaHQgJiZcbiAgICAgICAgICAgIHJlcXVlc3QuY2NzQ3JlZGVudGlhbFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVxdWVzdC5jY3NDcmVkZW50aWFsLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENjc0NyZWRlbnRpYWxUeXBlLkhPTUVfQUNDT1VOVF9JRDpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudEluZm8gPSBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNjc0NyZWRlbnRpYWwuY3JlZGVudGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc09pZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb3VsZCBub3QgcGFyc2UgaG9tZSBhY2NvdW50IElEIGZvciBDQ1MgSGVhZGVyOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDY3NDcmVkZW50aWFsVHlwZS5VUE46XG4gICAgICAgICAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc1VwbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNjc0NyZWRlbnRpYWwuY3JlZGVudGlhbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1ZXN0LmVtYmVkZGVkQ2xpZW50SWQpIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEJyb2tlclBhcmFtZXRlcnMoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5yZWRpcmVjdFVyaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1ZXN0LnRva2VuQm9keVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuaW5zdHJ1bWVudEJyb2tlclBhcmFtcyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQmFzZUNsaWVudCB9IGZyb20gXCIuL0Jhc2VDbGllbnQuanNcIjtcbmltcG9ydCB7IENsaWVudENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi4vY29uZmlnL0NsaWVudENvbmZpZ3VyYXRpb24uanNcIjtcbmltcG9ydCB7IENvbW1vblNpbGVudEZsb3dSZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQ29tbW9uU2lsZW50Rmxvd1JlcXVlc3QuanNcIjtcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uUmVzdWx0IH0gZnJvbSBcIi4uL3Jlc3BvbnNlL0F1dGhlbnRpY2F0aW9uUmVzdWx0LmpzXCI7XG5pbXBvcnQgKiBhcyBUaW1lVXRpbHMgZnJvbSBcIi4uL3V0aWxzL1RpbWVVdGlscy5qc1wiO1xuaW1wb3J0IHtcbiAgICBDbGllbnRBdXRoRXJyb3JDb2RlcyxcbiAgICBjcmVhdGVDbGllbnRBdXRoRXJyb3IsXG59IGZyb20gXCIuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IuanNcIjtcbmltcG9ydCB7IFJlc3BvbnNlSGFuZGxlciB9IGZyb20gXCIuLi9yZXNwb25zZS9SZXNwb25zZUhhbmRsZXIuanNcIjtcbmltcG9ydCB7IENhY2hlUmVjb3JkIH0gZnJvbSBcIi4uL2NhY2hlL2VudGl0aWVzL0NhY2hlUmVjb3JkLmpzXCI7XG5pbXBvcnQgeyBDYWNoZU91dGNvbWUgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBJUGVyZm9ybWFuY2VDbGllbnQgfSBmcm9tIFwiLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL0lQZXJmb3JtYW5jZUNsaWVudC5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvU3RyaW5nVXRpbHMuanNcIjtcbmltcG9ydCB7IGNoZWNrTWF4QWdlLCBleHRyYWN0VG9rZW5DbGFpbXMgfSBmcm9tIFwiLi4vYWNjb3VudC9BdXRoVG9rZW4uanNcIjtcbmltcG9ydCB7IFRva2VuQ2xhaW1zIH0gZnJvbSBcIi4uL2FjY291bnQvVG9rZW5DbGFpbXMuanNcIjtcbmltcG9ydCB7IFBlcmZvcm1hbmNlRXZlbnRzIH0gZnJvbSBcIi4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9QZXJmb3JtYW5jZUV2ZW50LmpzXCI7XG5pbXBvcnQgeyBpbnZva2VBc3luYyB9IGZyb20gXCIuLi91dGlscy9GdW5jdGlvbldyYXBwZXJzLmpzXCI7XG5pbXBvcnQgeyBnZXRUZW5hbnRGcm9tQXV0aG9yaXR5U3RyaW5nIH0gZnJvbSBcIi4uL2F1dGhvcml0eS9BdXRob3JpdHkuanNcIjtcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFNpbGVudEZsb3dDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgY29uZmlndXJhdGlvbjogQ2xpZW50Q29uZmlndXJhdGlvbixcbiAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/OiBJUGVyZm9ybWFuY2VDbGllbnRcbiAgICApIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvbiwgcGVyZm9ybWFuY2VDbGllbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0b2tlbiBmcm9tIGNhY2hlIG9yIHRocm93cyBhbiBlcnJvciBpZiBpdCBtdXN0IGJlIHJlZnJlc2hlZC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIGFjcXVpcmVDYWNoZWRUb2tlbihcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uU2lsZW50Rmxvd1JlcXVlc3RcbiAgICApOiBQcm9taXNlPFtBdXRoZW50aWNhdGlvblJlc3VsdCwgQ2FjaGVPdXRjb21lXT4ge1xuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50Rmxvd0NsaWVudEFjcXVpcmVDYWNoZWRUb2tlbixcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuICAgICAgICBsZXQgbGFzdENhY2hlT3V0Y29tZTogQ2FjaGVPdXRjb21lID0gQ2FjaGVPdXRjb21lLk5PVF9BUFBMSUNBQkxFO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHJlcXVlc3QuZm9yY2VSZWZyZXNoIHx8XG4gICAgICAgICAgICAoIXRoaXMuY29uZmlnLmNhY2hlT3B0aW9ucy5jbGFpbXNCYXNlZENhY2hpbmdFbmFibGVkICYmXG4gICAgICAgICAgICAgICAgIVN0cmluZ1V0aWxzLmlzRW1wdHlPYmoocmVxdWVzdC5jbGFpbXMpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIE11c3QgcmVmcmVzaCBkdWUgdG8gcHJlc2VudCBmb3JjZV9yZWZyZXNoIGZsYWcuXG4gICAgICAgICAgICB0aGlzLnNldENhY2hlT3V0Y29tZShcbiAgICAgICAgICAgICAgICBDYWNoZU91dGNvbWUuRk9SQ0VfUkVGUkVTSF9PUl9DTEFJTVMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuUmVmcmVzaFJlcXVpcmVkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgY3VycmVudGx5IGRvIG5vdCBzdXBwb3J0IHNpbGVudCBmbG93IGZvciBhY2NvdW50ID09PSBudWxsIHVzZSBjYXNlczsgVGhpcyB3aWxsIGJlIHJldmlzaXRlZCBmb3IgY29uZmlkZW50aWFsIGZsb3cgdXNlY2FzZXNcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub0FjY291bnRJblNpbGVudFJlcXVlc3RcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXF1ZXN0VGVuYW50SWQgPVxuICAgICAgICAgICAgcmVxdWVzdC5hY2NvdW50LnRlbmFudElkIHx8XG4gICAgICAgICAgICBnZXRUZW5hbnRGcm9tQXV0aG9yaXR5U3RyaW5nKHJlcXVlc3QuYXV0aG9yaXR5KTtcbiAgICAgICAgY29uc3QgdG9rZW5LZXlzID0gdGhpcy5jYWNoZU1hbmFnZXIuZ2V0VG9rZW5LZXlzKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlZEFjY2Vzc1Rva2VuID0gdGhpcy5jYWNoZU1hbmFnZXIuZ2V0QWNjZXNzVG9rZW4oXG4gICAgICAgICAgICByZXF1ZXN0LmFjY291bnQsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgdG9rZW5LZXlzLFxuICAgICAgICAgICAgcmVxdWVzdFRlbmFudElkLFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghY2FjaGVkQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIG11c3QgcmVmcmVzaCBkdWUgdG8gbm9uLWV4aXN0ZW50IGFjY2Vzc190b2tlblxuICAgICAgICAgICAgdGhpcy5zZXRDYWNoZU91dGNvbWUoXG4gICAgICAgICAgICAgICAgQ2FjaGVPdXRjb21lLk5PX0NBQ0hFRF9BQ0NFU1NfVE9LRU4sXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuUmVmcmVzaFJlcXVpcmVkXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgVGltZVV0aWxzLndhc0Nsb2NrVHVybmVkQmFjayhjYWNoZWRBY2Nlc3NUb2tlbi5jYWNoZWRBdCkgfHxcbiAgICAgICAgICAgIFRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZChcbiAgICAgICAgICAgICAgICBjYWNoZWRBY2Nlc3NUb2tlbi5leHBpcmVzT24sXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy50b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gbXVzdCByZWZyZXNoIGR1ZSB0byB0aGUgZXhwaXJlc19pbiB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zZXRDYWNoZU91dGNvbWUoXG4gICAgICAgICAgICAgICAgQ2FjaGVPdXRjb21lLkNBQ0hFRF9BQ0NFU1NfVE9LRU5fRVhQSVJFRCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5SZWZyZXNoUmVxdWlyZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBjYWNoZWRBY2Nlc3NUb2tlbi5yZWZyZXNoT24gJiZcbiAgICAgICAgICAgIFRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZChjYWNoZWRBY2Nlc3NUb2tlbi5yZWZyZXNoT24sIDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gbXVzdCByZWZyZXNoIChpbiB0aGUgYmFja2dyb3VuZCkgZHVlIHRvIHRoZSByZWZyZXNoX2luIHZhbHVlXG4gICAgICAgICAgICBsYXN0Q2FjaGVPdXRjb21lID0gQ2FjaGVPdXRjb21lLlBST0FDVElWRUxZX1JFRlJFU0hFRDtcblxuICAgICAgICAgICAgLy8gZG9uJ3QgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZVJlZnJlc2hSZXF1aXJlZEVycm9yKCksIHJldHVybiBjYWNoZWQgdG9rZW4gaW5zdGVhZFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW52aXJvbm1lbnQgPVxuICAgICAgICAgICAgcmVxdWVzdC5hdXRob3JpdHkgfHwgdGhpcy5hdXRob3JpdHkuZ2V0UHJlZmVycmVkQ2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2FjaGVSZWNvcmQ6IENhY2hlUmVjb3JkID0ge1xuICAgICAgICAgICAgYWNjb3VudDogdGhpcy5jYWNoZU1hbmFnZXIucmVhZEFjY291bnRGcm9tQ2FjaGUocmVxdWVzdC5hY2NvdW50KSxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBjYWNoZWRBY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIGlkVG9rZW46IHRoaXMuY2FjaGVNYW5hZ2VyLmdldElkVG9rZW4oXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hY2NvdW50LFxuICAgICAgICAgICAgICAgIHRva2VuS2V5cyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VGVuYW50SWQsXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IG51bGwsXG4gICAgICAgICAgICBhcHBNZXRhZGF0YTpcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5yZWFkQXBwTWV0YWRhdGFGcm9tQ2FjaGUoZW52aXJvbm1lbnQpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Q2FjaGVPdXRjb21lKGxhc3RDYWNoZU91dGNvbWUsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIuaW5jcmVtZW50Q2FjaGVIaXRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYXdhaXQgaW52b2tlQXN5bmMoXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVJlc3VsdEZyb21DYWNoZVJlY29yZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlNpbGVudEZsb3dDbGllbnRHZW5lcmF0ZVJlc3VsdEZyb21DYWNoZVJlY29yZCxcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgKShjYWNoZVJlY29yZCwgcmVxdWVzdCksXG4gICAgICAgICAgICBsYXN0Q2FjaGVPdXRjb21lLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0Q2FjaGVPdXRjb21lKFxuICAgICAgICBjYWNoZU91dGNvbWU6IENhY2hlT3V0Y29tZSxcbiAgICAgICAgY29ycmVsYXRpb25JZDogc3RyaW5nXG4gICAgKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcj8uc2V0Q2FjaGVPdXRjb21lKGNhY2hlT3V0Y29tZSk7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYWNoZU91dGNvbWU6IGNhY2hlT3V0Y29tZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjYWNoZU91dGNvbWUgIT09IENhY2hlT3V0Y29tZS5OT1RfQVBQTElDQUJMRSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBgVG9rZW4gcmVmcmVzaCBpcyByZXF1aXJlZCBkdWUgdG8gY2FjaGUgb3V0Y29tZTogJHtjYWNoZU91dGNvbWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBidWlsZCByZXNwb25zZSBvYmplY3QgZnJvbSB0aGUgQ2FjaGVSZWNvcmRcbiAgICAgKiBAcGFyYW0gY2FjaGVSZWNvcmRcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlUmVzdWx0RnJvbUNhY2hlUmVjb3JkKFxuICAgICAgICBjYWNoZVJlY29yZDogQ2FjaGVSZWNvcmQsXG4gICAgICAgIHJlcXVlc3Q6IENvbW1vblNpbGVudEZsb3dSZXF1ZXN0XG4gICAgKTogUHJvbWlzZTxBdXRoZW50aWNhdGlvblJlc3VsdD4ge1xuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFxuICAgICAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50Rmxvd0NsaWVudEdlbmVyYXRlUmVzdWx0RnJvbUNhY2hlUmVjb3JkLFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGxldCBpZFRva2VuQ2xhaW1zOiBUb2tlbkNsYWltcyB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNhY2hlUmVjb3JkLmlkVG9rZW4pIHtcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMgPSBleHRyYWN0VG9rZW5DbGFpbXMoXG4gICAgICAgICAgICAgICAgY2FjaGVSZWNvcmQuaWRUb2tlbi5zZWNyZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3J5cHRvSW50ZXJmYWNlLmJhc2U2NERlY29kZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRva2VuIG1heF9hZ2UgY2hlY2tcbiAgICAgICAgaWYgKHJlcXVlc3QubWF4QWdlIHx8IHJlcXVlc3QubWF4QWdlID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRoVGltZSA9IGlkVG9rZW5DbGFpbXM/LmF1dGhfdGltZTtcbiAgICAgICAgICAgIGlmICghYXV0aFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmF1dGhUaW1lTm90Rm91bmRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVja01heEFnZShhdXRoVGltZSwgcmVxdWVzdC5tYXhBZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlc3BvbnNlSGFuZGxlci5nZW5lcmF0ZUF1dGhlbnRpY2F0aW9uUmVzdWx0KFxuICAgICAgICAgICAgdGhpcy5jcnlwdG9VdGlscyxcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5LFxuICAgICAgICAgICAgY2FjaGVSZWNvcmQsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXNcbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbW1vbkF1dGhvcml6YXRpb25VcmxSZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQ29tbW9uQXV0aG9yaXphdGlvblVybFJlcXVlc3QuanNcIjtcbmltcG9ydCAqIGFzIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyIGZyb20gXCIuLi9yZXF1ZXN0L1JlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmpzXCI7XG5pbXBvcnQgeyBJUGVyZm9ybWFuY2VDbGllbnQgfSBmcm9tIFwiLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL0lQZXJmb3JtYW5jZUNsaWVudC5qc1wiO1xuaW1wb3J0ICogYXMgQUFEU2VydmVyUGFyYW1LZXlzIGZyb20gXCIuLi9jb25zdGFudHMvQUFEU2VydmVyUGFyYW1LZXlzLmpzXCI7XG5pbXBvcnQgeyBBdXRoT3B0aW9ucyB9IGZyb20gXCIuLi9jb25maWcvQ2xpZW50Q29uZmlndXJhdGlvbi5qc1wiO1xuaW1wb3J0IHsgUHJvbXB0VmFsdWUgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBBY2NvdW50SW5mbyB9IGZyb20gXCIuLi9hY2NvdW50L0FjY291bnRJbmZvLmpzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlci5qc1wiO1xuaW1wb3J0IHsgYnVpbGRDbGllbnRJbmZvRnJvbUhvbWVBY2NvdW50SWQgfSBmcm9tIFwiLi4vYWNjb3VudC9DbGllbnRJbmZvLmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpdHkgfSBmcm9tIFwiLi4vYXV0aG9yaXR5L0F1dGhvcml0eS5qc1wiO1xuaW1wb3J0IHsgbWFwVG9RdWVyeVN0cmluZyB9IGZyb20gXCIuLi91dGlscy9VcmxVdGlscy5qc1wiO1xuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSBcIi4uL3VybC9VcmxTdHJpbmcuanNcIjtcbmltcG9ydCB7IEF1dGhvcml6YXRpb25Db2RlUGF5bG9hZCB9IGZyb20gXCIuLi9yZXNwb25zZS9BdXRob3JpemF0aW9uQ29kZVBheWxvYWQuanNcIjtcbmltcG9ydCB7IEF1dGhvcml6ZVJlc3BvbnNlIH0gZnJvbSBcIi4uL3Jlc3BvbnNlL0F1dGhvcml6ZVJlc3BvbnNlLmpzXCI7XG5pbXBvcnQge1xuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbn0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHtcbiAgICBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yLFxuICAgIGlzSW50ZXJhY3Rpb25SZXF1aXJlZEVycm9yLFxufSBmcm9tIFwiLi4vZXJyb3IvSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgU2VydmVyRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3IvU2VydmVyRXJyb3IuanNcIjtcblxuLyoqXG4gKiBSZXR1cm5zIG1hcCBvZiBwYXJhbWV0ZXJzIHRoYXQgYXJlIGFwcGxpY2FibGUgdG8gYWxsIGNhbGxzIHRvIC9hdXRob3JpemUgd2hldGhlciB1c2luZyBQS0NFIG9yIEVBUlxuICogQHBhcmFtIGNvbmZpZ1xuICogQHBhcmFtIHJlcXVlc3RcbiAqIEBwYXJhbSBsb2dnZXJcbiAqIEBwYXJhbSBwZXJmb3JtYW5jZUNsaWVudFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YW5kYXJkQXV0aG9yaXplUmVxdWVzdFBhcmFtZXRlcnMoXG4gICAgYXV0aE9wdGlvbnM6IEF1dGhPcHRpb25zLFxuICAgIHJlcXVlc3Q6IENvbW1vbkF1dGhvcml6YXRpb25VcmxSZXF1ZXN0LFxuICAgIGxvZ2dlcjogTG9nZ2VyLFxuICAgIHBlcmZvcm1hbmNlQ2xpZW50PzogSVBlcmZvcm1hbmNlQ2xpZW50XG4pOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgY29ycmVsYXRpb25JZCBpZiBub3Qgc2V0IGJ5IHRoZSB1c2VyIGFuZCBhZGRcbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gcmVxdWVzdC5jb3JyZWxhdGlvbklkO1xuXG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRJZChcbiAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgcmVxdWVzdC5lbWJlZGRlZENsaWVudElkIHx8XG4gICAgICAgICAgICByZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzPy5bQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9JRF0gfHxcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLmNsaWVudElkXG4gICAgKTtcblxuICAgIGNvbnN0IHJlcXVlc3RTY29wZXMgPSBbXG4gICAgICAgIC4uLihyZXF1ZXN0LnNjb3BlcyB8fCBbXSksXG4gICAgICAgIC4uLihyZXF1ZXN0LmV4dHJhU2NvcGVzVG9Db25zZW50IHx8IFtdKSxcbiAgICBdO1xuICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNjb3BlcyhcbiAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgcmVxdWVzdFNjb3BlcyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgYXV0aE9wdGlvbnMuYXV0aG9yaXR5Lm9wdGlvbnMuT0lEQ09wdGlvbnM/LmRlZmF1bHRTY29wZXNcbiAgICApO1xuXG4gICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUmVkaXJlY3RVcmkocGFyYW1ldGVycywgcmVxdWVzdC5yZWRpcmVjdFVyaSk7XG5cbiAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDb3JyZWxhdGlvbklkKHBhcmFtZXRlcnMsIGNvcnJlbGF0aW9uSWQpO1xuXG4gICAgLy8gYWRkIHJlc3BvbnNlX21vZGUuIElmIG5vdCBwYXNzZWQgaW4gaXQgZGVmYXVsdHMgdG8gcXVlcnkuXG4gICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUmVzcG9uc2VNb2RlKHBhcmFtZXRlcnMsIHJlcXVlc3QucmVzcG9uc2VNb2RlKTtcblxuICAgIC8vIGFkZCBjbGllbnRfaW5mbz0xXG4gICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKTtcblxuICAgIGlmIChyZXF1ZXN0LnByb21wdCkge1xuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRQcm9tcHQocGFyYW1ldGVycywgcmVxdWVzdC5wcm9tcHQpO1xuICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD8uYWRkRmllbGRzKHsgcHJvbXB0OiByZXF1ZXN0LnByb21wdCB9LCBjb3JyZWxhdGlvbklkKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5kb21haW5IaW50KSB7XG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZERvbWFpbkhpbnQocGFyYW1ldGVycywgcmVxdWVzdC5kb21haW5IaW50KTtcbiAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyhcbiAgICAgICAgICAgIHsgZG9tYWluSGludEZyb21SZXF1ZXN0OiB0cnVlIH0sXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHNpZCBvciBsb2dpbkhpbnQgd2l0aCBwcmVmZXJlbmNlIGZvciBsb2dpbl9oaW50IGNsYWltIChpbiByZXF1ZXN0KSAtPiBzaWQgLT4gbG9naW5IaW50ICh1cG4vZW1haWwpIC0+IHVzZXJuYW1lIG9mIEFjY291bnRJbmZvIG9iamVjdFxuICAgIGlmIChyZXF1ZXN0LnByb21wdCAhPT0gUHJvbXB0VmFsdWUuU0VMRUNUX0FDQ09VTlQpIHtcbiAgICAgICAgLy8gQUFEIHdpbGwgdGhyb3cgaWYgcHJvbXB0PXNlbGVjdF9hY2NvdW50IGlzIHBhc3NlZCB3aXRoIGFuIGFjY291bnQgaGludFxuICAgICAgICBpZiAocmVxdWVzdC5zaWQgJiYgcmVxdWVzdC5wcm9tcHQgPT09IFByb21wdFZhbHVlLk5PTkUpIHtcbiAgICAgICAgICAgIC8vIFNlc3Npb25JRCBpcyBvbmx5IHVzZWQgaW4gc2lsZW50IGNhbGxzXG4gICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IFByb21wdCBpcyBub25lLCBhZGRpbmcgc2lkIGZyb20gcmVxdWVzdFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU2lkKHBhcmFtZXRlcnMsIHJlcXVlc3Quc2lkKTtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoXG4gICAgICAgICAgICAgICAgeyBzaWRGcm9tUmVxdWVzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5hY2NvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50U2lkID0gZXh0cmFjdEFjY291bnRTaWQocmVxdWVzdC5hY2NvdW50KTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50TG9naW5IaW50Q2xhaW0gPSBleHRyYWN0TG9naW5IaW50KHJlcXVlc3QuYWNjb3VudCk7XG5cbiAgICAgICAgICAgIGlmIChhY2NvdW50TG9naW5IaW50Q2xhaW0gJiYgcmVxdWVzdC5kb21haW5IaW50KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm5pbmcoXG4gICAgICAgICAgICAgICAgICAgIGBBdXRob3JpemF0aW9uQ29kZUNsaWVudC5jcmVhdGVBdXRoQ29kZVVybFF1ZXJ5U3RyaW5nOiBcImRvbWFpbkhpbnRcIiBwYXJhbSBpcyBzZXQsIHNraXBwaW5nIG9wYXF1ZSBcImxvZ2luX2hpbnRcIiBjbGFpbS4gUGxlYXNlIGNvbnNpZGVyIG5vdCBwYXNzaW5nIGRvbWFpbkhpbnRgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50TG9naW5IaW50Q2xhaW0gPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBsb2dpbl9oaW50IGNsYWltIGlzIHByZXNlbnQsIHVzZSBpdCBvdmVyIHNpZC91c2VybmFtZVxuICAgICAgICAgICAgaWYgKGFjY291bnRMb2dpbkhpbnRDbGFpbSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IGxvZ2luX2hpbnQgY2xhaW0gcHJlc2VudCBvbiBhY2NvdW50XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZExvZ2luSGludChcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudExvZ2luSGludENsYWltXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD8uYWRkRmllbGRzKFxuICAgICAgICAgICAgICAgICAgICB7IGxvZ2luSGludEZyb21DbGFpbTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvRnJvbUhvbWVBY2NvdW50SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFjY291bnQuaG9tZUFjY291bnRJZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDY3NPaWQocGFyYW1ldGVycywgY2xpZW50SW5mbyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY3JlYXRlQXV0aENvZGVVcmxRdWVyeVN0cmluZzogQ291bGQgbm90IHBhcnNlIGhvbWUgYWNjb3VudCBJRCBmb3IgQ0NTIEhlYWRlclwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhY2NvdW50U2lkICYmIHJlcXVlc3QucHJvbXB0ID09PSBQcm9tcHRWYWx1ZS5OT05FKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiBhY2NvdW50IGFuZCBsb2dpbkhpbnQgYXJlIHByb3ZpZGVkLCB3ZSB3aWxsIGNoZWNrIGFjY291bnQgZmlyc3QgZm9yIHNpZCBiZWZvcmUgYWRkaW5nIGxvZ2luSGludFxuICAgICAgICAgICAgICAgICAqIFNlc3Npb25JZCBpcyBvbmx5IHVzZWQgaW4gc2lsZW50IGNhbGxzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgIFwiY3JlYXRlQXV0aENvZGVVcmxRdWVyeVN0cmluZzogUHJvbXB0IGlzIG5vbmUsIGFkZGluZyBzaWQgZnJvbSBhY2NvdW50XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNpZChwYXJhbWV0ZXJzLCBhY2NvdW50U2lkKTtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD8uYWRkRmllbGRzKFxuICAgICAgICAgICAgICAgICAgICB7IHNpZEZyb21DbGFpbTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvRnJvbUhvbWVBY2NvdW50SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFjY291bnQuaG9tZUFjY291bnRJZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDY3NPaWQocGFyYW1ldGVycywgY2xpZW50SW5mbyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY3JlYXRlQXV0aENvZGVVcmxRdWVyeVN0cmluZzogQ291bGQgbm90IHBhcnNlIGhvbWUgYWNjb3VudCBJRCBmb3IgQ0NTIEhlYWRlclwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmxvZ2luSGludCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IEFkZGluZyBsb2dpbl9oaW50IGZyb20gcmVxdWVzdFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMb2dpbkhpbnQoXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QubG9naW5IaW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDY3NVcG4oXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QubG9naW5IaW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD8uYWRkRmllbGRzKFxuICAgICAgICAgICAgICAgICAgICB7IGxvZ2luSGludEZyb21SZXF1ZXN0OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmFjY291bnQudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBhY2NvdW50IHVzZXJuYW1lIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgIFwiY3JlYXRlQXV0aENvZGVVcmxRdWVyeVN0cmluZzogQWRkaW5nIGxvZ2luX2hpbnQgZnJvbSBhY2NvdW50XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZExvZ2luSGludChcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hY2NvdW50LnVzZXJuYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD8uYWRkRmllbGRzKFxuICAgICAgICAgICAgICAgICAgICB7IGxvZ2luSGludEZyb21VcG46IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mb0Zyb21Ib21lQWNjb3VudElkKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hY2NvdW50LmhvbWVBY2NvdW50SWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2NzT2lkKHBhcmFtZXRlcnMsIGNsaWVudEluZm8pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IENvdWxkIG5vdCBwYXJzZSBob21lIGFjY291bnQgSUQgZm9yIENDUyBIZWFkZXJcIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmxvZ2luSGludCkge1xuICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAgICAgXCJjcmVhdGVBdXRoQ29kZVVybFF1ZXJ5U3RyaW5nOiBObyBhY2NvdW50LCBhZGRpbmcgbG9naW5faGludCBmcm9tIHJlcXVlc3RcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZExvZ2luSGludChwYXJhbWV0ZXJzLCByZXF1ZXN0LmxvZ2luSGludCk7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDY3NVcG4ocGFyYW1ldGVycywgcmVxdWVzdC5sb2dpbkhpbnQpO1xuICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyhcbiAgICAgICAgICAgICAgICB7IGxvZ2luSGludEZyb21SZXF1ZXN0OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgXCJjcmVhdGVBdXRoQ29kZVVybFF1ZXJ5U3RyaW5nOiBQcm9tcHQgaXMgc2VsZWN0X2FjY291bnQsIGlnbm9yaW5nIGFjY291bnQgaGludHNcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm5vbmNlKSB7XG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZE5vbmNlKHBhcmFtZXRlcnMsIHJlcXVlc3Qubm9uY2UpO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnN0YXRlKSB7XG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFN0YXRlKHBhcmFtZXRlcnMsIHJlcXVlc3Quc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgcmVxdWVzdC5jbGFpbXMgfHxcbiAgICAgICAgKGF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxuICAgICAgICAgICAgYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApXG4gICAgKSB7XG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsYWltcyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZXF1ZXN0LmNsYWltcyxcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmVtYmVkZGVkQ2xpZW50SWQpIHtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQnJva2VyUGFyYW1ldGVycyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSWYgZXh0cmFRdWVyeVBhcmFtZXRlcnMgaW5jbHVkZXMgaW5zdGFuY2VfYXdhcmUgaXRzIHZhbHVlIHdpbGwgYmUgYWRkZWQgd2hlbiBleHRyYVF1ZXJ5UGFyYW1ldGVycyBhcmUgYWRkZWRcbiAgICBpZiAoXG4gICAgICAgIGF1dGhPcHRpb25zLmluc3RhbmNlQXdhcmUgJiZcbiAgICAgICAgKCFyZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzIHx8XG4gICAgICAgICAgICAhT2JqZWN0LmtleXMocmVxdWVzdC5leHRyYVF1ZXJ5UGFyYW1ldGVycykuaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgQUFEU2VydmVyUGFyYW1LZXlzLklOU1RBTkNFX0FXQVJFXG4gICAgICAgICAgICApKVxuICAgICkge1xuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRJbnN0YW5jZUF3YXJlKHBhcmFtZXRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXV0aG9yaXplIGVuZHBvaW50IHdpdGggZ2l2ZW4gcmVxdWVzdCBwYXJhbWV0ZXJzIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAqIEBwYXJhbSBhdXRob3JpdHlcbiAqIEBwYXJhbSByZXF1ZXN0UGFyYW1ldGVyc1xuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhvcml6ZVVybChcbiAgICBhdXRob3JpdHk6IEF1dGhvcml0eSxcbiAgICByZXF1ZXN0UGFyYW1ldGVyczogTWFwPHN0cmluZywgc3RyaW5nPlxuKTogc3RyaW5nIHtcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IG1hcFRvUXVlcnlTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMpO1xuXG4gICAgcmV0dXJuIFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyhcbiAgICAgICAgYXV0aG9yaXR5LmF1dGhvcml6YXRpb25FbmRwb2ludCxcbiAgICAgICAgcXVlcnlTdHJpbmdcbiAgICApO1xufVxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGhhc2ggZnJhZ21lbnQgcmVzcG9uc2UgZnJvbSBwdWJsaWMgY2xpZW50IGNvZGUgcmVxdWVzdC4gUmV0dXJucyBhIGNvZGUgcmVzcG9uc2UgdXNlZCBieVxuICogdGhlIGNsaWVudCB0byBleGNoYW5nZSBmb3IgYSB0b2tlbiBpbiBhY3F1aXJlVG9rZW4uXG4gKiBAcGFyYW0gc2VydmVyUGFyYW1zXG4gKiBAcGFyYW0gY2FjaGVkU3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhvcml6YXRpb25Db2RlUGF5bG9hZChcbiAgICBzZXJ2ZXJQYXJhbXM6IEF1dGhvcml6ZVJlc3BvbnNlLFxuICAgIGNhY2hlZFN0YXRlOiBzdHJpbmdcbik6IEF1dGhvcml6YXRpb25Db2RlUGF5bG9hZCB7XG4gICAgLy8gR2V0IGNvZGUgcmVzcG9uc2VcbiAgICB2YWxpZGF0ZUF1dGhvcml6YXRpb25SZXNwb25zZShzZXJ2ZXJQYXJhbXMsIGNhY2hlZFN0YXRlKTtcblxuICAgIC8vIHRocm93IHdoZW4gdGhlcmUgaXMgbm8gYXV0aCBjb2RlIGluIHRoZSByZXNwb25zZVxuICAgIGlmICghc2VydmVyUGFyYW1zLmNvZGUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aG9yaXphdGlvbkNvZGVNaXNzaW5nRnJvbVNlcnZlclJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcnZlclBhcmFtcyBhcyBBdXRob3JpemF0aW9uQ29kZVBheWxvYWQ7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gd2hpY2ggdmFsaWRhdGVzIHNlcnZlciBhdXRob3JpemF0aW9uIGNvZGUgcmVzcG9uc2UuXG4gKiBAcGFyYW0gc2VydmVyUmVzcG9uc2VIYXNoXG4gKiBAcGFyYW0gcmVxdWVzdFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUF1dGhvcml6YXRpb25SZXNwb25zZShcbiAgICBzZXJ2ZXJSZXNwb25zZTogQXV0aG9yaXplUmVzcG9uc2UsXG4gICAgcmVxdWVzdFN0YXRlOiBzdHJpbmdcbik6IHZvaWQge1xuICAgIGlmICghc2VydmVyUmVzcG9uc2Uuc3RhdGUgfHwgIXJlcXVlc3RTdGF0ZSkge1xuICAgICAgICB0aHJvdyBzZXJ2ZXJSZXNwb25zZS5zdGF0ZVxuICAgICAgICAgICAgPyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5zdGF0ZU5vdEZvdW5kLFxuICAgICAgICAgICAgICAgICAgXCJDYWNoZWQgU3RhdGVcIlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLnN0YXRlTm90Rm91bmQsXG4gICAgICAgICAgICAgICAgICBcIlNlcnZlciBTdGF0ZVwiXG4gICAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGRlY29kZWRTZXJ2ZXJSZXNwb25zZVN0YXRlOiBzdHJpbmc7XG4gICAgbGV0IGRlY29kZWRSZXF1ZXN0U3RhdGU6IHN0cmluZztcblxuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWRTZXJ2ZXJSZXNwb25zZVN0YXRlID0gZGVjb2RlVVJJQ29tcG9uZW50KHNlcnZlclJlc3BvbnNlLnN0YXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRTdGF0ZSxcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN0YXRlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZFJlcXVlc3RTdGF0ZSA9IGRlY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0U3RhdGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMuaW52YWxpZFN0YXRlLFxuICAgICAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3RhdGVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZGVjb2RlZFNlcnZlclJlc3BvbnNlU3RhdGUgIT09IGRlY29kZWRSZXF1ZXN0U3RhdGUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLnN0YXRlTWlzbWF0Y2gpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBlcnJvclxuICAgIGlmIChcbiAgICAgICAgc2VydmVyUmVzcG9uc2UuZXJyb3IgfHxcbiAgICAgICAgc2VydmVyUmVzcG9uc2UuZXJyb3JfZGVzY3JpcHRpb24gfHxcbiAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3ViZXJyb3JcbiAgICApIHtcbiAgICAgICAgY29uc3Qgc2VydmVyRXJyb3JObyA9IHBhcnNlU2VydmVyRXJyb3JObyhzZXJ2ZXJSZXNwb25zZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzSW50ZXJhY3Rpb25SZXF1aXJlZEVycm9yKFxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yLFxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuZXJyb3IgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5lcnJvcl9kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5zdWJlcnJvcixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS50aW1lc3RhbXAgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS50cmFjZV9pZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmNvcnJlbGF0aW9uX2lkIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UuY2xhaW1zIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgc2VydmVyRXJyb3JOb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBTZXJ2ZXJFcnJvcihcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yIHx8IFwiXCIsXG4gICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5lcnJvcl9kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yLFxuICAgICAgICAgICAgc2VydmVyRXJyb3JOb1xuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgc2VydmVyIGVycm9yIE5vIGZyb20gdGhlIGVycm9yX3VyaVxuICogQHBhcmFtIHNlcnZlclJlc3BvbnNlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBwYXJzZVNlcnZlckVycm9yTm8oXG4gICAgc2VydmVyUmVzcG9uc2U6IEF1dGhvcml6ZVJlc3BvbnNlXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGVycm9yQ29kZVByZWZpeCA9IFwiY29kZT1cIjtcbiAgICBjb25zdCBlcnJvckNvZGVQcmVmaXhJbmRleCA9XG4gICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yX3VyaT8ubGFzdEluZGV4T2YoZXJyb3JDb2RlUHJlZml4KTtcbiAgICByZXR1cm4gZXJyb3JDb2RlUHJlZml4SW5kZXggJiYgZXJyb3JDb2RlUHJlZml4SW5kZXggPj0gMFxuICAgICAgICA/IHNlcnZlclJlc3BvbnNlLmVycm9yX3VyaT8uc3Vic3RyaW5nKFxuICAgICAgICAgICAgICBlcnJvckNvZGVQcmVmaXhJbmRleCArIGVycm9yQ29kZVByZWZpeC5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgc2lkIGZyb20gYWNjb3VudC4gUmV0dXJucyBudWxsIGlmIGlkVG9rZW5DbGFpbXMgYXJlIG5vdCBwcmVzZW50IG9yIHNpZCBpcyBub3QgcHJlc2VudC5cbiAqIEBwYXJhbSBhY2NvdW50XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RBY2NvdW50U2lkKGFjY291bnQ6IEFjY291bnRJbmZvKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIGFjY291bnQuaWRUb2tlbkNsYWltcz8uc2lkIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RMb2dpbkhpbnQoYWNjb3VudDogQWNjb3VudEluZm8pOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gYWNjb3VudC5pZFRva2VuQ2xhaW1zPy5sb2dpbl9oaW50IHx8IG51bGw7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUyxcbiAgICBTZXBhcmF0b3JzLFxuICAgIENhY2hlT3V0Y29tZSxcbiAgICBDb25zdGFudHMsXG4gICAgUmVnaW9uRGlzY292ZXJ5U291cmNlcyxcbiAgICBSZWdpb25EaXNjb3ZlcnlPdXRjb21lcyxcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgQ2FjaGVNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uL2NhY2hlL0NhY2hlTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSBcIi4uLy4uL2Vycm9yL0F1dGhFcnJvci5qc1wiO1xuaW1wb3J0IHsgU2VydmVyVGVsZW1ldHJ5UmVxdWVzdCB9IGZyb20gXCIuL1NlcnZlclRlbGVtZXRyeVJlcXVlc3QuanNcIjtcbmltcG9ydCB7IFNlcnZlclRlbGVtZXRyeUVudGl0eSB9IGZyb20gXCIuLi8uLi9jYWNoZS9lbnRpdGllcy9TZXJ2ZXJUZWxlbWV0cnlFbnRpdHkuanNcIjtcbmltcG9ydCB7IFJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhIH0gZnJvbSBcIi4uLy4uL2F1dGhvcml0eS9SZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5qc1wiO1xuXG5jb25zdCBza3VHcm91cFNlcGFyYXRvciA9IFwiLFwiO1xuY29uc3Qgc2t1VmFsdWVTZXBhcmF0b3IgPSBcInxcIjtcblxudHlwZSBTa3VQYXJhbXMgPSB7XG4gICAgbGlicmFyeU5hbWU/OiBzdHJpbmc7XG4gICAgbGlicmFyeVZlcnNpb24/OiBzdHJpbmc7XG4gICAgZXh0ZW5zaW9uTmFtZT86IHN0cmluZztcbiAgICBleHRlbnNpb25WZXJzaW9uPzogc3RyaW5nO1xuICAgIHNrdXM/OiBzdHJpbmc7XG59O1xuXG5mdW5jdGlvbiBtYWtlRXh0cmFTa3VTdHJpbmcocGFyYW1zOiBTa3VQYXJhbXMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc2t1cyxcbiAgICAgICAgbGlicmFyeU5hbWUsXG4gICAgICAgIGxpYnJhcnlWZXJzaW9uLFxuICAgICAgICBleHRlbnNpb25OYW1lLFxuICAgICAgICBleHRlbnNpb25WZXJzaW9uLFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qgc2t1TWFwOiBNYXA8bnVtYmVyLCAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdPiA9IG5ldyBNYXAoW1xuICAgICAgICBbMCwgW2xpYnJhcnlOYW1lLCBsaWJyYXJ5VmVyc2lvbl1dLFxuICAgICAgICBbMiwgW2V4dGVuc2lvbk5hbWUsIGV4dGVuc2lvblZlcnNpb25dXSxcbiAgICBdKTtcbiAgICBsZXQgc2t1QXJyOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKHNrdXM/Lmxlbmd0aCkge1xuICAgICAgICBza3VBcnIgPSBza3VzLnNwbGl0KHNrdUdyb3VwU2VwYXJhdG9yKTtcblxuICAgICAgICAvLyBJZ25vcmUgaW52YWxpZCBpbnB1dCBza3UgcGFyYW1cbiAgICAgICAgaWYgKHNrdUFyci5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2t1cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNrdUFyciA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDQgfSwgKCkgPT4gc2t1VmFsdWVTZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIHNrdU1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWVbMF0/Lmxlbmd0aCAmJiB2YWx1ZVsxXT8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXRTa3Uoe1xuICAgICAgICAgICAgICAgIHNrdUFycixcbiAgICAgICAgICAgICAgICBpbmRleDoga2V5LFxuICAgICAgICAgICAgICAgIHNrdU5hbWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHNrdVZlcnNpb246IHZhbHVlWzFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBza3VBcnIuam9pbihza3VHcm91cFNlcGFyYXRvcik7XG59XG5cbmZ1bmN0aW9uIHNldFNrdShwYXJhbXM6IHtcbiAgICBza3VBcnI6IHN0cmluZ1tdO1xuICAgIGluZGV4OiBudW1iZXI7XG4gICAgc2t1TmFtZTogc3RyaW5nO1xuICAgIHNrdVZlcnNpb246IHN0cmluZztcbn0pOiB2b2lkIHtcbiAgICBjb25zdCB7IHNrdUFyciwgaW5kZXgsIHNrdU5hbWUsIHNrdVZlcnNpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoaW5kZXggPj0gc2t1QXJyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHNrdUFycltpbmRleF0gPSBbc2t1TmFtZSwgc2t1VmVyc2lvbl0uam9pbihza3VWYWx1ZVNlcGFyYXRvcik7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyIHtcbiAgICBwcml2YXRlIGNhY2hlTWFuYWdlcjogQ2FjaGVNYW5hZ2VyO1xuICAgIHByaXZhdGUgYXBpSWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGNvcnJlbGF0aW9uSWQ6IHN0cmluZztcbiAgICBwcml2YXRlIHRlbGVtZXRyeUNhY2hlS2V5OiBzdHJpbmc7XG4gICAgcHJpdmF0ZSB3cmFwcGVyU0tVOiBTdHJpbmc7XG4gICAgcHJpdmF0ZSB3cmFwcGVyVmVyOiBTdHJpbmc7XG4gICAgcHJpdmF0ZSByZWdpb25Vc2VkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSByZWdpb25Tb3VyY2U6IFJlZ2lvbkRpc2NvdmVyeVNvdXJjZXMgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSByZWdpb25PdXRjb21lOiBSZWdpb25EaXNjb3ZlcnlPdXRjb21lcyB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIGNhY2hlT3V0Y29tZTogQ2FjaGVPdXRjb21lID0gQ2FjaGVPdXRjb21lLk5PVF9BUFBMSUNBQkxFO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHRlbGVtZXRyeVJlcXVlc3Q6IFNlcnZlclRlbGVtZXRyeVJlcXVlc3QsXG4gICAgICAgIGNhY2hlTWFuYWdlcjogQ2FjaGVNYW5hZ2VyXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyID0gY2FjaGVNYW5hZ2VyO1xuICAgICAgICB0aGlzLmFwaUlkID0gdGVsZW1ldHJ5UmVxdWVzdC5hcGlJZDtcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gdGVsZW1ldHJ5UmVxdWVzdC5jb3JyZWxhdGlvbklkO1xuICAgICAgICB0aGlzLndyYXBwZXJTS1UgPSB0ZWxlbWV0cnlSZXF1ZXN0LndyYXBwZXJTS1UgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcbiAgICAgICAgdGhpcy53cmFwcGVyVmVyID0gdGVsZW1ldHJ5UmVxdWVzdC53cmFwcGVyVmVyIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG5cbiAgICAgICAgdGhpcy50ZWxlbWV0cnlDYWNoZUtleSA9XG4gICAgICAgICAgICBTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLkNBQ0hFX0tFWSArXG4gICAgICAgICAgICBTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1IgK1xuICAgICAgICAgICAgdGVsZW1ldHJ5UmVxdWVzdC5jbGllbnRJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBUEkgdG8gYWRkIE1TRVIgVGVsZW1ldHJ5IHRvIHJlcXVlc3RcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUN1cnJlbnRSZXF1ZXN0SGVhZGVyVmFsdWUoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGAke3RoaXMuYXBpSWR9JHtTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlZBTFVFX1NFUEFSQVRPUn0ke3RoaXMuY2FjaGVPdXRjb21lfWA7XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtRmllbGRzQXJyID0gW3RoaXMud3JhcHBlclNLVSwgdGhpcy53cmFwcGVyVmVyXTtcbiAgICAgICAgY29uc3QgbmF0aXZlQnJva2VyRXJyb3JDb2RlID0gdGhpcy5nZXROYXRpdmVCcm9rZXJFcnJvckNvZGUoKTtcbiAgICAgICAgaWYgKG5hdGl2ZUJyb2tlckVycm9yQ29kZT8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbGF0Zm9ybUZpZWxkc0Fyci5wdXNoKGBicm9rZXJfZXJyb3I9JHtuYXRpdmVCcm9rZXJFcnJvckNvZGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhdGZvcm1GaWVsZHMgPSBwbGF0Zm9ybUZpZWxkc0Fyci5qb2luKFxuICAgICAgICAgICAgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5WQUxVRV9TRVBBUkFUT1JcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVnaW9uRGlzY292ZXJ5RmllbGRzID0gdGhpcy5nZXRSZWdpb25EaXNjb3ZlcnlGaWVsZHMoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWdpb25EaXNjb3ZlcnlGaWVsZHMgPSBbXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcmVnaW9uRGlzY292ZXJ5RmllbGRzLFxuICAgICAgICBdLmpvaW4oU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5WQUxVRV9TRVBBUkFUT1IpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlNDSEVNQV9WRVJTSU9OLFxuICAgICAgICAgICAgcmVxdWVzdFdpdGhSZWdpb25EaXNjb3ZlcnlGaWVsZHMsXG4gICAgICAgICAgICBwbGF0Zm9ybUZpZWxkcyxcbiAgICAgICAgXS5qb2luKFNFUlZFUl9URUxFTV9DT05TVEFOVFMuQ0FURUdPUllfU0VQQVJBVE9SKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBUEkgdG8gYWRkIE1TRVIgVGVsZW1ldHJ5IGZvciB0aGUgbGFzdCBmYWlsZWQgcmVxdWVzdFxuICAgICAqL1xuICAgIGdlbmVyYXRlTGFzdFJlcXVlc3RIZWFkZXJWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBsYXN0UmVxdWVzdHMgPSB0aGlzLmdldExhc3RSZXF1ZXN0cygpO1xuXG4gICAgICAgIGNvbnN0IG1heEVycm9ycyA9IFNlcnZlclRlbGVtZXRyeU1hbmFnZXIubWF4RXJyb3JzVG9TZW5kKGxhc3RSZXF1ZXN0cyk7XG4gICAgICAgIGNvbnN0IGZhaWxlZFJlcXVlc3RzID0gbGFzdFJlcXVlc3RzLmZhaWxlZFJlcXVlc3RzXG4gICAgICAgICAgICAuc2xpY2UoMCwgMiAqIG1heEVycm9ycylcbiAgICAgICAgICAgIC5qb2luKFNFUlZFUl9URUxFTV9DT05TVEFOVFMuVkFMVUVfU0VQQVJBVE9SKTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gbGFzdFJlcXVlc3RzLmVycm9yc1xuICAgICAgICAgICAgLnNsaWNlKDAsIG1heEVycm9ycylcbiAgICAgICAgICAgIC5qb2luKFNFUlZFUl9URUxFTV9DT05TVEFOVFMuVkFMVUVfU0VQQVJBVE9SKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb3VudCA9IGxhc3RSZXF1ZXN0cy5lcnJvcnMubGVuZ3RoO1xuXG4gICAgICAgIC8vIEluZGljYXRlIHdoZXRoZXIgdGhpcyBoZWFkZXIgY29udGFpbnMgYWxsIGRhdGEgb3IgcGFydGlhbCBkYXRhXG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID1cbiAgICAgICAgICAgIG1heEVycm9ycyA8IGVycm9yQ291bnRcbiAgICAgICAgICAgICAgICA/IFNFUlZFUl9URUxFTV9DT05TVEFOVFMuT1ZFUkZMT1dfVFJVRVxuICAgICAgICAgICAgICAgIDogU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5PVkVSRkxPV19GQUxTRTtcbiAgICAgICAgY29uc3QgcGxhdGZvcm1GaWVsZHMgPSBbZXJyb3JDb3VudCwgb3ZlcmZsb3ddLmpvaW4oXG4gICAgICAgICAgICBTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlZBTFVFX1NFUEFSQVRPUlxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlNDSEVNQV9WRVJTSU9OLFxuICAgICAgICAgICAgbGFzdFJlcXVlc3RzLmNhY2hlSGl0cyxcbiAgICAgICAgICAgIGZhaWxlZFJlcXVlc3RzLFxuICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgcGxhdGZvcm1GaWVsZHMsXG4gICAgICAgIF0uam9pbihTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLkNBVEVHT1JZX1NFUEFSQVRPUik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQVBJIHRvIGNhY2hlIHRva2VuIGZhaWx1cmVzIGZvciBNU0VSIGRhdGEgY2FwdHVyZVxuICAgICAqIEBwYXJhbSBlcnJvclxuICAgICAqL1xuICAgIGNhY2hlRmFpbGVkUmVxdWVzdChlcnJvcjogdW5rbm93bik6IHZvaWQge1xuICAgICAgICBjb25zdCBsYXN0UmVxdWVzdHMgPSB0aGlzLmdldExhc3RSZXF1ZXN0cygpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBsYXN0UmVxdWVzdHMuZXJyb3JzLmxlbmd0aCA+PVxuICAgICAgICAgICAgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5NQVhfQ0FDSEVEX0VSUk9SU1xuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhIGNhY2hlZCBlcnJvciB0byBtYWtlIHJvb20sIGZpcnN0IGluIGZpcnN0IG91dFxuICAgICAgICAgICAgbGFzdFJlcXVlc3RzLmZhaWxlZFJlcXVlc3RzLnNoaWZ0KCk7IC8vIGFwaUlkXG4gICAgICAgICAgICBsYXN0UmVxdWVzdHMuZmFpbGVkUmVxdWVzdHMuc2hpZnQoKTsgLy8gY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgbGFzdFJlcXVlc3RzLmVycm9ycy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFJlcXVlc3RzLmZhaWxlZFJlcXVlc3RzLnB1c2godGhpcy5hcGlJZCwgdGhpcy5jb3JyZWxhdGlvbklkKTtcblxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhIWVycm9yICYmIGVycm9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdWJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UmVxdWVzdHMuZXJyb3JzLnB1c2goZXJyb3Iuc3ViRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuZXJyb3JDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0cy5lcnJvcnMucHVzaChlcnJvci5lcnJvckNvZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0cy5lcnJvcnMucHVzaChlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0cy5lcnJvcnMucHVzaChlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0cy5lcnJvcnMucHVzaChTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlVOS05PV05fRVJST1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIuc2V0U2VydmVyVGVsZW1ldHJ5KFxuICAgICAgICAgICAgdGhpcy50ZWxlbWV0cnlDYWNoZUtleSxcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0c1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc2VydmVyIHRlbGVtZXRyeSBjYWNoZSBlbnRyeSBieSBpbmNyZW1lbnRpbmcgY2FjaGUgaGl0IGNvdW50ZXJcbiAgICAgKi9cbiAgICBpbmNyZW1lbnRDYWNoZUhpdHMoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbGFzdFJlcXVlc3RzID0gdGhpcy5nZXRMYXN0UmVxdWVzdHMoKTtcbiAgICAgICAgbGFzdFJlcXVlc3RzLmNhY2hlSGl0cyArPSAxO1xuXG4gICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnNldFNlcnZlclRlbGVtZXRyeShcbiAgICAgICAgICAgIHRoaXMudGVsZW1ldHJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBsYXN0UmVxdWVzdHNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGxhc3RSZXF1ZXN0cy5jYWNoZUhpdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzZXJ2ZXIgdGVsZW1ldHJ5IGVudGl0eSBmcm9tIGNhY2hlIG9yIGluaXRpYWxpemUgYSBuZXcgb25lXG4gICAgICovXG4gICAgZ2V0TGFzdFJlcXVlc3RzKCk6IFNlcnZlclRlbGVtZXRyeUVudGl0eSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZTogU2VydmVyVGVsZW1ldHJ5RW50aXR5ID0ge1xuICAgICAgICAgICAgZmFpbGVkUmVxdWVzdHM6IFtdLFxuICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgIGNhY2hlSGl0czogMCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGFzdFJlcXVlc3RzID0gdGhpcy5jYWNoZU1hbmFnZXIuZ2V0U2VydmVyVGVsZW1ldHJ5KFxuICAgICAgICAgICAgdGhpcy50ZWxlbWV0cnlDYWNoZUtleVxuICAgICAgICApIGFzIFNlcnZlclRlbGVtZXRyeUVudGl0eTtcblxuICAgICAgICByZXR1cm4gbGFzdFJlcXVlc3RzIHx8IGluaXRpYWxWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc2VydmVyIHRlbGVtZXRyeSBjYWNoZSBlbnRyeVxuICAgICAqL1xuICAgIGNsZWFyVGVsZW1ldHJ5Q2FjaGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0cyA9IHRoaXMuZ2V0TGFzdFJlcXVlc3RzKCk7XG4gICAgICAgIGNvbnN0IG51bUVycm9yc0ZsdXNoZWQgPVxuICAgICAgICAgICAgU2VydmVyVGVsZW1ldHJ5TWFuYWdlci5tYXhFcnJvcnNUb1NlbmQobGFzdFJlcXVlc3RzKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb3VudCA9IGxhc3RSZXF1ZXN0cy5lcnJvcnMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtRXJyb3JzRmx1c2hlZCA9PT0gZXJyb3JDb3VudCkge1xuICAgICAgICAgICAgLy8gQWxsIGVycm9ycyB3ZXJlIHNlbnQgb24gbGFzdCByZXF1ZXN0LCBjbGVhciBUZWxlbWV0cnkgY2FjaGVcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnJlbW92ZUl0ZW0odGhpcy50ZWxlbWV0cnlDYWNoZUtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJ0aWFsIGRhdGEgd2FzIGZsdXNoZWQgdG8gc2VydmVyLCBjb25zdHJ1Y3QgYSBuZXcgdGVsZW1ldHJ5IGNhY2hlIGl0ZW0gd2l0aCBlcnJvcnMgdGhhdCB3ZXJlIG5vdCBmbHVzaGVkXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJUZWxlbUVudGl0eTogU2VydmVyVGVsZW1ldHJ5RW50aXR5ID0ge1xuICAgICAgICAgICAgICAgIGZhaWxlZFJlcXVlc3RzOiBsYXN0UmVxdWVzdHMuZmFpbGVkUmVxdWVzdHMuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIG51bUVycm9yc0ZsdXNoZWQgKiAyXG4gICAgICAgICAgICAgICAgKSwgLy8gZmFpbGVkUmVxdWVzdHMgY29udGFpbnMgMiBpdGVtcyBmb3IgZWFjaCBlcnJvclxuICAgICAgICAgICAgICAgIGVycm9yczogbGFzdFJlcXVlc3RzLmVycm9ycy5zbGljZShudW1FcnJvcnNGbHVzaGVkKSxcbiAgICAgICAgICAgICAgICBjYWNoZUhpdHM6IDAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5zZXRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgICAgICAgICAgdGhpcy50ZWxlbWV0cnlDYWNoZUtleSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUZWxlbUVudGl0eVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVycm9ycyB0aGF0IGNhbiBiZSBmbHVzaGVkIHRvIHRoZSBzZXJ2ZXIgaW4gdGhlIG5leHQgbmV0d29yayByZXF1ZXN0XG4gICAgICogQHBhcmFtIHNlcnZlclRlbGVtZXRyeUVudGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBtYXhFcnJvcnNUb1NlbmQoXG4gICAgICAgIHNlcnZlclRlbGVtZXRyeUVudGl0eTogU2VydmVyVGVsZW1ldHJ5RW50aXR5XG4gICAgKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBtYXhFcnJvcnMgPSAwO1xuICAgICAgICBsZXQgZGF0YVNpemUgPSAwO1xuICAgICAgICBjb25zdCBlcnJvckNvdW50ID0gc2VydmVyVGVsZW1ldHJ5RW50aXR5LmVycm9ycy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlcnJvckNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIC8vIGZhaWxlZFJlcXVlc3RzIHBhcmFtZXRlciBjb250YWlucyBwYWlycyBvZiBhcGlJZCBhbmQgY29ycmVsYXRpb25JZCwgbXVsdGlwbHkgaW5kZXggYnkgMiB0byBwcmVzZXJ2ZSBwYWlyc1xuICAgICAgICAgICAgY29uc3QgYXBpSWQgPVxuICAgICAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeUVudGl0eS5mYWlsZWRSZXF1ZXN0c1syICogaV0gfHxcbiAgICAgICAgICAgICAgICBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuICAgICAgICAgICAgY29uc3QgY29ycmVsYXRpb25JZCA9XG4gICAgICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5RW50aXR5LmZhaWxlZFJlcXVlc3RzWzIgKiBpICsgMV0gfHxcbiAgICAgICAgICAgICAgICBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID1cbiAgICAgICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlFbnRpdHkuZXJyb3JzW2ldIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XG5cbiAgICAgICAgICAgIC8vIENvdW50IG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd291bGQgYmUgYWRkZWQgdG8gaGVhZGVyLCBlYWNoIGNoYXJhY3RlciBpcyAxIGJ5dGUuIEFkZCAzIGF0IHRoZSBlbmQgdG8gYWNjb3VudCBmb3Igc2VwYXJhdG9yc1xuICAgICAgICAgICAgZGF0YVNpemUgKz1cbiAgICAgICAgICAgICAgICBhcGlJZC50b1N0cmluZygpLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZC50b1N0cmluZygpLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgMztcblxuICAgICAgICAgICAgaWYgKGRhdGFTaXplIDwgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5NQVhfTEFTVF9IRUFERVJfQllURVMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGhpcyBlbnRyeSB0byB0aGUgaGVhZGVyIHdvdWxkIHN0aWxsIGtlZXAgaGVhZGVyIHNpemUgYmVsb3cgdGhlIGxpbWl0XG4gICAgICAgICAgICAgICAgbWF4RXJyb3JzICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heEVycm9ycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlZ2lvbiBkaXNjb3ZlcnkgZmllbGRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRSZWdpb25EaXNjb3ZlcnlGaWVsZHMoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVnaW9uRGlzY292ZXJ5RmllbGRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIHJlZ2lvbkRpc2NvdmVyeUZpZWxkcy5wdXNoKHRoaXMucmVnaW9uVXNlZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgcmVnaW9uRGlzY292ZXJ5RmllbGRzLnB1c2godGhpcy5yZWdpb25Tb3VyY2UgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyk7XG4gICAgICAgIHJlZ2lvbkRpc2NvdmVyeUZpZWxkcy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5yZWdpb25PdXRjb21lIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkdcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gcmVnaW9uRGlzY292ZXJ5RmllbGRzLmpvaW4oXCIsXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcmVnaW9uIGRpc2NvdmVyeSBtZXRhZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIHVwZGF0ZVJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhKFxuICAgICAgICByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YTogUmVnaW9uRGlzY292ZXJ5TWV0YWRhdGFcbiAgICApOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZWdpb25Vc2VkID0gcmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX3VzZWQ7XG4gICAgICAgIHRoaXMucmVnaW9uU291cmNlID0gcmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX3NvdXJjZTtcbiAgICAgICAgdGhpcy5yZWdpb25PdXRjb21lID0gcmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX291dGNvbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGNhY2hlIG91dGNvbWVcbiAgICAgKi9cbiAgICBzZXRDYWNoZU91dGNvbWUoY2FjaGVPdXRjb21lOiBDYWNoZU91dGNvbWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jYWNoZU91dGNvbWUgPSBjYWNoZU91dGNvbWU7XG4gICAgfVxuXG4gICAgc2V0TmF0aXZlQnJva2VyRXJyb3JDb2RlKGVycm9yQ29kZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0cyA9IHRoaXMuZ2V0TGFzdFJlcXVlc3RzKCk7XG4gICAgICAgIGxhc3RSZXF1ZXN0cy5uYXRpdmVCcm9rZXJFcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnNldFNlcnZlclRlbGVtZXRyeShcbiAgICAgICAgICAgIHRoaXMudGVsZW1ldHJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBsYXN0UmVxdWVzdHNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXROYXRpdmVCcm9rZXJFcnJvckNvZGUoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdFJlcXVlc3RzKCkubmF0aXZlQnJva2VyRXJyb3JDb2RlO1xuICAgIH1cblxuICAgIGNsZWFyTmF0aXZlQnJva2VyRXJyb3JDb2RlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBsYXN0UmVxdWVzdHMgPSB0aGlzLmdldExhc3RSZXF1ZXN0cygpO1xuICAgICAgICBkZWxldGUgbGFzdFJlcXVlc3RzLm5hdGl2ZUJyb2tlckVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIuc2V0U2VydmVyVGVsZW1ldHJ5KFxuICAgICAgICAgICAgdGhpcy50ZWxlbWV0cnlDYWNoZUtleSxcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBtYWtlRXh0cmFTa3VTdHJpbmcocGFyYW1zOiBTa3VQYXJhbXMpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gbWFrZUV4dHJhU2t1U3RyaW5nKHBhcmFtcyk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEFjY291bnRDYWNoZSxcbiAgICBJZFRva2VuQ2FjaGUsXG4gICAgQWNjZXNzVG9rZW5DYWNoZSxcbiAgICBSZWZyZXNoVG9rZW5DYWNoZSxcbiAgICBBcHBNZXRhZGF0YUNhY2hlLFxuICAgIEFjY291bnRFbnRpdHksXG4gICAgSWRUb2tlbkVudGl0eSxcbiAgICBBY2Nlc3NUb2tlbkVudGl0eSxcbiAgICBSZWZyZXNoVG9rZW5FbnRpdHksXG4gICAgQ2FjaGVNYW5hZ2VyLFxuICAgIENyZWRlbnRpYWxUeXBlLFxuICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLFxufSBmcm9tIFwiQGF6dXJlL21zYWwtY29tbW9uL25vZGVcIjtcbmltcG9ydCB7XG4gICAgSnNvbkNhY2hlLFxuICAgIEluTWVtb3J5Q2FjaGUsXG4gICAgU2VyaWFsaXplZEFjY291bnRFbnRpdHksXG4gICAgU2VyaWFsaXplZElkVG9rZW5FbnRpdHksXG4gICAgU2VyaWFsaXplZEFjY2Vzc1Rva2VuRW50aXR5LFxuICAgIFNlcmlhbGl6ZWRSZWZyZXNoVG9rZW5FbnRpdHksXG4gICAgU2VyaWFsaXplZEFwcE1ldGFkYXRhRW50aXR5LFxufSBmcm9tIFwiLi9TZXJpYWxpemVyVHlwZXMuanNcIjtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGRlc2VyaWFsaXplcyBjYWNoZSBlbnRpdGllcyByZWFkIGZyb20gdGhlIGZpbGUgaW50byBpbi1tZW1vcnkgb2JqZWN0IHR5cGVzIGRlZmluZWQgaW50ZXJuYWxseVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXNlcmlhbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBKU09OIGJsb2IgaW4gbWVtb3J5IGFuZCBkZXNlcmlhbGl6ZSB0aGUgY29udGVudFxuICAgICAqIEBwYXJhbSBjYWNoZWRKc29uIC0gSlNPTiBibG9iIGNhY2hlXG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplSlNPTkJsb2IoanNvbkZpbGU6IHN0cmluZyk6IEpzb25DYWNoZSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZENhY2hlID0gIWpzb25GaWxlID8ge30gOiBKU09OLnBhcnNlKGpzb25GaWxlKTtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplZENhY2hlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhY2NvdW50cyB0byBBY2NvdW50RW50aXR5IG9iamVjdHNcbiAgICAgKiBAcGFyYW0gYWNjb3VudHMgLSBhY2NvdW50cyBvZiB0eXBlIFNlcmlhbGl6ZWRBY2NvdW50RW50aXR5XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplQWNjb3VudHMoXG4gICAgICAgIGFjY291bnRzOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkQWNjb3VudEVudGl0eT5cbiAgICApOiBBY2NvdW50Q2FjaGUge1xuICAgICAgICBjb25zdCBhY2NvdW50T2JqZWN0czogQWNjb3VudENhY2hlID0ge307XG4gICAgICAgIGlmIChhY2NvdW50cykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYWNjb3VudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZEFjYyA9IGFjY291bnRzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkQWNjID0ge1xuICAgICAgICAgICAgICAgICAgICBob21lQWNjb3VudElkOiBzZXJpYWxpemVkQWNjLmhvbWVfYWNjb3VudF9pZCxcbiAgICAgICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHNlcmlhbGl6ZWRBY2MuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlYWxtOiBzZXJpYWxpemVkQWNjLnJlYWxtLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbEFjY291bnRJZDogc2VyaWFsaXplZEFjYy5sb2NhbF9hY2NvdW50X2lkLFxuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogc2VyaWFsaXplZEFjYy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXV0aG9yaXR5VHlwZTogc2VyaWFsaXplZEFjYy5hdXRob3JpdHlfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc2VyaWFsaXplZEFjYy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJbmZvOiBzZXJpYWxpemVkQWNjLmNsaWVudF9pbmZvLFxuICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpY2F0aW9uVGltZTogc2VyaWFsaXplZEFjYy5sYXN0X21vZGlmaWNhdGlvbl90aW1lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpY2F0aW9uQXBwOiBzZXJpYWxpemVkQWNjLmxhc3RfbW9kaWZpY2F0aW9uX2FwcCxcbiAgICAgICAgICAgICAgICAgICAgdGVuYW50UHJvZmlsZXM6IHNlcmlhbGl6ZWRBY2MudGVuYW50UHJvZmlsZXM/Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXJpYWxpemVkVGVuYW50UHJvZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWRUZW5hbnRQcm9maWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQ6IEFjY291bnRFbnRpdHkgPSBuZXcgQWNjb3VudEVudGl0eSgpO1xuICAgICAgICAgICAgICAgIENhY2hlTWFuYWdlci50b09iamVjdChhY2NvdW50LCBtYXBwZWRBY2MpO1xuICAgICAgICAgICAgICAgIGFjY291bnRPYmplY3RzW2tleV0gPSBhY2NvdW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjb3VudE9iamVjdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGlkIHRva2VucyB0byBJZFRva2VuRW50aXR5IG9iamVjdHNcbiAgICAgKiBAcGFyYW0gaWRUb2tlbnMgLSBjcmVkZW50aWFscyBvZiB0eXBlIFNlcmlhbGl6ZWRJZFRva2VuRW50aXR5XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplSWRUb2tlbnMoXG4gICAgICAgIGlkVG9rZW5zOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkSWRUb2tlbkVudGl0eT5cbiAgICApOiBJZFRva2VuQ2FjaGUge1xuICAgICAgICBjb25zdCBpZE9iamVjdHM6IElkVG9rZW5DYWNoZSA9IHt9O1xuICAgICAgICBpZiAoaWRUb2tlbnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGlkVG9rZW5zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRJZFQgPSBpZFRva2Vuc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkVG9rZW46IElkVG9rZW5FbnRpdHkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHNlcmlhbGl6ZWRJZFQuaG9tZV9hY2NvdW50X2lkLFxuICAgICAgICAgICAgICAgICAgICBlbnZpcm9ubWVudDogc2VyaWFsaXplZElkVC5lbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbFR5cGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkSWRULmNyZWRlbnRpYWxfdHlwZSBhcyBDcmVkZW50aWFsVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IHNlcmlhbGl6ZWRJZFQuY2xpZW50X2lkLFxuICAgICAgICAgICAgICAgICAgICBzZWNyZXQ6IHNlcmlhbGl6ZWRJZFQuc2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICByZWFsbTogc2VyaWFsaXplZElkVC5yZWFsbSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlkT2JqZWN0c1trZXldID0gaWRUb2tlbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZE9iamVjdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGFjY2VzcyB0b2tlbnMgdG8gQWNjZXNzVG9rZW5FbnRpdHkgb2JqZWN0c1xuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbnMgLSBhY2Nlc3MgdG9rZW5zIG9mIHR5cGUgU2VyaWFsaXplZEFjY2Vzc1Rva2VuRW50aXR5XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplQWNjZXNzVG9rZW5zKFxuICAgICAgICBhY2Nlc3NUb2tlbnM6IFJlY29yZDxzdHJpbmcsIFNlcmlhbGl6ZWRBY2Nlc3NUb2tlbkVudGl0eT5cbiAgICApOiBBY2Nlc3NUb2tlbkNhY2hlIHtcbiAgICAgICAgY29uc3QgYXRPYmplY3RzOiBBY2Nlc3NUb2tlbkNhY2hlID0ge307XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFjY2Vzc1Rva2VucykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQVQgPSBhY2Nlc3NUb2tlbnNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbjogQWNjZXNzVG9rZW5FbnRpdHkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHNlcmlhbGl6ZWRBVC5ob21lX2FjY291bnRfaWQsXG4gICAgICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBzZXJpYWxpemVkQVQuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZEFULmNyZWRlbnRpYWxfdHlwZSBhcyBDcmVkZW50aWFsVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IHNlcmlhbGl6ZWRBVC5jbGllbnRfaWQsXG4gICAgICAgICAgICAgICAgICAgIHNlY3JldDogc2VyaWFsaXplZEFULnNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgcmVhbG06IHNlcmlhbGl6ZWRBVC5yZWFsbSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBzZXJpYWxpemVkQVQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZWRBdDogc2VyaWFsaXplZEFULmNhY2hlZF9hdCxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlc09uOiBzZXJpYWxpemVkQVQuZXhwaXJlc19vbixcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRFeHBpcmVzT246IHNlcmlhbGl6ZWRBVC5leHRlbmRlZF9leHBpcmVzX29uLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoT246IHNlcmlhbGl6ZWRBVC5yZWZyZXNoX29uLFxuICAgICAgICAgICAgICAgICAgICBrZXlJZDogc2VyaWFsaXplZEFULmtleV9pZCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBzZXJpYWxpemVkQVQudG9rZW5fdHlwZSBhcyBBdXRoZW50aWNhdGlvblNjaGVtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkQ2xhaW1zOiBzZXJpYWxpemVkQVQucmVxdWVzdGVkQ2xhaW1zLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRDbGFpbXNIYXNoOiBzZXJpYWxpemVkQVQucmVxdWVzdGVkQ2xhaW1zSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgdXNlckFzc2VydGlvbkhhc2g6IHNlcmlhbGl6ZWRBVC51c2VyQXNzZXJ0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF0T2JqZWN0c1trZXldID0gYWNjZXNzVG9rZW47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdE9iamVjdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIHJlZnJlc2ggdG9rZW5zIHRvIFJlZnJlc2hUb2tlbkVudGl0eSBvYmplY3RzXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbnMgLSByZWZyZXNoIHRva2VucyBvZiB0eXBlIFNlcmlhbGl6ZWRSZWZyZXNoVG9rZW5FbnRpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemVSZWZyZXNoVG9rZW5zKFxuICAgICAgICByZWZyZXNoVG9rZW5zOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkUmVmcmVzaFRva2VuRW50aXR5PlxuICAgICk6IFJlZnJlc2hUb2tlbkNhY2hlIHtcbiAgICAgICAgY29uc3QgcnRPYmplY3RzOiBSZWZyZXNoVG9rZW5DYWNoZSA9IHt9O1xuICAgICAgICBpZiAocmVmcmVzaFRva2Vucykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVmcmVzaFRva2VucykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkUlQgPSByZWZyZXNoVG9rZW5zW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuOiBSZWZyZXNoVG9rZW5FbnRpdHkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHNlcmlhbGl6ZWRSVC5ob21lX2FjY291bnRfaWQsXG4gICAgICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBzZXJpYWxpemVkUlQuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZFJULmNyZWRlbnRpYWxfdHlwZSBhcyBDcmVkZW50aWFsVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IHNlcmlhbGl6ZWRSVC5jbGllbnRfaWQsXG4gICAgICAgICAgICAgICAgICAgIHNlY3JldDogc2VyaWFsaXplZFJULnNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgZmFtaWx5SWQ6IHNlcmlhbGl6ZWRSVC5mYW1pbHlfaWQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogc2VyaWFsaXplZFJULnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgcmVhbG06IHNlcmlhbGl6ZWRSVC5yZWFsbSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJ0T2JqZWN0c1trZXldID0gcmVmcmVzaFRva2VuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnRPYmplY3RzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhcHBNZXRhZGF0YSB0byBBcHBNZXRhRGF0YSBvYmplY3RzXG4gICAgICogQHBhcmFtIGFwcE1ldGFkYXRhIC0gYXBwIG1ldGFkYXRhIG9mIHR5cGUgU2VyaWFsaXplZEFwcE1ldGFkYXRhRW50aXR5XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplQXBwTWV0YWRhdGEoXG4gICAgICAgIGFwcE1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkQXBwTWV0YWRhdGFFbnRpdHk+XG4gICAgKTogQXBwTWV0YWRhdGFDYWNoZSB7XG4gICAgICAgIGNvbnN0IGFwcE1ldGFkYXRhT2JqZWN0czogQXBwTWV0YWRhdGFDYWNoZSA9IHt9O1xuICAgICAgICBpZiAoYXBwTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFwcE1ldGFkYXRhKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBbWR0ID0gYXBwTWV0YWRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBhcHBNZXRhZGF0YU9iamVjdHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IHNlcmlhbGl6ZWRBbWR0LmNsaWVudF9pZCxcbiAgICAgICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHNlcmlhbGl6ZWRBbWR0LmVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICAgICBmYW1pbHlJZDogc2VyaWFsaXplZEFtZHQuZmFtaWx5X2lkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcHBNZXRhZGF0YU9iamVjdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgYW4gaW5NZW1vcnkgQ2FjaGVcbiAgICAgKiBAcGFyYW0ganNvbkNhY2hlIC0gSlNPTiBibG9iIGNhY2hlXG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplQWxsQ2FjaGUoanNvbkNhY2hlOiBKc29uQ2FjaGUpOiBJbk1lbW9yeUNhY2hlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRzOiBqc29uQ2FjaGUuQWNjb3VudFxuICAgICAgICAgICAgICAgID8gdGhpcy5kZXNlcmlhbGl6ZUFjY291bnRzKGpzb25DYWNoZS5BY2NvdW50KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBpZFRva2VuczoganNvbkNhY2hlLklkVG9rZW5cbiAgICAgICAgICAgICAgICA/IHRoaXMuZGVzZXJpYWxpemVJZFRva2Vucyhqc29uQ2FjaGUuSWRUb2tlbilcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5zOiBqc29uQ2FjaGUuQWNjZXNzVG9rZW5cbiAgICAgICAgICAgICAgICA/IHRoaXMuZGVzZXJpYWxpemVBY2Nlc3NUb2tlbnMoanNvbkNhY2hlLkFjY2Vzc1Rva2VuKVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICByZWZyZXNoVG9rZW5zOiBqc29uQ2FjaGUuUmVmcmVzaFRva2VuXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRlc2VyaWFsaXplUmVmcmVzaFRva2Vucyhqc29uQ2FjaGUuUmVmcmVzaFRva2VuKVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBhcHBNZXRhZGF0YToganNvbkNhY2hlLkFwcE1ldGFkYXRhXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRlc2VyaWFsaXplQXBwTWV0YWRhdGEoanNvbkNhY2hlLkFwcE1ldGFkYXRhKVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBIdHRwU3RhdHVzIH0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBMaW5lYXJSZXRyeVBvbGljeSB9IGZyb20gXCIuLi9yZXRyeS9MaW5lYXJSZXRyeVBvbGljeS5qc1wiO1xuXG4vLyBNU0kgQ29uc3RhbnRzLiBEb2NzIGZvciBNU0kgYXJlIGF2YWlsYWJsZSBoZXJlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2F6dXJlL2FwcC1zZXJ2aWNlL292ZXJ2aWV3LW1hbmFnZWQtaWRlbnRpdHlcbmV4cG9ydCBjb25zdCBBVVRIT1JJWkFUSU9OX0hFQURFUl9OQU1FOiBzdHJpbmcgPSBcIkF1dGhvcml6YXRpb25cIjtcbmV4cG9ydCBjb25zdCBNRVRBREFUQV9IRUFERVJfTkFNRTogc3RyaW5nID0gXCJNZXRhZGF0YVwiO1xuZXhwb3J0IGNvbnN0IEFQUF9TRVJWSUNFX1NFQ1JFVF9IRUFERVJfTkFNRTogc3RyaW5nID0gXCJYLUlERU5USVRZLUhFQURFUlwiO1xuZXhwb3J0IGNvbnN0IE1MX0FORF9TRl9TRUNSRVRfSEVBREVSX05BTUU6IHN0cmluZyA9IFwic2VjcmV0XCI7XG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT05fUVVFUllfUEFSQU1FVEVSX05BTUU6IHN0cmluZyA9IFwiYXBpLXZlcnNpb25cIjtcbmV4cG9ydCBjb25zdCBSRVNPVVJDRV9CT0RZX09SX1FVRVJZX1BBUkFNRVRFUl9OQU1FOiBzdHJpbmcgPSBcInJlc291cmNlXCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX0lEID0gXCJzeXN0ZW1fYXNzaWduZWRfbWFuYWdlZF9pZGVudGl0eVwiO1xuZXhwb3J0IGNvbnN0IE1BTkFHRURfSURFTlRJVFlfREVGQVVMVF9URU5BTlQgPSBcIm1hbmFnZWRfaWRlbnRpdHlcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0FVVEhPUklUWV9GT1JfTUFOQUdFRF9JREVOVElUWSA9IGBodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vJHtNQU5BR0VEX0lERU5USVRZX0RFRkFVTFRfVEVOQU5UfS9gO1xuXG4vKipcbiAqIE1hbmFnZWQgSWRlbnRpdHkgRW52aXJvbm1lbnQgVmFyaWFibGUgTmFtZXNcbiAqL1xuZXhwb3J0IGNvbnN0IE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcyA9IHtcbiAgICBBWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1Q6IFwiQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NUXCIsXG4gICAgSURFTlRJVFlfRU5EUE9JTlQ6IFwiSURFTlRJVFlfRU5EUE9JTlRcIixcbiAgICBJREVOVElUWV9IRUFERVI6IFwiSURFTlRJVFlfSEVBREVSXCIsXG4gICAgSURFTlRJVFlfU0VSVkVSX1RIVU1CUFJJTlQ6IFwiSURFTlRJVFlfU0VSVkVSX1RIVU1CUFJJTlRcIixcbiAgICBJTURTX0VORFBPSU5UOiBcIklNRFNfRU5EUE9JTlRcIixcbiAgICBNU0lfRU5EUE9JTlQ6IFwiTVNJX0VORFBPSU5UXCIsXG4gICAgTVNJX1NFQ1JFVDogXCJNU0lfU0VDUkVUXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzID1cbiAgICAodHlwZW9mIE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcylba2V5b2YgdHlwZW9mIE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lc107XG5cbi8qKlxuICogTWFuYWdlZCBJZGVudGl0eSBTb3VyY2UgTmFtZXNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzID0ge1xuICAgIEFQUF9TRVJWSUNFOiBcIkFwcFNlcnZpY2VcIixcbiAgICBBWlVSRV9BUkM6IFwiQXp1cmVBcmNcIixcbiAgICBDTE9VRF9TSEVMTDogXCJDbG91ZFNoZWxsXCIsXG4gICAgREVGQVVMVF9UT19JTURTOiBcIkRlZmF1bHRUb0ltZHNcIixcbiAgICBJTURTOiBcIkltZHNcIixcbiAgICBNQUNISU5FX0xFQVJOSU5HOiBcIk1hY2hpbmVMZWFybmluZ1wiLFxuICAgIFNFUlZJQ0VfRkFCUklDOiBcIlNlcnZpY2VGYWJyaWNcIixcbn0gYXMgY29uc3Q7XG4vKipcbiAqIFRoZSBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcyB0eXBlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzID1cbiAgICAodHlwZW9mIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzKVtrZXlvZiB0eXBlb2YgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXNdO1xuXG4vKipcbiAqIE1hbmFnZWQgSWRlbnRpdHkgSWRzXG4gKi9cbmV4cG9ydCBjb25zdCBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUgPSB7XG4gICAgU1lTVEVNX0FTU0lHTkVEOiBcInN5c3RlbS1hc3NpZ25lZFwiLFxuICAgIFVTRVJfQVNTSUdORURfQ0xJRU5UX0lEOiBcInVzZXItYXNzaWduZWQtY2xpZW50LWlkXCIsXG4gICAgVVNFUl9BU1NJR05FRF9SRVNPVVJDRV9JRDogXCJ1c2VyLWFzc2lnbmVkLXJlc291cmNlLWlkXCIsXG4gICAgVVNFUl9BU1NJR05FRF9PQkpFQ1RfSUQ6IFwidXNlci1hc3NpZ25lZC1vYmplY3QtaWRcIixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUgPVxuICAgICh0eXBlb2YgTWFuYWdlZElkZW50aXR5SWRUeXBlKVtrZXlvZiB0eXBlb2YgTWFuYWdlZElkZW50aXR5SWRUeXBlXTtcblxuLyoqXG4gKiBodHRwIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGNvbnN0IEh0dHBNZXRob2QgPSB7XG4gICAgR0VUOiBcImdldFwiLFxuICAgIFBPU1Q6IFwicG9zdFwiLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIEh0dHBNZXRob2QgPSAodHlwZW9mIEh0dHBNZXRob2QpW2tleW9mIHR5cGVvZiBIdHRwTWV0aG9kXTtcblxuZXhwb3J0IGNvbnN0IFByb3h5U3RhdHVzID0ge1xuICAgIFNVQ0NFU1M6IEh0dHBTdGF0dXMuU1VDQ0VTUyxcbiAgICBTVUNDRVNTX1JBTkdFX1NUQVJUOiBIdHRwU3RhdHVzLlNVQ0NFU1NfUkFOR0VfU1RBUlQsXG4gICAgU1VDQ0VTU19SQU5HRV9FTkQ6IEh0dHBTdGF0dXMuU1VDQ0VTU19SQU5HRV9FTkQsXG4gICAgU0VSVkVSX0VSUk9SOiBIdHRwU3RhdHVzLlNFUlZFUl9FUlJPUixcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBQcm94eVN0YXR1cyA9ICh0eXBlb2YgUHJveHlTdGF0dXMpW2tleW9mIHR5cGVvZiBQcm94eVN0YXR1c107XG5cbi8qKlxuICogQ29uc3RhbnRzIHVzZWQgZm9yIHJlZ2lvbiBkaXNjb3ZlcnlcbiAqL1xuZXhwb3J0IGNvbnN0IFJFR0lPTl9FTlZJUk9OTUVOVF9WQVJJQUJMRSA9IFwiUkVHSU9OX05BTUVcIjtcbmV4cG9ydCBjb25zdCBNU0FMX0ZPUkNFX1JFR0lPTiA9IFwiTVNBTF9GT1JDRV9SRUdJT05cIjtcblxuLyoqXG4gKiBDb25zdGFudCB1c2VkIGZvciBQS0NFXG4gKi9cbmV4cG9ydCBjb25zdCBSQU5ET01fT0NURVRfU0laRSA9IDMyO1xuXG4vKipcbiAqIENvbnN0YW50cyB1c2VkIGluIFBLQ0VcbiAqL1xuZXhwb3J0IGNvbnN0IEhhc2ggPSB7XG4gICAgU0hBMjU2OiBcInNoYTI1NlwiLFxufTtcblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGVuY29kaW5nIHNjaGVtZXNcbiAqL1xuZXhwb3J0IGNvbnN0IENoYXJTZXQgPSB7XG4gICAgQ1ZfQ0hBUlNFVDpcbiAgICAgICAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS0uX35cIixcbn07XG5cbi8qKlxuICogQ2FjaGUgQ29uc3RhbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBDQUNIRSA9IHtcbiAgICBGSUxFX0NBQ0hFOiBcImZpbGVDYWNoZVwiLFxuICAgIEVYVEVOU0lPTl9MSUI6IFwiZXh0ZW5zdGlvbl9saWJyYXJ5XCIsXG59O1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5leHBvcnQgY29uc3QgQ29uc3RhbnRzID0ge1xuICAgIE1TQUxfU0tVOiBcIm1zYWwuanMubm9kZVwiLFxuICAgIEpXVF9CRUFSRVJfQVNTRVJUSU9OX1RZUEU6XG4gICAgICAgIFwidXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyXCIsXG4gICAgQVVUSE9SSVpBVElPTl9QRU5ESU5HOiBcImF1dGhvcml6YXRpb25fcGVuZGluZ1wiLFxuICAgIEhUVFBfUFJPVE9DT0w6IFwiaHR0cDovL1wiLFxuICAgIExPQ0FMSE9TVDogXCJsb2NhbGhvc3RcIixcbn07XG5cbi8qKlxuICogQVBJIENvZGVzIGZvciBUZWxlbWV0cnkgcHVycG9zZXMuXG4gKiBCZWZvcmUgYWRkaW5nIGEgbmV3IGNvZGUgeW91IG11c3QgY2xhaW0gaXQgaW4gdGhlIE1TQUwgVGVsZW1ldHJ5IHRyYWNrZXIgYXMgdGhlc2UgbnVtYmVyIHNwYWNlcyBhcmUgc2hhcmVkIGFjcm9zcyBhbGwgTVNBTHNcbiAqIDAtOTkgU2lsZW50IEZsb3dcbiAqIDYwMC02OTkgRGV2aWNlIENvZGUgRmxvd1xuICogODAwLTg5OSBBdXRoIENvZGUgRmxvd1xuICovXG5leHBvcnQgY29uc3QgQXBpSWQgPSB7XG4gICAgYWNxdWlyZVRva2VuU2lsZW50OiA2MixcbiAgICBhY3F1aXJlVG9rZW5CeVVzZXJuYW1lUGFzc3dvcmQ6IDM3MSxcbiAgICBhY3F1aXJlVG9rZW5CeURldmljZUNvZGU6IDY3MSxcbiAgICBhY3F1aXJlVG9rZW5CeUNsaWVudENyZWRlbnRpYWw6IDc3MSxcbiAgICBhY3F1aXJlVG9rZW5CeUNvZGU6IDg3MSxcbiAgICBhY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbjogODcyLFxufTtcbmV4cG9ydCB0eXBlIEFwaUlkID0gKHR5cGVvZiBBcGlJZClba2V5b2YgdHlwZW9mIEFwaUlkXTtcblxuLyoqXG4gKiBKV1QgIGNvbnN0YW50c1xuICovXG5leHBvcnQgY29uc3QgSnd0Q29uc3RhbnRzID0ge1xuICAgIEFMR09SSVRITTogXCJhbGdcIixcbiAgICBSU0FfMjU2OiBcIlJTMjU2XCIsXG4gICAgUFNTXzI1NjogXCJQUzI1NlwiLFxuICAgIFg1VF8yNTY6IFwieDV0I1MyNTZcIixcbiAgICBYNVQ6IFwieDV0XCIsXG4gICAgWDVDOiBcIng1Y1wiLFxuICAgIEFVRElFTkNFOiBcImF1ZFwiLFxuICAgIEVYUElSQVRJT05fVElNRTogXCJleHBcIixcbiAgICBJU1NVRVI6IFwiaXNzXCIsXG4gICAgU1VCSkVDVDogXCJzdWJcIixcbiAgICBOT1RfQkVGT1JFOiBcIm5iZlwiLFxuICAgIEpXVF9JRDogXCJqdGlcIixcbn07XG5cbmV4cG9ydCBjb25zdCBMT09QQkFDS19TRVJWRVJfQ09OU1RBTlRTID0ge1xuICAgIElOVEVSVkFMX01TOiAxMDAsXG4gICAgVElNRU9VVF9NUzogNTAwMCxcbn07XG5cbmV4cG9ydCBjb25zdCBBWlVSRV9BUkNfU0VDUkVUX0ZJTEVfTUFYX1NJWkVfQllURVMgPSA0MDk2OyAvLyA0IEtCXG5cbmV4cG9ydCBjb25zdCBNQU5BR0VEX0lERU5USVRZX01BWF9SRVRSSUVTID0gMztcbmV4cG9ydCBjb25zdCBNQU5BR0VEX0lERU5USVRZX1JFVFJZX0RFTEFZID0gMTAwMDtcbmV4cG9ydCBjb25zdCBNQU5BR0VEX0lERU5USVRZX0hUVFBfU1RBVFVTX0NPREVTX1RPX1JFVFJZX09OID0gW1xuICAgIEh0dHBTdGF0dXMuTk9UX0ZPVU5ELFxuICAgIEh0dHBTdGF0dXMuUkVRVUVTVF9USU1FT1VULFxuICAgIEh0dHBTdGF0dXMuVE9PX01BTllfUkVRVUVTVFMsXG4gICAgSHR0cFN0YXR1cy5TRVJWRVJfRVJST1IsXG4gICAgSHR0cFN0YXR1cy5TRVJWSUNFX1VOQVZBSUxBQkxFLFxuICAgIEh0dHBTdGF0dXMuR0FURVdBWV9USU1FT1VULFxuXTtcblxuLyoqXG4gKiBSZXRyeSBQb2xpY3kgVHlwZXNcbiAqL1xuZXhwb3J0IHR5cGUgUmV0cnlQb2xpY2llcyA9IExpbmVhclJldHJ5UG9saWN5O1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBOZXR3b3JrUmVzcG9uc2UgfSBmcm9tIFwiQGF6dXJlL21zYWwtY29tbW9uL25vZGVcIjtcblxuZXhwb3J0IHR5cGUgVXJsVG9IdHRwUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgcHJvdG9jb2w6IHN0cmluZztcbiAgICBob3N0bmFtZTogc3RyaW5nO1xuICAgIGhhc2g6IHN0cmluZztcbiAgICBzZWFyY2g6IHN0cmluZztcbiAgICBwYXRobmFtZTogc3RyaW5nO1xuICAgIHBhdGg6IHN0cmluZztcbiAgICBocmVmOiBzdHJpbmc7XG4gICAgcG9ydD86IG51bWJlcjtcbiAgICBhdXRoPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGNsYXNzIE5ldHdvcmtVdGlscyB7XG4gICAgc3RhdGljIGdldE5ldHdvcmtSZXNwb25zZTxUPihcbiAgICAgICAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICAgICAgYm9keTogVCxcbiAgICAgICAgc3RhdHVzQ29kZTogbnVtYmVyXG4gICAgKTogTmV0d29ya1Jlc3BvbnNlPFQ+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNDb2RlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGEgVVJMIG9iamVjdCBpbnRvIGFuIG9yZGluYXJ5IG9wdGlvbnMgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZVxuICAgICAqIGh0dHAucmVxdWVzdCBhbmQgaHR0cHMucmVxdWVzdCBBUElzLlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL2ludGVybmFsL3VybC5qcyNMMTA5MFxuICAgICAqL1xuICAgIHN0YXRpYyB1cmxUb0h0dHBPcHRpb25zKHVybDogVVJMKTogVXJsVG9IdHRwUmVxdWVzdE9wdGlvbnMge1xuICAgICAgICBjb25zdCBvcHRpb25zOiBVcmxUb0h0dHBSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByb3RvY29sOiB1cmwucHJvdG9jb2wsXG4gICAgICAgICAgICBob3N0bmFtZTpcbiAgICAgICAgICAgICAgICB1cmwuaG9zdG5hbWUgJiYgdXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoXCJbXCIpXG4gICAgICAgICAgICAgICAgICAgID8gdXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgICAgICAgICAgICAgICAgICA6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIGhhc2g6IHVybC5oYXNoLFxuICAgICAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgICAgIHBhdGg6IGAke3VybC5wYXRobmFtZSB8fCBcIlwifSR7dXJsLnNlYXJjaCB8fCBcIlwifWAsXG4gICAgICAgICAgICBocmVmOiB1cmwuaHJlZixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHVybC5wb3J0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBOdW1iZXIodXJsLnBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwudXNlcm5hbWUgfHwgdXJsLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmF1dGggPSBgJHtkZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgdXJsLnVzZXJuYW1lXG4gICAgICAgICAgICApfToke2RlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIElOZXR3b3JrTW9kdWxlLFxuICAgIE5ldHdvcmtSZXF1ZXN0T3B0aW9ucyxcbiAgICBOZXR3b3JrUmVzcG9uc2UsXG4gICAgSHR0cFN0YXR1cyxcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBIdHRwTWV0aG9kLCBDb25zdGFudHMsIFByb3h5U3RhdHVzIH0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgTmV0d29ya1V0aWxzIH0gZnJvbSBcIi4uL3V0aWxzL05ldHdvcmtVdGlscy5qc1wiO1xuaW1wb3J0IGh0dHAgZnJvbSBcImh0dHBcIjtcbmltcG9ydCBodHRwcyBmcm9tIFwiaHR0cHNcIjtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIEFQSSBmb3IgbmV0d29yayByZXF1ZXN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEh0dHBDbGllbnQgaW1wbGVtZW50cyBJTmV0d29ya01vZHVsZSB7XG4gICAgcHJpdmF0ZSBwcm94eVVybDogc3RyaW5nO1xuICAgIHByaXZhdGUgY3VzdG9tQWdlbnRPcHRpb25zOiBodHRwLkFnZW50T3B0aW9ucyB8IGh0dHBzLkFnZW50T3B0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcm94eVVybD86IHN0cmluZyxcbiAgICAgICAgY3VzdG9tQWdlbnRPcHRpb25zPzogaHR0cC5BZ2VudE9wdGlvbnMgfCBodHRwcy5BZ2VudE9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgdGhpcy5wcm94eVVybCA9IHByb3h5VXJsIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuY3VzdG9tQWdlbnRPcHRpb25zID0gY3VzdG9tQWdlbnRPcHRpb25zIHx8IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEh0dHAgR2V0IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kR2V0UmVxdWVzdEFzeW5jPFQ+KFxuICAgICAgICB1cmw6IHN0cmluZyxcbiAgICAgICAgb3B0aW9ucz86IE5ldHdvcmtSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgdGltZW91dD86IG51bWJlclxuICAgICk6IFByb21pc2U8TmV0d29ya1Jlc3BvbnNlPFQ+PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3h5VXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29ya1JlcXVlc3RWaWFQcm94eShcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eVVybCxcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kLkdFVCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tQWdlbnRPcHRpb25zIGFzIGh0dHAuQWdlbnRPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVvdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29ya1JlcXVlc3RWaWFIdHRwcyhcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZC5HRVQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUFnZW50T3B0aW9ucyBhcyBodHRwcy5BZ2VudE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGltZW91dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEh0dHAgUG9zdCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHVybFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgc2VuZFBvc3RSZXF1ZXN0QXN5bmM8VD4oXG4gICAgICAgIHVybDogc3RyaW5nLFxuICAgICAgICBvcHRpb25zPzogTmV0d29ya1JlcXVlc3RPcHRpb25zXG4gICAgKTogUHJvbWlzZTxOZXR3b3JrUmVzcG9uc2U8VD4+IHtcbiAgICAgICAgaWYgKHRoaXMucHJveHlVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrUmVxdWVzdFZpYVByb3h5KFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5VXJsLFxuICAgICAgICAgICAgICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tQWdlbnRPcHRpb25zIGFzIGh0dHAuQWdlbnRPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtSZXF1ZXN0VmlhSHR0cHMoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tQWdlbnRPcHRpb25zIGFzIGh0dHBzLkFnZW50T3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbmV0d29ya1JlcXVlc3RWaWFQcm94eSA9IDxUPihcbiAgICBkZXN0aW5hdGlvblVybFN0cmluZzogc3RyaW5nLFxuICAgIHByb3h5VXJsU3RyaW5nOiBzdHJpbmcsXG4gICAgaHR0cE1ldGhvZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBOZXR3b3JrUmVxdWVzdE9wdGlvbnMsXG4gICAgYWdlbnRPcHRpb25zPzogaHR0cC5BZ2VudE9wdGlvbnMsXG4gICAgdGltZW91dD86IG51bWJlclxuKTogUHJvbWlzZTxOZXR3b3JrUmVzcG9uc2U8VD4+ID0+IHtcbiAgICBjb25zdCBkZXN0aW5hdGlvblVybCA9IG5ldyBVUkwoZGVzdGluYXRpb25VcmxTdHJpbmcpO1xuICAgIGNvbnN0IHByb3h5VXJsID0gbmV3IFVSTChwcm94eVVybFN0cmluZyk7XG5cbiAgICAvLyBcIm1ldGhvZDogY29ubmVjdFwiIG11c3QgYmUgdXNlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eVxuICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zPy5oZWFkZXJzIHx8ICh7fSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTtcbiAgICBjb25zdCB0dW5uZWxSZXF1ZXN0T3B0aW9uczogaHR0cHMuUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIGhvc3Q6IHByb3h5VXJsLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiBwcm94eVVybC5wb3J0LFxuICAgICAgICBtZXRob2Q6IFwiQ09OTkVDVFwiLFxuICAgICAgICBwYXRoOiBkZXN0aW5hdGlvblVybC5ob3N0bmFtZSxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICB9O1xuXG4gICAgaWYgKGFnZW50T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhhZ2VudE9wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICB0dW5uZWxSZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IG5ldyBodHRwLkFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9zZSBhIHJlcXVlc3Qgc3RyaW5nIGZvciB0aGUgc29ja2V0XG4gICAgbGV0IHBvc3RSZXF1ZXN0U3RyaW5nQ29udGVudDogc3RyaW5nID0gXCJcIjtcbiAgICBpZiAoaHR0cE1ldGhvZCA9PT0gSHR0cE1ldGhvZC5QT1NUKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zPy5ib2R5IHx8IFwiXCI7XG4gICAgICAgIHBvc3RSZXF1ZXN0U3RyaW5nQ29udGVudCA9XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxyXFxuXCIgK1xuICAgICAgICAgICAgYENvbnRlbnQtTGVuZ3RoOiAke2JvZHkubGVuZ3RofVxcclxcbmAgK1xuICAgICAgICAgICAgYFxcclxcbiR7Ym9keX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIHRpbWVvdXQgaXMgb25seSBmb3IgZ2V0IHJlcXVlc3RzIChyZWdpb25EaXNjb3ZlcnksIGZvciBleGFtcGxlKVxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgdHVubmVsUmVxdWVzdE9wdGlvbnMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0Z29pbmdSZXF1ZXN0U3RyaW5nID1cbiAgICAgICAgYCR7aHR0cE1ldGhvZC50b1VwcGVyQ2FzZSgpfSAke2Rlc3RpbmF0aW9uVXJsLmhyZWZ9IEhUVFAvMS4xXFxyXFxuYCArXG4gICAgICAgIGBIb3N0OiAke2Rlc3RpbmF0aW9uVXJsLmhvc3R9XFxyXFxuYCArXG4gICAgICAgIFwiQ29ubmVjdGlvbjogY2xvc2VcXHJcXG5cIiArXG4gICAgICAgIHBvc3RSZXF1ZXN0U3RyaW5nQ29udGVudCArXG4gICAgICAgIFwiXFxyXFxuXCI7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8TmV0d29ya1Jlc3BvbnNlPFQ+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwLnJlcXVlc3QodHVubmVsUmVxdWVzdE9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZSBvdXRcIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuXG4gICAgICAgIC8vIGVzdGFibGlzaCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eVxuICAgICAgICByZXF1ZXN0Lm9uKFwiY29ubmVjdFwiLCAocmVzcG9uc2UsIHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJveHlTdGF0dXNDb2RlID1cbiAgICAgICAgICAgICAgICByZXNwb25zZT8uc3RhdHVzQ29kZSB8fCBQcm94eVN0YXR1cy5TRVJWRVJfRVJST1I7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcHJveHlTdGF0dXNDb2RlIDwgUHJveHlTdGF0dXMuU1VDQ0VTU19SQU5HRV9TVEFSVCB8fFxuICAgICAgICAgICAgICAgIHByb3h5U3RhdHVzQ29kZSA+IFByb3h5U3RhdHVzLlNVQ0NFU1NfUkFOR0VfRU5EXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYEVycm9yIGNvbm5lY3RpbmcgdG8gcHJveHkuIEh0dHAgc3RhdHVzIGNvZGU6ICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfS4gSHR0cCBzdGF0dXMgbWVzc2FnZTogJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZT8uc3RhdHVzTWVzc2FnZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1ha2UgYSByZXF1ZXN0IG92ZXIgYW4gSFRUUCB0dW5uZWxcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShvdXRnb2luZ1JlcXVlc3RTdHJpbmcpO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhOiBCdWZmZXJbXSA9IFtdO1xuICAgICAgICAgICAgc29ja2V0Lm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNvY2tldC5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29tYmluZSBhbGwgcmVjZWl2ZWQgYnVmZmVyIHN0cmVhbXMgaW50byBvbmUgYnVmZmVyLCBhbmQgdGhlbiBpbnRvIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVN0cmluZyA9IEJ1ZmZlci5jb25jYXQoWy4uLmRhdGFdKS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgZWFjaCBsaW5lIGludG8gaXQncyBvd24gZW50cnkgaW4gYW4gYXJyeVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFTdHJpbmdBcnJheSA9IGRhdGFTdHJpbmcuc3BsaXQoXCJcXHJcXG5cIik7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGVudHJ5IHdpbGwgY29udGFpbiB0aGUgc3RhdHVzQ29kZSBhbmQgc3RhdHVzTWVzc2FnZVxuICAgICAgICAgICAgICAgIGNvbnN0IGh0dHBTdGF0dXNDb2RlID0gcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAgIGRhdGFTdHJpbmdBcnJheVswXS5zcGxpdChcIiBcIilbMV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBcIkhUVFAvMS4xXCIgYW5kIHRoZSBzdGF0dXMgY29kZSB0byBnZXQgdGhlIHN0YXR1cyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IGRhdGFTdHJpbmdBcnJheVswXVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIiBcIik7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGxhc3QgZW50cnkgd2lsbCBjb250YWluIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGRhdGFTdHJpbmdBcnJheVtkYXRhU3RyaW5nQXJyYXkubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAvLyBldmVyeXRoaW5nIGluIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IGVudHJpZXMgYXJlIHRoZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyc0FycmF5ID0gZGF0YVN0cmluZ0FycmF5LnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBkYXRhU3RyaW5nQXJyYXkubGVuZ3RoIC0gMlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBidWlsZCBhbiBvYmplY3Qgb3V0IG9mIGFsbCB0aGUgaGVhZGVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgaGVhZGVyc0FycmF5LmZvckVhY2goKGhlYWRlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGhlYWRlciBtaWdodCBsb29rIGxpa2UgXCJDb250ZW50LUxlbmd0aDogMTUzMVwiLCBidXQgdGhhdCBpcyBqdXN0IGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAqIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIGtleS92YWx1ZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgICAqIHNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIFwiOlwiIGlmIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyIGlzIHN1cHBvc2VkIHRvIGJlIGEgSlNPTiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcktleVZhbHVlID0gaGVhZGVyLnNwbGl0KG5ldyBSZWdFeHAoLzpcXHMoLiopL3MpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyS2V5ID0gaGVhZGVyS2V5VmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXJWYWx1ZSA9IGhlYWRlcktleVZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyIGlzIHN1cHBvc2VkIHRvIGJlIGEgSlNPTiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IEpTT04ucGFyc2UoaGVhZGVyVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcywgdGhlbiBjb252ZXJ0IGl0IGZyb20gYSBzdHJpbmcgdG8gYSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyVmFsdWUgPSBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgbGVhdmUgaXQgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMuc2V0KGhlYWRlcktleSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gaGVhZGVycyBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtSZXNwb25zZSA9IE5ldHdvcmtVdGlscy5nZXROZXR3b3JrUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlQm9keShcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICAgICAgICAgICkgYXMgVCxcbiAgICAgICAgICAgICAgICAgICAgaHR0cFN0YXR1c0NvZGVcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoaHR0cFN0YXR1c0NvZGUgPCBIdHRwU3RhdHVzLlNVQ0NFU1NfUkFOR0VfU1RBUlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlID4gSHR0cFN0YXR1cy5TVUNDRVNTX1JBTkdFX0VORCkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGRlc3Ryb3kgdGhlIHJlcXVlc3QgZm9yIHRoZSBkZXZpY2UgY29kZSBmbG93XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtSZXNwb25zZS5ib2R5W1wiZXJyb3JcIl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBDb25zdGFudHMuQVVUSE9SSVpBVElPTl9QRU5ESU5HXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ldHdvcmtSZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGNodW5rLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoY2h1bmsudG9TdHJpbmcoKSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IG5ldHdvcmtSZXF1ZXN0VmlhSHR0cHMgPSA8VD4oXG4gICAgdXJsU3RyaW5nOiBzdHJpbmcsXG4gICAgaHR0cE1ldGhvZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBOZXR3b3JrUmVxdWVzdE9wdGlvbnMsXG4gICAgYWdlbnRPcHRpb25zPzogaHR0cHMuQWdlbnRPcHRpb25zLFxuICAgIHRpbWVvdXQ/OiBudW1iZXJcbik6IFByb21pc2U8TmV0d29ya1Jlc3BvbnNlPFQ+PiA9PiB7XG4gICAgY29uc3QgaXNQb3N0UmVxdWVzdCA9IGh0dHBNZXRob2QgPT09IEh0dHBNZXRob2QuUE9TVDtcbiAgICBjb25zdCBib2R5OiBzdHJpbmcgPSBvcHRpb25zPy5ib2R5IHx8IFwiXCI7XG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnM/LmhlYWRlcnMgfHwgKHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pO1xuICAgIGNvbnN0IGN1c3RvbU9wdGlvbnM6IGh0dHBzLlJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IGh0dHBNZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIC4uLk5ldHdvcmtVdGlscy51cmxUb0h0dHBPcHRpb25zKHVybCksXG4gICAgfTtcblxuICAgIGlmIChhZ2VudE9wdGlvbnMgJiYgT2JqZWN0LmtleXMoYWdlbnRPcHRpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgY3VzdG9tT3B0aW9ucy5hZ2VudCA9IG5ldyBodHRwcy5BZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChpc1Bvc3RSZXF1ZXN0KSB7XG4gICAgICAgIC8vIG5lZWRlZCBmb3IgcG9zdCByZXF1ZXN0IHRvIHdvcmtcbiAgICAgICAgY3VzdG9tT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgLi4uY3VzdG9tT3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBib2R5Lmxlbmd0aCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvcHRpb25hbCB0aW1lb3V0IGlzIG9ubHkgZm9yIGdldCByZXF1ZXN0cyAocmVnaW9uRGlzY292ZXJ5LCBmb3IgZXhhbXBsZSlcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGN1c3RvbU9wdGlvbnMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8TmV0d29ya1Jlc3BvbnNlPFQ+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCByZXF1ZXN0OiBodHRwLkNsaWVudFJlcXVlc3Q7XG4gICAgICAgIC8vIG1hbmFnZWQgaWRlbnRpdHkgc291cmNlcyB1c2UgaHR0cCBpbnN0ZWFkIG9mIGh0dHBzXG4gICAgICAgIGlmIChjdXN0b21PcHRpb25zLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3VzdG9tT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChjdXN0b21PcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1Bvc3RSZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LndyaXRlKGJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qub24oXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCB0aW1lIG91dFwiKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG5cbiAgICAgICAgcmVxdWVzdC5vbihcInJlc3BvbnNlXCIsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZSBhcyBudW1iZXI7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzTWVzc2FnZTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YTogQnVmZmVyW10gPSBbXTtcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb21iaW5lIGFsbCByZWNlaXZlZCBidWZmZXIgc3RyZWFtcyBpbnRvIG9uZSBidWZmZXIsIGFuZCB0aGVuIGludG8gYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gQnVmZmVyLmNvbmNhdChbLi4uZGF0YV0pLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gaGVhZGVycyBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtSZXNwb25zZSA9IE5ldHdvcmtVdGlscy5nZXROZXR3b3JrUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlQm9keShcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgKSBhcyBULFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKHN0YXR1c0NvZGUgPCBIdHRwU3RhdHVzLlNVQ0NFU1NfUkFOR0VfU1RBUlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPiBIdHRwU3RhdHVzLlNVQ0NFU1NfUkFOR0VfRU5EKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgZGVzdHJveSB0aGUgcmVxdWVzdCBmb3IgdGhlIGRldmljZSBjb2RlIGZsb3dcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Jlc3BvbnNlLmJvZHlbXCJlcnJvclwiXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnN0YW50cy5BVVRIT1JJWkFUSU9OX1BFTkRJTkdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUobmV0d29ya1Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoY2h1bmsudG9TdHJpbmcoKSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZXh0cmEgcGFyc2luZyBpcyBuZWVkZWQgb24gdGhlIHJlcHNvbnNlIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIHN0YXR1c0NvZGUge251bWJlcn0gdGhlIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSBzdGF0dXNNZXNzYWdlIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRoZSBzdGF0dXMgbWVzc2FnZSBvZiB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gKiBAcGFyYW0gaGVhZGVycyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gdGhlIGhlYWRlcnMgb2YgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIGJvZHkge3N0cmluZ30gdGhlIGJvZHkgZnJvbSB0aGUgcmVzcG9uc2Ugb2YgdGhlIHNlcnZlclxuICogQHJldHVybnMge09iamVjdH0gSlNPTiBwYXJzZWQgYm9keSBvciBlcnJvciBvYmplY3RcbiAqL1xuY29uc3QgcGFyc2VCb2R5ID0gKFxuICAgIHN0YXR1c0NvZGU6IG51bWJlcixcbiAgICBzdGF0dXNNZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBib2R5OiBzdHJpbmdcbikgPT4ge1xuICAgIC8qXG4gICAgICogSW5mb3JtYXRpb25hbCByZXNwb25zZXMgKDEwMCBcdTIwMTMgMTk5KVxuICAgICAqIFN1Y2Nlc3NmdWwgcmVzcG9uc2VzICgyMDAgXHUyMDEzIDI5OSlcbiAgICAgKiBSZWRpcmVjdGlvbiBtZXNzYWdlcyAoMzAwIFx1MjAxMyAzOTkpXG4gICAgICogQ2xpZW50IGVycm9yIHJlc3BvbnNlcyAoNDAwIFx1MjAxMyA0OTkpXG4gICAgICogU2VydmVyIGVycm9yIHJlc3BvbnNlcyAoNTAwIFx1MjAxMyA1OTkpXG4gICAgICovXG5cbiAgICBsZXQgcGFyc2VkQm9keTtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsZXQgZXJyb3JUeXBlO1xuICAgICAgICBsZXQgZXJyb3JEZXNjcmlwdGlvbkhlbHBlcjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RhdHVzQ29kZSA+PSBIdHRwU3RhdHVzLkNMSUVOVF9FUlJPUl9SQU5HRV9TVEFSVCAmJlxuICAgICAgICAgICAgc3RhdHVzQ29kZSA8PSBIdHRwU3RhdHVzLkNMSUVOVF9FUlJPUl9SQU5HRV9FTkRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBlcnJvclR5cGUgPSBcImNsaWVudF9lcnJvclwiO1xuICAgICAgICAgICAgZXJyb3JEZXNjcmlwdGlvbkhlbHBlciA9IFwiQSBjbGllbnRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHN0YXR1c0NvZGUgPj0gSHR0cFN0YXR1cy5TRVJWRVJfRVJST1JfUkFOR0VfU1RBUlQgJiZcbiAgICAgICAgICAgIHN0YXR1c0NvZGUgPD0gSHR0cFN0YXR1cy5TRVJWRVJfRVJST1JfUkFOR0VfRU5EXG4gICAgICAgICkge1xuICAgICAgICAgICAgZXJyb3JUeXBlID0gXCJzZXJ2ZXJfZXJyb3JcIjtcbiAgICAgICAgICAgIGVycm9yRGVzY3JpcHRpb25IZWxwZXIgPSBcIkEgc2VydmVyXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvclR5cGUgPSBcInVua25vd25fZXJyb3JcIjtcbiAgICAgICAgICAgIGVycm9yRGVzY3JpcHRpb25IZWxwZXIgPSBcIkFuIHVua25vd25cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZEJvZHkgPSB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3JUeXBlLFxuICAgICAgICAgICAgZXJyb3JfZGVzY3JpcHRpb246IGAke2Vycm9yRGVzY3JpcHRpb25IZWxwZXJ9IGVycm9yIG9jY3VyZWQuXFxuSHR0cCBzdGF0dXMgY29kZTogJHtzdGF0dXNDb2RlfVxcbkh0dHAgc3RhdHVzIG1lc3NhZ2U6ICR7XG4gICAgICAgICAgICAgICAgc3RhdHVzTWVzc2FnZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgfVxcbkhlYWRlcnM6ICR7SlNPTi5zdHJpbmdpZnkoaGVhZGVycyl9YCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkQm9keTtcbn07XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcyB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcblxuZXhwb3J0IGNvbnN0IGludmFsaWRGaWxlRXh0ZW5zaW9uID0gXCJpbnZhbGlkX2ZpbGVfZXh0ZW5zaW9uXCI7XG5leHBvcnQgY29uc3QgaW52YWxpZEZpbGVQYXRoID0gXCJpbnZhbGlkX2ZpbGVfcGF0aFwiO1xuZXhwb3J0IGNvbnN0IGludmFsaWRNYW5hZ2VkSWRlbnRpdHlJZFR5cGUgPSBcImludmFsaWRfbWFuYWdlZF9pZGVudGl0eV9pZF90eXBlXCI7XG5leHBvcnQgY29uc3QgaW52YWxpZFNlY3JldCA9IFwiaW52YWxpZF9zZWNyZXRcIjtcbmV4cG9ydCBjb25zdCBtaXNzaW5nSWQgPSBcIm1pc3NpbmdfY2xpZW50X2lkXCI7XG5leHBvcnQgY29uc3QgbmV0d29ya1VuYXZhaWxhYmxlID0gXCJuZXR3b3JrX3VuYXZhaWxhYmxlXCI7XG5leHBvcnQgY29uc3QgcGxhdGZvcm1Ob3RTdXBwb3J0ZWQgPSBcInBsYXRmb3JtX25vdF9zdXBwb3J0ZWRcIjtcbmV4cG9ydCBjb25zdCB1bmFibGVUb0NyZWF0ZUF6dXJlQXJjID0gXCJ1bmFibGVfdG9fY3JlYXRlX2F6dXJlX2FyY1wiO1xuZXhwb3J0IGNvbnN0IHVuYWJsZVRvQ3JlYXRlQ2xvdWRTaGVsbCA9IFwidW5hYmxlX3RvX2NyZWF0ZV9jbG91ZF9zaGVsbFwiO1xuZXhwb3J0IGNvbnN0IHVuYWJsZVRvQ3JlYXRlU291cmNlID0gXCJ1bmFibGVfdG9fY3JlYXRlX3NvdXJjZVwiO1xuZXhwb3J0IGNvbnN0IHVuYWJsZVRvUmVhZFNlY3JldEZpbGUgPSBcInVuYWJsZV90b19yZWFkX3NlY3JldF9maWxlXCI7XG5leHBvcnQgY29uc3QgdXJsUGFyc2VFcnJvciA9IFwidXJsX3BhcnNlX2Vycm9yXCI7XG5leHBvcnQgY29uc3QgdXNlckFzc2lnbmVkTm90QXZhaWxhYmxlQXRSdW50aW1lID1cbiAgICBcInVzZXJfYXNzaWduZWRfbm90X2F2YWlsYWJsZV9hdF9ydW50aW1lXCI7XG5leHBvcnQgY29uc3Qgd3d3QXV0aGVudGljYXRlSGVhZGVyTWlzc2luZyA9IFwid3d3X2F1dGhlbnRpY2F0ZV9oZWFkZXJfbWlzc2luZ1wiO1xuZXhwb3J0IGNvbnN0IHd3d0F1dGhlbnRpY2F0ZUhlYWRlclVuc3VwcG9ydGVkRm9ybWF0ID1cbiAgICBcInd3d19hdXRoZW50aWNhdGVfaGVhZGVyX3Vuc3VwcG9ydGVkX2Zvcm1hdFwiO1xuXG5leHBvcnQgY29uc3QgTXNpRW52aXJvbm1lbnRWYXJpYWJsZVVybE1hbGZvcm1lZEVycm9yQ29kZXMgPSB7XG4gICAgW01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RdOlxuICAgICAgICBcImF6dXJlX3BvZF9pZGVudGl0eV9hdXRob3JpdHlfaG9zdF91cmxfbWFsZm9ybWVkXCIsXG4gICAgW01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JREVOVElUWV9FTkRQT0lOVF06XG4gICAgICAgIFwiaWRlbnRpdHlfZW5kcG9pbnRfdXJsX21hbGZvcm1lZFwiLFxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSU1EU19FTkRQT0lOVF06XG4gICAgICAgIFwiaW1kc19lbmRwb2ludF91cmxfbWFsZm9ybWVkXCIsXG4gICAgW01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5NU0lfRU5EUE9JTlRdOlxuICAgICAgICBcIm1zaV9lbmRwb2ludF91cmxfbWFsZm9ybWVkXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgTXNpRW52aXJvbm1lbnRWYXJpYWJsZUVycm9yQ29kZXMgPVxuICAgICh0eXBlb2YgTXNpRW52aXJvbm1lbnRWYXJpYWJsZVVybE1hbGZvcm1lZEVycm9yQ29kZXMpW2tleW9mIHR5cGVvZiBNc2lFbnZpcm9ubWVudFZhcmlhYmxlVXJsTWFsZm9ybWVkRXJyb3JDb2Rlc107XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuaW1wb3J0ICogYXMgTWFuYWdlZElkZW50aXR5RXJyb3JDb2RlcyBmcm9tIFwiLi9NYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLmpzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5leHBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzIH07XG5cbi8qKlxuICogTWFuYWdlZElkZW50aXR5RXJyb3JNZXNzYWdlIGNsYXNzIGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyB1c2VkIGJ5IGVycm9yIGNvZGVzIGFuZCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IE1hbmFnZWRJZGVudGl0eUVycm9yTWVzc2FnZXMgPSB7XG4gICAgW01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuaW52YWxpZEZpbGVFeHRlbnNpb25dOlxuICAgICAgICBcIlRoZSBmaWxlIHBhdGggaW4gdGhlIFdXVy1BdXRoZW50aWNhdGUgaGVhZGVyIGRvZXMgbm90IGNvbnRhaW4gYSAua2V5IGZpbGUuXCIsXG4gICAgW01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuaW52YWxpZEZpbGVQYXRoXTpcbiAgICAgICAgXCJUaGUgZmlsZSBwYXRoIGluIHRoZSBXV1ctQXV0aGVudGljYXRlIGhlYWRlciBpcyBub3QgaW4gYSB2YWxpZCBXaW5kb3dzIG9yIExpbnV4IEZvcm1hdC5cIixcbiAgICBbTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5pbnZhbGlkTWFuYWdlZElkZW50aXR5SWRUeXBlXTpcbiAgICAgICAgXCJNb3JlIHRoYW4gb25lIE1hbmFnZWRJZGVudGl0eUlkVHlwZSB3YXMgcHJvdmlkZWQuXCIsXG4gICAgW01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuaW52YWxpZFNlY3JldF06XG4gICAgICAgIFwiVGhlIHNlY3JldCBpbiB0aGUgZmlsZSBvbiB0aGUgZmlsZSBwYXRoIGluIHRoZSBXV1ctQXV0aGVudGljYXRlIGhlYWRlciBpcyBncmVhdGVyIHRoYW4gNDA5NiBieXRlcy5cIixcbiAgICBbTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5wbGF0Zm9ybU5vdFN1cHBvcnRlZF06XG4gICAgICAgIFwiVGhlIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQgYnkgQXp1cmUgQXJjLiBBenVyZSBBcmMgb25seSBzdXBwb3J0cyBXaW5kb3dzIGFuZCBMaW51eC5cIixcbiAgICBbTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5taXNzaW5nSWRdOlxuICAgICAgICBcIkEgTWFuYWdlZElkZW50aXR5SWQgaWQgd2FzIG5vdCBwcm92aWRlZC5cIixcbiAgICBbTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5Nc2lFbnZpcm9ubWVudFZhcmlhYmxlVXJsTWFsZm9ybWVkRXJyb3JDb2Rlc1xuICAgICAgICAuQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NUXTogYFRoZSBNYW5hZ2VkIElkZW50aXR5J3MgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLkFaVVJFX1BPRF9JREVOVElUWV9BVVRIT1JJVFlfSE9TVH0nIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1hbGZvcm1lZC5gLFxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLk1zaUVudmlyb25tZW50VmFyaWFibGVVcmxNYWxmb3JtZWRFcnJvckNvZGVzXG4gICAgICAgIC5JREVOVElUWV9FTkRQT0lOVF06IGBUaGUgTWFuYWdlZCBJZGVudGl0eSdzICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JREVOVElUWV9FTkRQT0lOVH0nIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1hbGZvcm1lZC5gLFxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLk1zaUVudmlyb25tZW50VmFyaWFibGVVcmxNYWxmb3JtZWRFcnJvckNvZGVzXG4gICAgICAgIC5JTURTX0VORFBPSU5UXTogYFRoZSBNYW5hZ2VkIElkZW50aXR5J3MgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklNRFNfRU5EUE9JTlR9JyBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtYWxmb3JtZWQuYCxcbiAgICBbTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5Nc2lFbnZpcm9ubWVudFZhcmlhYmxlVXJsTWFsZm9ybWVkRXJyb3JDb2Rlc1xuICAgICAgICAuTVNJX0VORFBPSU5UXTogYFRoZSBNYW5hZ2VkIElkZW50aXR5J3MgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLk1TSV9FTkRQT0lOVH0nIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1hbGZvcm1lZC5gLFxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLm5ldHdvcmtVbmF2YWlsYWJsZV06XG4gICAgICAgIFwiQXV0aGVudGljYXRpb24gdW5hdmFpbGFibGUuIFRoZSByZXF1ZXN0IHRvIHRoZSBtYW5hZ2VkIGlkZW50aXR5IGVuZHBvaW50IHRpbWVkIG91dC5cIixcbiAgICBbTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy51bmFibGVUb0NyZWF0ZUF6dXJlQXJjXTpcbiAgICAgICAgXCJBenVyZSBBcmMgTWFuYWdlZCBJZGVudGl0aWVzIGNhbiBvbmx5IGJlIHN5c3RlbSBhc3NpZ25lZC5cIixcbiAgICBbTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy51bmFibGVUb0NyZWF0ZUNsb3VkU2hlbGxdOlxuICAgICAgICBcIkNsb3VkIFNoZWxsIE1hbmFnZWQgSWRlbnRpdGllcyBjYW4gb25seSBiZSBzeXN0ZW0gYXNzaWduZWQuXCIsXG4gICAgW01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMudW5hYmxlVG9DcmVhdGVTb3VyY2VdOlxuICAgICAgICBcIlVuYWJsZSB0byBjcmVhdGUgYSBNYW5hZ2VkIElkZW50aXR5IHNvdXJjZSBiYXNlZCBvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXCIsXG4gICAgW01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMudW5hYmxlVG9SZWFkU2VjcmV0RmlsZV06XG4gICAgICAgIFwiVW5hYmxlIHRvIHJlYWQgdGhlIHNlY3JldCBmaWxlLlwiLFxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnVzZXJBc3NpZ25lZE5vdEF2YWlsYWJsZUF0UnVudGltZV06XG4gICAgICAgIFwiU2VydmljZSBGYWJyaWMgdXNlciBhc3NpZ25lZCBtYW5hZ2VkIGlkZW50aXR5IENsaWVudElkIG9yIFJlc291cmNlSWQgaXMgbm90IGNvbmZpZ3VyYWJsZSBhdCBydW50aW1lLlwiLFxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnd3d0F1dGhlbnRpY2F0ZUhlYWRlck1pc3NpbmddOlxuICAgICAgICBcIkEgNDAxIHJlc3BvbnNlIHdhcyByZWNlaXZlZCBmb3JtIHRoZSBBenVyZSBBcmMgTWFuYWdlZCBJZGVudGl0eSwgYnV0IHRoZSB3d3ctYXV0aGVudGljYXRlIGhlYWRlciBpcyBtaXNzaW5nLlwiLFxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnd3d0F1dGhlbnRpY2F0ZUhlYWRlclVuc3VwcG9ydGVkRm9ybWF0XTpcbiAgICAgICAgXCJBIDQwMSByZXNwb25zZSB3YXMgcmVjZWl2ZWQgZm9ybSB0aGUgQXp1cmUgQXJjIE1hbmFnZWQgSWRlbnRpdHksIGJ1dCB0aGUgd3d3LWF1dGhlbnRpY2F0ZSBoZWFkZXIgaXMgaW4gYW4gdW5zdXBwb3J0ZWQgZm9ybWF0LlwiLFxufTtcblxuZXhwb3J0IGNsYXNzIE1hbmFnZWRJZGVudGl0eUVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvckNvZGU6IHN0cmluZykge1xuICAgICAgICBzdXBlcihlcnJvckNvZGUsIE1hbmFnZWRJZGVudGl0eUVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTWFuYWdlZElkZW50aXR5RXJyb3JcIjtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE1hbmFnZWRJZGVudGl0eUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IoXG4gICAgZXJyb3JDb2RlOiBzdHJpbmdcbik6IE1hbmFnZWRJZGVudGl0eUVycm9yIHtcbiAgICByZXR1cm4gbmV3IE1hbmFnZWRJZGVudGl0eUVycm9yKGVycm9yQ29kZSk7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuXG4vKipcbiAqIE5vZGVBdXRoRXJyb3JNZXNzYWdlIGNsYXNzIGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyB1c2VkIGJ5IGVycm9yIGNvZGVzIGFuZCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IE5vZGVBdXRoRXJyb3JNZXNzYWdlID0ge1xuICAgIGludmFsaWRMb29wYmFja0FkZHJlc3NUeXBlOiB7XG4gICAgICAgIGNvZGU6IFwiaW52YWxpZF9sb29wYmFja19zZXJ2ZXJfYWRkcmVzc190eXBlXCIsXG4gICAgICAgIGRlc2M6IFwiTG9vcGJhY2sgc2VydmVyIGFkZHJlc3MgaXMgbm90IHR5cGUgc3RyaW5nLiBUaGlzIGlzIHVuZXhwZWN0ZWQuXCIsXG4gICAgfSxcbiAgICB1bmFibGVUb0xvYWRSZWRpcmVjdFVyaToge1xuICAgICAgICBjb2RlOiBcInVuYWJsZV90b19sb2FkX3JlZGlyZWN0VXJsXCIsXG4gICAgICAgIGRlc2M6IFwiTG9vcGJhY2sgc2VydmVyIGNhbGxiYWNrIHdhcyBpbnZva2VkIHdpdGhvdXQgYSB1cmwuIFRoaXMgaXMgdW5leHBlY3RlZC5cIixcbiAgICB9LFxuICAgIG5vQXV0aENvZGVJblJlc3BvbnNlOiB7XG4gICAgICAgIGNvZGU6IFwibm9fYXV0aF9jb2RlX2luX3Jlc3BvbnNlXCIsXG4gICAgICAgIGRlc2M6IFwiTm8gYXV0aCBjb2RlIGZvdW5kIGluIHRoZSBzZXJ2ZXIgcmVzcG9uc2UuIFBsZWFzZSBjaGVjayB5b3VyIG5ldHdvcmsgdHJhY2UgdG8gZGV0ZXJtaW5lIHdoYXQgaGFwcGVuZWQuXCIsXG4gICAgfSxcbiAgICBub0xvb3BiYWNrU2VydmVyRXhpc3RzOiB7XG4gICAgICAgIGNvZGU6IFwibm9fbG9vcGJhY2tfc2VydmVyX2V4aXN0c1wiLFxuICAgICAgICBkZXNjOiBcIk5vIGxvb3BiYWNrIHNlcnZlciBleGlzdHMgeWV0LlwiLFxuICAgIH0sXG4gICAgbG9vcGJhY2tTZXJ2ZXJBbHJlYWR5RXhpc3RzOiB7XG4gICAgICAgIGNvZGU6IFwibG9vcGJhY2tfc2VydmVyX2FscmVhZHlfZXhpc3RzXCIsXG4gICAgICAgIGRlc2M6IFwiTG9vcGJhY2sgc2VydmVyIGFscmVhZHkgZXhpc3RzLiBDYW5ub3QgY3JlYXRlIGFub3RoZXIuXCIsXG4gICAgfSxcbiAgICBsb29wYmFja1NlcnZlclRpbWVvdXQ6IHtcbiAgICAgICAgY29kZTogXCJsb29wYmFja19zZXJ2ZXJfdGltZW91dFwiLFxuICAgICAgICBkZXNjOiBcIlRpbWVkIG91dCB3YWl0aW5nIGZvciBhdXRoIGNvZGUgbGlzdGVuZXIgdG8gYmUgcmVnaXN0ZXJlZC5cIixcbiAgICB9LFxuICAgIHN0YXRlTm90Rm91bmRFcnJvcjoge1xuICAgICAgICBjb2RlOiBcInN0YXRlX25vdF9mb3VuZFwiLFxuICAgICAgICBkZXNjOiBcIlN0YXRlIG5vdCBmb3VuZC4gUGxlYXNlIHZlcmlmeSB0aGF0IHRoZSByZXF1ZXN0IG9yaWdpbmF0ZWQgZnJvbSBtc2FsLlwiLFxuICAgIH0sXG4gICAgdGh1bWJwcmludE1pc3Npbmc6IHtcbiAgICAgICAgY29kZTogXCJ0aHVtYnByaW50X21pc3NpbmdfZnJvbV9jbGllbnRfY2VydGlmaWNhdGVcIixcbiAgICAgICAgZGVzYzogXCJDbGllbnQgY2VydGlmaWNhdGUgZG9lcyBub3QgY29udGFpbiBhIFNIQS0xIG9yIFNIQS0yNTYgdGh1bWJwcmludC5cIixcbiAgICB9LFxufTtcblxuZXhwb3J0IGNsYXNzIE5vZGVBdXRoRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZTogc3RyaW5nLCBlcnJvck1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5vZGVBdXRoRXJyb3JcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biBpZiBsb29wYmFjayBzZXJ2ZXIgYWRkcmVzcyBpcyBvZiB0eXBlIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW52YWxpZExvb3BiYWNrQWRkcmVzc1R5cGVFcnJvcigpOiBOb2RlQXV0aEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQXV0aEVycm9yKFxuICAgICAgICAgICAgTm9kZUF1dGhFcnJvck1lc3NhZ2UuaW52YWxpZExvb3BiYWNrQWRkcmVzc1R5cGUuY29kZSxcbiAgICAgICAgICAgIGAke05vZGVBdXRoRXJyb3JNZXNzYWdlLmludmFsaWRMb29wYmFja0FkZHJlc3NUeXBlLmRlc2N9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIHRoZSBsb29wYmFjayBzZXJ2ZXIgaXMgdW5hYmxlIHRvIGdldCBhIHVybC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVW5hYmxlVG9Mb2FkUmVkaXJlY3RVcmxFcnJvcigpOiBOb2RlQXV0aEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQXV0aEVycm9yKFxuICAgICAgICAgICAgTm9kZUF1dGhFcnJvck1lc3NhZ2UudW5hYmxlVG9Mb2FkUmVkaXJlY3RVcmkuY29kZSxcbiAgICAgICAgICAgIGAke05vZGVBdXRoRXJyb3JNZXNzYWdlLnVuYWJsZVRvTG9hZFJlZGlyZWN0VXJpLmRlc2N9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgZG9lcyBub3QgY29udGFpbiBhbiBhdXRoIGNvZGUuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vQXV0aENvZGVJblJlc3BvbnNlRXJyb3IoKTogTm9kZUF1dGhFcnJvciB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZUF1dGhFcnJvcihcbiAgICAgICAgICAgIE5vZGVBdXRoRXJyb3JNZXNzYWdlLm5vQXV0aENvZGVJblJlc3BvbnNlLmNvZGUsXG4gICAgICAgICAgICBgJHtOb2RlQXV0aEVycm9yTWVzc2FnZS5ub0F1dGhDb2RlSW5SZXNwb25zZS5kZXNjfWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biBpZiB0aGUgbG9vcGJhY2sgc2VydmVyIGhhcyBub3QgYmVlbiBzcHVuIHVwIHlldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm9Mb29wYmFja1NlcnZlckV4aXN0c0Vycm9yKCk6IE5vZGVBdXRoRXJyb3Ige1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVBdXRoRXJyb3IoXG4gICAgICAgICAgICBOb2RlQXV0aEVycm9yTWVzc2FnZS5ub0xvb3BiYWNrU2VydmVyRXhpc3RzLmNvZGUsXG4gICAgICAgICAgICBgJHtOb2RlQXV0aEVycm9yTWVzc2FnZS5ub0xvb3BiYWNrU2VydmVyRXhpc3RzLmRlc2N9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIGEgbG9vcGJhY2sgc2VydmVyIGFscmVhZHkgZXhpc3RzIHdoZW4gYXR0ZW1wdGluZyB0byBjcmVhdGUgYW5vdGhlciBvbmUuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUxvb3BiYWNrU2VydmVyQWxyZWFkeUV4aXN0c0Vycm9yKCk6IE5vZGVBdXRoRXJyb3Ige1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVBdXRoRXJyb3IoXG4gICAgICAgICAgICBOb2RlQXV0aEVycm9yTWVzc2FnZS5sb29wYmFja1NlcnZlckFscmVhZHlFeGlzdHMuY29kZSxcbiAgICAgICAgICAgIGAke05vZGVBdXRoRXJyb3JNZXNzYWdlLmxvb3BiYWNrU2VydmVyQWxyZWFkeUV4aXN0cy5kZXNjfWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biBpZiB0aGUgbG9vcGJhY2sgc2VydmVyIHRpbWVzIG91dCByZWdpc3RlcmluZyB0aGUgYXV0aCBjb2RlIGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVMb29wYmFja1NlcnZlclRpbWVvdXRFcnJvcigpOiBOb2RlQXV0aEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQXV0aEVycm9yKFxuICAgICAgICAgICAgTm9kZUF1dGhFcnJvck1lc3NhZ2UubG9vcGJhY2tTZXJ2ZXJUaW1lb3V0LmNvZGUsXG4gICAgICAgICAgICBgJHtOb2RlQXV0aEVycm9yTWVzc2FnZS5sb29wYmFja1NlcnZlclRpbWVvdXQuZGVzY31gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgc3RhdGUgaXMgbm90IHByZXNlbnQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0YXRlTm90Rm91bmRFcnJvcigpOiBOb2RlQXV0aEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQXV0aEVycm9yKFxuICAgICAgICAgICAgTm9kZUF1dGhFcnJvck1lc3NhZ2Uuc3RhdGVOb3RGb3VuZEVycm9yLmNvZGUsXG4gICAgICAgICAgICBOb2RlQXV0aEVycm9yTWVzc2FnZS5zdGF0ZU5vdEZvdW5kRXJyb3IuZGVzY1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIHdoZW4gY2xpZW50IGNlcnRpZmljYXRlIHdhcyBwcm92aWRlZCwgYnV0IG5laXRoZXIgdGhlIFNIQS0xIG9yIFNIQS0yNTYgdGh1bWJwcmludHMgd2VyZSBwcm92aWRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVUaHVtYnByaW50TWlzc2luZ0Vycm9yKCk6IE5vZGVBdXRoRXJyb3Ige1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVBdXRoRXJyb3IoXG4gICAgICAgICAgICBOb2RlQXV0aEVycm9yTWVzc2FnZS50aHVtYnByaW50TWlzc2luZy5jb2RlLFxuICAgICAgICAgICAgTm9kZUF1dGhFcnJvck1lc3NhZ2UudGh1bWJwcmludE1pc3NpbmcuZGVzY1xuICAgICAgICApO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBMb2dnZXJPcHRpb25zLFxuICAgIElOZXR3b3JrTW9kdWxlLFxuICAgIExvZ0xldmVsLFxuICAgIFByb3RvY29sTW9kZSxcbiAgICBJQ2FjaGVQbHVnaW4sXG4gICAgQ29uc3RhbnRzLFxuICAgIEF6dXJlQ2xvdWRJbnN0YW5jZSxcbiAgICBBenVyZUNsb3VkT3B0aW9ucyxcbiAgICBBcHBsaWNhdGlvblRlbGVtZXRyeSxcbiAgICBJTmF0aXZlQnJva2VyUGx1Z2luLFxuICAgIENsaWVudEFzc2VydGlvbkNhbGxiYWNrLFxufSBmcm9tIFwiQGF6dXJlL21zYWwtY29tbW9uL25vZGVcIjtcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tIFwiLi4vbmV0d29yay9IdHRwQ2xpZW50LmpzXCI7XG5pbXBvcnQgaHR0cCBmcm9tIFwiaHR0cFwiO1xuaW1wb3J0IGh0dHBzIGZyb20gXCJodHRwc1wiO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5SWQgfSBmcm9tIFwiLi9NYW5hZ2VkSWRlbnRpdHlJZC5qc1wiO1xuaW1wb3J0IHsgTm9kZUF1dGhFcnJvciB9IGZyb20gXCIuLi9lcnJvci9Ob2RlQXV0aEVycm9yLmpzXCI7XG5cbi8qKlxuICogLSBjbGllbnRJZCAgICAgICAgICAgICAgIC0gQ2xpZW50IGlkIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqIC0gYXV0aG9yaXR5ICAgICAgICAgICAgICAtIFVybCBvZiB0aGUgYXV0aG9yaXR5LiBJZiBubyB2YWx1ZSBpcyBzZXQsIGRlZmF1bHRzIHRvIGh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb21tb24uXG4gKiAtIGtub3duQXV0aG9yaXRpZXMgICAgICAgLSBOZWVkZWQgZm9yIEF6dXJlIEIyQyBhbmQgQURGUy4gQWxsIGF1dGhvcml0aWVzIHRoYXQgd2lsbCBiZSB1c2VkIGluIHRoZSBjbGllbnQgYXBwbGljYXRpb24uIE9ubHkgdGhlIGhvc3Qgb2YgdGhlIGF1dGhvcml0eSBzaG91bGQgYmUgcGFzc2VkIGluLlxuICogLSBjbGllbnRTZWNyZXQgICAgICAgICAgIC0gU2VjcmV0IHN0cmluZyB0aGF0IHRoZSBhcHBsaWNhdGlvbiB1c2VzIHdoZW4gcmVxdWVzdGluZyBhIHRva2VuLiBPbmx5IHVzZWQgaW4gY29uZmlkZW50aWFsIGNsaWVudCBhcHBsaWNhdGlvbnMuIENhbiBiZSBjcmVhdGVkIGluIHRoZSBBenVyZSBhcHAgcmVnaXN0cmF0aW9uIHBvcnRhbC5cbiAqIC0gY2xpZW50QXNzZXJ0aW9uICAgICAgICAtIEEgQ2xpZW50QXNzZXJ0aW9uIG9iamVjdCBjb250YWluaW5nIGFuIGFzc2VydGlvbiBzdHJpbmcgb3IgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXNzZXJ0aW9uIHN0cmluZyB0aGF0IHRoZSBhcHBsaWNhdGlvbiB1c2VzIHdoZW4gcmVxdWVzdGluZyBhIHRva2VuLCBhcyB3ZWxsIGFzIHRoZSBhc3NlcnRpb24ncyB0eXBlICh1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Y2xpZW50LWFzc2VydGlvbi10eXBlOmp3dC1iZWFyZXIpLiBPbmx5IHVzZWQgaW4gY29uZmlkZW50aWFsIGNsaWVudCBhcHBsaWNhdGlvbnMuXG4gKiAtIGNsaWVudENlcnRpZmljYXRlICAgICAgLSBDZXJ0aWZpY2F0ZSB0aGF0IHRoZSBhcHBsaWNhdGlvbiB1c2VzIHdoZW4gcmVxdWVzdGluZyBhIHRva2VuLiBPbmx5IHVzZWQgaW4gY29uZmlkZW50aWFsIGNsaWVudCBhcHBsaWNhdGlvbnMuIFJlcXVpcmVzIGhleCBlbmNvZGVkIFguNTA5IFNIQS0xIG9yIFNIQS0yNTYgdGh1bWJwcmludCBvZiB0aGUgY2VydGlmaWNhdGUsIGFuZCB0aGUgUEVNIGVuY29kZWQgcHJpdmF0ZSBrZXkgKHN0cmluZyBzaG91bGQgY29udGFpbiAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS0gLi4uIC0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0gKVxuICogLSBwcm90b2NvbE1vZGUgICAgICAgICAgIC0gRW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb3RvY29sIHRoYXQgbXNhbCBmb2xsb3dzLiBVc2VkIGZvciBjb25maWd1cmluZyBwcm9wZXIgZW5kcG9pbnRzLlxuICogLSBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZSAtIEEgZmxhZyB0byBjaG9vc2Ugd2hldGhlciB0byB1c2Ugb3Igbm90IHVzZSB0aGUgbG9jYWwgbWV0YWRhdGEgY2FjaGUgZHVyaW5nIGF1dGhvcml0eSBpbml0aWFsaXphdGlvbi4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIE5vZGVBdXRoT3B0aW9ucyA9IHtcbiAgICBjbGllbnRJZDogc3RyaW5nO1xuICAgIGF1dGhvcml0eT86IHN0cmluZztcbiAgICBjbGllbnRTZWNyZXQ/OiBzdHJpbmc7XG4gICAgY2xpZW50QXNzZXJ0aW9uPzogc3RyaW5nIHwgQ2xpZW50QXNzZXJ0aW9uQ2FsbGJhY2s7XG4gICAgY2xpZW50Q2VydGlmaWNhdGU/OiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGh1bWJwcmludFNoYTIgcHJvcGVydHkgaW5zdGVhZC4gVGh1bWJwcmludCBuZWVkcyB0byBiZSBjb21wdXRlZCB3aXRoIFNIQS0yNTYgYWxnb3JpdGhtLlxuICAgICAgICAgKiBTSEEtMSBpcyBvbmx5IG5lZWRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBBREZTLlxuICAgICAgICAgKi9cbiAgICAgICAgdGh1bWJwcmludD86IHN0cmluZztcbiAgICAgICAgdGh1bWJwcmludFNoYTI1Nj86IHN0cmluZztcbiAgICAgICAgcHJpdmF0ZUtleTogc3RyaW5nO1xuICAgICAgICB4NWM/OiBzdHJpbmc7XG4gICAgfTtcbiAgICBrbm93bkF1dGhvcml0aWVzPzogQXJyYXk8c3RyaW5nPjtcbiAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhPzogc3RyaW5nO1xuICAgIGF1dGhvcml0eU1ldGFkYXRhPzogc3RyaW5nO1xuICAgIGNsaWVudENhcGFiaWxpdGllcz86IEFycmF5PHN0cmluZz47XG4gICAgcHJvdG9jb2xNb2RlPzogUHJvdG9jb2xNb2RlO1xuICAgIGF6dXJlQ2xvdWRPcHRpb25zPzogQXp1cmVDbG91ZE9wdGlvbnM7XG4gICAgc2tpcEF1dGhvcml0eU1ldGFkYXRhQ2FjaGU/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBVc2UgdGhpcyB0byBjb25maWd1cmUgdGhlIGJlbG93IGNhY2hlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczpcbiAqXG4gKiAtIGNhY2hlUGx1Z2luICAgLSBQbHVnaW4gZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG9rZW4gY2FjaGUgdG8gZGlzay5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgQ2FjaGVPcHRpb25zID0ge1xuICAgIGNhY2hlUGx1Z2luPzogSUNhY2hlUGx1Z2luO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGNsYWltcy1iYXNlZC1jYWNoaW5nIGZ1bmN0aW9uYWxpdHkgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24gb2YgTVNBTEpTXG4gICAgICovXG4gICAgY2xhaW1zQmFzZWRDYWNoaW5nRW5hYmxlZD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIFVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB0aGUgYmVsb3cgYnJva2VyIG9wdGlvbnM6XG4gKiAtIG5hdGl2ZUJyb2tlclBsdWdpbiAtIE5hdGl2ZSBicm9rZXIgaW1wbGVtZW50YXRpb24gKHNob3VsZCBiZSBpbXBvcnRlZCBmcm9tIG1zYWwtbm9kZS1leHRlbnNpb25zKVxuICpcbiAqIE5vdGU6IFRoZXNlIG9wdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGZvciBQdWJsaWNDbGllbnRBcHBsaWNhdGlvbnMgdXNpbmcgdGhlIEF1dGhvcml6YXRpb24gQ29kZSBGbG93XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEJyb2tlck9wdGlvbnMgPSB7XG4gICAgbmF0aXZlQnJva2VyUGx1Z2luPzogSU5hdGl2ZUJyb2tlclBsdWdpbjtcbn07XG5cbi8qKlxuICogVHlwZSBmb3IgY29uZmlndXJpbmcgbG9nZ2VyIGFuZCBodHRwIGNsaWVudCBvcHRpb25zXG4gKlxuICogLSBsb2dnZXIgICAgICAgICAgICAgICAgICAgICAgIC0gVXNlZCB0byBpbml0aWFsaXplIHRoZSBMb2dnZXIgb2JqZWN0OyBUT0RPOiBFeHBhbmQgb24gbG9nZ2VyIGRldGFpbHMgb3IgbGluayB0byB0aGUgZG9jdW1lbnRhdGlvbiBvbiBsb2dnZXJcbiAqIC0gbmV0d29ya0NsaWVudCAgICAgICAgICAgICAgICAtIEh0dHAgY2xpZW50IHVzZWQgZm9yIGFsbCBodHRwIGdldCBhbmQgcG9zdCBjYWxscy4gRGVmYXVsdHMgdG8gdXNpbmcgTVNBTCdzIGRlZmF1bHQgaHR0cCBjbGllbnQuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIE5vZGVTeXN0ZW1PcHRpb25zID0ge1xuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zO1xuICAgIG5ldHdvcmtDbGllbnQ/OiBJTmV0d29ya01vZHVsZTtcbiAgICBwcm94eVVybD86IHN0cmluZztcbiAgICBjdXN0b21BZ2VudE9wdGlvbnM/OiBodHRwLkFnZW50T3B0aW9ucyB8IGh0dHBzLkFnZW50T3B0aW9ucztcbiAgICBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzPzogYm9vbGVhbjtcbn07XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBOb2RlVGVsZW1ldHJ5T3B0aW9ucyA9IHtcbiAgICBhcHBsaWNhdGlvbj86IEFwcGxpY2F0aW9uVGVsZW1ldHJ5O1xufTtcblxuLyoqXG4gKiBVc2UgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRvIGNvbmZpZ3VyZSBNU0FMIGFuZCBpbml0aWFsaXplIHRoZSBjbGllbnQgYXBwbGljYXRpb24gb2JqZWN0XG4gKlxuICogLSBhdXRoOiB0aGlzIGlzIHdoZXJlIHlvdSBjb25maWd1cmUgYXV0aCBlbGVtZW50cyBsaWtlIGNsaWVudElELCBhdXRob3JpdHkgdXNlZCBmb3IgYXV0aGVudGljYXRpbmcgYWdhaW5zdCB0aGUgTWljcm9zb2Z0IElkZW50aXR5IFBsYXRmb3JtXG4gKiAtIGJyb2tlcjogdGhpcyBpcyB3aGVyZSB5b3UgY29uZmlndXJlIGJyb2tlciBvcHRpb25zXG4gKiAtIGNhY2hlOiB0aGlzIGlzIHdoZXJlIHlvdSBjb25maWd1cmUgY2FjaGUgbG9jYXRpb25cbiAqIC0gc3lzdGVtOiB0aGlzIGlzIHdoZXJlIHlvdSBjYW4gY29uZmlndXJlIHRoZSBuZXR3b3JrIGNsaWVudCwgbG9nZ2VyXG4gKiAtIHRlbGVtZXRyeTogdGhpcyBpcyB3aGVyZSB5b3UgY2FuIGNvbmZpZ3VyZSB0ZWxlbWV0cnkgb3B0aW9uc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBDb25maWd1cmF0aW9uID0ge1xuICAgIGF1dGg6IE5vZGVBdXRoT3B0aW9ucztcbiAgICBicm9rZXI/OiBCcm9rZXJPcHRpb25zO1xuICAgIGNhY2hlPzogQ2FjaGVPcHRpb25zO1xuICAgIHN5c3RlbT86IE5vZGVTeXN0ZW1PcHRpb25zO1xuICAgIHRlbGVtZXRyeT86IE5vZGVUZWxlbWV0cnlPcHRpb25zO1xufTtcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIE1hbmFnZWRJZGVudGl0eUlkUGFyYW1zID0ge1xuICAgIHVzZXJBc3NpZ25lZENsaWVudElkPzogc3RyaW5nO1xuICAgIHVzZXJBc3NpZ25lZFJlc291cmNlSWQ/OiBzdHJpbmc7XG4gICAgdXNlckFzc2lnbmVkT2JqZWN0SWQ/OiBzdHJpbmc7XG59O1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgTWFuYWdlZElkZW50aXR5Q29uZmlndXJhdGlvbiA9IHtcbiAgICBtYW5hZ2VkSWRlbnRpdHlJZFBhcmFtcz86IE1hbmFnZWRJZGVudGl0eUlkUGFyYW1zO1xuICAgIHN5c3RlbT86IE5vZGVTeXN0ZW1PcHRpb25zO1xufTtcblxuY29uc3QgREVGQVVMVF9BVVRIX09QVElPTlM6IFJlcXVpcmVkPE5vZGVBdXRoT3B0aW9ucz4gPSB7XG4gICAgY2xpZW50SWQ6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgYXV0aG9yaXR5OiBDb25zdGFudHMuREVGQVVMVF9BVVRIT1JJVFksXG4gICAgY2xpZW50U2VjcmV0OiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgIGNsaWVudEFzc2VydGlvbjogQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICBjbGllbnRDZXJ0aWZpY2F0ZToge1xuICAgICAgICB0aHVtYnByaW50OiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICB0aHVtYnByaW50U2hhMjU2OiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICBwcml2YXRlS2V5OiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICB4NWM6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgfSxcbiAgICBrbm93bkF1dGhvcml0aWVzOiBbXSxcbiAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgIGF1dGhvcml0eU1ldGFkYXRhOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgIGNsaWVudENhcGFiaWxpdGllczogW10sXG4gICAgcHJvdG9jb2xNb2RlOiBQcm90b2NvbE1vZGUuQUFELFxuICAgIGF6dXJlQ2xvdWRPcHRpb25zOiB7XG4gICAgICAgIGF6dXJlQ2xvdWRJbnN0YW5jZTogQXp1cmVDbG91ZEluc3RhbmNlLk5vbmUsXG4gICAgICAgIHRlbmFudDogQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcbiAgICB9LFxuICAgIHNraXBBdXRob3JpdHlNZXRhZGF0YUNhY2hlOiBmYWxzZSxcbn07XG5cbmNvbnN0IERFRkFVTFRfQ0FDSEVfT1BUSU9OUzogQ2FjaGVPcHRpb25zID0ge1xuICAgIGNsYWltc0Jhc2VkQ2FjaGluZ0VuYWJsZWQ6IGZhbHNlLFxufTtcblxuY29uc3QgREVGQVVMVF9MT0dHRVJfT1BUSU9OUzogTG9nZ2VyT3B0aW9ucyA9IHtcbiAgICBsb2dnZXJDYWxsYmFjazogKCk6IHZvaWQgPT4ge1xuICAgICAgICAvLyBhbGxvdyB1c2VycyB0byBub3Qgc2V0IGxvZ2dlciBjYWxsIGJhY2tcbiAgICB9LFxuICAgIHBpaUxvZ2dpbmdFbmFibGVkOiBmYWxzZSxcbiAgICBsb2dMZXZlbDogTG9nTGV2ZWwuSW5mbyxcbn07XG5cbmNvbnN0IERFRkFVTFRfU1lTVEVNX09QVElPTlM6IFJlcXVpcmVkPE5vZGVTeXN0ZW1PcHRpb25zPiA9IHtcbiAgICBsb2dnZXJPcHRpb25zOiBERUZBVUxUX0xPR0dFUl9PUFRJT05TLFxuICAgIG5ldHdvcmtDbGllbnQ6IG5ldyBIdHRwQ2xpZW50KCksXG4gICAgcHJveHlVcmw6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgY3VzdG9tQWdlbnRPcHRpb25zOiB7fSBhcyBodHRwLkFnZW50T3B0aW9ucyB8IGh0dHBzLkFnZW50T3B0aW9ucyxcbiAgICBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzOiBmYWxzZSxcbn07XG5cbmNvbnN0IERFRkFVTFRfVEVMRU1FVFJZX09QVElPTlM6IFJlcXVpcmVkPE5vZGVUZWxlbWV0cnlPcHRpb25zPiA9IHtcbiAgICBhcHBsaWNhdGlvbjoge1xuICAgICAgICBhcHBOYW1lOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICBhcHBWZXJzaW9uOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgIH0sXG59O1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSBOb2RlQ29uZmlndXJhdGlvbiA9IHtcbiAgICBhdXRoOiBSZXF1aXJlZDxOb2RlQXV0aE9wdGlvbnM+O1xuICAgIGJyb2tlcjogQnJva2VyT3B0aW9ucztcbiAgICBjYWNoZTogQ2FjaGVPcHRpb25zO1xuICAgIHN5c3RlbTogUmVxdWlyZWQ8Tm9kZVN5c3RlbU9wdGlvbnM+O1xuICAgIHRlbGVtZXRyeTogUmVxdWlyZWQ8Tm9kZVRlbGVtZXRyeU9wdGlvbnM+O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMgd2hlbiBub3QgZXhwbGljaXRseSBjb25maWd1cmVkIGZyb20gYXBwIGRldmVsb3BlclxuICpcbiAqIEBwYXJhbSBhdXRoIC0gQXV0aGVudGljYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIGNhY2hlIC0gQ2FjaGUgb3B0aW9uc1xuICogQHBhcmFtIHN5c3RlbSAtIFN5c3RlbSBvcHRpb25zXG4gKiBAcGFyYW0gdGVsZW1ldHJ5IC0gVGVsZW1ldHJ5IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBDb25maWd1cmF0aW9uXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQXBwQ29uZmlndXJhdGlvbih7XG4gICAgYXV0aCxcbiAgICBicm9rZXIsXG4gICAgY2FjaGUsXG4gICAgc3lzdGVtLFxuICAgIHRlbGVtZXRyeSxcbn06IENvbmZpZ3VyYXRpb24pOiBOb2RlQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3Qgc3lzdGVtT3B0aW9uczogUmVxdWlyZWQ8Tm9kZVN5c3RlbU9wdGlvbnM+ID0ge1xuICAgICAgICAuLi5ERUZBVUxUX1NZU1RFTV9PUFRJT05TLFxuICAgICAgICBuZXR3b3JrQ2xpZW50OiBuZXcgSHR0cENsaWVudChcbiAgICAgICAgICAgIHN5c3RlbT8ucHJveHlVcmwsXG4gICAgICAgICAgICBzeXN0ZW0/LmN1c3RvbUFnZW50T3B0aW9ucyBhcyBodHRwLkFnZW50T3B0aW9ucyB8IGh0dHBzLkFnZW50T3B0aW9uc1xuICAgICAgICApLFxuICAgICAgICBsb2dnZXJPcHRpb25zOiBzeXN0ZW0/LmxvZ2dlck9wdGlvbnMgfHwgREVGQVVMVF9MT0dHRVJfT1BUSU9OUyxcbiAgICAgICAgZGlzYWJsZUludGVybmFsUmV0cmllczogc3lzdGVtPy5kaXNhYmxlSW50ZXJuYWxSZXRyaWVzIHx8IGZhbHNlLFxuICAgIH07XG5cbiAgICAvLyBpZiBjbGllbnQgY2VydGlmaWNhdGUgd2FzIHByb3ZpZGVkLCBlbnN1cmUgdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlIFNIQS0xIG9yIFNIQS0yNTYgdGh1bWJwcmludHMgd2VyZSBwcm92aWRlZFxuICAgIGlmIChcbiAgICAgICAgISFhdXRoLmNsaWVudENlcnRpZmljYXRlICYmXG4gICAgICAgICEhIWF1dGguY2xpZW50Q2VydGlmaWNhdGUudGh1bWJwcmludCAmJlxuICAgICAgICAhISFhdXRoLmNsaWVudENlcnRpZmljYXRlLnRodW1icHJpbnRTaGEyNTZcbiAgICApIHtcbiAgICAgICAgdGhyb3cgTm9kZUF1dGhFcnJvci5jcmVhdGVTdGF0ZU5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhdXRoOiB7IC4uLkRFRkFVTFRfQVVUSF9PUFRJT05TLCAuLi5hdXRoIH0sXG4gICAgICAgIGJyb2tlcjogeyAuLi5icm9rZXIgfSxcbiAgICAgICAgY2FjaGU6IHsgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLCAuLi5jYWNoZSB9LFxuICAgICAgICBzeXN0ZW06IHsgLi4uc3lzdGVtT3B0aW9ucywgLi4uc3lzdGVtIH0sXG4gICAgICAgIHRlbGVtZXRyeTogeyAuLi5ERUZBVUxUX1RFTEVNRVRSWV9PUFRJT05TLCAuLi50ZWxlbWV0cnkgfSxcbiAgICB9O1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSBNYW5hZ2VkSWRlbnRpdHlOb2RlQ29uZmlndXJhdGlvbiA9IHtcbiAgICBtYW5hZ2VkSWRlbnRpdHlJZDogTWFuYWdlZElkZW50aXR5SWQ7XG4gICAgc3lzdGVtOiBSZXF1aXJlZDxcbiAgICAgICAgUGljazxOb2RlU3lzdGVtT3B0aW9ucywgXCJsb2dnZXJPcHRpb25zXCIgfCBcIm5ldHdvcmtDbGllbnRcIj5cbiAgICA+O1xuICAgIGRpc2FibGVJbnRlcm5hbFJldHJpZXM6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNYW5hZ2VkSWRlbnRpdHlDb25maWd1cmF0aW9uKHtcbiAgICBtYW5hZ2VkSWRlbnRpdHlJZFBhcmFtcyxcbiAgICBzeXN0ZW0sXG59OiBNYW5hZ2VkSWRlbnRpdHlDb25maWd1cmF0aW9uKTogTWFuYWdlZElkZW50aXR5Tm9kZUNvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0IG1hbmFnZWRJZGVudGl0eUlkOiBNYW5hZ2VkSWRlbnRpdHlJZCA9IG5ldyBNYW5hZ2VkSWRlbnRpdHlJZChcbiAgICAgICAgbWFuYWdlZElkZW50aXR5SWRQYXJhbXNcbiAgICApO1xuXG4gICAgY29uc3QgbG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucyA9XG4gICAgICAgIHN5c3RlbT8ubG9nZ2VyT3B0aW9ucyB8fCBERUZBVUxUX0xPR0dFUl9PUFRJT05TO1xuXG4gICAgbGV0IG5ldHdvcmtDbGllbnQ6IElOZXR3b3JrTW9kdWxlO1xuICAgIC8vIHVzZSBkZXZlbG9wZXIgcHJvdmlkZWQgbmV0d29yayBjbGllbnQgaWYgcGFzc2VkIGluXG4gICAgaWYgKHN5c3RlbT8ubmV0d29ya0NsaWVudCkge1xuICAgICAgICBuZXR3b3JrQ2xpZW50ID0gc3lzdGVtLm5ldHdvcmtDbGllbnQ7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IG9uZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldHdvcmtDbGllbnQgPSBuZXcgSHR0cENsaWVudChcbiAgICAgICAgICAgIHN5c3RlbT8ucHJveHlVcmwsXG4gICAgICAgICAgICBzeXN0ZW0/LmN1c3RvbUFnZW50T3B0aW9ucyBhcyBodHRwLkFnZW50T3B0aW9ucyB8IGh0dHBzLkFnZW50T3B0aW9uc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRJZGVudGl0eUlkOiBtYW5hZ2VkSWRlbnRpdHlJZCxcbiAgICAgICAgc3lzdGVtOiB7XG4gICAgICAgICAgICBsb2dnZXJPcHRpb25zLFxuICAgICAgICAgICAgbmV0d29ya0NsaWVudCxcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZUludGVybmFsUmV0cmllczogc3lzdGVtPy5kaXNhYmxlSW50ZXJuYWxSZXRyaWVzIHx8IGZhbHNlLFxuICAgIH07XG59XG4iLCAiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsICJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwgImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsICJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCAiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJR3VpZEdlbmVyYXRvciB9IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcblxuZXhwb3J0IGNsYXNzIEd1aWRHZW5lcmF0b3IgaW1wbGVtZW50cyBJR3VpZEdlbmVyYXRvciB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSRkM0MTIyOiBUaGUgdmVyc2lvbiA0IFVVSUQgaXMgbWVhbnQgZm9yIGdlbmVyYXRpbmcgVVVJRHMgZnJvbSB0cnVseS1yYW5kb20gb3IgcHNldWRvLXJhbmRvbSBudW1iZXJzLlxuICAgICAqIHV1aWR2NCBnZW5lcmF0ZXMgZ3VpZHMgZnJvbSBjcnlwcnRvZ3JhcGhpY2FsbHktc3RyaW5nIHJhbmRvbVxuICAgICAqL1xuICAgIGdlbmVyYXRlR3VpZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdXVpZHY0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZpZXMgaWYgYSBzdHJpbmcgaXMgIEdVSURcbiAgICAgKiBAcGFyYW0gZ3VpZFxuICAgICAqL1xuICAgIGlzR3VpZChndWlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcmVnZXhHdWlkID1cbiAgICAgICAgICAgIC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2k7XG4gICAgICAgIHJldHVybiByZWdleEd1aWQudGVzdChndWlkKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuXG5leHBvcnQgY2xhc3MgRW5jb2RpbmdVdGlscyB7XG4gICAgLyoqXG4gICAgICogJ3V0ZjgnOiBNdWx0aWJ5dGUgZW5jb2RlZCBVbmljb2RlIGNoYXJhY3RlcnMuIE1hbnkgd2ViIHBhZ2VzIGFuZCBvdGhlciBkb2N1bWVudCBmb3JtYXRzIHVzZSBVVEYtOC5cbiAgICAgKiAnYmFzZTY0JzogQmFzZTY0IGVuY29kaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciB0ZXh0XG4gICAgICovXG4gICAgc3RhdGljIGJhc2U2NEVuY29kZShzdHI6IHN0cmluZywgZW5jb2Rpbmc/OiBCdWZmZXJFbmNvZGluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIGVuY29kaW5nKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbmNvZGUgYSBVUkxcbiAgICAgKiBAcGFyYW0gc3RyXG4gICAgICovXG4gICAgc3RhdGljIGJhc2U2NEVuY29kZVVybChzdHI6IHN0cmluZywgZW5jb2Rpbmc/OiBCdWZmZXJFbmNvZGluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBFbmNvZGluZ1V0aWxzLmJhc2U2NEVuY29kZShzdHIsIGVuY29kaW5nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz0vZywgQ29uc3RhbnRzLkVNUFRZX1NUUklORylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAndXRmOCc6IE11bHRpYnl0ZSBlbmNvZGVkIFVuaWNvZGUgY2hhcmFjdGVycy4gTWFueSB3ZWIgcGFnZXMgYW5kIG90aGVyIGRvY3VtZW50IGZvcm1hdHMgdXNlIFVURi04LlxuICAgICAqICdiYXNlNjQnOiBCYXNlNjQgZW5jb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZTY0U3RyIEJhc2U2NCBlbmNvZGVkIHRleHRcbiAgICAgKi9cbiAgICBzdGF0aWMgYmFzZTY0RGVjb2RlKGJhc2U2NFN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NFN0ciwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBiYXNlNjRTdHIgQmFzZTY0IGVuY29kZWQgVXJsXG4gICAgICovXG4gICAgc3RhdGljIGJhc2U2NERlY29kZVVybChiYXNlNjRTdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBzdHIgPSBiYXNlNjRTdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCkge1xuICAgICAgICAgICAgc3RyICs9IFwiPVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFbmNvZGluZ1V0aWxzLmJhc2U2NERlY29kZShzdHIpO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSGFzaCB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcbmltcG9ydCBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xuXG5leHBvcnQgY2xhc3MgSGFzaFV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSAnU0hBMjU2JyBoYXNoXG4gICAgICogQHBhcmFtIGJ1ZmZlclxuICAgICAqL1xuICAgIHNoYTI1NihidWZmZXI6IHN0cmluZyk6IEJ1ZmZlciB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaChIYXNoLlNIQTI1NikudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KCk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIFBrY2VDb2RlcyB9IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuaW1wb3J0IHsgQ2hhclNldCwgUkFORE9NX09DVEVUX1NJWkUgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBFbmNvZGluZ1V0aWxzIH0gZnJvbSBcIi4uL3V0aWxzL0VuY29kaW5nVXRpbHMuanNcIjtcbmltcG9ydCB7IEhhc2hVdGlscyB9IGZyb20gXCIuL0hhc2hVdGlscy5qc1wiO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbi8qKlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc2MzYjcGFnZS04XG4gKi9cbmV4cG9ydCBjbGFzcyBQa2NlR2VuZXJhdG9yIHtcbiAgICBwcml2YXRlIGhhc2hVdGlsczogSGFzaFV0aWxzO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFzaFV0aWxzID0gbmV3IEhhc2hVdGlscygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZXMgdGhlIGNvZGVWZXJmaWVyIGFuZCB0aGUgY2hhbGxlbmdlIGZyb20gdGhlIGNvZGVWZXJmaWVyXG4gICAgICogcmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzYzNiNzZWN0aW9uLTQuMSBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc2MzYjc2VjdGlvbi00LjJcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVBrY2VDb2RlcygpOiBQcm9taXNlPFBrY2VDb2Rlcz4ge1xuICAgICAgICBjb25zdCB2ZXJpZmllciA9IHRoaXMuZ2VuZXJhdGVDb2RlVmVyaWZpZXIoKTtcbiAgICAgICAgY29uc3QgY2hhbGxlbmdlID0gdGhpcy5nZW5lcmF0ZUNvZGVDaGFsbGVuZ2VGcm9tVmVyaWZpZXIodmVyaWZpZXIpO1xuICAgICAgICByZXR1cm4geyB2ZXJpZmllciwgY2hhbGxlbmdlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGVzIHRoZSBjb2RlVmVyZmllcjsgcmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzYzNiNzZWN0aW9uLTQuMVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVDb2RlVmVyaWZpZXIoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgY2hhckFyciA9IFtdO1xuICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyNTYgLSAoMjU2ICUgQ2hhclNldC5DVl9DSEFSU0VULmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChjaGFyQXJyLmxlbmd0aCA8PSBSQU5ET01fT0NURVRfU0laRSkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZSA9IGNyeXB0by5yYW5kb21CeXRlcygxKVswXTtcbiAgICAgICAgICAgIGlmIChieXRlID49IG1heE51bWJlcikge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogSWdub3JlIHRoaXMgbnVtYmVyIHRvIG1haW50YWluIHJhbmRvbW5lc3MuXG4gICAgICAgICAgICAgICAgICogSW5jbHVkaW5nIGl0IHdvdWxkIHJlc3VsdCBpbiBhbiB1bmVxdWFsIGRpc3RyaWJ1dGlvbiBvZiBjaGFyYWN0ZXJzIGFmdGVyIGRvaW5nIHRoZSBtb2R1bG9cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYnl0ZSAlIENoYXJTZXQuQ1ZfQ0hBUlNFVC5sZW5ndGg7XG4gICAgICAgICAgICBjaGFyQXJyLnB1c2goQ2hhclNldC5DVl9DSEFSU0VUW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyaWZpZXI6IHN0cmluZyA9IGNoYXJBcnIuam9pbihDb25zdGFudHMuRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RW5jb2RlVXJsKHZlcmlmaWVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgY2hhbGxlbmdlIGZyb20gdGhlIGNvZGVWZXJmaWVyOyByZWZlcmVuY2U6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NjM2I3NlY3Rpb24tNC4yXG4gICAgICogQHBhcmFtIGNvZGVWZXJpZmllclxuICAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlRnJvbVZlcmlmaWVyKGNvZGVWZXJpZmllcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RW5jb2RlVXJsKFxuICAgICAgICAgICAgdGhpcy5oYXNoVXRpbHMuc2hhMjU2KGNvZGVWZXJpZmllcikudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICAgICAgICBcImJhc2U2NFwiXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJQ3J5cHRvLCBQa2NlQ29kZXMgfSBmcm9tIFwiQGF6dXJlL21zYWwtY29tbW9uL25vZGVcIjtcbmltcG9ydCB7IEd1aWRHZW5lcmF0b3IgfSBmcm9tIFwiLi9HdWlkR2VuZXJhdG9yLmpzXCI7XG5pbXBvcnQgeyBFbmNvZGluZ1V0aWxzIH0gZnJvbSBcIi4uL3V0aWxzL0VuY29kaW5nVXRpbHMuanNcIjtcbmltcG9ydCB7IFBrY2VHZW5lcmF0b3IgfSBmcm9tIFwiLi9Qa2NlR2VuZXJhdG9yLmpzXCI7XG5pbXBvcnQgeyBIYXNoVXRpbHMgfSBmcm9tIFwiLi9IYXNoVXRpbHMuanNcIjtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgTVNBTCBub2RlJ3MgY3J5cHRvIGludGVyZmFjZSwgd2hpY2ggYWxsb3dzIGl0IHRvIHBlcmZvcm0gYmFzZTY0IGVuY29kaW5nIGFuZCBkZWNvZGluZywgZ2VuZXJhdGluZyBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gR1VJRHMgYW5kXG4gKiBpbXBsZW1lbnRpbmcgUHJvb2YgS2V5IGZvciBDb2RlIEV4Y2hhbmdlIHNwZWNzIGZvciB0aGUgT0F1dGggQXV0aG9yaXphdGlvbiBDb2RlIEZsb3cgdXNpbmcgUEtDRSAocmZjIGhlcmU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NjM2KS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENyeXB0b1Byb3ZpZGVyIGltcGxlbWVudHMgSUNyeXB0byB7XG4gICAgcHJpdmF0ZSBwa2NlR2VuZXJhdG9yOiBQa2NlR2VuZXJhdG9yO1xuICAgIHByaXZhdGUgZ3VpZEdlbmVyYXRvcjogR3VpZEdlbmVyYXRvcjtcbiAgICBwcml2YXRlIGhhc2hVdGlsczogSGFzaFV0aWxzO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEJyb3dzZXIgY3J5cHRvIG5lZWRzIHRvIGJlIHZhbGlkYXRlZCBmaXJzdCBiZWZvcmUgYW55IG90aGVyIGNsYXNzZXMgY2FuIGJlIHNldC5cbiAgICAgICAgdGhpcy5wa2NlR2VuZXJhdG9yID0gbmV3IFBrY2VHZW5lcmF0b3IoKTtcbiAgICAgICAgdGhpcy5ndWlkR2VuZXJhdG9yID0gbmV3IEd1aWRHZW5lcmF0b3IoKTtcbiAgICAgICAgdGhpcy5oYXNoVXRpbHMgPSBuZXcgSGFzaFV0aWxzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYmFzZTY0IFVSTCBzYWZlIGVuY29kZWQgc3RyaW5nXG4gICAgICovXG4gICAgYmFzZTY0VXJsRW5jb2RlKCk6IHN0cmluZyB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJpbmdpZmllcyBhbmQgYmFzZTY0VXJsIGVuY29kZXMgaW5wdXQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpbnB1dEtpZCAtIHB1YmxpYyBrZXkgaWRcbiAgICAgKiBAcmV0dXJucyBCYXNlNjRVcmwgZW5jb2RlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZW5jb2RlS2lkKCk6IHN0cmluZyB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmFuZG9tIEdVSUQgLSB1c2VkIHRvIHBvcHVsYXRlIHN0YXRlIGFuZCBub25jZS5cbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgKEdVSUQpXG4gICAgICovXG4gICAgY3JlYXRlTmV3R3VpZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5ndWlkR2VuZXJhdG9yLmdlbmVyYXRlR3VpZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgaW5wdXQgc3RyaW5nIHRvIGJhc2U2NC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBzdHJpbmcgdG8gYmUgZW5jb2RlZFxuICAgICAqL1xuICAgIGJhc2U2NEVuY29kZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RW5jb2RlKGlucHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGlucHV0IHN0cmluZyBmcm9tIGJhc2U2NC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBzdHJpbmcgdG8gYmUgZGVjb2RlZFxuICAgICAqL1xuICAgIGJhc2U2NERlY29kZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RGVjb2RlKGlucHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgUEtDRSBjb2RlcyB1c2VkIGluIEF1dGhvcml6YXRpb24gQ29kZSBGbG93LlxuICAgICAqL1xuICAgIGdlbmVyYXRlUGtjZUNvZGVzKCk6IFByb21pc2U8UGtjZUNvZGVzPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBrY2VHZW5lcmF0b3IuZ2VuZXJhdGVQa2NlQ29kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBrZXlwYWlyLCBzdG9yZXMgaXQgYW5kIHJldHVybnMgYSB0aHVtYnByaW50IC0gbm90IHlldCBpbXBsZW1lbnRlZCBmb3Igbm9kZVxuICAgICAqL1xuICAgIGdldFB1YmxpY0tleVRodW1icHJpbnQoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBjcnlwdG9ncmFwaGljIGtleXBhaXIgZnJvbSBrZXkgc3RvcmUgbWF0Y2hpbmcgdGhlIGtleUlkIHBhc3NlZCBpblxuICAgICAqIEBwYXJhbSBraWQgLSBwdWJsaWMga2V5IGlkXG4gICAgICovXG4gICAgcmVtb3ZlVG9rZW5CaW5kaW5nS2V5KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjcnlwdG9ncmFwaGljIGtleXMgZnJvbSBLZXlzdG9yZVxuICAgICAqL1xuICAgIGNsZWFyS2V5c3RvcmUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBnaXZlbiBvYmplY3QgYXMgYSBqd3QgcGF5bG9hZCB3aXRoIHByaXZhdGUga2V5IHJldHJpZXZlZCBieSBnaXZlbiBraWQgLSBjdXJyZW50bHkgbm90IGltcGxlbWVudGVkIGZvciBub2RlXG4gICAgICovXG4gICAgc2lnbkp3dCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTSEEtMjU2IGhhc2ggb2YgYW4gaW5wdXQgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgaGFzaFN0cmluZyhwbGFpblRleHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiBFbmNvZGluZ1V0aWxzLmJhc2U2NEVuY29kZVVybChcbiAgICAgICAgICAgIHRoaXMuaGFzaFV0aWxzLnNoYTI1NihwbGFpblRleHQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLFxuICAgICAgICAgICAgXCJiYXNlNjRcIlxuICAgICAgICApO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBUb2tlbktleXMsXG4gICAgQWNjb3VudEVudGl0eSxcbiAgICBJZFRva2VuRW50aXR5LFxuICAgIEFjY2Vzc1Rva2VuRW50aXR5LFxuICAgIFJlZnJlc2hUb2tlbkVudGl0eSxcbiAgICBBcHBNZXRhZGF0YUVudGl0eSxcbiAgICBTZXJ2ZXJUZWxlbWV0cnlFbnRpdHksXG4gICAgVGhyb3R0bGluZ0VudGl0eSxcbiAgICBDYWNoZU1hbmFnZXIsXG4gICAgTG9nZ2VyLFxuICAgIFZhbGlkQ2FjaGVUeXBlLFxuICAgIElDcnlwdG8sXG4gICAgQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHksXG4gICAgVmFsaWRDcmVkZW50aWFsVHlwZSxcbiAgICBTdGF0aWNBdXRob3JpdHlPcHRpb25zLFxuICAgIENhY2hlSGVscGVycyxcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5cbmltcG9ydCB7IERlc2VyaWFsaXplciB9IGZyb20gXCIuL3NlcmlhbGl6ZXIvRGVzZXJpYWxpemVyLmpzXCI7XG5pbXBvcnQgeyBTZXJpYWxpemVyIH0gZnJvbSBcIi4vc2VyaWFsaXplci9TZXJpYWxpemVyLmpzXCI7XG5pbXBvcnQge1xuICAgIEluTWVtb3J5Q2FjaGUsXG4gICAgSnNvbkNhY2hlLFxuICAgIENhY2hlS1ZTdG9yZSxcbn0gZnJvbSBcIi4vc2VyaWFsaXplci9TZXJpYWxpemVyVHlwZXMuanNcIjtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgU3RvcmFnZSBmb3Igbm9kZSwgcmVhZGluZyBjYWNoZSBmcm9tIHVzZXIgc3BlY2lmaWVkIHN0b3JhZ2UgbG9jYXRpb24gb3IgYW4gIGV4dGVuc2lvbiBsaWJyYXJ5XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlU3RvcmFnZSBleHRlbmRzIENhY2hlTWFuYWdlciB7XG4gICAgLy8gQ2FjaGUgY29uZmlndXJhdGlvbiwgZWl0aGVyIHNldCBieSB1c2VyIG9yIGRlZmF1bHQgdmFsdWVzLlxuICAgIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XG4gICAgcHJpdmF0ZSBjYWNoZTogQ2FjaGVLVlN0b3JlID0ge307XG4gICAgcHJpdmF0ZSBjaGFuZ2VFbWl0dGVyczogQXJyYXk8RnVuY3Rpb24+ID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgbG9nZ2VyOiBMb2dnZXIsXG4gICAgICAgIGNsaWVudElkOiBzdHJpbmcsXG4gICAgICAgIGNyeXB0b0ltcGw6IElDcnlwdG8sXG4gICAgICAgIHN0YXRpY0F1dGhvcml0eU9wdGlvbnM/OiBTdGF0aWNBdXRob3JpdHlPcHRpb25zXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGNsaWVudElkLCBjcnlwdG9JbXBsLCBsb2dnZXIsIHN0YXRpY0F1dGhvcml0eU9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSB1cCBjYWxsYmFja3NcbiAgICAgKiBAcGFyYW0gZnVuYyAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGNhY2hlIGNoYW5nZSBpbmRpY2F0aW9uXG4gICAgICovXG4gICAgcmVnaXN0ZXJDaGFuZ2VFbWl0dGVyKGZ1bmM6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VFbWl0dGVycy5wdXNoKGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2hlbiBjYWNoZSBjaGFuZ2VzXG4gICAgICovXG4gICAgZW1pdENoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VFbWl0dGVycy5mb3JFYWNoKChmdW5jKSA9PiBmdW5jLmNhbGwobnVsbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGNhY2hlS1ZTdG9yZSB0byBJbk1lbW9yeUNhY2hlXG4gICAgICogQHBhcmFtIGNhY2hlIC0ga2V5IHZhbHVlIHN0b3JlXG4gICAgICovXG4gICAgY2FjaGVUb0luTWVtb3J5Q2FjaGUoY2FjaGU6IENhY2hlS1ZTdG9yZSk6IEluTWVtb3J5Q2FjaGUge1xuICAgICAgICBjb25zdCBpbk1lbW9yeUNhY2hlOiBJbk1lbW9yeUNhY2hlID0ge1xuICAgICAgICAgICAgYWNjb3VudHM6IHt9LFxuICAgICAgICAgICAgaWRUb2tlbnM6IHt9LFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5zOiB7fSxcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbnM6IHt9LFxuICAgICAgICAgICAgYXBwTWV0YWRhdGE6IHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBY2NvdW50RW50aXR5KSB7XG4gICAgICAgICAgICAgICAgaW5NZW1vcnlDYWNoZS5hY2NvdW50c1trZXldID0gdmFsdWUgYXMgQWNjb3VudEVudGl0eTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQ2FjaGVIZWxwZXJzLmlzSWRUb2tlbkVudGl0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbk1lbW9yeUNhY2hlLmlkVG9rZW5zW2tleV0gPSB2YWx1ZSBhcyBJZFRva2VuRW50aXR5O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChDYWNoZUhlbHBlcnMuaXNBY2Nlc3NUb2tlbkVudGl0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbk1lbW9yeUNhY2hlLmFjY2Vzc1Rva2Vuc1trZXldID0gdmFsdWUgYXMgQWNjZXNzVG9rZW5FbnRpdHk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKENhY2hlSGVscGVycy5pc1JlZnJlc2hUb2tlbkVudGl0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbk1lbW9yeUNhY2hlLnJlZnJlc2hUb2tlbnNba2V5XSA9IHZhbHVlIGFzIFJlZnJlc2hUb2tlbkVudGl0eTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQ2FjaGVIZWxwZXJzLmlzQXBwTWV0YWRhdGFFbnRpdHkoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbk1lbW9yeUNhY2hlLmFwcE1ldGFkYXRhW2tleV0gPSB2YWx1ZSBhcyBBcHBNZXRhZGF0YUVudGl0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5NZW1vcnlDYWNoZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBpbk1lbW9yeUNhY2hlIHRvIENhY2hlS1ZTdG9yZVxuICAgICAqIEBwYXJhbSBpbk1lbW9yeUNhY2hlIC0ga3ZzdG9yZSBtYXAgZm9yIGlubWVtb3J5XG4gICAgICovXG4gICAgaW5NZW1vcnlDYWNoZVRvQ2FjaGUoaW5NZW1vcnlDYWNoZTogSW5NZW1vcnlDYWNoZSk6IENhY2hlS1ZTdG9yZSB7XG4gICAgICAgIC8vIGNvbnZlcnQgaW4gbWVtb3J5IGNhY2hlIHRvIGEgZmxhdCBLZXktVmFsdWUgbWFwXG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoKTtcblxuICAgICAgICBjYWNoZSA9IHtcbiAgICAgICAgICAgIC4uLmNhY2hlLFxuICAgICAgICAgICAgLi4uaW5NZW1vcnlDYWNoZS5hY2NvdW50cyxcbiAgICAgICAgICAgIC4uLmluTWVtb3J5Q2FjaGUuaWRUb2tlbnMsXG4gICAgICAgICAgICAuLi5pbk1lbW9yeUNhY2hlLmFjY2Vzc1Rva2VucyxcbiAgICAgICAgICAgIC4uLmluTWVtb3J5Q2FjaGUucmVmcmVzaFRva2VucyxcbiAgICAgICAgICAgIC4uLmluTWVtb3J5Q2FjaGUuYXBwTWV0YWRhdGEsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY29udmVydCBpbiBtZW1vcnkgY2FjaGUgdG8gYSBmbGF0IEtleS1WYWx1ZSBtYXBcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldHMgdGhlIGN1cnJlbnQgaW4gbWVtb3J5IGNhY2hlIGZvciB0aGUgY2xpZW50XG4gICAgICovXG4gICAgZ2V0SW5NZW1vcnlDYWNoZSgpOiBJbk1lbW9yeUNhY2hlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJHZXR0aW5nIGluLW1lbW9yeSBjYWNoZVwiKTtcblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBjYWNoZSBrZXkgdmFsdWUgc3RvcmUgdG8gaW5NZW1vcnlDYWNoZVxuICAgICAgICBjb25zdCBpbk1lbW9yeUNhY2hlID0gdGhpcy5jYWNoZVRvSW5NZW1vcnlDYWNoZSh0aGlzLmdldENhY2hlKCkpO1xuICAgICAgICByZXR1cm4gaW5NZW1vcnlDYWNoZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBjdXJyZW50IGluIG1lbW9yeSBjYWNoZSBmb3IgdGhlIGNsaWVudFxuICAgICAqIEBwYXJhbSBpbk1lbW9yeUNhY2hlIC0ga2V5IHZhbHVlIG1hcCBpbiBtZW1vcnlcbiAgICAgKi9cbiAgICBzZXRJbk1lbW9yeUNhY2hlKGluTWVtb3J5Q2FjaGU6IEluTWVtb3J5Q2FjaGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJTZXR0aW5nIGluLW1lbW9yeSBjYWNoZVwiKTtcblxuICAgICAgICAvLyBjb252ZXJ0IGFuZCBhcHBlbmQgdGhlIGluTWVtb3J5Q2FjaGUgdG8gY2FjaGVLVlN0b3JlXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5pbk1lbW9yeUNhY2hlVG9DYWNoZShpbk1lbW9yeUNhY2hlKTtcbiAgICAgICAgdGhpcy5zZXRDYWNoZShjYWNoZSk7XG5cbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjdXJyZW50IGNhY2hlIGtleS12YWx1ZSBzdG9yZVxuICAgICAqL1xuICAgIGdldENhY2hlKCk6IENhY2hlS1ZTdG9yZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiR2V0dGluZyBjYWNoZSBrZXktdmFsdWUgc3RvcmVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIGN1cnJlbnQgY2FjaGUgKGtleSB2YWx1ZSBzdG9yZSlcbiAgICAgKiBAcGFyYW0gY2FjaGVNYXAgLSBrZXkgdmFsdWUgbWFwXG4gICAgICovXG4gICAgc2V0Q2FjaGUoY2FjaGU6IENhY2hlS1ZTdG9yZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlNldHRpbmcgY2FjaGUga2V5IHZhbHVlIHN0b3JlXCIpO1xuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG5cbiAgICAgICAgLy8gbWFyayBjaGFuZ2UgaW4gY2FjaGVcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWNoZSBpdGVtIHdpdGggZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgLSBsb29rdXAga2V5IGZvciB0aGUgY2FjaGUgZW50cnlcbiAgICAgKi9cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogVmFsaWRDYWNoZVR5cGUge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZVBpaShgSXRlbSBrZXk6ICR7a2V5fWApO1xuXG4gICAgICAgIC8vIHJlYWQgY2FjaGVcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmdldENhY2hlKCk7XG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FjaGUgaXRlbSB3aXRoIGdpdmVuIGtleS12YWx1ZVxuICAgICAqIEBwYXJhbSBrZXkgLSBsb29rdXAga2V5IGZvciB0aGUgY2FjaGUgZW50cnlcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSBvZiB0aGUgY2FjaGUgZW50cnlcbiAgICAgKi9cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogVmFsaWRDYWNoZVR5cGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2VQaWkoYEl0ZW0ga2V5OiAke2tleX1gKTtcblxuICAgICAgICAvLyByZWFkIGNhY2hlXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5nZXRDYWNoZSgpO1xuICAgICAgICBjYWNoZVtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgLy8gd3JpdGUgdG8gY2FjaGVcbiAgICAgICAgdGhpcy5zZXRDYWNoZShjYWNoZSk7XG4gICAgfVxuXG4gICAgZ2V0QWNjb3VudEtleXMoKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBpbk1lbW9yeUNhY2hlID0gdGhpcy5nZXRJbk1lbW9yeUNhY2hlKCk7XG4gICAgICAgIGNvbnN0IGFjY291bnRLZXlzID0gT2JqZWN0LmtleXMoaW5NZW1vcnlDYWNoZS5hY2NvdW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGFjY291bnRLZXlzO1xuICAgIH1cblxuICAgIGdldFRva2VuS2V5cygpOiBUb2tlbktleXMge1xuICAgICAgICBjb25zdCBpbk1lbW9yeUNhY2hlID0gdGhpcy5nZXRJbk1lbW9yeUNhY2hlKCk7XG4gICAgICAgIGNvbnN0IHRva2VuS2V5cyA9IHtcbiAgICAgICAgICAgIGlkVG9rZW46IE9iamVjdC5rZXlzKGluTWVtb3J5Q2FjaGUuaWRUb2tlbnMpLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IE9iamVjdC5rZXlzKGluTWVtb3J5Q2FjaGUuYWNjZXNzVG9rZW5zKSxcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbjogT2JqZWN0LmtleXMoaW5NZW1vcnlDYWNoZS5yZWZyZXNoVG9rZW5zKSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdG9rZW5LZXlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFjY291bnQgZnJvbSBjYWNoZSwgYnVpbGRzIGl0IGludG8gYW4gYWNjb3VudCBlbnRpdHkgYW5kIHJldHVybnMgaXQuXG4gICAgICogQHBhcmFtIGFjY291bnRLZXkgLSBsb29rdXAga2V5IHRvIGZldGNoIGNhY2hlIHR5cGUgQWNjb3VudEVudGl0eVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0QWNjb3VudChhY2NvdW50S2V5OiBzdHJpbmcpOiBBY2NvdW50RW50aXR5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNhY2hlZEFjY291bnQgPSB0aGlzLmdldEl0ZW0oYWNjb3VudEtleSk7XG4gICAgICAgIHJldHVybiBjYWNoZWRBY2NvdW50XG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24obmV3IEFjY291bnRFbnRpdHkoKSwgdGhpcy5nZXRJdGVtKGFjY291bnRLZXkpKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBhY2NvdW50IGVudGl0eVxuICAgICAqIEBwYXJhbSBhY2NvdW50IC0gY2FjaGUgdmFsdWUgdG8gYmUgc2V0IG9mIHR5cGUgQWNjb3VudEVudGl0eVxuICAgICAqL1xuICAgIGFzeW5jIHNldEFjY291bnQoYWNjb3VudDogQWNjb3VudEVudGl0eSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBhY2NvdW50S2V5ID0gYWNjb3VudC5nZW5lcmF0ZUFjY291bnRLZXkoKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtKGFjY291bnRLZXksIGFjY291bnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZldGNoIHRoZSBpZFRva2VuIGNyZWRlbnRpYWxcbiAgICAgKiBAcGFyYW0gaWRUb2tlbktleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBJZFRva2VuRW50aXR5XG4gICAgICovXG4gICAgZ2V0SWRUb2tlbkNyZWRlbnRpYWwoaWRUb2tlbktleTogc3RyaW5nKTogSWRUb2tlbkVudGl0eSB8IG51bGwge1xuICAgICAgICBjb25zdCBpZFRva2VuID0gdGhpcy5nZXRJdGVtKGlkVG9rZW5LZXkpIGFzIElkVG9rZW5FbnRpdHk7XG4gICAgICAgIGlmIChDYWNoZUhlbHBlcnMuaXNJZFRva2VuRW50aXR5KGlkVG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgaWRUb2tlbiBjcmVkZW50aWFsXG4gICAgICogQHBhcmFtIGlkVG9rZW4gLSBjYWNoZSB2YWx1ZSB0byBiZSBzZXQgb2YgdHlwZSBJZFRva2VuRW50aXR5XG4gICAgICovXG4gICAgYXN5bmMgc2V0SWRUb2tlbkNyZWRlbnRpYWwoaWRUb2tlbjogSWRUb2tlbkVudGl0eSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBpZFRva2VuS2V5ID0gQ2FjaGVIZWxwZXJzLmdlbmVyYXRlQ3JlZGVudGlhbEtleShpZFRva2VuKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtKGlkVG9rZW5LZXksIGlkVG9rZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZldGNoIHRoZSBhY2Nlc3NUb2tlbiBjcmVkZW50aWFsXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuS2V5IC0gbG9va3VwIGtleSB0byBmZXRjaCBjYWNoZSB0eXBlIEFjY2Vzc1Rva2VuRW50aXR5XG4gICAgICovXG4gICAgZ2V0QWNjZXNzVG9rZW5DcmVkZW50aWFsKGFjY2Vzc1Rva2VuS2V5OiBzdHJpbmcpOiBBY2Nlc3NUb2tlbkVudGl0eSB8IG51bGwge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMuZ2V0SXRlbShhY2Nlc3NUb2tlbktleSkgYXMgQWNjZXNzVG9rZW5FbnRpdHk7XG4gICAgICAgIGlmIChDYWNoZUhlbHBlcnMuaXNBY2Nlc3NUb2tlbkVudGl0eShhY2Nlc3NUb2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgYWNjZXNzVG9rZW4gY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtICBjYWNoZSB2YWx1ZSB0byBiZSBzZXQgb2YgdHlwZSBBY2Nlc3NUb2tlbkVudGl0eVxuICAgICAqL1xuICAgIGFzeW5jIHNldEFjY2Vzc1Rva2VuQ3JlZGVudGlhbChcbiAgICAgICAgYWNjZXNzVG9rZW46IEFjY2Vzc1Rva2VuRW50aXR5XG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuS2V5ID0gQ2FjaGVIZWxwZXJzLmdlbmVyYXRlQ3JlZGVudGlhbEtleShhY2Nlc3NUb2tlbik7XG4gICAgICAgIHRoaXMuc2V0SXRlbShhY2Nlc3NUb2tlbktleSwgYWNjZXNzVG9rZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZldGNoIHRoZSByZWZyZXNoVG9rZW4gY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW5LZXkgLSBsb29rdXAga2V5IHRvIGZldGNoIGNhY2hlIHR5cGUgUmVmcmVzaFRva2VuRW50aXR5XG4gICAgICovXG4gICAgZ2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbChcbiAgICAgICAgcmVmcmVzaFRva2VuS2V5OiBzdHJpbmdcbiAgICApOiBSZWZyZXNoVG9rZW5FbnRpdHkgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gdGhpcy5nZXRJdGVtKFxuICAgICAgICAgICAgcmVmcmVzaFRva2VuS2V5XG4gICAgICAgICkgYXMgUmVmcmVzaFRva2VuRW50aXR5O1xuICAgICAgICBpZiAoQ2FjaGVIZWxwZXJzLmlzUmVmcmVzaFRva2VuRW50aXR5KHJlZnJlc2hUb2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZyZXNoVG9rZW4gYXMgUmVmcmVzaFRva2VuRW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCByZWZyZXNoVG9rZW4gY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gLSBjYWNoZSB2YWx1ZSB0byBiZSBzZXQgb2YgdHlwZSBSZWZyZXNoVG9rZW5FbnRpdHlcbiAgICAgKi9cbiAgICBhc3luYyBzZXRSZWZyZXNoVG9rZW5DcmVkZW50aWFsKFxuICAgICAgICByZWZyZXNoVG9rZW46IFJlZnJlc2hUb2tlbkVudGl0eVxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCByZWZyZXNoVG9rZW5LZXkgPVxuICAgICAgICAgICAgQ2FjaGVIZWxwZXJzLmdlbmVyYXRlQ3JlZGVudGlhbEtleShyZWZyZXNoVG9rZW4pO1xuICAgICAgICB0aGlzLnNldEl0ZW0ocmVmcmVzaFRva2VuS2V5LCByZWZyZXNoVG9rZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZldGNoIGFwcE1ldGFkYXRhIGVudGl0eSBmcm9tIHRoZSBwbGF0Zm9ybSBjYWNoZVxuICAgICAqIEBwYXJhbSBhcHBNZXRhZGF0YUtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBBcHBNZXRhZGF0YUVudGl0eVxuICAgICAqL1xuICAgIGdldEFwcE1ldGFkYXRhKGFwcE1ldGFkYXRhS2V5OiBzdHJpbmcpOiBBcHBNZXRhZGF0YUVudGl0eSB8IG51bGwge1xuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YTogQXBwTWV0YWRhdGFFbnRpdHkgPSB0aGlzLmdldEl0ZW0oXG4gICAgICAgICAgICBhcHBNZXRhZGF0YUtleVxuICAgICAgICApIGFzIEFwcE1ldGFkYXRhRW50aXR5O1xuICAgICAgICBpZiAoQ2FjaGVIZWxwZXJzLmlzQXBwTWV0YWRhdGFFbnRpdHkoYXBwTWV0YWRhdGFLZXksIGFwcE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcE1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBhcHBNZXRhZGF0YSBlbnRpdHkgdG8gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIGFwcE1ldGFkYXRhIC0gY2FjaGUgdmFsdWUgdG8gYmUgc2V0IG9mIHR5cGUgQXBwTWV0YWRhdGFFbnRpdHlcbiAgICAgKi9cbiAgICBzZXRBcHBNZXRhZGF0YShhcHBNZXRhZGF0YTogQXBwTWV0YWRhdGFFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYXBwTWV0YWRhdGFLZXkgPSBDYWNoZUhlbHBlcnMuZ2VuZXJhdGVBcHBNZXRhZGF0YUtleShhcHBNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuc2V0SXRlbShhcHBNZXRhZGF0YUtleSwgYXBwTWV0YWRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZldGNoIHNlcnZlciB0ZWxlbWV0cnkgZW50aXR5IGZyb20gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIHNlcnZlclRlbGVtZXRyeWtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBTZXJ2ZXJUZWxlbWV0cnlFbnRpdHlcbiAgICAgKi9cbiAgICBnZXRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgIHNlcnZlclRlbGVtZXRyeWtleTogc3RyaW5nXG4gICAgKTogU2VydmVyVGVsZW1ldHJ5RW50aXR5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHNlcnZlclRlbGVtZXRyeUVudGl0eTogU2VydmVyVGVsZW1ldHJ5RW50aXR5ID0gdGhpcy5nZXRJdGVtKFxuICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5a2V5XG4gICAgICAgICkgYXMgU2VydmVyVGVsZW1ldHJ5RW50aXR5O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlFbnRpdHkgJiZcbiAgICAgICAgICAgIENhY2hlSGVscGVycy5pc1NlcnZlclRlbGVtZXRyeUVudGl0eShcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlrZXksXG4gICAgICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5RW50aXR5XG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZlclRlbGVtZXRyeUVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgc2VydmVyIHRlbGVtZXRyeSBlbnRpdHkgdG8gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIHNlcnZlclRlbGVtZXRyeUtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBTZXJ2ZXJUZWxlbWV0cnlFbnRpdHlcbiAgICAgKiBAcGFyYW0gc2VydmVyVGVsZW1ldHJ5IC0gY2FjaGUgdmFsdWUgdG8gYmUgc2V0IG9mIHR5cGUgU2VydmVyVGVsZW1ldHJ5RW50aXR5XG4gICAgICovXG4gICAgc2V0U2VydmVyVGVsZW1ldHJ5KFxuICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlLZXk6IHN0cmluZyxcbiAgICAgICAgc2VydmVyVGVsZW1ldHJ5OiBTZXJ2ZXJUZWxlbWV0cnlFbnRpdHlcbiAgICApOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtKHNlcnZlclRlbGVtZXRyeUtleSwgc2VydmVyVGVsZW1ldHJ5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaCBhdXRob3JpdHkgbWV0YWRhdGEgZW50aXR5IGZyb20gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIGtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBBdXRob3JpdHlNZXRhZGF0YUVudGl0eVxuICAgICAqL1xuICAgIGdldEF1dGhvcml0eU1ldGFkYXRhKGtleTogc3RyaW5nKTogQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkgfCBudWxsIHtcbiAgICAgICAgY29uc3QgYXV0aG9yaXR5TWV0YWRhdGFFbnRpdHk6IEF1dGhvcml0eU1ldGFkYXRhRW50aXR5ID0gdGhpcy5nZXRJdGVtKFxuICAgICAgICAgICAga2V5XG4gICAgICAgICkgYXMgQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGF1dGhvcml0eU1ldGFkYXRhRW50aXR5ICYmXG4gICAgICAgICAgICBDYWNoZUhlbHBlcnMuaXNBdXRob3JpdHlNZXRhZGF0YUVudGl0eShrZXksIGF1dGhvcml0eU1ldGFkYXRhRW50aXR5KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBhdXRob3JpdHlNZXRhZGF0YUVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGF1dGhvcml0eSBtZXRhZGF0YSBrZXlzXG4gICAgICovXG4gICAgZ2V0QXV0aG9yaXR5TWV0YWRhdGFLZXlzKCk6IEFycmF5PHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlzKCkuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQXV0aG9yaXR5TWV0YWRhdGEoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGF1dGhvcml0eSBtZXRhZGF0YSBlbnRpdHkgdG8gdGhlIHBsYXRmb3JtIGNhY2hlXG4gICAgICogQHBhcmFtIGtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBBdXRob3JpdHlNZXRhZGF0YUVudGl0eVxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSAtIGNhY2hlIHZhbHVlIHRvIGJlIHNldCBvZiB0eXBlIEF1dGhvcml0eU1ldGFkYXRhRW50aXR5XG4gICAgICovXG4gICAgc2V0QXV0aG9yaXR5TWV0YWRhdGEoa2V5OiBzdHJpbmcsIG1ldGFkYXRhOiBBdXRob3JpdHlNZXRhZGF0YUVudGl0eSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldEl0ZW0oa2V5LCBtZXRhZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmV0Y2ggdGhyb3R0bGluZyBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gdGhyb3R0bGluZ0NhY2hlS2V5IC0gbG9va3VwIGtleSB0byBmZXRjaCBjYWNoZSB0eXBlIFRocm90dGxpbmdFbnRpdHlcbiAgICAgKi9cbiAgICBnZXRUaHJvdHRsaW5nQ2FjaGUodGhyb3R0bGluZ0NhY2hlS2V5OiBzdHJpbmcpOiBUaHJvdHRsaW5nRW50aXR5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRocm90dGxpbmdDYWNoZTogVGhyb3R0bGluZ0VudGl0eSA9IHRoaXMuZ2V0SXRlbShcbiAgICAgICAgICAgIHRocm90dGxpbmdDYWNoZUtleVxuICAgICAgICApIGFzIFRocm90dGxpbmdFbnRpdHk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRocm90dGxpbmdDYWNoZSAmJlxuICAgICAgICAgICAgQ2FjaGVIZWxwZXJzLmlzVGhyb3R0bGluZ0VudGl0eSh0aHJvdHRsaW5nQ2FjaGVLZXksIHRocm90dGxpbmdDYWNoZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3R0bGluZ0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aHJvdHRsaW5nIGVudGl0eSB0byB0aGUgcGxhdGZvcm0gY2FjaGVcbiAgICAgKiBAcGFyYW0gdGhyb3R0bGluZ0NhY2hlS2V5IC0gbG9va3VwIGtleSB0byBmZXRjaCBjYWNoZSB0eXBlIFRocm90dGxpbmdFbnRpdHlcbiAgICAgKiBAcGFyYW0gdGhyb3R0bGluZ0NhY2hlIC0gY2FjaGUgdmFsdWUgdG8gYmUgc2V0IG9mIHR5cGUgVGhyb3R0bGluZ0VudGl0eVxuICAgICAqL1xuICAgIHNldFRocm90dGxpbmdDYWNoZShcbiAgICAgICAgdGhyb3R0bGluZ0NhY2hlS2V5OiBzdHJpbmcsXG4gICAgICAgIHRocm90dGxpbmdDYWNoZTogVGhyb3R0bGluZ0VudGl0eVxuICAgICk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldEl0ZW0odGhyb3R0bGluZ0NhY2hlS2V5LCB0aHJvdHRsaW5nQ2FjaGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNhY2hlIGl0ZW0gZnJvbSBtZW1vcnkgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgLSBsb29rdXAga2V5IHRvIHJlbW92ZSBhIGNhY2hlIGVudGl0eVxuICAgICAqIEBwYXJhbSBpbk1lbW9yeSAtIGtleSB2YWx1ZSBtYXAgb2YgdGhlIGNhY2hlXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZVBpaShgSXRlbSBrZXk6ICR7a2V5fWApO1xuXG4gICAgICAgIC8vIHJlYWQgaW5NZW1vcnlDYWNoZVxuICAgICAgICBsZXQgcmVzdWx0OiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5nZXRDYWNoZSgpO1xuXG4gICAgICAgIGlmICghIWNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdyaXRlIHRvIHRoZSBjYWNoZSBhZnRlciByZW1vdmFsXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FjaGUoY2FjaGUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWNjb3VudCBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGUgaWYgaXQncyBvdXRkYXRlZFxuICAgICAqIEBwYXJhbSBhY2NvdW50S2V5IC0gbG9va3VwIGtleSB0byBmZXRjaCBjYWNoZSB0eXBlIEFjY291bnRFbnRpdHlcbiAgICAgKi9cbiAgICByZW1vdmVPdXRkYXRlZEFjY291bnQoYWNjb3VudEtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShhY2NvdW50S2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBrZXkgaXMgaW4gY2FjaGUuXG4gICAgICogQHBhcmFtIGtleSAtIGxvb2sgdXAga2V5IGZvciBhIGNhY2hlIGVudGl0eVxuICAgICAqL1xuICAgIGNvbnRhaW5zS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleXMoKS5pbmNsdWRlcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGtleXMgaW4gd2luZG93LlxuICAgICAqL1xuICAgIGdldEtleXMoKTogc3RyaW5nW10ge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlJldHJpZXZpbmcgYWxsIGNhY2hlIGtleXNcIik7XG5cbiAgICAgICAgLy8gcmVhZCBjYWNoZVxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoKTtcbiAgICAgICAgcmV0dXJuIFsuLi5PYmplY3Qua2V5cyhjYWNoZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2FjaGUgZW50cmllcyBjcmVhdGVkIGJ5IE1TQUwgKGV4Y2VwdCB0b2tlbnMpLlxuICAgICAqL1xuICAgIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkNsZWFyaW5nIGNhY2hlIGVudHJpZXMgY3JlYXRlZCBieSBNU0FMXCIpO1xuXG4gICAgICAgIC8vIHJlYWQgaW5NZW1vcnlDYWNoZVxuICAgICAgICBjb25zdCBjYWNoZUtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLyBkZWxldGUgZWFjaCBlbGVtZW50XG4gICAgICAgIGNhY2hlS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBpbiBtZW1vcnkgY2FjaGUgZnJvbSBhbiBleGlzaXRpbmcgY2FjaGUgdmF1bHRcbiAgICAgKiBAcGFyYW0gY2FjaGUgLSBibG9iIGZvcm1hdHRlZCBjYWNoZSAoSlNPTilcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGVJbk1lbW9yeUNhY2hlKGNhY2hlOiBzdHJpbmcpOiBJbk1lbW9yeUNhY2hlIHtcbiAgICAgICAgcmV0dXJuIERlc2VyaWFsaXplci5kZXNlcmlhbGl6ZUFsbENhY2hlKFxuICAgICAgICAgICAgRGVzZXJpYWxpemVyLmRlc2VyaWFsaXplSlNPTkJsb2IoY2FjaGUpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0cmlldmVzIHRoZSBmaW5hbCBKU09OXG4gICAgICogQHBhcmFtIGluTWVtb3J5Q2FjaGUgLSBpdGVtaXNlZCBjYWNoZSByZWFkIGZyb20gdGhlIEpTT05cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGVKc29uQ2FjaGUoaW5NZW1vcnlDYWNoZTogSW5NZW1vcnlDYWNoZSk6IEpzb25DYWNoZSB7XG4gICAgICAgIHJldHVybiBTZXJpYWxpemVyLnNlcmlhbGl6ZUFsbENhY2hlKGluTWVtb3J5Q2FjaGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBjcmVkZW50aWFsJ3MgY2FjaGUga2V5IGlmIHRoZSBjdXJyZW50IGNhY2hlIGtleSBpcyBvdXRkYXRlZFxuICAgICAqL1xuICAgIHVwZGF0ZUNyZWRlbnRpYWxDYWNoZUtleShcbiAgICAgICAgY3VycmVudENhY2hlS2V5OiBzdHJpbmcsXG4gICAgICAgIGNyZWRlbnRpYWw6IFZhbGlkQ3JlZGVudGlhbFR5cGVcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB1cGRhdGVkQ2FjaGVLZXkgPSBDYWNoZUhlbHBlcnMuZ2VuZXJhdGVDcmVkZW50aWFsS2V5KGNyZWRlbnRpYWwpO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q2FjaGVLZXkgIT09IHVwZGF0ZWRDYWNoZUtleSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVJdGVtID0gdGhpcy5nZXRJdGVtKGN1cnJlbnRDYWNoZUtleSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGN1cnJlbnRDYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKHVwZGF0ZWRDYWNoZUtleSwgY2FjaGVJdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgICAgICBgVXBkYXRlZCBhbiBvdXRkYXRlZCAke2NyZWRlbnRpYWwuY3JlZGVudGlhbFR5cGV9IGNhY2hlIGtleWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkQ2FjaGVLZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHVwZGF0ZSBhbiBvdXRkYXRlZCAke2NyZWRlbnRpYWwuY3JlZGVudGlhbFR5cGV9IGNhY2hlIGtleSBidXQgbm8gaXRlbSBtYXRjaGluZyB0aGUgb3V0ZGF0ZWQga2V5IHdhcyBmb3VuZCBpbiBzdG9yYWdlYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VycmVudENhY2hlS2V5O1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTm9kZVN0b3JhZ2UgfSBmcm9tIFwiLi9Ob2RlU3RvcmFnZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBBY2NvdW50RW50aXR5LFxuICAgIEFjY291bnRJbmZvLFxuICAgIExvZ2dlcixcbiAgICBJU2VyaWFsaXphYmxlVG9rZW5DYWNoZSxcbiAgICBJQ2FjaGVQbHVnaW4sXG4gICAgVG9rZW5DYWNoZUNvbnRleHQsXG59IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuaW1wb3J0IHtcbiAgICBJbk1lbW9yeUNhY2hlLFxuICAgIEpzb25DYWNoZSxcbiAgICBTZXJpYWxpemVkQWNjb3VudEVudGl0eSxcbiAgICBTZXJpYWxpemVkQWNjZXNzVG9rZW5FbnRpdHksXG4gICAgU2VyaWFsaXplZFJlZnJlc2hUb2tlbkVudGl0eSxcbiAgICBTZXJpYWxpemVkSWRUb2tlbkVudGl0eSxcbiAgICBTZXJpYWxpemVkQXBwTWV0YWRhdGFFbnRpdHksXG4gICAgQ2FjaGVLVlN0b3JlLFxufSBmcm9tIFwiLi9zZXJpYWxpemVyL1NlcmlhbGl6ZXJUeXBlcy5qc1wiO1xuaW1wb3J0IHsgRGVzZXJpYWxpemVyIH0gZnJvbSBcIi4vc2VyaWFsaXplci9EZXNlcmlhbGl6ZXIuanNcIjtcbmltcG9ydCB7IFNlcmlhbGl6ZXIgfSBmcm9tIFwiLi9zZXJpYWxpemVyL1NlcmlhbGl6ZXIuanNcIjtcbmltcG9ydCB7IElUb2tlbkNhY2hlIH0gZnJvbSBcIi4vSVRva2VuQ2FjaGUuanNcIjtcblxuY29uc3QgZGVmYXVsdFNlcmlhbGl6ZWRDYWNoZTogSnNvbkNhY2hlID0ge1xuICAgIEFjY291bnQ6IHt9LFxuICAgIElkVG9rZW46IHt9LFxuICAgIEFjY2Vzc1Rva2VuOiB7fSxcbiAgICBSZWZyZXNoVG9rZW46IHt9LFxuICAgIEFwcE1ldGFkYXRhOiB7fSxcbn07XG5cbi8qKlxuICogSW4tbWVtb3J5IHRva2VuIGNhY2hlIG1hbmFnZXJcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuQ2FjaGUgaW1wbGVtZW50cyBJU2VyaWFsaXphYmxlVG9rZW5DYWNoZSwgSVRva2VuQ2FjaGUge1xuICAgIHByaXZhdGUgc3RvcmFnZTogTm9kZVN0b3JhZ2U7XG4gICAgcHJpdmF0ZSBjYWNoZUhhc0NoYW5nZWQ6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBjYWNoZVNuYXBzaG90OiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IHBlcnNpc3RlbmNlOiBJQ2FjaGVQbHVnaW47XG4gICAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBzdG9yYWdlOiBOb2RlU3RvcmFnZSxcbiAgICAgICAgbG9nZ2VyOiBMb2dnZXIsXG4gICAgICAgIGNhY2hlUGx1Z2luPzogSUNhY2hlUGx1Z2luXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2FjaGVIYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZWdpc3RlckNoYW5nZUVtaXR0ZXIodGhpcy5oYW5kbGVDaGFuZ2VFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKGNhY2hlUGx1Z2luKSB7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gY2FjaGVQbHVnaW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgY2FjaGUgc3RhdGUgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCB0aW1lIHNlcmlhbGl6ZSBvciB3cml0ZVRvUGVyc2lzdGVuY2Ugd2FzIGNhbGxlZFxuICAgICAqL1xuICAgIGhhc0NoYW5nZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlSGFzQ2hhbmdlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGluIG1lbW9yeSBjYWNoZSB0byBKU09OXG4gICAgICovXG4gICAgc2VyaWFsaXplKCk6IHN0cmluZyB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2VyaWFsaXppbmcgaW4tbWVtb3J5IGNhY2hlXCIpO1xuICAgICAgICBsZXQgZmluYWxTdGF0ZSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQWxsQ2FjaGUoXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZ2V0SW5NZW1vcnlDYWNoZSgpIGFzIEluTWVtb3J5Q2FjaGVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBpZiBjYWNoZVNuYXBzaG90IG5vdCBudWxsIG9yIGVtcHR5LCBtZXJnZVxuICAgICAgICBpZiAodGhpcy5jYWNoZVNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlJlYWRpbmcgY2FjaGUgc25hcHNob3QgZnJvbSBkaXNrXCIpO1xuICAgICAgICAgICAgZmluYWxTdGF0ZSA9IHRoaXMubWVyZ2VTdGF0ZShcbiAgICAgICAgICAgICAgICBKU09OLnBhcnNlKHRoaXMuY2FjaGVTbmFwc2hvdCksXG4gICAgICAgICAgICAgICAgZmluYWxTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiTm8gY2FjaGUgc25hcHNob3QgdG8gbWVyZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZUhhc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZmluYWxTdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIEpTT04gdG8gaW4tbWVtb3J5IGNhY2hlLiBKU09OIHNob3VsZCBiZSBpbiBNU0FMIGNhY2hlIHNjaGVtYSBmb3JtYXRcbiAgICAgKiBAcGFyYW0gY2FjaGUgLSBibG9iIGZvcm1hdHRlZCBjYWNoZVxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplKGNhY2hlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJEZXNlcmlhbGl6aW5nIEpTT04gdG8gaW4tbWVtb3J5IGNhY2hlXCIpO1xuICAgICAgICB0aGlzLmNhY2hlU25hcHNob3QgPSBjYWNoZTtcblxuICAgICAgICBpZiAodGhpcy5jYWNoZVNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlJlYWRpbmcgY2FjaGUgc25hcHNob3QgZnJvbSBkaXNrXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkQ2FjaGUgPSBEZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBbGxDYWNoZShcbiAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXlEZWZhdWx0cyhKU09OLnBhcnNlKHRoaXMuY2FjaGVTbmFwc2hvdCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEluTWVtb3J5Q2FjaGUoZGVzZXJpYWxpemVkQ2FjaGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJObyBjYWNoZSBzbmFwc2hvdCB0byBkZXNlcmlhbGl6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGNhY2hlIGtleS12YWx1ZSBtYXBcbiAgICAgKi9cbiAgICBnZXRLVlN0b3JlKCk6IENhY2hlS1ZTdG9yZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0Q2FjaGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhY2hlIHNuYXBzaG90IGluIENhY2hlS1ZTdG9yZSBmb3JtYXRcbiAgICAgKi9cbiAgICBnZXRDYWNoZVNuYXBzaG90KCk6IENhY2hlS1ZTdG9yZSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZFBlcnNpc3RlbnRTdG9yYWdlID0gTm9kZVN0b3JhZ2UuZ2VuZXJhdGVJbk1lbW9yeUNhY2hlKFxuICAgICAgICAgICAgdGhpcy5jYWNoZVNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuaW5NZW1vcnlDYWNoZVRvQ2FjaGUoZGVzZXJpYWxpemVkUGVyc2lzdGVudFN0b3JhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFQSSB0aGF0IHJldHJpZXZlcyBhbGwgYWNjb3VudHMgY3VycmVudGx5IGluIGNhY2hlIHRvIHRoZSB1c2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsQWNjb3VudHMoKTogUHJvbWlzZTxBY2NvdW50SW5mb1tdPiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiZ2V0QWxsQWNjb3VudHMgY2FsbGVkXCIpO1xuICAgICAgICBsZXQgY2FjaGVDb250ZXh0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgICBjYWNoZUNvbnRleHQgPSBuZXcgVG9rZW5DYWNoZUNvbnRleHQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuYmVmb3JlQ2FjaGVBY2Nlc3MoY2FjaGVDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0QWxsQWNjb3VudHMoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlICYmIGNhY2hlQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuYWZ0ZXJDYWNoZUFjY2VzcyhjYWNoZUNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2lnbmVkIGluIGFjY291bnQgbWF0Y2hpbmcgaG9tZUFjY291bnRJZC5cbiAgICAgKiAodGhlIGFjY291bnQgb2JqZWN0IGlzIGNyZWF0ZWQgYXQgdGhlIHRpbWUgb2Ygc3VjY2Vzc2Z1bCBsb2dpbilcbiAgICAgKiBvciBudWxsIHdoZW4gbm8gbWF0Y2hpbmcgYWNjb3VudCBpcyBmb3VuZFxuICAgICAqIEBwYXJhbSBob21lQWNjb3VudElkIC0gdW5pcXVlIGlkZW50aWZpZXIgZm9yIGFuIGFjY291bnQgKHVpZC51dGlkKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjY291bnRCeUhvbWVJZChcbiAgICAgICAgaG9tZUFjY291bnRJZDogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxBY2NvdW50SW5mbyB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgYWxsQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFsbEFjY291bnRzKCk7XG4gICAgICAgIGlmIChob21lQWNjb3VudElkICYmIGFsbEFjY291bnRzICYmIGFsbEFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBhbGxBY2NvdW50cy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIChhY2NvdW50T2JqKSA9PiBhY2NvdW50T2JqLmhvbWVBY2NvdW50SWQgPT09IGhvbWVBY2NvdW50SWRcbiAgICAgICAgICAgICAgICApWzBdIHx8IG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ25lZCBpbiBhY2NvdW50IG1hdGNoaW5nIGxvY2FsQWNjb3VudElkLlxuICAgICAqICh0aGUgYWNjb3VudCBvYmplY3QgaXMgY3JlYXRlZCBhdCB0aGUgdGltZSBvZiBzdWNjZXNzZnVsIGxvZ2luKVxuICAgICAqIG9yIG51bGwgd2hlbiBubyBtYXRjaGluZyBhY2NvdW50IGlzIGZvdW5kXG4gICAgICogQHBhcmFtIGxvY2FsQWNjb3VudElkIC0gdW5pcXVlIGlkZW50aWZpZXIgb2YgYW4gYWNjb3VudCAoc3ViL29iaiB3aGVuIGhvbWVBY2NvdW50SWQgY2Fubm90IGJlIHBvcHVsYXRlZClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY2NvdW50QnlMb2NhbElkKFxuICAgICAgICBsb2NhbEFjY291bnRJZDogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxBY2NvdW50SW5mbyB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgYWxsQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFsbEFjY291bnRzKCk7XG4gICAgICAgIGlmIChsb2NhbEFjY291bnRJZCAmJiBhbGxBY2NvdW50cyAmJiBhbGxBY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgYWxsQWNjb3VudHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAoYWNjb3VudE9iaikgPT4gYWNjb3VudE9iai5sb2NhbEFjY291bnRJZCA9PT0gbG9jYWxBY2NvdW50SWRcbiAgICAgICAgICAgICAgICApWzBdIHx8IG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFQSSB0byByZW1vdmUgYSBzcGVjaWZpYyBhY2NvdW50IGFuZCB0aGUgcmVsZXZhbnQgZGF0YSBmcm9tIGNhY2hlXG4gICAgICogQHBhcmFtIGFjY291bnQgLSBBY2NvdW50SW5mbyBwYXNzZWQgYnkgdGhlIHVzZXJcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBY2NvdW50KGFjY291bnQ6IEFjY291bnRJbmZvKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwicmVtb3ZlQWNjb3VudCBjYWxsZWRcIik7XG4gICAgICAgIGxldCBjYWNoZUNvbnRleHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgICAgIGNhY2hlQ29udGV4dCA9IG5ldyBUb2tlbkNhY2hlQ29udGV4dCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLmJlZm9yZUNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JhZ2UucmVtb3ZlQWNjb3VudChcbiAgICAgICAgICAgICAgICBBY2NvdW50RW50aXR5LmdlbmVyYXRlQWNjb3VudENhY2hlS2V5KGFjY291bnQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2UgJiYgY2FjaGVDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5hZnRlckNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGVzIGluLW1lbW9yeSBjYWNoZSB3aXRoIHBlcnNpc3RlbnQgY2FjaGVcbiAgICAgKi9cbiAgICBhc3luYyBvdmVyd3JpdGVDYWNoZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgIFwiTm8gcGVyc2lzdGVuY2UgbGF5ZXIgc3BlY2lmaWVkLCBjYWNoZSBjYW5ub3QgYmUgb3ZlcndyaXR0ZW5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiT3ZlcndyaXRpbmcgaW4tbWVtb3J5IGNhY2hlIHdpdGggcGVyc2lzdGVudCBjYWNoZVwiKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlQ29udGV4dCA9IG5ldyBUb2tlbkNhY2hlQ29udGV4dCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuYmVmb3JlQ2FjaGVBY2Nlc3MoY2FjaGVDb250ZXh0KTtcbiAgICAgICAgY29uc3QgY2FjaGVTbmFwc2hvdCA9IHRoaXMuZ2V0Q2FjaGVTbmFwc2hvdCgpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0Q2FjaGUoY2FjaGVTbmFwc2hvdCk7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuYWZ0ZXJDYWNoZUFjY2VzcyhjYWNoZUNvbnRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjYWNoZSBoYXMgY2hhbmdlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUNoYW5nZUV2ZW50KCkge1xuICAgICAgICB0aGlzLmNhY2hlSGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgaW4gbWVtb3J5IGNhY2hlIHdpdGggdGhlIGNhY2hlIHNuYXBzaG90LlxuICAgICAqIEBwYXJhbSBvbGRTdGF0ZSAtIGNhY2hlIGJlZm9yZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIGN1cnJlbnRTdGF0ZSAtIGN1cnJlbnQgY2FjaGUgc3RhdGUgaW4gdGhlIGxpYnJhcnlcbiAgICAgKi9cbiAgICBwcml2YXRlIG1lcmdlU3RhdGUoXG4gICAgICAgIG9sZFN0YXRlOiBKc29uQ2FjaGUsXG4gICAgICAgIGN1cnJlbnRTdGF0ZTogSnNvbkNhY2hlXG4gICAgKTogSnNvbkNhY2hlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJNZXJnaW5nIGluLW1lbW9yeSBjYWNoZSB3aXRoIGNhY2hlIHNuYXBzaG90XCIpO1xuICAgICAgICBjb25zdCBzdGF0ZUFmdGVyUmVtb3ZhbCA9IHRoaXMubWVyZ2VSZW1vdmFscyhvbGRTdGF0ZSwgY3VycmVudFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VVcGRhdGVzKHN0YXRlQWZ0ZXJSZW1vdmFsLCBjdXJyZW50U3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZXAgdXBkYXRlIG9mIG9sZFN0YXRlIGJhc2VkIG9uIG5ld1N0YXRlIHZhbHVlc1xuICAgICAqIEBwYXJhbSBvbGRTdGF0ZSAtIGNhY2hlIGJlZm9yZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIC0gdXBkYXRlZCBjYWNoZVxuICAgICAqL1xuICAgIHByaXZhdGUgbWVyZ2VVcGRhdGVzKG9sZFN0YXRlOiBvYmplY3QsIG5ld1N0YXRlOiBvYmplY3QpOiBKc29uQ2FjaGUge1xuICAgICAgICBPYmplY3Qua2V5cyhuZXdTdGF0ZSkuZm9yRWFjaCgobmV3S2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3U3RhdGVbbmV3S2V5XTtcblxuICAgICAgICAgICAgLy8gaWYgb2xkU3RhdGUgZG9lcyBub3QgY29udGFpbiB2YWx1ZSBidXQgbmV3VmFsdWUgZG9lcywgYWRkIGl0XG4gICAgICAgICAgICBpZiAoIW9sZFN0YXRlLmhhc093blByb3BlcnR5KG5ld0tleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGVbbmV3S2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYm90aCBvbGRTdGF0ZSBhbmQgbmV3U3RhdGUgY29udGFpbiB0aGUga2V5LCBkbyBkZWVwIHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlTm90TnVsbCA9IG5ld1ZhbHVlICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlSXNPYmplY3QgPSB0eXBlb2YgbmV3VmFsdWUgPT09IFwib2JqZWN0XCI7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWVJc05vdEFycmF5ID0gIUFycmF5LmlzQXJyYXkobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFN0YXRlTm90VW5kZWZpbmVkT3JOdWxsID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9sZFN0YXRlW25ld0tleV0gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGVbbmV3S2V5XSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVOb3ROdWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlSXNPYmplY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVJc05vdEFycmF5ICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlTm90VW5kZWZpbmVkT3JOdWxsXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VVcGRhdGVzKG9sZFN0YXRlW25ld0tleV0sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZVtuZXdLZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb2xkU3RhdGUgYXMgSnNvbkNhY2hlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZW50aXRpZXMgaW4gb2xkU3RhdGUgdGhhdCB0aGUgd2VyZSByZW1vdmVkIGZyb20gbmV3U3RhdGUuIElmIHRoZXJlIGFyZSBhbnkgdW5rbm93biB2YWx1ZXMgaW4gcm9vdCBvZlxuICAgICAqIG9sZFN0YXRlIHRoYXQgYXJlIG5vdCByZWNvZ25pemVkLCB0aGV5IGFyZSBsZWZ0IHVudG91Y2hlZC5cbiAgICAgKiBAcGFyYW0gb2xkU3RhdGUgLSBjYWNoZSBiZWZvcmUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBuZXdTdGF0ZSAtIHVwZGF0ZWQgY2FjaGVcbiAgICAgKi9cbiAgICBwcml2YXRlIG1lcmdlUmVtb3ZhbHMob2xkU3RhdGU6IEpzb25DYWNoZSwgbmV3U3RhdGU6IEpzb25DYWNoZSk6IEpzb25DYWNoZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiUmVtb3ZlIHVwZGF0ZWQgZW50cmllcyBpbiBjYWNoZVwiKTtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBvbGRTdGF0ZS5BY2NvdW50XG4gICAgICAgICAgICA/IHRoaXMubWVyZ2VSZW1vdmFsc0RpY3Q8U2VyaWFsaXplZEFjY291bnRFbnRpdHk+KFxuICAgICAgICAgICAgICAgICAgb2xkU3RhdGUuQWNjb3VudCxcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLkFjY291bnRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBvbGRTdGF0ZS5BY2NvdW50O1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbnMgPSBvbGRTdGF0ZS5BY2Nlc3NUb2tlblxuICAgICAgICAgICAgPyB0aGlzLm1lcmdlUmVtb3ZhbHNEaWN0PFNlcmlhbGl6ZWRBY2Nlc3NUb2tlbkVudGl0eT4oXG4gICAgICAgICAgICAgICAgICBvbGRTdGF0ZS5BY2Nlc3NUb2tlbixcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLkFjY2Vzc1Rva2VuXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogb2xkU3RhdGUuQWNjZXNzVG9rZW47XG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbnMgPSBvbGRTdGF0ZS5SZWZyZXNoVG9rZW5cbiAgICAgICAgICAgID8gdGhpcy5tZXJnZVJlbW92YWxzRGljdDxTZXJpYWxpemVkUmVmcmVzaFRva2VuRW50aXR5PihcbiAgICAgICAgICAgICAgICAgIG9sZFN0YXRlLlJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLlJlZnJlc2hUb2tlblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IG9sZFN0YXRlLlJlZnJlc2hUb2tlbjtcbiAgICAgICAgY29uc3QgaWRUb2tlbnMgPSBvbGRTdGF0ZS5JZFRva2VuXG4gICAgICAgICAgICA/IHRoaXMubWVyZ2VSZW1vdmFsc0RpY3Q8U2VyaWFsaXplZElkVG9rZW5FbnRpdHk+KFxuICAgICAgICAgICAgICAgICAgb2xkU3RhdGUuSWRUb2tlbixcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLklkVG9rZW5cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBvbGRTdGF0ZS5JZFRva2VuO1xuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YSA9IG9sZFN0YXRlLkFwcE1ldGFkYXRhXG4gICAgICAgICAgICA/IHRoaXMubWVyZ2VSZW1vdmFsc0RpY3Q8U2VyaWFsaXplZEFwcE1ldGFkYXRhRW50aXR5PihcbiAgICAgICAgICAgICAgICAgIG9sZFN0YXRlLkFwcE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuQXBwTWV0YWRhdGFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBvbGRTdGF0ZS5BcHBNZXRhZGF0YTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ub2xkU3RhdGUsXG4gICAgICAgICAgICBBY2NvdW50OiBhY2NvdW50cyxcbiAgICAgICAgICAgIEFjY2Vzc1Rva2VuOiBhY2Nlc3NUb2tlbnMsXG4gICAgICAgICAgICBSZWZyZXNoVG9rZW46IHJlZnJlc2hUb2tlbnMsXG4gICAgICAgICAgICBJZFRva2VuOiBpZFRva2VucyxcbiAgICAgICAgICAgIEFwcE1ldGFkYXRhOiBhcHBNZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gbWVyZ2UgbmV3IGNhY2hlIHdpdGggdGhlIG9sZCBvbmVcbiAgICAgKiBAcGFyYW0gb2xkU3RhdGUgLSBjYWNoZSBiZWZvcmUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBuZXdTdGF0ZSAtIHVwZGF0ZWQgY2FjaGVcbiAgICAgKi9cbiAgICBwcml2YXRlIG1lcmdlUmVtb3ZhbHNEaWN0PFQ+KFxuICAgICAgICBvbGRTdGF0ZTogUmVjb3JkPHN0cmluZywgVD4sXG4gICAgICAgIG5ld1N0YXRlPzogUmVjb3JkPHN0cmluZywgVD5cbiAgICApOiBSZWNvcmQ8c3RyaW5nLCBUPiB7XG4gICAgICAgIGNvbnN0IGZpbmFsU3RhdGUgPSB7IC4uLm9sZFN0YXRlIH07XG4gICAgICAgIE9iamVjdC5rZXlzKG9sZFN0YXRlKS5mb3JFYWNoKChvbGRLZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUgfHwgIW5ld1N0YXRlLmhhc093blByb3BlcnR5KG9sZEtleSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZmluYWxTdGF0ZVtvbGRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIHRvIG92ZXJsYXkgYXMgYSBwYXJ0IG9mIGNhY2hlIG1lcmdlXG4gICAgICogQHBhcmFtIHBhc3NlZEluQ2FjaGUgLSBjYWNoZSByZWFkIGZyb20gdGhlIGJsb2JcbiAgICAgKi9cbiAgICBwcml2YXRlIG92ZXJsYXlEZWZhdWx0cyhwYXNzZWRJbkNhY2hlOiBKc29uQ2FjaGUpOiBKc29uQ2FjaGUge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIk92ZXJsYXlpbmcgaW5wdXQgY2FjaGUgd2l0aCB0aGUgZGVmYXVsdCBjYWNoZVwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEFjY291bnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0U2VyaWFsaXplZENhY2hlLkFjY291bnQsXG4gICAgICAgICAgICAgICAgLi4ucGFzc2VkSW5DYWNoZS5BY2NvdW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIElkVG9rZW46IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0U2VyaWFsaXplZENhY2hlLklkVG9rZW4sXG4gICAgICAgICAgICAgICAgLi4ucGFzc2VkSW5DYWNoZS5JZFRva2VuLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEFjY2Vzc1Rva2VuOiB7XG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdFNlcmlhbGl6ZWRDYWNoZS5BY2Nlc3NUb2tlbixcbiAgICAgICAgICAgICAgICAuLi5wYXNzZWRJbkNhY2hlLkFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFJlZnJlc2hUb2tlbjoge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRTZXJpYWxpemVkQ2FjaGUuUmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgICAgIC4uLnBhc3NlZEluQ2FjaGUuUmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEFwcE1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdFNlcmlhbGl6ZWRDYWNoZS5BcHBNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAuLi5wYXNzZWRJbkNhY2hlLkFwcE1ldGFkYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBqd3QgZnJvbSBcImpzb253ZWJ0b2tlblwiO1xuaW1wb3J0IHtcbiAgICBUaW1lVXRpbHMsXG4gICAgQ29uc3RhbnRzLFxuICAgIGNyZWF0ZUNsaWVudEF1dGhFcnJvcixcbiAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcyxcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBDcnlwdG9Qcm92aWRlciB9IGZyb20gXCIuLi9jcnlwdG8vQ3J5cHRvUHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IEVuY29kaW5nVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvRW5jb2RpbmdVdGlscy5qc1wiO1xuaW1wb3J0IHsgSnd0Q29uc3RhbnRzIH0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuXG4vKipcbiAqIENsaWVudCBhc3NlcnRpb24gb2YgdHlwZSBqd3QtYmVhcmVyIHVzZWQgaW4gY29uZmlkZW50aWFsIGNsaWVudCBmbG93c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ2xpZW50QXNzZXJ0aW9uIHtcbiAgICBwcml2YXRlIGp3dDogc3RyaW5nO1xuICAgIHByaXZhdGUgcHJpdmF0ZUtleTogc3RyaW5nO1xuICAgIHByaXZhdGUgdGh1bWJwcmludDogc3RyaW5nO1xuICAgIHByaXZhdGUgdXNlU2hhMjU2OiBib29sZWFuO1xuICAgIHByaXZhdGUgZXhwaXJhdGlvblRpbWU6IG51bWJlcjtcbiAgICBwcml2YXRlIGlzc3Vlcjogc3RyaW5nO1xuICAgIHByaXZhdGUgand0QXVkaWVuY2U6IHN0cmluZztcbiAgICBwcml2YXRlIHB1YmxpY0NlcnRpZmljYXRlOiBBcnJheTxzdHJpbmc+O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgQ2xpZW50QXNzZXJ0aW9uIGNsYXNzIGZyb20gdGhlIGNsaWVudEFzc2VydGlvbiBwYXNzZWQgYnkgdGhlIHVzZXJcbiAgICAgKiBAcGFyYW0gYXNzZXJ0aW9uIC0gcmVmZXIgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MjFcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21Bc3NlcnRpb24oYXNzZXJ0aW9uOiBzdHJpbmcpOiBDbGllbnRBc3NlcnRpb24ge1xuICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb24gPSBuZXcgQ2xpZW50QXNzZXJ0aW9uKCk7XG4gICAgICAgIGNsaWVudEFzc2VydGlvbi5qd3QgPSBhc3NlcnRpb247XG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGZyb21DZXJ0aWZpY2F0ZVdpdGhTaGEyNTZUaHVtYnByaW50IGluc3RlYWQsIHdpdGggYSBTSEEtMjU2IHRodW1wcmludFxuICAgICAqIEluaXRpYWxpemUgdGhlIENsaWVudEFzc2VydGlvbiBjbGFzcyBmcm9tIHRoZSBjZXJ0aWZpY2F0ZSBwYXNzZWQgYnkgdGhlIHVzZXJcbiAgICAgKiBAcGFyYW0gdGh1bWJwcmludCAtIGlkZW50aWZpZXIgb2YgYSBjZXJ0aWZpY2F0ZVxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IC0gc2VjcmV0IGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNDZXJ0aWZpY2F0ZSAtIGVsZWN0cm9uaWMgZG9jdW1lbnQgcHJvdmlkZWQgdG8gcHJvdmUgdGhlIG93bmVyc2hpcCBvZiB0aGUgcHVibGljIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUNlcnRpZmljYXRlKFxuICAgICAgICB0aHVtYnByaW50OiBzdHJpbmcsXG4gICAgICAgIHByaXZhdGVLZXk6IHN0cmluZyxcbiAgICAgICAgcHVibGljQ2VydGlmaWNhdGU/OiBzdHJpbmdcbiAgICApOiBDbGllbnRBc3NlcnRpb24ge1xuICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb24gPSBuZXcgQ2xpZW50QXNzZXJ0aW9uKCk7XG4gICAgICAgIGNsaWVudEFzc2VydGlvbi5wcml2YXRlS2V5ID0gcHJpdmF0ZUtleTtcbiAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnRodW1icHJpbnQgPSB0aHVtYnByaW50O1xuICAgICAgICBjbGllbnRBc3NlcnRpb24udXNlU2hhMjU2ID0gZmFsc2U7XG4gICAgICAgIGlmIChwdWJsaWNDZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnB1YmxpY0NlcnRpZmljYXRlID1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQ2VydGlmaWNhdGUocHVibGljQ2VydGlmaWNhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgQ2xpZW50QXNzZXJ0aW9uIGNsYXNzIGZyb20gdGhlIGNlcnRpZmljYXRlIHBhc3NlZCBieSB0aGUgdXNlclxuICAgICAqIEBwYXJhbSB0aHVtYnByaW50IC0gaWRlbnRpZmllciBvZiBhIGNlcnRpZmljYXRlXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgLSBzZWNyZXQga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0NlcnRpZmljYXRlIC0gZWxlY3Ryb25pYyBkb2N1bWVudCBwcm92aWRlZCB0byBwcm92ZSB0aGUgb3duZXJzaGlwIG9mIHRoZSBwdWJsaWMga2V5XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmcm9tQ2VydGlmaWNhdGVXaXRoU2hhMjU2VGh1bWJwcmludChcbiAgICAgICAgdGh1bWJwcmludDogc3RyaW5nLFxuICAgICAgICBwcml2YXRlS2V5OiBzdHJpbmcsXG4gICAgICAgIHB1YmxpY0NlcnRpZmljYXRlPzogc3RyaW5nXG4gICAgKTogQ2xpZW50QXNzZXJ0aW9uIHtcbiAgICAgICAgY29uc3QgY2xpZW50QXNzZXJ0aW9uID0gbmV3IENsaWVudEFzc2VydGlvbigpO1xuICAgICAgICBjbGllbnRBc3NlcnRpb24ucHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIGNsaWVudEFzc2VydGlvbi50aHVtYnByaW50ID0gdGh1bWJwcmludDtcbiAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnVzZVNoYTI1NiA9IHRydWU7XG4gICAgICAgIGlmIChwdWJsaWNDZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnB1YmxpY0NlcnRpZmljYXRlID1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQ2VydGlmaWNhdGUocHVibGljQ2VydGlmaWNhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIEpXVCBmb3IgY2VydGlmaWNhdGUgYmFzZWQgY2xpZW50QXNzZXJ0aW9uLCBpZiBwYXNzZWQgYnkgdGhlIHVzZXIsIHVzZXMgaXQgYXMgaXNcbiAgICAgKiBAcGFyYW0gY3J5cHRvUHJvdmlkZXIgLSBsaWJyYXJ5J3MgY3J5cHRvIGhlbHBlclxuICAgICAqIEBwYXJhbSBpc3N1ZXIgLSBpc3MgY2xhaW1cbiAgICAgKiBAcGFyYW0gand0QXVkaWVuY2UgLSBhdWQgY2xhaW1cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Snd0KFxuICAgICAgICBjcnlwdG9Qcm92aWRlcjogQ3J5cHRvUHJvdmlkZXIsXG4gICAgICAgIGlzc3Vlcjogc3RyaW5nLFxuICAgICAgICBqd3RBdWRpZW5jZTogc3RyaW5nXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgLy8gaWYgYXNzZXJ0aW9uIHdhcyBjcmVhdGVkIGZyb20gY2VydGlmaWNhdGUsIGNoZWNrIGlmIGp3dCBpcyBleHBpcmVkIGFuZCBjcmVhdGUgbmV3IG9uZS5cbiAgICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleSAmJiB0aGlzLnRodW1icHJpbnQpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzLmp3dCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzRXhwaXJlZCgpICYmXG4gICAgICAgICAgICAgICAgaXNzdWVyID09PSB0aGlzLmlzc3VlciAmJlxuICAgICAgICAgICAgICAgIGp3dEF1ZGllbmNlID09PSB0aGlzLmp3dEF1ZGllbmNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qd3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUp3dChjcnlwdG9Qcm92aWRlciwgaXNzdWVyLCBqd3RBdWRpZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBpZiBhc3NlcnRpb24gd2FzIGNyZWF0ZWQgYnkgY2FsbGVyLCB0aGVuIHdlIGp1c3QgYXBwZW5kIGl0LiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvXG4gICAgICAgICAqIGVuc3VyZSB0aGF0IGl0IGNvbnRhaW5zIG5lY2Vzc2FyeSBjbGFpbXMgYW5kIHRoYXQgaXQgaXMgbm90IGV4cGlyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5qd3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmp3dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQXNzZXJ0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKV1QgZm9ybWF0IGFuZCByZXF1aXJlZCBjbGFpbXMgc3BlY2lmaWVkOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUyMyNzZWN0aW9uLTNcbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZUp3dChcbiAgICAgICAgY3J5cHRvUHJvdmlkZXI6IENyeXB0b1Byb3ZpZGVyLFxuICAgICAgICBpc3N1ZXI6IHN0cmluZyxcbiAgICAgICAgand0QXVkaWVuY2U6IHN0cmluZ1xuICAgICk6IHN0cmluZyB7XG4gICAgICAgIHRoaXMuaXNzdWVyID0gaXNzdWVyO1xuICAgICAgICB0aGlzLmp3dEF1ZGllbmNlID0gand0QXVkaWVuY2U7XG4gICAgICAgIGNvbnN0IGlzc3VlZEF0ID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IGlzc3VlZEF0ICsgNjAwO1xuXG4gICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IHRoaXMudXNlU2hhMjU2XG4gICAgICAgICAgICA/IEp3dENvbnN0YW50cy5QU1NfMjU2XG4gICAgICAgICAgICA6IEp3dENvbnN0YW50cy5SU0FfMjU2O1xuICAgICAgICBjb25zdCBoZWFkZXI6IGp3dC5Kd3RIZWFkZXIgPSB7XG4gICAgICAgICAgICBhbGc6IGFsZ29yaXRobSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB0aHVtYnByaW50SGVhZGVyID0gdGhpcy51c2VTaGEyNTZcbiAgICAgICAgICAgID8gSnd0Q29uc3RhbnRzLlg1VF8yNTZcbiAgICAgICAgICAgIDogSnd0Q29uc3RhbnRzLlg1VDtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIsIHtcbiAgICAgICAgICAgIFt0aHVtYnByaW50SGVhZGVyXTogRW5jb2RpbmdVdGlscy5iYXNlNjRFbmNvZGVVcmwoXG4gICAgICAgICAgICAgICAgdGhpcy50aHVtYnByaW50LFxuICAgICAgICAgICAgICAgIFwiaGV4XCJcbiAgICAgICAgICAgICksXG4gICAgICAgIH0gYXMgUGFydGlhbDxqd3QuSnd0SGVhZGVyPik7XG5cbiAgICAgICAgaWYgKHRoaXMucHVibGljQ2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVyLCB7XG4gICAgICAgICAgICAgICAgW0p3dENvbnN0YW50cy5YNUNdOiB0aGlzLnB1YmxpY0NlcnRpZmljYXRlLFxuICAgICAgICAgICAgfSBhcyBQYXJ0aWFsPGp3dC5Kd3RIZWFkZXI+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBbSnd0Q29uc3RhbnRzLkFVRElFTkNFXTogdGhpcy5qd3RBdWRpZW5jZSxcbiAgICAgICAgICAgIFtKd3RDb25zdGFudHMuRVhQSVJBVElPTl9USU1FXTogdGhpcy5leHBpcmF0aW9uVGltZSxcbiAgICAgICAgICAgIFtKd3RDb25zdGFudHMuSVNTVUVSXTogdGhpcy5pc3N1ZXIsXG4gICAgICAgICAgICBbSnd0Q29uc3RhbnRzLlNVQkpFQ1RdOiB0aGlzLmlzc3VlcixcbiAgICAgICAgICAgIFtKd3RDb25zdGFudHMuTk9UX0JFRk9SRV06IGlzc3VlZEF0LFxuICAgICAgICAgICAgW0p3dENvbnN0YW50cy5KV1RfSURdOiBjcnlwdG9Qcm92aWRlci5jcmVhdGVOZXdHdWlkKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5qd3QgPSBqd3Quc2lnbihwYXlsb2FkLCB0aGlzLnByaXZhdGVLZXksIHsgaGVhZGVyIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qd3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBBUEkgdG8gY2hlY2sgZXhwaXJhdGlvblxuICAgICAqL1xuICAgIHByaXZhdGUgaXNFeHBpcmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9uVGltZSA8IFRpbWVVdGlscy5ub3dTZWNvbmRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHJhdyBjZXJ0cyBmcm9tIGEgZ2l2ZW4gY2VydGlmaWNhdGUgc3RyaW5nIGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHB1YmxpY0NlcnRpZmljYXRlIC0gZWxlY3Ryb25pYyBkb2N1bWVudCBwcm92aWRlZCB0byBwcm92ZSB0aGUgb3duZXJzaGlwIG9mIHRoZSBwdWJsaWMga2V5XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZUNlcnRpZmljYXRlKHB1YmxpY0NlcnRpZmljYXRlOiBzdHJpbmcpOiBBcnJheTxzdHJpbmc+IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgcmVnZXggdG8gaWRlbnRpZnkgdGhlIGNlcnRzIGluIGEgZ2l2ZW4gY2VydGlmaWNhdGUgc3RyaW5nLlxuICAgICAgICAgKiBXZSB3YW50IHRvIGxvb2sgZm9yIHRoZSBjb250ZW50cyBiZXR3ZWVuIHRoZSBCRUdJTiBhbmQgRU5EIGNlcnRpZmljYXRlIHN0cmluZ3MsIHdpdGhvdXQgdGhlIGFzc29jaWF0ZWQgbmV3bGluZXMuXG4gICAgICAgICAqIFRoZSBpbmZvcm1hdGlvbiBpbiBwYXJlbnMgXCIoLis/KVwiIGlzIHRoZSBjYXB0dXJlIGdyb3VwIHRvIHJlcHJlc2VudCB0aGUgY2VydCB3ZSB3YW50IGlzb2xhdGVkLlxuICAgICAgICAgKiBcIi5cIiBtZWFucyBhbnkgc3RyaW5nIGNoYXJhY3RlciwgXCIrXCIgbWVhbnMgbWF0Y2ggMSBvciBtb3JlIHRpbWVzLCBhbmQgXCI/XCIgbWVhbnMgdGhlIHNob3J0ZXN0IG1hdGNoLlxuICAgICAgICAgKiBUaGUgXCJnXCIgYXQgdGhlIGVuZCBvZiB0aGUgcmVnZXggbWVhbnMgc2VhcmNoIHRoZSBzdHJpbmcgZ2xvYmFsbHksIGFuZCB0aGUgXCJzXCIgZW5hYmxlcyB0aGUgXCIuXCIgdG8gbWF0Y2ggbmV3bGluZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZWdleFRvRmluZENlcnRzID1cbiAgICAgICAgICAgIC8tLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cXHIqXFxuKC4rPylcXHIqXFxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLS9ncztcbiAgICAgICAgY29uc3QgY2VydHM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICAgIHdoaWxlICgobWF0Y2hlcyA9IHJlZ2V4VG9GaW5kQ2VydHMuZXhlYyhwdWJsaWNDZXJ0aWZpY2F0ZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBtYXRjaGVzWzFdIHJlcHJlc2VudHMgdGhlIGZpcnN0IHBhcmVucyBjYXB0dXJlIGdyb3VwIGluIHRoZSByZWdleC5cbiAgICAgICAgICAgIGNlcnRzLnB1c2gobWF0Y2hlc1sxXS5yZXBsYWNlKC9cXHIqXFxuL2csIENvbnN0YW50cy5FTVBUWV9TVFJJTkcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZXJ0cztcbiAgICB9XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgaGVhZGVyL2hlYWRlciAqL1xuZXhwb3J0IGNvbnN0IG5hbWUgPSBcIkBhenVyZS9tc2FsLW5vZGVcIjtcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCIzLjQuMVwiO1xuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEF1dGhlbnRpY2F0aW9uUmVzdWx0LFxuICAgIEF1dGhvcml0eSxcbiAgICBCYXNlQ2xpZW50LFxuICAgIENjc0NyZWRlbnRpYWxUeXBlLFxuICAgIENsaWVudEFzc2VydGlvbixcbiAgICBDbGllbnRDb25maWd1cmF0aW9uLFxuICAgIENvbW1vblVzZXJuYW1lUGFzc3dvcmRSZXF1ZXN0LFxuICAgIEdyYW50VHlwZSxcbiAgICBOZXR3b3JrUmVzcG9uc2UsXG4gICAgT0F1dGhSZXNwb25zZVR5cGUsXG4gICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIsXG4gICAgUmVxdWVzdFRodW1icHJpbnQsXG4gICAgUmVzcG9uc2VIYW5kbGVyLFxuICAgIFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlLFxuICAgIFN0cmluZ1V0aWxzLFxuICAgIFRpbWVVdGlscyxcbiAgICBVcmxTdHJpbmcsXG4gICAgVXJsVXRpbHMsXG4gICAgZ2V0Q2xpZW50QXNzZXJ0aW9uLFxufSBmcm9tIFwiQGF6dXJlL21zYWwtY29tbW9uL25vZGVcIjtcblxuLyoqXG4gKiBPYXV0aDIuMCBQYXNzd29yZCBncmFudCBjbGllbnRcbiAqIE5vdGU6IFdlIGFyZSBvbmx5IHN1cHBvcnRpbmcgcHVibGljIGNsaWVudHMgZm9yIHBhc3N3b3JkIGdyYW50IGFuZCBmb3IgcHVyZWx5IHRlc3RpbmcgcHVycG9zZXNcbiAqIEBwdWJsaWNcbiAqIEBkZXByZWNhdGVkIC0gVXNlIGEgbW9yZSBzZWN1cmUgZmxvdyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBjbGFzcyBVc2VybmFtZVBhc3N3b3JkQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbjogQ2xpZW50Q29uZmlndXJhdGlvbikge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBUEkgdG8gYWNxdWlyZSBhIHRva2VuIGJ5IHBhc3NpbmcgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCB0byB0aGUgc2VydmljZSBpbiBleGNoYWdlIG9mIGNyZWRlbnRpYWxzXG4gICAgICogcGFzc3dvcmRfZ3JhbnRcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIENvbW1vblVzZXJuYW1lUGFzc3dvcmRSZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuKFxuICAgICAgICByZXF1ZXN0OiBDb21tb25Vc2VybmFtZVBhc3N3b3JkUmVxdWVzdFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsPiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJpbiBhY3F1aXJlVG9rZW4gY2FsbCBpbiB1c2VybmFtZS1wYXNzd29yZCBjbGllbnRcIik7XG5cbiAgICAgICAgY29uc3QgcmVxVGltZXN0YW1wID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVUb2tlblJlcXVlc3QoXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eSxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSBuZXcgUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICB0aGlzLmNhY2hlTWFuYWdlcixcbiAgICAgICAgICAgIHRoaXMuY3J5cHRvVXRpbHMsXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNlcmlhbGl6YWJsZUNhY2hlLFxuICAgICAgICAgICAgdGhpcy5jb25maWcucGVyc2lzdGVuY2VQbHVnaW5cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSByZXNwb25zZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3MgYSBzZXJ2ZXIgZXJyb3IgaWYgYW4gZXJyb3IgaXMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnZhbGlkYXRlVG9rZW5SZXNwb25zZShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IHJlc3BvbnNlSGFuZGxlci5oYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5LFxuICAgICAgICAgICAgcmVxVGltZXN0YW1wLFxuICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0b2tlblJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIFBPU1QgcmVxdWVzdCB0byB0b2tlbiBlbmRwb2ludFxuICAgICAqIEBwYXJhbSBhdXRob3JpdHkgLSBhdXRob3JpdHkgb2JqZWN0XG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBDb21tb25Vc2VybmFtZVBhc3N3b3JkUmVxdWVzdCBwcm92aWRlZCBieSB0aGUgZGV2ZWxvcGVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBleGVjdXRlVG9rZW5SZXF1ZXN0KFxuICAgICAgICBhdXRob3JpdHk6IEF1dGhvcml0eSxcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uVXNlcm5hbWVQYXNzd29yZFJlcXVlc3RcbiAgICApOiBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZT4+IHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5jcmVhdGVUb2tlblF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBVcmxTdHJpbmcuYXBwZW5kUXVlcnlTdHJpbmcoXG4gICAgICAgICAgICBhdXRob3JpdHkudG9rZW5FbmRwb2ludCxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1N0cmluZ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGF3YWl0IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0SGVhZGVycyh7XG4gICAgICAgICAgICBjcmVkZW50aWFsOiByZXF1ZXN0LnVzZXJuYW1lLFxuICAgICAgICAgICAgdHlwZTogQ2NzQ3JlZGVudGlhbFR5cGUuVVBOLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGh1bWJwcmludDogUmVxdWVzdFRodW1icHJpbnQgPSB7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICBhdXRob3JpdHk6IGF1dGhvcml0eS5jYW5vbmljYWxBdXRob3JpdHksXG4gICAgICAgICAgICBzY29wZXM6IHJlcXVlc3Quc2NvcGVzLFxuICAgICAgICAgICAgY2xhaW1zOiByZXF1ZXN0LmNsYWltcyxcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uU2NoZW1lOiByZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lLFxuICAgICAgICAgICAgcmVzb3VyY2VSZXF1ZXN0TWV0aG9kOiByZXF1ZXN0LnJlc291cmNlUmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgIHJlc291cmNlUmVxdWVzdFVyaTogcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RVcmksXG4gICAgICAgICAgICBzaHJDbGFpbXM6IHJlcXVlc3Quc2hyQ2xhaW1zLFxuICAgICAgICAgICAgc3NoS2lkOiByZXF1ZXN0LnNzaEtpZCxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludChcbiAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgcmVxdWVzdEJvZHksXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgdGh1bWJwcmludCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG1hcCBmb3IgYWxsIHRoZSBwYXJhbXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmljZVxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gQ29tbW9uVXNlcm5hbWVQYXNzd29yZFJlcXVlc3QgcHJvdmlkZWQgYnkgdGhlIGRldmVsb3BlclxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uVXNlcm5hbWVQYXNzd29yZFJlcXVlc3RcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRJZChcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZFxuICAgICAgICApO1xuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRVc2VybmFtZShwYXJhbWV0ZXJzLCByZXF1ZXN0LnVzZXJuYW1lKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUGFzc3dvcmQocGFyYW1ldGVycywgcmVxdWVzdC5wYXNzd29yZCk7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU2NvcGVzKHBhcmFtZXRlcnMsIHJlcXVlc3Quc2NvcGVzKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRSZXNwb25zZVR5cGUoXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgT0F1dGhSZXNwb25zZVR5cGUuSURUT0tFTl9UT0tFTlxuICAgICAgICApO1xuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEdyYW50VHlwZShcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICBHcmFudFR5cGUuUkVTT1VSQ0VfT1dORVJfUEFTU1dPUkRfR1JBTlRcbiAgICAgICAgKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMaWJyYXJ5SW5mbyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5saWJyYXJ5SW5mb1xuICAgICAgICApO1xuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRBcHBsaWNhdGlvblRlbGVtZXRyeShcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy50ZWxlbWV0cnkuYXBwbGljYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3JyZWxhdGlvbklkID1cbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZCB8fFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY3J5cHRvSW50ZXJmYWNlLmNyZWF0ZU5ld0d1aWQoKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ29ycmVsYXRpb25JZChwYXJhbWV0ZXJzLCBjb3JyZWxhdGlvbklkKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRTZWNyZXQoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb246IENsaWVudEFzc2VydGlvbiB8IHVuZGVmaW5lZCA9XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRBc3NlcnRpb247XG5cbiAgICAgICAgaWYgKGNsaWVudEFzc2VydGlvbikge1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50QXNzZXJ0aW9uKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYXdhaXQgZ2V0Q2xpZW50QXNzZXJ0aW9uKFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRBc3NlcnRpb24uYXNzZXJ0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RVcmlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50QXNzZXJ0aW9uVHlwZShcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGNsaWVudEFzc2VydGlvbi5hc3NlcnRpb25UeXBlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIVN0cmluZ1V0aWxzLmlzRW1wdHlPYmoocmVxdWVzdC5jbGFpbXMpIHx8XG4gICAgICAgICAgICAodGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xhaW1zKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jbGFpbXMsXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy5wcmV2ZW50Q29yc1ByZWZsaWdodCAmJlxuICAgICAgICAgICAgcmVxdWVzdC51c2VybmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc1VwbihwYXJhbWV0ZXJzLCByZXF1ZXN0LnVzZXJuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBBdXRob3JpdHksXG4gICAgQXV0aG9yaXplUHJvdG9jb2wsXG4gICAgQ29tbW9uQXV0aG9yaXphdGlvblVybFJlcXVlc3QsXG4gICAgTG9nZ2VyLFxuICAgIE9BdXRoUmVzcG9uc2VUeXBlLFxuICAgIFByb3RvY29sTW9kZSxcbiAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlcixcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBOb2RlQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuLi9jb25maWcvQ29uZmlndXJhdGlvbi5qc1wiO1xuaW1wb3J0IHsgQ29uc3RhbnRzIGFzIE5vZGVDb25zdGFudHMgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL3BhY2thZ2VNZXRhZGF0YS5qc1wiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgdGhlIGZ1bGwgL2F1dGhvcml6ZSBVUkwgd2l0aCByZXF1ZXN0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBjb25maWdcbiAqIEBwYXJhbSBhdXRob3JpdHlcbiAqIEBwYXJhbSByZXF1ZXN0XG4gKiBAcGFyYW0gbG9nZ2VyXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0aENvZGVSZXF1ZXN0VXJsKFxuICAgIGNvbmZpZzogTm9kZUNvbmZpZ3VyYXRpb24sXG4gICAgYXV0aG9yaXR5OiBBdXRob3JpdHksXG4gICAgcmVxdWVzdDogQ29tbW9uQXV0aG9yaXphdGlvblVybFJlcXVlc3QsXG4gICAgbG9nZ2VyOiBMb2dnZXJcbik6IHN0cmluZyB7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IEF1dGhvcml6ZVByb3RvY29sLmdldFN0YW5kYXJkQXV0aG9yaXplUmVxdWVzdFBhcmFtZXRlcnMoXG4gICAgICAgIHtcbiAgICAgICAgICAgIC4uLmNvbmZpZy5hdXRoLFxuICAgICAgICAgICAgYXV0aG9yaXR5OiBhdXRob3JpdHksXG4gICAgICAgICAgICByZWRpcmVjdFVyaTogcmVxdWVzdC5yZWRpcmVjdFVyaSB8fCBcIlwiLFxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2dnZXJcbiAgICApO1xuICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZExpYnJhcnlJbmZvKHBhcmFtZXRlcnMsIHtcbiAgICAgICAgc2t1OiBOb2RlQ29uc3RhbnRzLk1TQUxfU0tVLFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICBjcHU6IHByb2Nlc3MuYXJjaCB8fCBcIlwiLFxuICAgICAgICBvczogcHJvY2Vzcy5wbGF0Zm9ybSB8fCBcIlwiLFxuICAgIH0pO1xuICAgIGlmIChjb25maWcuYXV0aC5wcm90b2NvbE1vZGUgIT09IFByb3RvY29sTW9kZS5PSURDKSB7XG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEFwcGxpY2F0aW9uVGVsZW1ldHJ5KFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvbmZpZy50ZWxlbWV0cnkuYXBwbGljYXRpb25cbiAgICAgICAgKTtcbiAgICB9XG4gICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUmVzcG9uc2VUeXBlKHBhcmFtZXRlcnMsIE9BdXRoUmVzcG9uc2VUeXBlLkNPREUpO1xuICAgIGlmIChyZXF1ZXN0LmNvZGVDaGFsbGVuZ2UgJiYgcmVxdWVzdC5jb2RlQ2hhbGxlbmdlTWV0aG9kKSB7XG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENvZGVDaGFsbGVuZ2VQYXJhbXMoXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcmVxdWVzdC5jb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgcmVxdWVzdC5jb2RlQ2hhbGxlbmdlTWV0aG9kXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkRXh0cmFRdWVyeVBhcmFtZXRlcnMoXG4gICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgIHJlcXVlc3QuZXh0cmFRdWVyeVBhcmFtZXRlcnMgfHwge31cbiAgICApO1xuXG4gICAgcmV0dXJuIEF1dGhvcml6ZVByb3RvY29sLmdldEF1dGhvcml6ZVVybChhdXRob3JpdHksIHBhcmFtZXRlcnMpO1xufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEF1dGhvcml6YXRpb25Db2RlQ2xpZW50LFxuICAgIENsaWVudENvbmZpZ3VyYXRpb24sXG4gICAgUmVmcmVzaFRva2VuQ2xpZW50LFxuICAgIEF1dGhlbnRpY2F0aW9uUmVzdWx0LFxuICAgIEF1dGhvcml0eSxcbiAgICBBdXRob3JpdHlGYWN0b3J5LFxuICAgIEJhc2VBdXRoUmVxdWVzdCxcbiAgICBTaWxlbnRGbG93Q2xpZW50LFxuICAgIExvZ2dlcixcbiAgICBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLFxuICAgIFNlcnZlclRlbGVtZXRyeVJlcXVlc3QsXG4gICAgQ29tbW9uU2lsZW50Rmxvd1JlcXVlc3QsXG4gICAgQ29tbW9uUmVmcmVzaFRva2VuUmVxdWVzdCxcbiAgICBDb21tb25BdXRob3JpemF0aW9uQ29kZVJlcXVlc3QsXG4gICAgQ29tbW9uQXV0aG9yaXphdGlvblVybFJlcXVlc3QsXG4gICAgQ29tbW9uVXNlcm5hbWVQYXNzd29yZFJlcXVlc3QsXG4gICAgQXV0aGVudGljYXRpb25TY2hlbWUsXG4gICAgUmVzcG9uc2VNb2RlLFxuICAgIEF1dGhvcml0eU9wdGlvbnMsXG4gICAgT0lEQ19ERUZBVUxUX1NDT1BFUyxcbiAgICBBenVyZVJlZ2lvbkNvbmZpZ3VyYXRpb24sXG4gICAgQXV0aEVycm9yLFxuICAgIEF6dXJlQ2xvdWRPcHRpb25zLFxuICAgIEF1dGhvcml6YXRpb25Db2RlUGF5bG9hZCxcbiAgICBDb25zdGFudHMsXG4gICAgU3RyaW5nVXRpbHMsXG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIGJ1aWxkU3RhdGljQXV0aG9yaXR5T3B0aW9ucyxcbiAgICBDbGllbnRBc3NlcnRpb24gYXMgQ2xpZW50QXNzZXJ0aW9uVHlwZSxcbiAgICBnZXRDbGllbnRBc3NlcnRpb24sXG4gICAgQ2xpZW50QXNzZXJ0aW9uQ2FsbGJhY2ssXG4gICAgQ2FjaGVPdXRjb21lLFxuICAgIENsaWVudEF1dGhFcnJvcixcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQge1xuICAgIENvbmZpZ3VyYXRpb24sXG4gICAgYnVpbGRBcHBDb25maWd1cmF0aW9uLFxuICAgIE5vZGVDb25maWd1cmF0aW9uLFxufSBmcm9tIFwiLi4vY29uZmlnL0NvbmZpZ3VyYXRpb24uanNcIjtcbmltcG9ydCB7IENyeXB0b1Byb3ZpZGVyIH0gZnJvbSBcIi4uL2NyeXB0by9DcnlwdG9Qcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgTm9kZVN0b3JhZ2UgfSBmcm9tIFwiLi4vY2FjaGUvTm9kZVN0b3JhZ2UuanNcIjtcbmltcG9ydCB7IENvbnN0YW50cyBhcyBOb2RlQ29uc3RhbnRzLCBBcGlJZCB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7IFRva2VuQ2FjaGUgfSBmcm9tIFwiLi4vY2FjaGUvVG9rZW5DYWNoZS5qc1wiO1xuaW1wb3J0IHsgQ2xpZW50QXNzZXJ0aW9uIH0gZnJvbSBcIi4vQ2xpZW50QXNzZXJ0aW9uLmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpemF0aW9uVXJsUmVxdWVzdCB9IGZyb20gXCIuLi9yZXF1ZXN0L0F1dGhvcml6YXRpb25VcmxSZXF1ZXN0LmpzXCI7XG5pbXBvcnQgeyBBdXRob3JpemF0aW9uQ29kZVJlcXVlc3QgfSBmcm9tIFwiLi4vcmVxdWVzdC9BdXRob3JpemF0aW9uQ29kZVJlcXVlc3QuanNcIjtcbmltcG9ydCB7IFJlZnJlc2hUb2tlblJlcXVlc3QgfSBmcm9tIFwiLi4vcmVxdWVzdC9SZWZyZXNoVG9rZW5SZXF1ZXN0LmpzXCI7XG5pbXBvcnQgeyBTaWxlbnRGbG93UmVxdWVzdCB9IGZyb20gXCIuLi9yZXF1ZXN0L1NpbGVudEZsb3dSZXF1ZXN0LmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uLCBuYW1lIH0gZnJvbSBcIi4uL3BhY2thZ2VNZXRhZGF0YS5qc1wiO1xuaW1wb3J0IHsgVXNlcm5hbWVQYXNzd29yZFJlcXVlc3QgfSBmcm9tIFwiLi4vcmVxdWVzdC9Vc2VybmFtZVBhc3N3b3JkUmVxdWVzdC5qc1wiO1xuaW1wb3J0IHsgTm9kZUF1dGhFcnJvciB9IGZyb20gXCIuLi9lcnJvci9Ob2RlQXV0aEVycm9yLmpzXCI7XG5pbXBvcnQgeyBVc2VybmFtZVBhc3N3b3JkQ2xpZW50IH0gZnJvbSBcIi4vVXNlcm5hbWVQYXNzd29yZENsaWVudC5qc1wiO1xuaW1wb3J0IHsgZ2V0QXV0aENvZGVSZXF1ZXN0VXJsIH0gZnJvbSBcIi4uL3Byb3RvY29sL0F1dGhvcml6ZS5qc1wiO1xuXG4vKipcbiAqIEJhc2UgYWJzdHJhY3QgY2xhc3MgZm9yIGFsbCBDbGllbnRBcHBsaWNhdGlvbnMgLSBwdWJsaWMgYW5kIGNvbmZpZGVudGlhbFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xpZW50QXBwbGljYXRpb24ge1xuICAgIHByb3RlY3RlZCByZWFkb25seSBjcnlwdG9Qcm92aWRlcjogQ3J5cHRvUHJvdmlkZXI7XG4gICAgcHJpdmF0ZSB0b2tlbkNhY2hlOiBUb2tlbkNhY2hlO1xuXG4gICAgLyoqXG4gICAgICogUGxhdGZvcm0gc3RvcmFnZSBvYmplY3RcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RvcmFnZTogTm9kZVN0b3JhZ2U7XG4gICAgLyoqXG4gICAgICogTG9nZ2VyIG9iamVjdCB0byBsb2cgdGhlIGFwcGxpY2F0aW9uIGZsb3dcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgbG9nZ2VyOiBMb2dnZXI7XG4gICAgLyoqXG4gICAgICogUGxhdGZvcm0gY29uZmlndXJhdGlvbiBpbml0aWFsaXplZCBieSB0aGUgYXBwbGljYXRpb25cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBOb2RlQ29uZmlndXJhdGlvbjtcbiAgICAvKipcbiAgICAgKiBDbGllbnQgYXNzZXJ0aW9uIHBhc3NlZCBieSB0aGUgdXNlciBmb3IgY29uZmlkZW50aWFsIGNsaWVudCBmbG93c1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBjbGllbnRBc3NlcnRpb246IENsaWVudEFzc2VydGlvbjtcbiAgICBwcm90ZWN0ZWQgZGV2ZWxvcGVyUHJvdmlkZWRDbGllbnRBc3NlcnRpb246XG4gICAgICAgIHwgc3RyaW5nXG4gICAgICAgIHwgQ2xpZW50QXNzZXJ0aW9uQ2FsbGJhY2s7XG4gICAgLyoqXG4gICAgICogQ2xpZW50IHNlY3JldCBwYXNzZWQgYnkgdGhlIHVzZXIgZm9yIGNvbmZpZGVudGlhbCBjbGllbnQgZmxvd3NcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2xpZW50U2VjcmV0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIENsaWVudEFwcGxpY2F0aW9uXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBidWlsZEFwcENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgICAgIHRoaXMuY3J5cHRvUHJvdmlkZXIgPSBuZXcgQ3J5cHRvUHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgdGhpcy5jb25maWcuc3lzdGVtLmxvZ2dlck9wdGlvbnMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTm9kZVN0b3JhZ2UoXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWQsXG4gICAgICAgICAgICB0aGlzLmNyeXB0b1Byb3ZpZGVyLFxuICAgICAgICAgICAgYnVpbGRTdGF0aWNBdXRob3JpdHlPcHRpb25zKHRoaXMuY29uZmlnLmF1dGgpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudG9rZW5DYWNoZSA9IG5ldyBUb2tlbkNhY2hlKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYWNoZS5jYWNoZVBsdWdpblxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFVSTCBvZiB0aGUgYXV0aG9yaXphdGlvbiByZXF1ZXN0LCBsZXR0aW5nIHRoZSB1c2VyIGlucHV0IGNyZWRlbnRpYWxzIGFuZCBjb25zZW50IHRvIHRoZVxuICAgICAqIGFwcGxpY2F0aW9uLiBUaGUgVVJMIHRhcmdldHMgdGhlIC9hdXRob3JpemUgZW5kcG9pbnQgb2YgdGhlIGF1dGhvcml0eSBjb25maWd1cmVkIGluIHRoZVxuICAgICAqIGFwcGxpY2F0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIE9uY2UgdGhlIHVzZXIgaW5wdXRzIHRoZWlyIGNyZWRlbnRpYWxzIGFuZCBjb25zZW50cywgdGhlIGF1dGhvcml0eSB3aWxsIHNlbmQgYSByZXNwb25zZSB0byB0aGUgcmVkaXJlY3QgVVJJXG4gICAgICogc2VudCBpbiB0aGUgcmVxdWVzdCBhbmQgc2hvdWxkIGNvbnRhaW4gYW4gYXV0aG9yaXphdGlvbiBjb2RlLCB3aGljaCBjYW4gdGhlbiBiZSB1c2VkIHRvIGFjcXVpcmUgdG9rZW5zIHZpYVxuICAgICAqIGBhY3F1aXJlVG9rZW5CeUNvZGUoQXV0aG9yaXphdGlvbkNvZGVSZXF1ZXN0KWAuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXV0aENvZGVVcmwocmVxdWVzdDogQXV0aG9yaXphdGlvblVybFJlcXVlc3QpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiZ2V0QXV0aENvZGVVcmwgY2FsbGVkXCIsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XG4gICAgICAgIGNvbnN0IHZhbGlkUmVxdWVzdDogQ29tbW9uQXV0aG9yaXphdGlvblVybFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgLi4uKGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUJhc2VSZXF1ZXN0KHJlcXVlc3QpKSxcbiAgICAgICAgICAgIHJlc3BvbnNlTW9kZTogcmVxdWVzdC5yZXNwb25zZU1vZGUgfHwgUmVzcG9uc2VNb2RlLlFVRVJZLFxuICAgICAgICAgICAgYXV0aGVudGljYXRpb25TY2hlbWU6IEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUixcbiAgICAgICAgICAgIHN0YXRlOiByZXF1ZXN0LnN0YXRlIHx8IFwiXCIsXG4gICAgICAgICAgICBub25jZTogcmVxdWVzdC5ub25jZSB8fCBcIlwiLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRpc2NvdmVyZWRBdXRob3JpdHkgPSBhd2FpdCB0aGlzLmNyZWF0ZUF1dGhvcml0eShcbiAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5hdXRob3JpdHksXG4gICAgICAgICAgICB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlcXVlc3QuYXp1cmVDbG91ZE9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdldEF1dGhDb2RlUmVxdWVzdFVybChcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgZGlzY292ZXJlZEF1dGhvcml0eSxcbiAgICAgICAgICAgIHZhbGlkUmVxdWVzdCxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSB0b2tlbiBieSBleGNoYW5naW5nIHRoZSBBdXRob3JpemF0aW9uIENvZGUgcmVjZWl2ZWQgZnJvbSB0aGUgZmlyc3Qgc3RlcCBvZiBPQXV0aDIuMFxuICAgICAqIEF1dGhvcml6YXRpb24gQ29kZSBmbG93LlxuICAgICAqXG4gICAgICogYGdldEF1dGhDb2RlVXJsKEF1dGhvcml6YXRpb25Db2RlVXJsUmVxdWVzdClgIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgVVJMIGZvciB0aGUgZmlyc3Qgc3RlcCBvZiBPQXV0aDIuMFxuICAgICAqIEF1dGhvcml6YXRpb24gQ29kZSBmbG93LiBFbnN1cmUgdGhhdCB2YWx1ZXMgZm9yIHJlZGlyZWN0VXJpIGFuZCBzY29wZXMgaW4gQXV0aG9yaXphdGlvbkNvZGVVcmxSZXF1ZXN0IGFuZFxuICAgICAqIEF1dGhvcml6YXRpb25Db2RlUmVxdWVzdCBhcmUgdGhlIHNhbWUuXG4gICAgICovXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuQnlDb2RlKFxuICAgICAgICByZXF1ZXN0OiBBdXRob3JpemF0aW9uQ29kZVJlcXVlc3QsXG4gICAgICAgIGF1dGhDb2RlUGF5TG9hZD86IEF1dGhvcml6YXRpb25Db2RlUGF5bG9hZFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQ+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImFjcXVpcmVUb2tlbkJ5Q29kZSBjYWxsZWRcIik7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXRlICYmIGF1dGhDb2RlUGF5TG9hZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImFjcXVpcmVUb2tlbkJ5Q29kZSAtIHZhbGlkYXRpbmcgc3RhdGVcIik7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU3RhdGUocmVxdWVzdC5zdGF0ZSwgYXV0aENvZGVQYXlMb2FkLnN0YXRlIHx8IFwiXCIpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBhdXRoQ29kZVBheUxvYWQgPSB7IC4uLmF1dGhDb2RlUGF5TG9hZCwgc3RhdGU6IFwiXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZFJlcXVlc3Q6IENvbW1vbkF1dGhvcml6YXRpb25Db2RlUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5pbml0aWFsaXplQmFzZVJlcXVlc3QocmVxdWVzdCkpLFxuICAgICAgICAgICAgYXV0aGVudGljYXRpb25TY2hlbWU6IEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUixcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyID0gdGhpcy5pbml0aWFsaXplU2VydmVyVGVsZW1ldHJ5TWFuYWdlcihcbiAgICAgICAgICAgIEFwaUlkLmFjcXVpcmVUb2tlbkJ5Q29kZSxcbiAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjb3ZlcmVkQXV0aG9yaXR5ID0gYXdhaXQgdGhpcy5jcmVhdGVBdXRob3JpdHkoXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5henVyZUNsb3VkT3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhDbGllbnRDb25maWcgPSBhd2FpdCB0aGlzLmJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uKFxuICAgICAgICAgICAgICAgIGRpc2NvdmVyZWRBdXRob3JpdHksXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LnJlZGlyZWN0VXJpLFxuICAgICAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uQ29kZUNsaWVudCA9IG5ldyBBdXRob3JpemF0aW9uQ29kZUNsaWVudChcbiAgICAgICAgICAgICAgICBhdXRoQ2xpZW50Q29uZmlnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIkF1dGggY29kZSBjbGllbnQgY3JlYXRlZFwiLFxuICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGF1dGhvcml6YXRpb25Db2RlQ2xpZW50LmFjcXVpcmVUb2tlbihcbiAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgYXV0aENvZGVQYXlMb2FkXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xuICAgICAgICAgICAgICAgIGUuc2V0Q29ycmVsYXRpb25JZCh2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmNhY2hlRmFpbGVkUmVxdWVzdChlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlcyBhIHRva2VuIGJ5IGV4Y2hhbmdpbmcgdGhlIHJlZnJlc2ggdG9rZW4gcHJvdmlkZWQgZm9yIGEgbmV3IHNldCBvZiB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIEFQSSBpcyBwcm92aWRlZCBvbmx5IGZvciBzY2VuYXJpb3Mgd2hlcmUgeW91IHdvdWxkIGxpa2UgdG8gbWlncmF0ZSBmcm9tIEFEQUwgdG8gTVNBTC4gT3RoZXJ3aXNlLCBpdCBpc1xuICAgICAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBgYWNxdWlyZVRva2VuU2lsZW50KClgIGZvciBzaWxlbnQgc2NlbmFyaW9zLiBXaGVuIHVzaW5nIGBhY3F1aXJlVG9rZW5TaWxlbnQoKWAsIE1TQUwgd2lsbFxuICAgICAqIGhhbmRsZSB0aGUgY2FjaGluZyBhbmQgcmVmcmVzaGluZyBvZiB0b2tlbnMgYXV0b21hdGljYWxseS5cbiAgICAgKi9cbiAgICBhc3luYyBhY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbihcbiAgICAgICAgcmVxdWVzdDogUmVmcmVzaFRva2VuUmVxdWVzdFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsPiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICBcImFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuIGNhbGxlZFwiLFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHZhbGlkUmVxdWVzdDogQ29tbW9uUmVmcmVzaFRva2VuUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5pbml0aWFsaXplQmFzZVJlcXVlc3QocmVxdWVzdCkpLFxuICAgICAgICAgICAgYXV0aGVudGljYXRpb25TY2hlbWU6IEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUixcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyID0gdGhpcy5pbml0aWFsaXplU2VydmVyVGVsZW1ldHJ5TWFuYWdlcihcbiAgICAgICAgICAgIEFwaUlkLmFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyZWRBdXRob3JpdHkgPSBhd2FpdCB0aGlzLmNyZWF0ZUF1dGhvcml0eShcbiAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QuYXV0aG9yaXR5LFxuICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmF6dXJlQ2xvdWRPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuQ2xpZW50Q29uZmlnID1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uKFxuICAgICAgICAgICAgICAgICAgICBkaXNjb3ZlcmVkQXV0aG9yaXR5LFxuICAgICAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LnJlZGlyZWN0VXJpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuQ2xpZW50ID0gbmV3IFJlZnJlc2hUb2tlbkNsaWVudChcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW5DbGllbnRDb25maWdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIFwiUmVmcmVzaCB0b2tlbiBjbGllbnQgY3JlYXRlZFwiLFxuICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlZnJlc2hUb2tlbkNsaWVudC5hY3F1aXJlVG9rZW4odmFsaWRSZXF1ZXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBdXRoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLnNldENvcnJlbGF0aW9uSWQodmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5jYWNoZUZhaWxlZFJlcXVlc3QoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSB0b2tlbiBzaWxlbnRseSB3aGVuIGEgdXNlciBzcGVjaWZpZXMgdGhlIGFjY291bnQgdGhlIHRva2VuIGlzIHJlcXVlc3RlZCBmb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIEFQSSBleHBlY3RzIHRoZSB1c2VyIHRvIHByb3ZpZGUgYW4gYWNjb3VudCBvYmplY3QgYW5kIGxvb2tzIGludG8gdGhlIGNhY2hlIHRvIHJldHJpZXZlIHRoZSB0b2tlbiBpZiBwcmVzZW50LlxuICAgICAqIFRoZXJlIGlzIGFsc28gYW4gb3B0aW9uYWwgXCJmb3JjZVJlZnJlc2hcIiBib29sZWFuIHRoZSB1c2VyIGNhbiBzZW5kIHRvIGJ5cGFzcyB0aGUgY2FjaGUgZm9yIGFjY2Vzc190b2tlbiBhbmQgaWRfdG9rZW4uXG4gICAgICogSW4gY2FzZSB0aGUgcmVmcmVzaF90b2tlbiBpcyBleHBpcmVkIG9yIG5vdCBmb3VuZCwgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgICogYW5kIHRoZSBndWlkYW5jZSBpcyBmb3IgdGhlIHVzZXIgdG8gY2FsbCBhbnkgaW50ZXJhY3RpdmUgdG9rZW4gYWNxdWlzaXRpb24gQVBJIChlZzogYGFjcXVpcmVUb2tlbkJ5Q29kZSgpYCkuXG4gICAgICovXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuU2lsZW50KFxuICAgICAgICByZXF1ZXN0OiBTaWxlbnRGbG93UmVxdWVzdFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0OiBDb21tb25TaWxlbnRGbG93UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5pbml0aWFsaXplQmFzZVJlcXVlc3QocmVxdWVzdCkpLFxuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiByZXF1ZXN0LmZvcmNlUmVmcmVzaCB8fCBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyID0gdGhpcy5pbml0aWFsaXplU2VydmVyVGVsZW1ldHJ5TWFuYWdlcihcbiAgICAgICAgICAgIEFwaUlkLmFjcXVpcmVUb2tlblNpbGVudCxcbiAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmZvcmNlUmVmcmVzaFxuICAgICAgICApO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjb3ZlcmVkQXV0aG9yaXR5ID0gYXdhaXQgdGhpcy5jcmVhdGVBdXRob3JpdHkoXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5henVyZUNsb3VkT3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudENvbmZpZ3VyYXRpb24gPVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYnVpbGRPYXV0aENsaWVudENvbmZpZ3VyYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIGRpc2NvdmVyZWRBdXRob3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QucmVkaXJlY3RVcmkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzaWxlbnRGbG93Q2xpZW50ID0gbmV3IFNpbGVudEZsb3dDbGllbnQoY2xpZW50Q29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIFwiU2lsZW50IGZsb3cgY2xpZW50IGNyZWF0ZWRcIixcbiAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIG92ZXJ3cml0ZSB0aGUgaW4tbWVtb3J5IGNhY2hlIHdpdGggdGhlIHBlcnNpc3RlbmNlIGNhY2hlIChpZiBpdCBleGlzdHMpIGJlZm9yZSBhIGNhY2hlIGxvb2t1cFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5DYWNoZS5vdmVyd3JpdGVDYWNoZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjcXVpcmVDYWNoZWRUb2tlblNpbGVudChcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnRGbG93Q2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRDb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENsaWVudEF1dGhFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlcnJvci5lcnJvckNvZGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblJlZnJlc2hSZXF1aXJlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoVG9rZW5DbGllbnQgPSBuZXcgUmVmcmVzaFRva2VuQ2xpZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50Q29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaFRva2VuQ2xpZW50LmFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXV0aEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Iuc2V0Q29ycmVsYXRpb25JZCh2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmNhY2hlRmFpbGVkUmVxdWVzdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgYWNxdWlyZUNhY2hlZFRva2VuU2lsZW50KFxuICAgICAgICB2YWxpZFJlcXVlc3Q6IENvbW1vblNpbGVudEZsb3dSZXF1ZXN0LFxuICAgICAgICBzaWxlbnRGbG93Q2xpZW50OiBTaWxlbnRGbG93Q2xpZW50LFxuICAgICAgICBjbGllbnRDb25maWd1cmF0aW9uOiBDbGllbnRDb25maWd1cmF0aW9uXG4gICAgKTogUHJvbWlzZTxBdXRoZW50aWNhdGlvblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBbYXV0aFJlc3BvbnNlLCBjYWNoZU91dGNvbWVdID1cbiAgICAgICAgICAgIGF3YWl0IHNpbGVudEZsb3dDbGllbnQuYWNxdWlyZUNhY2hlZFRva2VuKHtcbiAgICAgICAgICAgICAgICAuLi52YWxpZFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgc2NvcGVzOiB2YWxpZFJlcXVlc3Quc2NvcGVzPy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyB2YWxpZFJlcXVlc3Quc2NvcGVzXG4gICAgICAgICAgICAgICAgICAgIDogWy4uLk9JRENfREVGQVVMVF9TQ09QRVNdLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNhY2hlT3V0Y29tZSA9PT0gQ2FjaGVPdXRjb21lLlBST0FDVElWRUxZX1JFRlJFU0hFRCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBcIkNsaWVudEFwcGxpY2F0aW9uOmFjcXVpcmVDYWNoZWRUb2tlblNpbGVudCAtIENhY2hlZCBhY2Nlc3MgdG9rZW4ncyByZWZyZXNoT24gcHJvcGVydHkgaGFzIGJlZW4gZXhjZWVkZWQnLiBJdCdzIG5vdCBleHBpcmVkLCBidXQgbXVzdCBiZSByZWZyZXNoZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBhY2Nlc3MgdG9rZW4gaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbkNsaWVudCA9IG5ldyBSZWZyZXNoVG9rZW5DbGllbnQoXG4gICAgICAgICAgICAgICAgY2xpZW50Q29uZmlndXJhdGlvblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZWZyZXNoVG9rZW5DbGllbnQuYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW4oXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nLCB0aGlzIGlzIHJ1bm5pbmcgaW4gdGhlIGJhY2tncm91bmQgYW5kIG5vIGFjdGlvbiBpcyB0byBiZSB0YWtlbiB1cG9uIHN1Y2Nlc3Mgb3IgZmFpbHVyZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBjYWNoZWQgdG9rZW5cbiAgICAgICAgcmV0dXJuIGF1dGhSZXNwb25zZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlcyB0b2tlbnMgd2l0aCBwYXNzd29yZCBncmFudCBieSBleGNoYW5naW5nIGNsaWVudCBhcHBsaWNhdGlvbnMgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGZvciBjcmVkZW50aWFsc1xuICAgICAqXG4gICAgICogVGhlIGxhdGVzdCBPQXV0aCAyLjAgU2VjdXJpdHkgQmVzdCBDdXJyZW50IFByYWN0aWNlIGRpc2FsbG93cyB0aGUgcGFzc3dvcmQgZ3JhbnQgZW50aXJlbHkuXG4gICAgICogTW9yZSBkZXRhaWxzIG9uIHRoaXMgcmVjb21tZW5kYXRpb24gYXQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtb2F1dGgtc2VjdXJpdHktdG9waWNzLTEzI3NlY3Rpb24tMy40XG4gICAgICogTWljcm9zb2Z0J3MgZG9jdW1lbnRhdGlvbiBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSBhdDpcbiAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9henVyZS9hY3RpdmUtZGlyZWN0b3J5L2RldmVsb3AvbXNhbC1hdXRoZW50aWNhdGlvbi1mbG93cyN1c2VybmFtZXBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIFVzZW5hbWVQYXNzd29yZFJlcXVlc3RcbiAgICAgKiBAZGVwcmVjYXRlZCAtIFVzZSBhIG1vcmUgc2VjdXJlIGZsb3cgaW5zdGVhZFxuICAgICAqL1xuICAgIGFzeW5jIGFjcXVpcmVUb2tlbkJ5VXNlcm5hbWVQYXNzd29yZChcbiAgICAgICAgcmVxdWVzdDogVXNlcm5hbWVQYXNzd29yZFJlcXVlc3RcbiAgICApOiBQcm9taXNlPEF1dGhlbnRpY2F0aW9uUmVzdWx0IHwgbnVsbD4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgXCJhY3F1aXJlVG9rZW5CeVVzZXJuYW1lUGFzc3dvcmQgY2FsbGVkXCIsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0OiBDb21tb25Vc2VybmFtZVBhc3N3b3JkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5pbml0aWFsaXplQmFzZVJlcXVlc3QocmVxdWVzdCkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyID0gdGhpcy5pbml0aWFsaXplU2VydmVyVGVsZW1ldHJ5TWFuYWdlcihcbiAgICAgICAgICAgIEFwaUlkLmFjcXVpcmVUb2tlbkJ5VXNlcm5hbWVQYXNzd29yZCxcbiAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjb3ZlcmVkQXV0aG9yaXR5ID0gYXdhaXQgdGhpcy5jcmVhdGVBdXRob3JpdHkoXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5henVyZUNsb3VkT3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJuYW1lUGFzc3dvcmRDbGllbnRDb25maWcgPVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYnVpbGRPYXV0aENsaWVudENvbmZpZ3VyYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIGRpc2NvdmVyZWRBdXRob3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJuYW1lUGFzc3dvcmRDbGllbnQgPSBuZXcgVXNlcm5hbWVQYXNzd29yZENsaWVudChcbiAgICAgICAgICAgICAgICB1c2VybmFtZVBhc3N3b3JkQ2xpZW50Q29uZmlnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIlVzZXJuYW1lIHBhc3N3b3JkIGNsaWVudCBjcmVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdXNlcm5hbWVQYXNzd29yZENsaWVudC5hY3F1aXJlVG9rZW4odmFsaWRSZXF1ZXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBdXRoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLnNldENvcnJlbGF0aW9uSWQodmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5jYWNoZUZhaWxlZFJlcXVlc3QoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdG9rZW4gY2FjaGUgZm9yIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRUb2tlbkNhY2hlKCk6IFRva2VuQ2FjaGUge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiZ2V0VG9rZW5DYWNoZSBjYWxsZWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuQ2FjaGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIE9JREMgc3RhdGUgYnkgY29tcGFyaW5nIHRoZSB1c2VyIGNhY2hlZCBzdGF0ZSB3aXRoIHRoZSBzdGF0ZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIEFQSSBpcyBwcm92aWRlZCBmb3Igc2NlbmFyaW9zIHdoZXJlIHlvdSB3b3VsZCB1c2UgT0F1dGgyLjAgc3RhdGUgcGFyYW1ldGVyIHRvIG1pdGlnYXRlIGFnYWluc3RcbiAgICAgKiBDU1JGIGF0dGFja3MuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgc3RhdGUsIHZpc2l0IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjgxOSNzZWN0aW9uLTMuNi5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBVbmlxdWUgR1VJRCBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgdGhhdCBpcyBjYWNoZWQgYnkgdGhlIHVzZXIgYW5kIHNlbnQgdG8gdGhlIHNlcnZlciBkdXJpbmcgdGhlIGZpcnN0IGxlZyBvZiB0aGUgZmxvd1xuICAgICAqIEBwYXJhbSBjYWNoZWRTdGF0ZSAtIFRoaXMgc3RyaW5nIGlzIHNlbnQgYmFjayBieSB0aGUgc2VydmVyIHdpdGggdGhlIGF1dGhvcml6YXRpb24gY29kZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCB2YWxpZGF0ZVN0YXRlKHN0YXRlOiBzdHJpbmcsIGNhY2hlZFN0YXRlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgTm9kZUF1dGhFcnJvci5jcmVhdGVTdGF0ZU5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gY2FjaGVkU3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5zdGF0ZU1pc21hdGNoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvZ2dlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldExvZ2dlcigpOiBMb2dnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGhlIGRlZmF1bHQgbG9nZ2VyIHNldCBpbiBjb25maWd1cmF0aW9ucyB3aXRoIG5ldyBMb2dnZXIgd2l0aCBuZXcgY29uZmlndXJhdGlvbnNcbiAgICAgKiBAcGFyYW0gbG9nZ2VyIC0gTG9nZ2VyIGluc3RhbmNlXG4gICAgICovXG4gICAgc2V0TG9nZ2VyKGxvZ2dlcjogTG9nZ2VyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgY29tbW9uIGNvbmZpZ3VyYXRpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBjb21tb24gY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwbGF0Zm9ybSBjb25maWd1cmFyaW9uXG4gICAgICogQHBhcmFtIGF1dGhvcml0eSAtIHVzZXIgcGFzc2VkIGF1dGhvcml0eSBpbiBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHNlcnZlclRlbGVtZXRyeU1hbmFnZXIgLSBpbml0aWFsaXplcyBzZXJ2ZXJ0ZWxlbWV0cnkgaWYgcGFzc2VkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uKFxuICAgICAgICBkaXNjb3ZlcmVkQXV0aG9yaXR5OiBBdXRob3JpdHksXG4gICAgICAgIHJlcXVlc3RDb3JyZWxhdGlvbklkOiBzdHJpbmcsXG4gICAgICAgIHJlZGlyZWN0VXJpOiBzdHJpbmcsXG4gICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI/OiBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyXG4gICAgKTogUHJvbWlzZTxDbGllbnRDb25maWd1cmF0aW9uPiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICBcImJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uIGNhbGxlZFwiLFxuICAgICAgICAgICAgcmVxdWVzdENvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgYEJ1aWxkaW5nIG9hdXRoIGNsaWVudCBjb25maWd1cmF0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBhdXRob3JpdHk6ICR7ZGlzY292ZXJlZEF1dGhvcml0eS50b2tlbkVuZHBvaW50fS5gLFxuICAgICAgICAgICAgcmVxdWVzdENvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcblxuICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyPy51cGRhdGVSZWdpb25EaXNjb3ZlcnlNZXRhZGF0YShcbiAgICAgICAgICAgIGRpc2NvdmVyZWRBdXRob3JpdHkucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGFcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBjbGllbnRDb25maWd1cmF0aW9uOiBDbGllbnRDb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgYXV0aE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aC5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IGRpc2NvdmVyZWRBdXRob3JpdHksXG4gICAgICAgICAgICAgICAgY2xpZW50Q2FwYWJpbGl0aWVzOiB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFVyaSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2dnZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbG9nTGV2ZWw6IHRoaXMuY29uZmlnLnN5c3RlbS5sb2dnZXJPcHRpb25zLmxvZ0xldmVsLFxuICAgICAgICAgICAgICAgIGxvZ2dlckNhbGxiYWNrOiB0aGlzLmNvbmZpZy5zeXN0ZW0ubG9nZ2VyT3B0aW9ucy5sb2dnZXJDYWxsYmFjayxcbiAgICAgICAgICAgICAgICBwaWlMb2dnaW5nRW5hYmxlZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc3lzdGVtLmxvZ2dlck9wdGlvbnMucGlpTG9nZ2luZ0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdENvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FjaGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgY2xhaW1zQmFzZWRDYWNoaW5nRW5hYmxlZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY2FjaGUuY2xhaW1zQmFzZWRDYWNoaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcnlwdG9JbnRlcmZhY2U6IHRoaXMuY3J5cHRvUHJvdmlkZXIsXG4gICAgICAgICAgICBuZXR3b3JrSW50ZXJmYWNlOiB0aGlzLmNvbmZpZy5zeXN0ZW0ubmV0d29ya0NsaWVudCxcbiAgICAgICAgICAgIHN0b3JhZ2VJbnRlcmZhY2U6IHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI6IHNlcnZlclRlbGVtZXRyeU1hbmFnZXIsXG4gICAgICAgICAgICBjbGllbnRDcmVkZW50aWFsczoge1xuICAgICAgICAgICAgICAgIGNsaWVudFNlY3JldDogdGhpcy5jbGllbnRTZWNyZXQsXG4gICAgICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uOiBhd2FpdCB0aGlzLmdldENsaWVudEFzc2VydGlvbihcbiAgICAgICAgICAgICAgICAgICAgZGlzY292ZXJlZEF1dGhvcml0eVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlicmFyeUluZm86IHtcbiAgICAgICAgICAgICAgICBza3U6IE5vZGVDb25zdGFudHMuTVNBTF9TS1UsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBjcHU6IHByb2Nlc3MuYXJjaCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICAgICAgICAgIG9zOiBwcm9jZXNzLnBsYXRmb3JtIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVsZW1ldHJ5OiB0aGlzLmNvbmZpZy50ZWxlbWV0cnksXG4gICAgICAgICAgICBwZXJzaXN0ZW5jZVBsdWdpbjogdGhpcy5jb25maWcuY2FjaGUuY2FjaGVQbHVnaW4sXG4gICAgICAgICAgICBzZXJpYWxpemFibGVDYWNoZTogdGhpcy50b2tlbkNhY2hlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjbGllbnRDb25maWd1cmF0aW9uO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0Q2xpZW50QXNzZXJ0aW9uKFxuICAgICAgICBhdXRob3JpdHk6IEF1dGhvcml0eVxuICAgICk6IFByb21pc2U8Q2xpZW50QXNzZXJ0aW9uVHlwZT4ge1xuICAgICAgICBpZiAodGhpcy5kZXZlbG9wZXJQcm92aWRlZENsaWVudEFzc2VydGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRBc3NlcnRpb24gPSBDbGllbnRBc3NlcnRpb24uZnJvbUFzc2VydGlvbihcbiAgICAgICAgICAgICAgICBhd2FpdCBnZXRDbGllbnRBc3NlcnRpb24oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV2ZWxvcGVyUHJvdmlkZWRDbGllbnRBc3NlcnRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcml0eS50b2tlbkVuZHBvaW50XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmNsaWVudEFzc2VydGlvbiAmJiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0aW9uOiB0aGlzLmNsaWVudEFzc2VydGlvbi5nZXRKd3QoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3J5cHRvUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcml0eS50b2tlbkVuZHBvaW50XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBhc3NlcnRpb25UeXBlOiBOb2RlQ29uc3RhbnRzLkpXVF9CRUFSRVJfQVNTRVJUSU9OX1RZUEUsXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcmVxdWVzdCB3aXRoIHRoZSBkZWZhdWx0IHNjb3BlcyAmIGdlbmVyYXRlcyBhIGNvcnJlbGF0aW9uSWQuXG4gICAgICogQHBhcmFtIGF1dGhSZXF1ZXN0IC0gQmFzZUF1dGhSZXF1ZXN0IGZvciBpbml0aWFsaXphdGlvblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhc3luYyBpbml0aWFsaXplQmFzZVJlcXVlc3QoXG4gICAgICAgIGF1dGhSZXF1ZXN0OiBQYXJ0aWFsPEJhc2VBdXRoUmVxdWVzdD5cbiAgICApOiBQcm9taXNlPEJhc2VBdXRoUmVxdWVzdD4ge1xuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgXCJpbml0aWFsaXplUmVxdWVzdFNjb3BlcyBjYWxsZWRcIixcbiAgICAgICAgICAgIGF1dGhSZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgLy8gRGVmYXVsdCBhdXRoZW50aWNhdGlvblNjaGVtZSB0byBCZWFyZXIsIGxvZyB0aGF0IFBPUCBpc24ndCBzdXBwb3J0ZWQgeWV0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGF1dGhSZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lICYmXG4gICAgICAgICAgICBhdXRoUmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSA9PT0gQXV0aGVudGljYXRpb25TY2hlbWUuUE9QXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIkF1dGhlbnRpY2F0aW9uIFNjaGVtZSAncG9wJyBpcyBub3Qgc3VwcG9ydGVkIHlldCwgc2V0dGluZyBBdXRoZW50aWNhdGlvbiBTY2hlbWUgdG8gJ0JlYXJlcicgZm9yIHJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBhdXRoUmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXV0aFJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgPSBBdXRoZW50aWNhdGlvblNjaGVtZS5CRUFSRVI7XG5cbiAgICAgICAgLy8gU2V0IHJlcXVlc3RlZCBjbGFpbXMgaGFzaCBpZiBjbGFpbXMtYmFzZWQgY2FjaGluZyBpcyBlbmFibGVkIGFuZCBjbGFpbXMgd2VyZSByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2FjaGUuY2xhaW1zQmFzZWRDYWNoaW5nRW5hYmxlZCAmJlxuICAgICAgICAgICAgYXV0aFJlcXVlc3QuY2xhaW1zICYmXG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yIGVtcHR5IHN0cmluZ2lmaWVkIG9iamVjdCBcInt9XCIgd2hpY2ggZG9lc24ndCBxdWFsaWZ5IGFzIHJlcXVlc3RlZCBjbGFpbXNcbiAgICAgICAgICAgICFTdHJpbmdVdGlscy5pc0VtcHR5T2JqKGF1dGhSZXF1ZXN0LmNsYWltcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBhdXRoUmVxdWVzdC5yZXF1ZXN0ZWRDbGFpbXNIYXNoID1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyeXB0b1Byb3ZpZGVyLmhhc2hTdHJpbmcoYXV0aFJlcXVlc3QuY2xhaW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5hdXRoUmVxdWVzdCxcbiAgICAgICAgICAgIHNjb3BlczogW1xuICAgICAgICAgICAgICAgIC4uLigoYXV0aFJlcXVlc3QgJiYgYXV0aFJlcXVlc3Quc2NvcGVzKSB8fCBbXSksXG4gICAgICAgICAgICAgICAgLi4uT0lEQ19ERUZBVUxUX1NDT1BFUyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOlxuICAgICAgICAgICAgICAgIChhdXRoUmVxdWVzdCAmJiBhdXRoUmVxdWVzdC5jb3JyZWxhdGlvbklkKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY3J5cHRvUHJvdmlkZXIuY3JlYXRlTmV3R3VpZCgpLFxuICAgICAgICAgICAgYXV0aG9yaXR5OiBhdXRoUmVxdWVzdC5hdXRob3JpdHkgfHwgdGhpcy5jb25maWcuYXV0aC5hdXRob3JpdHksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHNlcnZlciB0ZWxlbWV0cnkgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBhcGlJZCAtIElkIGZvciBhIHNwZWNpZmljIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gY29ycmVsYXRpb25JZCAtIEdVSURcbiAgICAgKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gYm9vbGVhbiB0byBpbmRpY2F0ZSBuZXR3b3JrIGNhbGxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZVNlcnZlclRlbGVtZXRyeU1hbmFnZXIoXG4gICAgICAgIGFwaUlkOiBudW1iZXIsXG4gICAgICAgIGNvcnJlbGF0aW9uSWQ6IHN0cmluZyxcbiAgICAgICAgZm9yY2VSZWZyZXNoPzogYm9vbGVhblxuICAgICk6IFNlcnZlclRlbGVtZXRyeU1hbmFnZXIge1xuICAgICAgICBjb25zdCB0ZWxlbWV0cnlQYXlsb2FkOiBTZXJ2ZXJUZWxlbWV0cnlSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWQsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgYXBpSWQ6IGFwaUlkLFxuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiBmb3JjZVJlZnJlc2ggfHwgZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKHRlbGVtZXRyeVBheWxvYWQsIHRoaXMuc3RvcmFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGF1dGhvcml0eSBpbnN0YW5jZS4gSWYgYXV0aG9yaXR5IG5vdCBwYXNzZWQgaW4gcmVxdWVzdCwgZGVmYXVsdCB0byBhdXRob3JpdHkgc2V0IG9uIHRoZSBhcHBsaWNhdGlvblxuICAgICAqIG9iamVjdC4gSWYgbm8gYXV0aG9yaXR5IHNldCBpbiBhcHBsaWNhdGlvbiBvYmplY3QsIHRoZW4gZGVmYXVsdCB0byBjb21tb24gYXV0aG9yaXR5LlxuICAgICAqIEBwYXJhbSBhdXRob3JpdHlTdHJpbmcgLSBhdXRob3JpdHkgZnJvbSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYXN5bmMgY3JlYXRlQXV0aG9yaXR5KFxuICAgICAgICBhdXRob3JpdHlTdHJpbmc6IHN0cmluZyxcbiAgICAgICAgcmVxdWVzdENvcnJlbGF0aW9uSWQ6IHN0cmluZyxcbiAgICAgICAgYXp1cmVSZWdpb25Db25maWd1cmF0aW9uPzogQXp1cmVSZWdpb25Db25maWd1cmF0aW9uLFxuICAgICAgICBhenVyZUNsb3VkT3B0aW9ucz86IEF6dXJlQ2xvdWRPcHRpb25zXG4gICAgKTogUHJvbWlzZTxBdXRob3JpdHk+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhvcml0eSBjYWxsZWRcIiwgcmVxdWVzdENvcnJlbGF0aW9uSWQpO1xuXG4gICAgICAgIC8vIGJ1aWxkIGF1dGhvcml0eSBzdHJpbmcgYmFzZWQgb24gYXV0aCBwYXJhbXMgLSBhenVyZUNsb3VkSW5zdGFuY2UgaXMgcHJpb3JpdGl6ZWQgaWYgcHJvdmlkZWRcbiAgICAgICAgY29uc3QgYXV0aG9yaXR5VXJsID0gQXV0aG9yaXR5LmdlbmVyYXRlQXV0aG9yaXR5KFxuICAgICAgICAgICAgYXV0aG9yaXR5U3RyaW5nLFxuICAgICAgICAgICAgYXp1cmVDbG91ZE9wdGlvbnMgfHwgdGhpcy5jb25maWcuYXV0aC5henVyZUNsb3VkT3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eU9wdGlvbnM6IEF1dGhvcml0eU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwcm90b2NvbE1vZGU6IHRoaXMuY29uZmlnLmF1dGgucHJvdG9jb2xNb2RlLFxuICAgICAgICAgICAga25vd25BdXRob3JpdGllczogdGhpcy5jb25maWcuYXV0aC5rbm93bkF1dGhvcml0aWVzLFxuICAgICAgICAgICAgY2xvdWREaXNjb3ZlcnlNZXRhZGF0YTogdGhpcy5jb25maWcuYXV0aC5jbG91ZERpc2NvdmVyeU1ldGFkYXRhLFxuICAgICAgICAgICAgYXV0aG9yaXR5TWV0YWRhdGE6IHRoaXMuY29uZmlnLmF1dGguYXV0aG9yaXR5TWV0YWRhdGEsXG4gICAgICAgICAgICBhenVyZVJlZ2lvbkNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZTpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoLnNraXBBdXRob3JpdHlNZXRhZGF0YUNhY2hlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBBdXRob3JpdHlGYWN0b3J5LmNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZShcbiAgICAgICAgICAgIGF1dGhvcml0eVVybCxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnN5c3RlbS5uZXR3b3JrQ2xpZW50LFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgYXV0aG9yaXR5T3B0aW9ucyxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgcmVxdWVzdENvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY2FjaGVcbiAgICAgKi9cbiAgICBjbGVhckNhY2hlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQWNjZXNzVG9rZW5FbnRpdHksXG4gICAgQXV0aGVudGljYXRpb25SZXN1bHQsXG4gICAgQXV0aGVudGljYXRpb25TY2hlbWUsXG4gICAgQXV0aG9yaXR5LFxuICAgIEJhc2VDbGllbnQsXG4gICAgQ2FjaGVNYW5hZ2VyLFxuICAgIENhY2hlT3V0Y29tZSxcbiAgICBDbGllbnRBdXRoRXJyb3JDb2RlcyxcbiAgICBDbGllbnRDb25maWd1cmF0aW9uLFxuICAgIENvbW1vbkNsaWVudENyZWRlbnRpYWxSZXF1ZXN0LFxuICAgIENvbnN0YW50cyxcbiAgICBDcmVkZW50aWFsRmlsdGVyLFxuICAgIENyZWRlbnRpYWxUeXBlLFxuICAgIERFRkFVTFRfVE9LRU5fUkVORVdBTF9PRkZTRVRfU0VDLFxuICAgIEdyYW50VHlwZSxcbiAgICBJQXBwVG9rZW5Qcm92aWRlcixcbiAgICBJQ3J5cHRvLFxuICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLFxuICAgIFJlcXVlc3RUaHVtYnByaW50LFxuICAgIFJlc3BvbnNlSGFuZGxlcixcbiAgICBTY29wZVNldCxcbiAgICBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZSxcbiAgICBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLFxuICAgIFN0cmluZ1V0aWxzLFxuICAgIFRpbWVVdGlscyxcbiAgICBUb2tlbkNhY2hlQ29udGV4dCxcbiAgICBVcmxTdHJpbmcsXG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIENsaWVudEFzc2VydGlvbixcbiAgICBnZXRDbGllbnRBc3NlcnRpb24sXG4gICAgVXJsVXRpbHMsXG59IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuaW1wb3J0IHtcbiAgICBNYW5hZ2VkSWRlbnRpdHlDb25maWd1cmF0aW9uLFxuICAgIE1hbmFnZWRJZGVudGl0eU5vZGVDb25maWd1cmF0aW9uLFxufSBmcm9tIFwiLi4vY29uZmlnL0NvbmZpZ3VyYXRpb24uanNcIjtcblxuLyoqXG4gKiBPQXV0aDIuMCBjbGllbnQgY3JlZGVudGlhbCBncmFudFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ2xpZW50Q3JlZGVudGlhbENsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgYXBwVG9rZW5Qcm92aWRlcj86IElBcHBUb2tlblByb3ZpZGVyO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IENsaWVudENvbmZpZ3VyYXRpb24sXG4gICAgICAgIGFwcFRva2VuUHJvdmlkZXI/OiBJQXBwVG9rZW5Qcm92aWRlclxuICAgICkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5hcHBUb2tlblByb3ZpZGVyID0gYXBwVG9rZW5Qcm92aWRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIHRvIGFjcXVpcmUgYSB0b2tlbiB3aXRoIENsaWVudENyZWRlbnRpYWwgRmxvdyBmb3IgQ29uZmlkZW50aWFsIGNsaWVudHNcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIENvbW1vbkNsaWVudENyZWRlbnRpYWxSZXF1ZXN0IHByb3ZpZGVkIGJ5IHRoZSBkZXZlbG9wZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgYWNxdWlyZVRva2VuKFxuICAgICAgICByZXF1ZXN0OiBDb21tb25DbGllbnRDcmVkZW50aWFsUmVxdWVzdFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsPiB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnNraXBDYWNoZSB8fCByZXF1ZXN0LmNsYWltcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVRva2VuUmVxdWVzdChyZXF1ZXN0LCB0aGlzLmF1dGhvcml0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbY2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQsIGxhc3RDYWNoZU91dGNvbWVdID1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b1V0aWxzLFxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5LFxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICBpZiAoY2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZCBidXQgbXVzdCBiZSByZWZyZXNoZWQ7IGdldCBhIG5ldyBvbmUgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgIGlmIChsYXN0Q2FjaGVPdXRjb21lID09PSBDYWNoZU91dGNvbWUuUFJPQUNUSVZFTFlfUkVGUkVTSEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAgXCJDbGllbnRDcmVkZW50aWFsQ2xpZW50OmdldENhY2hlZEF1dGhlbnRpY2F0aW9uUmVzdWx0IC0gQ2FjaGVkIGFjY2VzcyB0b2tlbidzIHJlZnJlc2hPbiBwcm9wZXJ0eSBoYXMgYmVlbiBleGNlZWRlZCcuIEl0J3Mgbm90IGV4cGlyZWQsIGJ1dCBtdXN0IGJlIHJlZnJlc2hlZC5cIlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBhY2Nlc3MgdG9rZW4gaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoQWNjZXNzVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZVRva2VuUmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRob3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hBY2Nlc3NUb2tlblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgY2FjaGVkIHRva2VuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlVG9rZW5SZXF1ZXN0KHJlcXVlc3QsIHRoaXMuYXV0aG9yaXR5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvb2tzIHVwIGNhY2hlIGlmIHRoZSB0b2tlbnMgYXJlIGNhY2hlZCBhbHJlYWR5XG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldENhY2hlZEF1dGhlbnRpY2F0aW9uUmVzdWx0KFxuICAgICAgICByZXF1ZXN0OiBDb21tb25DbGllbnRDcmVkZW50aWFsUmVxdWVzdCxcbiAgICAgICAgY29uZmlnOiBDbGllbnRDb25maWd1cmF0aW9uIHwgTWFuYWdlZElkZW50aXR5Q29uZmlndXJhdGlvbixcbiAgICAgICAgY3J5cHRvVXRpbHM6IElDcnlwdG8sXG4gICAgICAgIGF1dGhvcml0eTogQXV0aG9yaXR5LFxuICAgICAgICBjYWNoZU1hbmFnZXI6IENhY2hlTWFuYWdlcixcbiAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcj86IFNlcnZlclRlbGVtZXRyeU1hbmFnZXIgfCBudWxsXG4gICAgKTogUHJvbWlzZTxbQXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsLCBDYWNoZU91dGNvbWVdPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudENvbmZpZ3VyYXRpb24gPSBjb25maWcgYXMgQ2xpZW50Q29uZmlndXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWFuYWdlZElkZW50aXR5Q29uZmlndXJhdGlvbiA9XG4gICAgICAgICAgICBjb25maWcgYXMgTWFuYWdlZElkZW50aXR5Tm9kZUNvbmZpZ3VyYXRpb247XG5cbiAgICAgICAgbGV0IGxhc3RDYWNoZU91dGNvbWU6IENhY2hlT3V0Y29tZSA9IENhY2hlT3V0Y29tZS5OT1RfQVBQTElDQUJMRTtcblxuICAgICAgICAvLyByZWFkIHRoZSB1c2VyLXN1cHBsaWVkIGNhY2hlIGludG8gbWVtb3J5LCBpZiBhcHBsaWNhYmxlXG4gICAgICAgIGxldCBjYWNoZUNvbnRleHQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNsaWVudENvbmZpZ3VyYXRpb24uc2VyaWFsaXphYmxlQ2FjaGUgJiZcbiAgICAgICAgICAgIGNsaWVudENvbmZpZ3VyYXRpb24ucGVyc2lzdGVuY2VQbHVnaW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjYWNoZUNvbnRleHQgPSBuZXcgVG9rZW5DYWNoZUNvbnRleHQoXG4gICAgICAgICAgICAgICAgY2xpZW50Q29uZmlndXJhdGlvbi5zZXJpYWxpemFibGVDYWNoZSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudENvbmZpZ3VyYXRpb24ucGVyc2lzdGVuY2VQbHVnaW4uYmVmb3JlQ2FjaGVBY2Nlc3MoXG4gICAgICAgICAgICAgICAgY2FjaGVDb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FjaGVkQWNjZXNzVG9rZW4gPSB0aGlzLnJlYWRBY2Nlc3NUb2tlbkZyb21DYWNoZShcbiAgICAgICAgICAgIGF1dGhvcml0eSxcbiAgICAgICAgICAgIG1hbmFnZWRJZGVudGl0eUNvbmZpZ3VyYXRpb24ubWFuYWdlZElkZW50aXR5SWQ/LmlkIHx8XG4gICAgICAgICAgICAgICAgY2xpZW50Q29uZmlndXJhdGlvbi5hdXRoT3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgIG5ldyBTY29wZVNldChyZXF1ZXN0LnNjb3BlcyB8fCBbXSksXG4gICAgICAgICAgICBjYWNoZU1hbmFnZXJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjbGllbnRDb25maWd1cmF0aW9uLnNlcmlhbGl6YWJsZUNhY2hlICYmXG4gICAgICAgICAgICBjbGllbnRDb25maWd1cmF0aW9uLnBlcnNpc3RlbmNlUGx1Z2luICYmXG4gICAgICAgICAgICBjYWNoZUNvbnRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnRDb25maWd1cmF0aW9uLnBlcnNpc3RlbmNlUGx1Z2luLmFmdGVyQ2FjaGVBY2Nlc3MoXG4gICAgICAgICAgICAgICAgY2FjaGVDb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbXVzdCByZWZyZXNoIGR1ZSB0byBub24tZXhpc3RlbnQgYWNjZXNzX3Rva2VuXG4gICAgICAgIGlmICghY2FjaGVkQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShcbiAgICAgICAgICAgICAgICBDYWNoZU91dGNvbWUuTk9fQ0FDSEVEX0FDQ0VTU19UT0tFTlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgQ2FjaGVPdXRjb21lLk5PX0NBQ0hFRF9BQ0NFU1NfVE9LRU5dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbXVzdCByZWZyZXNoIGR1ZSB0byB0aGUgZXhwaXJlc19pbiB2YWx1ZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBUaW1lVXRpbHMuaXNUb2tlbkV4cGlyZWQoXG4gICAgICAgICAgICAgICAgY2FjaGVkQWNjZXNzVG9rZW4uZXhwaXJlc09uLFxuICAgICAgICAgICAgICAgIGNsaWVudENvbmZpZ3VyYXRpb24uc3lzdGVtT3B0aW9ucz8udG9rZW5SZW5ld2FsT2Zmc2V0U2Vjb25kcyB8fFxuICAgICAgICAgICAgICAgICAgICBERUZBVUxUX1RPS0VOX1JFTkVXQUxfT0ZGU0VUX1NFQ1xuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShcbiAgICAgICAgICAgICAgICBDYWNoZU91dGNvbWUuQ0FDSEVEX0FDQ0VTU19UT0tFTl9FWFBJUkVEXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBDYWNoZU91dGNvbWUuQ0FDSEVEX0FDQ0VTU19UT0tFTl9FWFBJUkVEXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG11c3QgcmVmcmVzaCAoaW4gdGhlIGJhY2tncm91bmQpIGR1ZSB0byB0aGUgcmVmcmVzaF9pbiB2YWx1ZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjYWNoZWRBY2Nlc3NUb2tlbi5yZWZyZXNoT24gJiZcbiAgICAgICAgICAgIFRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZChjYWNoZWRBY2Nlc3NUb2tlbi5yZWZyZXNoT24udG9TdHJpbmcoKSwgMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsYXN0Q2FjaGVPdXRjb21lID0gQ2FjaGVPdXRjb21lLlBST0FDVElWRUxZX1JFRlJFU0hFRDtcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShcbiAgICAgICAgICAgICAgICBDYWNoZU91dGNvbWUuUFJPQUNUSVZFTFlfUkVGUkVTSEVEXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGF3YWl0IFJlc3BvbnNlSGFuZGxlci5nZW5lcmF0ZUF1dGhlbnRpY2F0aW9uUmVzdWx0KFxuICAgICAgICAgICAgICAgIGNyeXB0b1V0aWxzLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBjYWNoZWRBY2Nlc3NUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhcHBNZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxhc3RDYWNoZU91dGNvbWUsXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYWNjZXNzIHRva2VuIGZyb20gdGhlIGNhY2hlXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkQWNjZXNzVG9rZW5Gcm9tQ2FjaGUoXG4gICAgICAgIGF1dGhvcml0eTogQXV0aG9yaXR5LFxuICAgICAgICBpZDogc3RyaW5nLFxuICAgICAgICBzY29wZVNldDogU2NvcGVTZXQsXG4gICAgICAgIGNhY2hlTWFuYWdlcjogQ2FjaGVNYW5hZ2VyXG4gICAgKTogQWNjZXNzVG9rZW5FbnRpdHkgfCBudWxsIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5GaWx0ZXI6IENyZWRlbnRpYWxGaWx0ZXIgPSB7XG4gICAgICAgICAgICBob21lQWNjb3VudElkOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6XG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5LmNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMuSG9zdE5hbWVBbmRQb3J0LFxuICAgICAgICAgICAgY3JlZGVudGlhbFR5cGU6IENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTixcbiAgICAgICAgICAgIGNsaWVudElkOiBpZCxcbiAgICAgICAgICAgIHJlYWxtOiBhdXRob3JpdHkudGVuYW50LFxuICAgICAgICAgICAgdGFyZ2V0OiBTY29wZVNldC5jcmVhdGVTZWFyY2hTY29wZXMoc2NvcGVTZXQuYXNBcnJheSgpKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbnMgPVxuICAgICAgICAgICAgY2FjaGVNYW5hZ2VyLmdldEFjY2Vzc1Rva2Vuc0J5RmlsdGVyKGFjY2Vzc1Rva2VuRmlsdGVyKTtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2Vucy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChhY2Nlc3NUb2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdUb2tlbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2Vuc1swXSBhcyBBY2Nlc3NUb2tlbkVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIG5ldHdvcmsgY2FsbCB0byByZXF1ZXN0IHRoZSB0b2tlbiBmcm9tIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBDb21tb25DbGllbnRDcmVkZW50aWFsUmVxdWVzdCBwcm92aWRlZCBieSB0aGUgZGV2ZWxvcGVyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eSAtIGF1dGhvcml0eSBvYmplY3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGV4ZWN1dGVUb2tlblJlcXVlc3QoXG4gICAgICAgIHJlcXVlc3Q6IENvbW1vbkNsaWVudENyZWRlbnRpYWxSZXF1ZXN0LFxuICAgICAgICBhdXRob3JpdHk6IEF1dGhvcml0eSxcbiAgICAgICAgcmVmcmVzaEFjY2Vzc1Rva2VuPzogYm9vbGVhblxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsPiB7XG4gICAgICAgIGxldCBzZXJ2ZXJUb2tlblJlc3BvbnNlOiBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZTtcbiAgICAgICAgbGV0IHJlcVRpbWVzdGFtcDogbnVtYmVyO1xuXG4gICAgICAgIGlmICh0aGlzLmFwcFRva2VuUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJVc2luZyBhcHBUb2tlblByb3ZpZGVyIGV4dGVuc2liaWxpdHkuXCIpO1xuXG4gICAgICAgICAgICBjb25zdCBhcHBUb2tlblByb3B2aWRlclBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgIHRlbmFudElkOiB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5hdXRob3JpdHkudGVuYW50LFxuICAgICAgICAgICAgICAgIHNjb3BlczogcmVxdWVzdC5zY29wZXMsXG4gICAgICAgICAgICAgICAgY2xhaW1zOiByZXF1ZXN0LmNsYWltcyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcVRpbWVzdGFtcCA9IFRpbWVVdGlscy5ub3dTZWNvbmRzKCk7XG4gICAgICAgICAgICBjb25zdCBhcHBUb2tlblByb3ZpZGVyUmVzdWx0ID0gYXdhaXQgdGhpcy5hcHBUb2tlblByb3ZpZGVyKFxuICAgICAgICAgICAgICAgIGFwcFRva2VuUHJvcHZpZGVyUGFyYW1ldGVyc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IGFwcFRva2VuUHJvdmlkZXJSZXN1bHQuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19pbjogYXBwVG9rZW5Qcm92aWRlclJlc3VsdC5leHBpcmVzSW5TZWNvbmRzLFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfaW46IGFwcFRva2VuUHJvdmlkZXJSZXN1bHQucmVmcmVzaEluU2Vjb25kcyxcbiAgICAgICAgICAgICAgICB0b2tlbl90eXBlOiBBdXRoZW50aWNhdGlvblNjaGVtZS5CRUFSRVIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID1cbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuUXVlcnlQYXJhbWV0ZXJzKHJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBVcmxTdHJpbmcuYXBwZW5kUXVlcnlTdHJpbmcoXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5LnRva2VuRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGF3YWl0IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShyZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPVxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgY29uc3QgdGh1bWJwcmludDogUmVxdWVzdFRodW1icHJpbnQgPSB7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogcmVxdWVzdC5hdXRob3JpdHksXG4gICAgICAgICAgICAgICAgc2NvcGVzOiByZXF1ZXN0LnNjb3BlcyxcbiAgICAgICAgICAgICAgICBjbGFpbXM6IHJlcXVlc3QuY2xhaW1zLFxuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uU2NoZW1lOiByZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlUmVxdWVzdE1ldGhvZDogcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VSZXF1ZXN0VXJpOiByZXF1ZXN0LnJlc291cmNlUmVxdWVzdFVyaSxcbiAgICAgICAgICAgICAgICBzaHJDbGFpbXM6IHJlcXVlc3Quc2hyQ2xhaW1zLFxuICAgICAgICAgICAgICAgIHNzaEtpZDogcmVxdWVzdC5zc2hLaWQsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgIFwiU2VuZGluZyB0b2tlbiByZXF1ZXN0IHRvIGVuZHBvaW50OiBcIiArIGF1dGhvcml0eS50b2tlbkVuZHBvaW50XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXFUaW1lc3RhbXAgPSBUaW1lVXRpbHMubm93U2Vjb25kcygpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50KFxuICAgICAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgdGh1bWJwcmludCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2UgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSBuZXcgUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICB0aGlzLmNhY2hlTWFuYWdlcixcbiAgICAgICAgICAgIHRoaXMuY3J5cHRvVXRpbHMsXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNlcmlhbGl6YWJsZUNhY2hlLFxuICAgICAgICAgICAgdGhpcy5jb25maWcucGVyc2lzdGVuY2VQbHVnaW5cbiAgICAgICAgKTtcblxuICAgICAgICByZXNwb25zZUhhbmRsZXIudmFsaWRhdGVUb2tlblJlc3BvbnNlKFxuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZSxcbiAgICAgICAgICAgIHJlZnJlc2hBY2Nlc3NUb2tlblxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZUhhbmRsZXIuaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZShcbiAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2UsXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eSxcbiAgICAgICAgICAgIHJlcVRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdG9rZW5SZXNwb25zZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyIGluIHRoZSBhY2NlcHRhYmxlIGZvcm1hdFxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gQ29tbW9uQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3QgcHJvdmlkZWQgYnkgdGhlIGRldmVsb3BlclxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3RcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRJZChcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZFxuICAgICAgICApO1xuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNjb3BlcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LnNjb3BlcywgZmFsc2UpO1xuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEdyYW50VHlwZShcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICBHcmFudFR5cGUuQ0xJRU5UX0NSRURFTlRJQUxTX0dSQU5UXG4gICAgICAgICk7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkTGlicmFyeUluZm8oXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdGhpcy5jb25maWcubGlicmFyeUluZm9cbiAgICAgICAgKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQXBwbGljYXRpb25UZWxlbWV0cnkoXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdGhpcy5jb25maWcudGVsZW1ldHJ5LmFwcGxpY2F0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3JyZWxhdGlvbklkID1cbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZCB8fFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY3J5cHRvSW50ZXJmYWNlLmNyZWF0ZU5ld0d1aWQoKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ29ycmVsYXRpb25JZChwYXJhbWV0ZXJzLCBjb3JyZWxhdGlvbklkKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRTZWNyZXQoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgY2xpZW50QXNzZXJ0aW9uIGZyb20gcmVxdWVzdCwgZmFsbGJhY2sgdG8gY2xpZW50IGFzc2VydGlvbiBpbiBiYXNlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgY29uc3QgY2xpZW50QXNzZXJ0aW9uOiBDbGllbnRBc3NlcnRpb24gfCB1bmRlZmluZWQgPVxuICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRBc3NlcnRpb24gfHxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudEFzc2VydGlvbjtcblxuICAgICAgICBpZiAoY2xpZW50QXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb24oXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhd2FpdCBnZXRDbGllbnRBc3NlcnRpb24oXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEFzc2VydGlvbi5hc3NlcnRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc291cmNlUmVxdWVzdFVyaVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb25UeXBlKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvblR5cGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhU3RyaW5nVXRpbHMuaXNFbXB0eU9iaihyZXF1ZXN0LmNsYWltcykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMubGVuZ3RoID4gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGFpbXMoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNsYWltcyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVXJsVXRpbHMubWFwVG9RdWVyeVN0cmluZyhwYXJhbWV0ZXJzKTtcbiAgICB9XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQUFEU2VydmVyUGFyYW1LZXlzLFxuICAgIEFjY2Vzc1Rva2VuRW50aXR5LFxuICAgIEFjY291bnRFbnRpdHksXG4gICAgQWNjb3VudEluZm8sXG4gICAgQXV0aGVudGljYXRpb25SZXN1bHQsXG4gICAgQXV0aGVudGljYXRpb25TY2hlbWUsXG4gICAgQXV0aG9yaXR5LFxuICAgIEF1dGhUb2tlbixcbiAgICBCYXNlQ2xpZW50LFxuICAgIENhY2hlT3V0Y29tZSxcbiAgICBDbGllbnRBdXRoRXJyb3JDb2RlcyxcbiAgICBDbGllbnRDb25maWd1cmF0aW9uLFxuICAgIENvbW1vbk9uQmVoYWxmT2ZSZXF1ZXN0LFxuICAgIENvbnN0YW50cyxcbiAgICBjcmVhdGVDbGllbnRBdXRoRXJyb3IsXG4gICAgQ3JlZGVudGlhbEZpbHRlcixcbiAgICBDcmVkZW50aWFsVHlwZSxcbiAgICBHcmFudFR5cGUsXG4gICAgSWRUb2tlbkVudGl0eSxcbiAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlcixcbiAgICBSZXF1ZXN0VGh1bWJwcmludCxcbiAgICBSZXNwb25zZUhhbmRsZXIsXG4gICAgU2NvcGVTZXQsXG4gICAgVGltZVV0aWxzLFxuICAgIFRva2VuQ2xhaW1zLFxuICAgIFVybFN0cmluZyxcbiAgICBDbGllbnRBc3NlcnRpb24sXG4gICAgZ2V0Q2xpZW50QXNzZXJ0aW9uLFxuICAgIFVybFV0aWxzLFxufSBmcm9tIFwiQGF6dXJlL21zYWwtY29tbW9uL25vZGVcIjtcbmltcG9ydCB7IEVuY29kaW5nVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvRW5jb2RpbmdVdGlscy5qc1wiO1xuXG4vKipcbiAqIE9uLUJlaGFsZi1PZiBjbGllbnRcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE9uQmVoYWxmT2ZDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICBwcml2YXRlIHNjb3BlU2V0OiBTY29wZVNldDtcbiAgICBwcml2YXRlIHVzZXJBc3NlcnRpb25IYXNoOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBDbGllbnRDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUEkgdG8gYWNxdWlyZSB0b2tlbnMgd2l0aCBvbiBiZWhhbGYgb2YgZmxvd1xuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gZGV2ZWxvcGVyIHByb3ZpZGVkIENvbW1vbk9uQmVoYWxmT2ZSZXF1ZXN0XG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGFjcXVpcmVUb2tlbihcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uT25CZWhhbGZPZlJlcXVlc3RcbiAgICApOiBQcm9taXNlPEF1dGhlbnRpY2F0aW9uUmVzdWx0IHwgbnVsbD4ge1xuICAgICAgICB0aGlzLnNjb3BlU2V0ID0gbmV3IFNjb3BlU2V0KHJlcXVlc3Quc2NvcGVzIHx8IFtdKTtcblxuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgdXNlcl9hc3NlcnRpb25faGFzaCBmb3IgT0JPQXNzZXJ0aW9uXG4gICAgICAgIHRoaXMudXNlckFzc2VydGlvbkhhc2ggPSBhd2FpdCB0aGlzLmNyeXB0b1V0aWxzLmhhc2hTdHJpbmcoXG4gICAgICAgICAgICByZXF1ZXN0Lm9ib0Fzc2VydGlvblxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0LnNraXBDYWNoZSB8fCByZXF1ZXN0LmNsYWltcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVRva2VuUmVxdWVzdChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5LFxuICAgICAgICAgICAgICAgIHRoaXMudXNlckFzc2VydGlvbkhhc2hcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQocmVxdWVzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEFueSBmYWlsdXJlIGZhbGxzIGJhY2sgdG8gaW50ZXJhY3RpdmUgcmVxdWVzdCwgb25jZSB3ZSBpbXBsZW1lbnQgZGlzdHJpYnV0ZWQgY2FjaGUsIHdlIHBsYW4gdG8gaGFuZGxlIGBjcmVhdGVSZWZyZXNoUmVxdWlyZWRFcnJvcmAgdG8gcmVmcmVzaCB1c2luZyB0aGUgUlRcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVUb2tlblJlcXVlc3QoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJBc3NlcnRpb25IYXNoXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9vayB1cCBjYWNoZSBmb3IgdG9rZW5zXG4gICAgICogRmluZCBpZHRva2VuIGluIHRoZSBjYWNoZVxuICAgICAqIEZpbmQgYWNjZXNzVG9rZW4gYmFzZWQgb24gdXNlciBhc3NlcnRpb24gYW5kIGFjY291bnQgaW5mbyBpbiB0aGUgY2FjaGVcbiAgICAgKiBQbGVhc2Ugbm90ZSB3ZSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgT0JPIHRva2VucyByZWZyZXNoZWQgd2l0aCBsb25nIGxpdmVkIFJULiBVc2VyIHdpbGwgaGF2ZSB0byBzZW5kIGEgbmV3IGFzc2VydGlvbiBpZiB0aGUgY3VycmVudCBhY2Nlc3MgdG9rZW4gZXhwaXJlc1xuICAgICAqIFRoaXMgaXMgdG8gcHJldmVudCBzZWN1cml0eSBpc3N1ZXMgd2hlbiB0aGUgYXNzZXJ0aW9uIGNoYW5nZXMgb3ZlciB0aW1lLCBob3dldmVyLCBsb25nbGl2ZWQgUlQgaGVscHMgcmV0YWluaW5nIHRoZSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uT25CZWhhbGZPZlJlcXVlc3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGdldENhY2hlZEF1dGhlbnRpY2F0aW9uUmVzdWx0KFxuICAgICAgICByZXF1ZXN0OiBDb21tb25PbkJlaGFsZk9mUmVxdWVzdFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsPiB7XG4gICAgICAgIC8vIGxvb2sgaW4gdGhlIGNhY2hlIGZvciB0aGUgYWNjZXNzX3Rva2VuIHdoaWNoIG1hdGNoZXMgdGhlIGluY29taW5nX2Fzc2VydGlvblxuICAgICAgICBjb25zdCBjYWNoZWRBY2Nlc3NUb2tlbiA9IHRoaXMucmVhZEFjY2Vzc1Rva2VuRnJvbUNhY2hlRm9yT0JPKFxuICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICk7XG4gICAgICAgIGlmICghY2FjaGVkQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIE11c3QgcmVmcmVzaCBkdWUgdG8gbm9uLWV4aXN0ZW50IGFjY2Vzc190b2tlbi5cbiAgICAgICAgICAgIHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcj8uc2V0Q2FjaGVPdXRjb21lKFxuICAgICAgICAgICAgICAgIENhY2hlT3V0Y29tZS5OT19DQUNIRURfQUNDRVNTX1RPS0VOXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBcIlNpbGVudEZsb3dDbGllbnQ6YWNxdWlyZUNhY2hlZFRva2VuIC0gTm8gYWNjZXNzIHRva2VuIGZvdW5kIGluIGNhY2hlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihcbiAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblJlZnJlc2hSZXF1aXJlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIFRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZChcbiAgICAgICAgICAgICAgICBjYWNoZWRBY2Nlc3NUb2tlbi5leHBpcmVzT24sXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy50b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gQWNjZXNzIHRva2VuIGV4cGlyZWQsIHdpbGwgbmVlZCB0byByZW5ld2VkXG4gICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShcbiAgICAgICAgICAgICAgICBDYWNoZU91dGNvbWUuQ0FDSEVEX0FDQ0VTU19UT0tFTl9FWFBJUkVEXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBgT25iZWhhbGZvZkZsb3c6Z2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQgLSBDYWNoZWQgYWNjZXNzIHRva2VuIGlzIGV4cGlyZWQgb3Igd2lsbCBleHBpcmUgd2l0aGluICR7dGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy50b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzfSBzZWNvbmRzLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5SZWZyZXNoUmVxdWlyZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmZXRjaCB0aGUgaWRUb2tlbiBmcm9tIGNhY2hlXG4gICAgICAgIGNvbnN0IGNhY2hlZElkVG9rZW4gPSB0aGlzLnJlYWRJZFRva2VuRnJvbUNhY2hlRm9yT0JPKFxuICAgICAgICAgICAgY2FjaGVkQWNjZXNzVG9rZW4uaG9tZUFjY291bnRJZFxuICAgICAgICApO1xuICAgICAgICBsZXQgaWRUb2tlbkNsYWltczogVG9rZW5DbGFpbXMgfCB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjYWNoZWRBY2NvdW50OiBBY2NvdW50RW50aXR5IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChjYWNoZWRJZFRva2VuKSB7XG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zID0gQXV0aFRva2VuLmV4dHJhY3RUb2tlbkNsYWltcyhcbiAgICAgICAgICAgICAgICBjYWNoZWRJZFRva2VuLnNlY3JldCxcbiAgICAgICAgICAgICAgICBFbmNvZGluZ1V0aWxzLmJhc2U2NERlY29kZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQWNjb3VudElkID0gaWRUb2tlbkNsYWltcy5vaWQgfHwgaWRUb2tlbkNsYWltcy5zdWI7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50SW5mbzogQWNjb3VudEluZm8gPSB7XG4gICAgICAgICAgICAgICAgaG9tZUFjY291bnRJZDogY2FjaGVkSWRUb2tlbi5ob21lQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBjYWNoZWRJZFRva2VuLmVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHRlbmFudElkOiBjYWNoZWRJZFRva2VuLnJlYWxtLFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICAgICAgICAgIGxvY2FsQWNjb3VudElkOiBsb2NhbEFjY291bnRJZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FjaGVkQWNjb3VudCA9IHRoaXMuY2FjaGVNYW5hZ2VyLnJlYWRBY2NvdW50RnJvbUNhY2hlKGFjY291bnRJbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluY3JlbWVudCB0ZWxlbWV0cnkgY2FjaGUgaGl0IGNvdW50ZXJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIuaW5jcmVtZW50Q2FjaGVIaXRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVzcG9uc2VIYW5kbGVyLmdlbmVyYXRlQXV0aGVudGljYXRpb25SZXN1bHQoXG4gICAgICAgICAgICB0aGlzLmNyeXB0b1V0aWxzLFxuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogY2FjaGVkQWNjb3VudCxcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogY2FjaGVkQWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgaWRUb2tlbjogY2FjaGVkSWRUb2tlbixcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgYXBwTWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVhZCBpZHRva2VuIGZyb20gY2FjaGUsIHRoaXMgaXMgYSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBmb3IgT0JPIGFzIHRoZSByZXF1aXJlbWVudHMgZGlmZmVyIGZyb20gYSBnZW5lcmljIGxvb2t1cCBpbiB0aGUgY2FjaGVNYW5hZ2VyXG4gICAgICogQ2VydGFpbiB1c2UgY2FzZXMgb2YgT0JPIGZsb3cgZG8gbm90IGV4cGVjdCBhbiBpZFRva2VuIGluIHRoZSBjYWNoZS9vciBmcm9tIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIGF0SG9tZUFjY291bnRJZCAtIGFjY291bnQgaWRcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRJZFRva2VuRnJvbUNhY2hlRm9yT0JPKFxuICAgICAgICBhdEhvbWVBY2NvdW50SWQ6IHN0cmluZ1xuICAgICk6IElkVG9rZW5FbnRpdHkgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaWRUb2tlbkZpbHRlcjogQ3JlZGVudGlhbEZpbHRlciA9IHtcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IGF0SG9tZUFjY291bnRJZCxcbiAgICAgICAgICAgIGVudmlyb25tZW50OlxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5LmNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMuSG9zdE5hbWVBbmRQb3J0LFxuICAgICAgICAgICAgY3JlZGVudGlhbFR5cGU6IENyZWRlbnRpYWxUeXBlLklEX1RPS0VOLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgcmVhbG06IHRoaXMuYXV0aG9yaXR5LnRlbmFudCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpZFRva2VuTWFwOiBNYXA8c3RyaW5nLCBJZFRva2VuRW50aXR5PiA9XG4gICAgICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5nZXRJZFRva2Vuc0J5RmlsdGVyKGlkVG9rZW5GaWx0ZXIpO1xuXG4gICAgICAgIC8vIFdoZW4gYWNxdWlyaW5nIGEgdG9rZW4gb24gYmVoYWxmIG9mIGFuIGFwcGxpY2F0aW9uLCB0aGVyZSBtaWdodCBub3QgYmUgYW4gaWQgdG9rZW4gaW4gdGhlIGNhY2hlXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGlkVG9rZW5NYXApLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGlkVG9rZW5NYXApWzBdIGFzIElkVG9rZW5FbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbiBiYXNlZCBvbiBpbmNvbWluZyBhc3NlcnRpb25cbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgLSBjbGllbnQgaWRcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIGRldmVsb3BlciBwcm92aWRlZCBDb21tb25PbkJlaGFsZk9mUmVxdWVzdFxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZEFjY2Vzc1Rva2VuRnJvbUNhY2hlRm9yT0JPKFxuICAgICAgICBjbGllbnRJZDogc3RyaW5nLFxuICAgICAgICByZXF1ZXN0OiBDb21tb25PbkJlaGFsZk9mUmVxdWVzdFxuICAgICkge1xuICAgICAgICBjb25zdCBhdXRoU2NoZW1lID1cbiAgICAgICAgICAgIHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgfHwgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSO1xuICAgICAgICAvKlxuICAgICAgICAgKiBEaXN0aW5ndWlzaCBiZXR3ZWVuIEJlYXJlciBhbmQgUG9QL1NTSCB0b2tlbiBjYWNoZSB0eXBlc1xuICAgICAgICAgKiBDYXN0IHRvIGxvd2VyY2FzZSB0byBoYW5kbGUgXCJiZWFyZXJcIiBmcm9tIEFERlNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxUeXBlID1cbiAgICAgICAgICAgIGF1dGhTY2hlbWUgJiZcbiAgICAgICAgICAgIGF1dGhTY2hlbWUudG9Mb3dlckNhc2UoKSAhPT1cbiAgICAgICAgICAgICAgICBBdXRoZW50aWNhdGlvblNjaGVtZS5CRUFSRVIudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgID8gQ3JlZGVudGlhbFR5cGUuQUNDRVNTX1RPS0VOX1dJVEhfQVVUSF9TQ0hFTUVcbiAgICAgICAgICAgICAgICA6IENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTjtcblxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbkZpbHRlcjogQ3JlZGVudGlhbEZpbHRlciA9IHtcbiAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOiBjcmVkZW50aWFsVHlwZSxcbiAgICAgICAgICAgIGNsaWVudElkLFxuICAgICAgICAgICAgdGFyZ2V0OiBTY29wZVNldC5jcmVhdGVTZWFyY2hTY29wZXModGhpcy5zY29wZVNldC5hc0FycmF5KCkpLFxuICAgICAgICAgICAgdG9rZW5UeXBlOiBhdXRoU2NoZW1lLFxuICAgICAgICAgICAga2V5SWQ6IHJlcXVlc3Quc3NoS2lkLFxuICAgICAgICAgICAgcmVxdWVzdGVkQ2xhaW1zSGFzaDogcmVxdWVzdC5yZXF1ZXN0ZWRDbGFpbXNIYXNoLFxuICAgICAgICAgICAgdXNlckFzc2VydGlvbkhhc2g6IHRoaXMudXNlckFzc2VydGlvbkhhc2gsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5zID1cbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLmdldEFjY2Vzc1Rva2Vuc0J5RmlsdGVyKGFjY2Vzc1Rva2VuRmlsdGVyKTtcblxuICAgICAgICBjb25zdCBudW1BY2Nlc3NUb2tlbnMgPSBhY2Nlc3NUb2tlbnMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQWNjZXNzVG9rZW5zIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtQWNjZXNzVG9rZW5zID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdUb2tlbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW5zWzBdIGFzIEFjY2Vzc1Rva2VuRW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBuZXR3b3JrIGNhbGwgdG8gdGhlIHNlcnZlciByZXF1ZXN0aW5nIGNyZWRlbnRpYWxzXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uT25CZWhhbGZPZlJlcXVlc3RcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5IC0gYXV0aG9yaXR5IG9iamVjdFxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgZXhlY3V0ZVRva2VuUmVxdWVzdChcbiAgICAgICAgcmVxdWVzdDogQ29tbW9uT25CZWhhbGZPZlJlcXVlc3QsXG4gICAgICAgIGF1dGhvcml0eTogQXV0aG9yaXR5LFxuICAgICAgICB1c2VyQXNzZXJ0aW9uSGFzaDogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxBdXRoZW50aWNhdGlvblJlc3VsdCB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5jcmVhdGVUb2tlblF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBVcmxTdHJpbmcuYXBwZW5kUXVlcnlTdHJpbmcoXG4gICAgICAgICAgICBhdXRob3JpdHkudG9rZW5FbmRwb2ludCxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1N0cmluZ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGF3YWl0IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgY29uc3QgdGh1bWJwcmludDogUmVxdWVzdFRodW1icHJpbnQgPSB7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICAgICBhdXRob3JpdHk6IHJlcXVlc3QuYXV0aG9yaXR5LFxuICAgICAgICAgICAgc2NvcGVzOiByZXF1ZXN0LnNjb3BlcyxcbiAgICAgICAgICAgIGNsYWltczogcmVxdWVzdC5jbGFpbXMsXG4gICAgICAgICAgICBhdXRoZW50aWNhdGlvblNjaGVtZTogcmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSxcbiAgICAgICAgICAgIHJlc291cmNlUmVxdWVzdE1ldGhvZDogcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RVcmk6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpLFxuICAgICAgICAgICAgc2hyQ2xhaW1zOiByZXF1ZXN0LnNockNsYWltcyxcbiAgICAgICAgICAgIHNzaEtpZDogcmVxdWVzdC5zc2hLaWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVxVGltZXN0YW1wID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50KFxuICAgICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgICByZXF1ZXN0Qm9keSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB0aHVtYnByaW50LFxuICAgICAgICAgICAgcmVxdWVzdC5jb3JyZWxhdGlvbklkXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gbmV3IFJlc3BvbnNlSGFuZGxlcihcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIsXG4gICAgICAgICAgICB0aGlzLmNyeXB0b1V0aWxzLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXJpYWxpemFibGVDYWNoZSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnBlcnNpc3RlbmNlUGx1Z2luXG4gICAgICAgICk7XG5cbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnZhbGlkYXRlVG9rZW5SZXNwb25zZShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlSGFuZGxlci5oYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5LFxuICAgICAgICAgICAgcmVxVGltZXN0YW1wLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVzZXJBc3NlcnRpb25IYXNoXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRva2VuUmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgYSBzZXJ2ZXIgcmVxdWVzdCBpbiBhY2NlcGFibGUgZm9ybWF0XG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uT25CZWhhbGZPZlJlcXVlc3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRva2VuUmVxdWVzdEJvZHkoXG4gICAgICAgIHJlcXVlc3Q6IENvbW1vbk9uQmVoYWxmT2ZSZXF1ZXN0XG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SWQoXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWRcbiAgICAgICAgKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTY29wZXMocGFyYW1ldGVycywgcmVxdWVzdC5zY29wZXMpO1xuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEdyYW50VHlwZShwYXJhbWV0ZXJzLCBHcmFudFR5cGUuSldUX0JFQVJFUik7XG5cbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMaWJyYXJ5SW5mbyhcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5saWJyYXJ5SW5mb1xuICAgICAgICApO1xuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRBcHBsaWNhdGlvblRlbGVtZXRyeShcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy50ZWxlbWV0cnkuYXBwbGljYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyhwYXJhbWV0ZXJzKTtcblxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTZXJ2ZXJUZWxlbWV0cnkoXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3JyZWxhdGlvbklkID1cbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZCB8fFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY3J5cHRvSW50ZXJmYWNlLmNyZWF0ZU5ld0d1aWQoKTtcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ29ycmVsYXRpb25JZChwYXJhbWV0ZXJzLCBjb3JyZWxhdGlvbklkKTtcblxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRSZXF1ZXN0VG9rZW5Vc2UoXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgQUFEU2VydmVyUGFyYW1LZXlzLk9OX0JFSEFMRl9PRlxuICAgICAgICApO1xuXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZE9ib0Fzc2VydGlvbihcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZXF1ZXN0Lm9ib0Fzc2VydGlvblxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXQpIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudFNlY3JldChcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudFNlY3JldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsaWVudEFzc2VydGlvbjogQ2xpZW50QXNzZXJ0aW9uIHwgdW5kZWZpbmVkID1cbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudEFzc2VydGlvbjtcblxuICAgICAgICBpZiAoY2xpZW50QXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb24oXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhd2FpdCBnZXRDbGllbnRBc3NlcnRpb24oXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEFzc2VydGlvbi5hc3NlcnRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc291cmNlUmVxdWVzdFVyaVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb25UeXBlKFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvblR5cGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXF1ZXN0LmNsYWltcyB8fFxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcy5sZW5ndGggPiAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsYWltcyhcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xhaW1zLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xuICAgIH1cbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLy8gQUFEQXV0aG9yaXR5Q29uc3RhbnRzXG5cbmltcG9ydCB7IENsaWVudEFwcGxpY2F0aW9uIH0gZnJvbSBcIi4vQ2xpZW50QXBwbGljYXRpb24uanNcIjtcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi4vY29uZmlnL0NvbmZpZ3VyYXRpb24uanNcIjtcbmltcG9ydCB7IENsaWVudEFzc2VydGlvbiB9IGZyb20gXCIuL0NsaWVudEFzc2VydGlvbi5qc1wiO1xuaW1wb3J0IHtcbiAgICBDb25zdGFudHMgYXMgTm9kZUNvbnN0YW50cyxcbiAgICBBcGlJZCxcbiAgICBSRUdJT05fRU5WSVJPTk1FTlRfVkFSSUFCTEUsXG4gICAgTVNBTF9GT1JDRV9SRUdJT04sXG59IGZyb20gXCIuLi91dGlscy9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7XG4gICAgQ29tbW9uQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3QsXG4gICAgQ29tbW9uT25CZWhhbGZPZlJlcXVlc3QsXG4gICAgQXV0aGVudGljYXRpb25SZXN1bHQsXG4gICAgQXp1cmVSZWdpb25Db25maWd1cmF0aW9uLFxuICAgIEF1dGhFcnJvcixcbiAgICBJQXBwVG9rZW5Qcm92aWRlcixcbiAgICBPSURDX0RFRkFVTFRfU0NPUEVTLFxuICAgIFVybFN0cmluZyxcbiAgICBBQURBdXRob3JpdHlDb25zdGFudHMsXG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIENsaWVudEF1dGhFcnJvckNvZGVzLFxuICAgIENsaWVudEFzc2VydGlvbiBhcyBDbGllbnRBc3NlcnRpb25UeXBlLFxuICAgIGdldENsaWVudEFzc2VydGlvbixcbiAgICBBenVyZVJlZ2lvbixcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBJQ29uZmlkZW50aWFsQ2xpZW50QXBwbGljYXRpb24gfSBmcm9tIFwiLi9JQ29uZmlkZW50aWFsQ2xpZW50QXBwbGljYXRpb24uanNcIjtcbmltcG9ydCB7IE9uQmVoYWxmT2ZSZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvT25CZWhhbGZPZlJlcXVlc3QuanNcIjtcbmltcG9ydCB7IENsaWVudENyZWRlbnRpYWxSZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3QuanNcIjtcbmltcG9ydCB7IENsaWVudENyZWRlbnRpYWxDbGllbnQgfSBmcm9tIFwiLi9DbGllbnRDcmVkZW50aWFsQ2xpZW50LmpzXCI7XG5pbXBvcnQgeyBPbkJlaGFsZk9mQ2xpZW50IH0gZnJvbSBcIi4vT25CZWhhbGZPZkNsaWVudC5qc1wiO1xuXG4vKipcbiAqICBUaGlzIGNsYXNzIGlzIHRvIGJlIHVzZWQgdG8gYWNxdWlyZSB0b2tlbnMgZm9yIGNvbmZpZGVudGlhbCBjbGllbnQgYXBwbGljYXRpb25zICh3ZWJBcHAsIHdlYkFQSSkuIENvbmZpZGVudGlhbCBjbGllbnQgYXBwbGljYXRpb25zXG4gKiAgd2lsbCBjb25maWd1cmUgYXBwbGljYXRpb24gc2VjcmV0cywgY2xpZW50IGNlcnRpZmljYXRlcy9hc3NlcnRpb25zIGFzIGFwcGxpY2FibGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZGVudGlhbENsaWVudEFwcGxpY2F0aW9uXG4gICAgZXh0ZW5kcyBDbGllbnRBcHBsaWNhdGlvblxuICAgIGltcGxlbWVudHMgSUNvbmZpZGVudGlhbENsaWVudEFwcGxpY2F0aW9uXG57XG4gICAgcHJpdmF0ZSBhcHBUb2tlblByb3ZpZGVyPzogSUFwcFRva2VuUHJvdmlkZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIENvbmZpZGVudGlhbENsaWVudEFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKiBSZXF1aXJlZCBhdHRyaWJ1dGVzIGluIHRoZSBDb25maWd1cmF0aW9uIG9iamVjdCBhcmU6XG4gICAgICogLSBjbGllbnRJRDogdGhlIGFwcGxpY2F0aW9uIElEIG9mIHlvdXIgYXBwbGljYXRpb24uIFlvdSBjYW4gb2J0YWluIG9uZSBieSByZWdpc3RlcmluZyB5b3VyIGFwcGxpY2F0aW9uIHdpdGggb3VyIGFwcGxpY2F0aW9uIHJlZ2lzdHJhdGlvbiBwb3J0YWxcbiAgICAgKiAtIGF1dGhvcml0eTogdGhlIGF1dGhvcml0eSBVUkwgZm9yIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogLSBjbGllbnQgY3JlZGVudGlhbDogTXVzdCBzZXQgZWl0aGVyIGNsaWVudCBzZWNyZXQsIGNlcnRpZmljYXRlLCBvciBhc3NlcnRpb24gZm9yIGNvbmZpZGVudGlhbCBjbGllbnRzLiBZb3UgY2FuIG9idGFpbiBhIGNsaWVudCBzZWNyZXQgZnJvbSB0aGUgYXBwbGljYXRpb24gcmVnaXN0cmF0aW9uIHBvcnRhbC5cbiAgICAgKlxuICAgICAqIEluIEF6dXJlIEFELCBhdXRob3JpdHkgaXMgYSBVUkwgaW5kaWNhdGluZyBvZiB0aGUgZm9ybSBodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vXFx7RW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcXH0uXG4gICAgICogSWYgeW91ciBhcHBsaWNhdGlvbiBzdXBwb3J0cyBBY2NvdW50cyBpbiBvbmUgb3JnYW5pemF0aW9uYWwgZGlyZWN0b3J5LCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIHRoZSBUZW5hbnQgSWQgb3IgVGVuYW50IG5hbWUgKGZvciBleGFtcGxlLCBjb250b3NvLm1pY3Jvc29mdC5jb20pLlxuICAgICAqIElmIHlvdXIgYXBwbGljYXRpb24gc3VwcG9ydHMgQWNjb3VudHMgaW4gYW55IG9yZ2FuaXphdGlvbmFsIGRpcmVjdG9yeSwgcmVwbGFjZSBcIkVudGVyX3RoZV9UZW5hbnRfSW5mb19IZXJlXCIgdmFsdWUgd2l0aCBvcmdhbml6YXRpb25zLlxuICAgICAqIElmIHlvdXIgYXBwbGljYXRpb24gc3VwcG9ydHMgQWNjb3VudHMgaW4gYW55IG9yZ2FuaXphdGlvbmFsIGRpcmVjdG9yeSBhbmQgcGVyc29uYWwgTWljcm9zb2Z0IGFjY291bnRzLCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIGNvbW1vbi5cbiAgICAgKiBUbyByZXN0cmljdCBzdXBwb3J0IHRvIFBlcnNvbmFsIE1pY3Jvc29mdCBhY2NvdW50cyBvbmx5LCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIGNvbnN1bWVycy5cbiAgICAgKlxuICAgICAqIEluIEF6dXJlIEIyQywgYXV0aG9yaXR5IGlzIG9mIHRoZSBmb3JtIGh0dHBzOi8vXFx7aW5zdGFuY2VcXH0vdGZwL1xce3RlbmFudFxcfS9cXHtwb2xpY3lOYW1lXFx9L1xuICAgICAqIEZ1bGwgQjJDIGZ1bmN0aW9uYWxpdHkgd2lsbCBiZSBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5IGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBDb25maWd1cmF0aW9uIC0gY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBNU0FMIENvbmZpZGVudGlhbENsaWVudEFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbikge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uKTtcblxuICAgICAgICBjb25zdCBjbGllbnRTZWNyZXROb3RFbXB0eSA9ICEhdGhpcy5jb25maWcuYXV0aC5jbGllbnRTZWNyZXQ7XG4gICAgICAgIGNvbnN0IGNsaWVudEFzc2VydGlvbk5vdEVtcHR5ID0gISF0aGlzLmNvbmZpZy5hdXRoLmNsaWVudEFzc2VydGlvbjtcbiAgICAgICAgY29uc3QgY2VydGlmaWNhdGVOb3RFbXB0eSA9XG4gICAgICAgICAgICAoISF0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlPy50aHVtYnByaW50IHx8XG4gICAgICAgICAgICAgICAgISF0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlPy50aHVtYnByaW50U2hhMjU2KSAmJlxuICAgICAgICAgICAgISF0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlPy5wcml2YXRlS2V5O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIElmIGFwcCBkZXZlbG9wZXIgY29uZmlndXJlcyB0aGlzIGNhbGxiYWNrLCB0aGV5IGRvbid0IG5lZWQgYSBjcmVkZW50aWFsXG4gICAgICAgICAqIGkuZS4gQXp1cmVTREsgY2FuIGdldCB0b2tlbiBmcm9tIE1hbmFnZWQgSWRlbnRpdHkgd2l0aG91dCBhIGNlcnQgLyBzZWNyZXRcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmFwcFRva2VuUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgYXQgbW9zdCBvbmUgY3JlZGVudGlhbCBpcyBzZXQgb24gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChjbGllbnRTZWNyZXROb3RFbXB0eSAmJiBjbGllbnRBc3NlcnRpb25Ob3RFbXB0eSkgfHxcbiAgICAgICAgICAgIChjbGllbnRBc3NlcnRpb25Ob3RFbXB0eSAmJiBjZXJ0aWZpY2F0ZU5vdEVtcHR5KSB8fFxuICAgICAgICAgICAgKGNsaWVudFNlY3JldE5vdEVtcHR5ICYmIGNlcnRpZmljYXRlTm90RW1wdHkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDbGllbnRDcmVkZW50aWFsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGguY2xpZW50U2VjcmV0KSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFNlY3JldCA9IHRoaXMuY29uZmlnLmF1dGguY2xpZW50U2VjcmV0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGguY2xpZW50QXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRldmVsb3BlclByb3ZpZGVkQ2xpZW50QXNzZXJ0aW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudEFzc2VydGlvbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2VydGlmaWNhdGVOb3RFbXB0eSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDbGllbnRDcmVkZW50aWFsXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRBc3NlcnRpb24gPSAhIXRoaXMuY29uZmlnLmF1dGguY2xpZW50Q2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgICAudGh1bWJwcmludFNoYTI1NlxuICAgICAgICAgICAgICAgID8gQ2xpZW50QXNzZXJ0aW9uLmZyb21DZXJ0aWZpY2F0ZVdpdGhTaGEyNTZUaHVtYnByaW50KFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGguY2xpZW50Q2VydGlmaWNhdGUudGh1bWJwcmludFNoYTI1NixcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZS54NWNcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IENsaWVudEFzc2VydGlvbi5mcm9tQ2VydGlmaWNhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZ3VhcmFudGVlZCB0byBiZSBhIHN0cmluZywgZHVlIHRvIHByaW9yIGVycm9yIGNoZWNraW5nIGluIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlLnRodW1icHJpbnQgYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGguY2xpZW50Q2VydGlmaWNhdGUucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlLng1Y1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcFRva2VuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBleHRlbnNpYmlsaXR5IHBvaW50IG9ubHkgd29ya3MgZm9yIHRoZSBjbGllbnRfY3JlZGVudGlhbCBmbG93LCBpLmUuIGFjcXVpcmVUb2tlbkJ5Q2xpZW50Q3JlZGVudGlhbCBhbmRcbiAgICAgKiBpcyBtZWFudCBmb3IgQXp1cmUgU0RLIHRvIGVuaGFuY2UgTWFuYWdlZCBJZGVudGl0eSBzdXBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIElBcHBUb2tlblByb3ZpZGVyICAtIEV4dGVuc2liaWxpdHkgaW50ZXJmYWNlLCB3aGljaCBhbGxvd3MgdGhlIGFwcCBkZXZlbG9wZXIgdG8gcmV0dXJuIGEgdG9rZW4gZnJvbSBhIGN1c3RvbSBzb3VyY2UuXG4gICAgICovXG4gICAgU2V0QXBwVG9rZW5Qcm92aWRlcihwcm92aWRlcjogSUFwcFRva2VuUHJvdmlkZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hcHBUb2tlblByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgdG9rZW5zIGZyb20gdGhlIGF1dGhvcml0eSBmb3IgdGhlIGFwcGxpY2F0aW9uIChub3QgZm9yIGFuIGVuZCB1c2VyKS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgYWNxdWlyZVRva2VuQnlDbGllbnRDcmVkZW50aWFsKFxuICAgICAgICByZXF1ZXN0OiBDbGllbnRDcmVkZW50aWFsUmVxdWVzdFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsPiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICBcImFjcXVpcmVUb2tlbkJ5Q2xpZW50Q3JlZGVudGlhbCBjYWxsZWRcIixcbiAgICAgICAgICAgIHJlcXVlc3QuY29ycmVsYXRpb25JZFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgY2xpZW50IGFzc2VydGlvbiBwcmVzZW50IGluIHRoZSByZXF1ZXN0LCBpdCBvdmVycmlkZXMgdGhlIG9uZSBwcmVzZW50IGluIHRoZSBjbGllbnQgY29uZmlndXJhdGlvblxuICAgICAgICBsZXQgY2xpZW50QXNzZXJ0aW9uOiBDbGllbnRBc3NlcnRpb25UeXBlIHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVxdWVzdC5jbGllbnRBc3NlcnRpb24pIHtcbiAgICAgICAgICAgIGNsaWVudEFzc2VydGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRpb246IGF3YWl0IGdldENsaWVudEFzc2VydGlvbihcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRBc3NlcnRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9rZW5FbmRwb2ludCB3aWxsIGJlIHVuZGVmaW5lZC4gcmVzb3VyY2VSZXF1ZXN0VXJpIGlzIG9taXR0ZWQgaW4gQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3RcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGFzc2VydGlvblR5cGU6IE5vZGVDb25zdGFudHMuSldUX0JFQVJFUl9BU1NFUlRJT05fVFlQRSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXNlUmVxdWVzdCA9IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUJhc2VSZXF1ZXN0KHJlcXVlc3QpO1xuXG4gICAgICAgIC8vIHZhbGlkIGJhc2UgcmVxdWVzdCBzaG91bGQgbm90IGNvbnRhaW4gb2lkYyBzY29wZXMgaW4gdGhpcyBncmFudCB0eXBlXG4gICAgICAgIGNvbnN0IHZhbGlkQmFzZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICAuLi5iYXNlUmVxdWVzdCxcbiAgICAgICAgICAgIHNjb3BlczogYmFzZVJlcXVlc3Quc2NvcGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAoc2NvcGU6IHN0cmluZykgPT4gIU9JRENfREVGQVVMVF9TQ09QRVMuaW5jbHVkZXMoc2NvcGUpXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHZhbGlkUmVxdWVzdDogQ29tbW9uQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgLi4udmFsaWRCYXNlUmVxdWVzdCxcbiAgICAgICAgICAgIGNsaWVudEFzc2VydGlvbixcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiB2YWxpZCByZXF1ZXN0IHNob3VsZCBub3QgaGF2ZSBcImNvbW1vblwiIG9yIFwib3JnYW5pemF0aW9uc1wiIGluIGxpZXUgb2YgdGhlIHRlbmFudF9pZCBpbiB0aGUgYXV0aG9yaXR5IGluIHRoZSBhdXRoIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICogZXhhbXBsZSBhdXRob3JpdHk6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL1RlbmFudElkXCIsXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdXRob3JpdHkgPSBuZXcgVXJsU3RyaW5nKHZhbGlkUmVxdWVzdC5hdXRob3JpdHkpO1xuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF1dGhvcml0eS5nZXRVcmxDb21wb25lbnRzKCkuUGF0aFNlZ21lbnRzWzBdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKEFBREF1dGhvcml0eUNvbnN0YW50cykuaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgdGVuYW50SWQgYXMgQUFEQXV0aG9yaXR5Q29uc3RhbnRzXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKFxuICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLm1pc3NpbmdUZW5hbnRJZEVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogaWYgdGhpcyBlbnYgdmFyaWFibGUgaXMgc2V0LCBhbmQgdGhlIGRldmVsb3BlciBwcm92aWRlZCByZWdpb24gaXNuJ3QgZGVmaW5lZCBhbmQgaXNuJ3QgXCJEaXNhYmxlTXNhbEZvcmNlUmVnaW9uXCIsXG4gICAgICAgICAqIE1TQUwgc2hhbGwgb3B0LWluIHRvIEVTVFMtUiB3aXRoIHRoZSB2YWx1ZSBvZiB0aGlzIHZhcmlhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBFTlZfTVNBTF9GT1JDRV9SRUdJT046IEF6dXJlUmVnaW9uIHwgdW5kZWZpbmVkID1cbiAgICAgICAgICAgIHByb2Nlc3MuZW52W01TQUxfRk9SQ0VfUkVHSU9OXTtcblxuICAgICAgICBsZXQgcmVnaW9uOiBBenVyZVJlZ2lvbiB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZhbGlkUmVxdWVzdC5henVyZVJlZ2lvbiAhPT0gXCJEaXNhYmxlTXNhbEZvcmNlUmVnaW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRSZXF1ZXN0LmF6dXJlUmVnaW9uICYmIEVOVl9NU0FMX0ZPUkNFX1JFR0lPTikge1xuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IEVOVl9NU0FMX0ZPUkNFX1JFR0lPTjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uID0gdmFsaWRSZXF1ZXN0LmF6dXJlUmVnaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXp1cmVSZWdpb25Db25maWd1cmF0aW9uOiBBenVyZVJlZ2lvbkNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgICAgICBhenVyZVJlZ2lvbjogcmVnaW9uLFxuICAgICAgICAgICAgZW52aXJvbm1lbnRSZWdpb246IHByb2Nlc3MuZW52W1JFR0lPTl9FTlZJUk9OTUVOVF9WQVJJQUJMRV0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc2VydmVyVGVsZW1ldHJ5TWFuYWdlciA9IHRoaXMuaW5pdGlhbGl6ZVNlcnZlclRlbGVtZXRyeU1hbmFnZXIoXG4gICAgICAgICAgICBBcGlJZC5hY3F1aXJlVG9rZW5CeUNsaWVudENyZWRlbnRpYWwsXG4gICAgICAgICAgICB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5za2lwQ2FjaGVcbiAgICAgICAgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyZWRBdXRob3JpdHkgPSBhd2FpdCB0aGlzLmNyZWF0ZUF1dGhvcml0eShcbiAgICAgICAgICAgICAgICB2YWxpZFJlcXVlc3QuYXV0aG9yaXR5LFxuICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgIGF6dXJlUmVnaW9uQ29uZmlndXJhdGlvbixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmF6dXJlQ2xvdWRPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50Q3JlZGVudGlhbENvbmZpZyA9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5idWlsZE9hdXRoQ2xpZW50Q29uZmlndXJhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgZGlzY292ZXJlZEF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50Q3JlZGVudGlhbENsaWVudCA9IG5ldyBDbGllbnRDcmVkZW50aWFsQ2xpZW50KFxuICAgICAgICAgICAgICAgIGNsaWVudENyZWRlbnRpYWxDb25maWcsXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBUb2tlblByb3ZpZGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICAgICBcIkNsaWVudCBjcmVkZW50aWFsIGNsaWVudCBjcmVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY2xpZW50Q3JlZGVudGlhbENsaWVudC5hY3F1aXJlVG9rZW4odmFsaWRSZXF1ZXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBdXRoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLnNldENvcnJlbGF0aW9uSWQodmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5jYWNoZUZhaWxlZFJlcXVlc3QoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgdG9rZW5zIGZyb20gdGhlIGF1dGhvcml0eSBmb3IgdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqXG4gICAgICogVXNlZCBpbiBzY2VuYXJpb3Mgd2hlcmUgdGhlIGN1cnJlbnQgYXBwIGlzIGEgbWlkZGxlLXRpZXIgc2VydmljZSB3aGljaCB3YXMgY2FsbGVkIHdpdGggYSB0b2tlblxuICAgICAqIHJlcHJlc2VudGluZyBhbiBlbmQgdXNlci4gVGhlIGN1cnJlbnQgYXBwIGNhbiB1c2UgdGhlIHRva2VuIChvYm9Bc3NlcnRpb24pIHRvIHJlcXVlc3QgYW5vdGhlclxuICAgICAqIHRva2VuIHRvIGFjY2VzcyBkb3duc3RyZWFtIHdlYiBBUEksIG9uIGJlaGFsZiBvZiB0aGF0IHVzZXIuXG4gICAgICpcbiAgICAgKiBUaGUgY3VycmVudCBtaWRkbGUtdGllciBhcHAgaGFzIG5vIHVzZXIgaW50ZXJhY3Rpb24gdG8gb2J0YWluIGNvbnNlbnQuXG4gICAgICogU2VlIGhvdyB0byBnYWluIGNvbnNlbnQgdXBmcm9udCBmb3IgeW91ciBtaWRkbGUtdGllciBhcHAgZnJvbSB0aGlzIGFydGljbGUuXG4gICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvYWN0aXZlLWRpcmVjdG9yeS9kZXZlbG9wL3YyLW9hdXRoMi1vbi1iZWhhbGYtb2YtZmxvdyNnYWluaW5nLWNvbnNlbnQtZm9yLXRoZS1taWRkbGUtdGllci1hcHBsaWNhdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBhY3F1aXJlVG9rZW5PbkJlaGFsZk9mKFxuICAgICAgICByZXF1ZXN0OiBPbkJlaGFsZk9mUmVxdWVzdFxuICAgICk6IFByb21pc2U8QXV0aGVudGljYXRpb25SZXN1bHQgfCBudWxsPiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICBcImFjcXVpcmVUb2tlbk9uQmVoYWxmT2YgY2FsbGVkXCIsXG4gICAgICAgICAgICByZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0OiBDb21tb25PbkJlaGFsZk9mUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5pbml0aWFsaXplQmFzZVJlcXVlc3QocmVxdWVzdCkpLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGlzY292ZXJlZEF1dGhvcml0eSA9IGF3YWl0IHRoaXMuY3JlYXRlQXV0aG9yaXR5KFxuICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5hdXRob3JpdHksXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuYXp1cmVDbG91ZE9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBvbkJlaGFsZk9mQ29uZmlnID0gYXdhaXQgdGhpcy5idWlsZE9hdXRoQ2xpZW50Q29uZmlndXJhdGlvbihcbiAgICAgICAgICAgICAgICBkaXNjb3ZlcmVkQXV0aG9yaXR5LFxuICAgICAgICAgICAgICAgIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgb2JvQ2xpZW50ID0gbmV3IE9uQmVoYWxmT2ZDbGllbnQob25CZWhhbGZPZkNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgICAgIFwiT24gYmVoYWxmIG9mIGNsaWVudCBjcmVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgb2JvQ2xpZW50LmFjcXVpcmVUb2tlbih2YWxpZFJlcXVlc3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xuICAgICAgICAgICAgICAgIGUuc2V0Q29ycmVsYXRpb25JZCh2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZGF0ZSBzdHJpbmcgaXMgaW4gSVNPIDg2MDEgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBkYXRlU3RyaW5nIC0gVGhlIGRhdGUgc3RyaW5nIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBib29sZWFuIC0gUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRlIHN0cmluZyBpcyBpbiBJU08gODYwMSBmb3JtYXQsIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSXNvODYwMShkYXRlU3RyaW5nOiBudW1iZXIgfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAodHlwZW9mIGRhdGVTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgICByZXR1cm4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSAmJiBkYXRlLnRvSVNPU3RyaW5nKCkgPT09IGRhdGVTdHJpbmc7XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgSGVhZGVyTmFtZXMsXG4gICAgSU5ldHdvcmtNb2R1bGUsXG4gICAgTmV0d29ya1JlcXVlc3RPcHRpb25zLFxuICAgIE5ldHdvcmtSZXNwb25zZSxcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBJSHR0cFJldHJ5UG9saWN5IH0gZnJvbSBcIi4uL3JldHJ5L0lIdHRwUmV0cnlQb2xpY3kuanNcIjtcbmltcG9ydCB7IEh0dHBNZXRob2QgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzLmpzXCI7XG5cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50V2l0aFJldHJpZXMgaW1wbGVtZW50cyBJTmV0d29ya01vZHVsZSB7XG4gICAgcHJpdmF0ZSBodHRwQ2xpZW50Tm9SZXRyaWVzOiBJTmV0d29ya01vZHVsZTtcbiAgICBwcml2YXRlIHJldHJ5UG9saWN5OiBJSHR0cFJldHJ5UG9saWN5O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGh0dHBDbGllbnROb1JldHJpZXM6IElOZXR3b3JrTW9kdWxlLFxuICAgICAgICByZXRyeVBvbGljeTogSUh0dHBSZXRyeVBvbGljeVxuICAgICkge1xuICAgICAgICB0aGlzLmh0dHBDbGllbnROb1JldHJpZXMgPSBodHRwQ2xpZW50Tm9SZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJ5UG9saWN5ID0gcmV0cnlQb2xpY3k7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBzZW5kTmV0d29ya1JlcXVlc3RBc3luY0hlbHBlcjxUPihcbiAgICAgICAgaHR0cE1ldGhvZDogSHR0cE1ldGhvZCxcbiAgICAgICAgdXJsOiBzdHJpbmcsXG4gICAgICAgIG9wdGlvbnM/OiBOZXR3b3JrUmVxdWVzdE9wdGlvbnNcbiAgICApOiBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxUPj4ge1xuICAgICAgICBpZiAoaHR0cE1ldGhvZCA9PT0gSHR0cE1ldGhvZC5HRVQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnROb1JldHJpZXMuc2VuZEdldFJlcXVlc3RBc3luYyh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudE5vUmV0cmllcy5zZW5kUG9zdFJlcXVlc3RBc3luYyh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBzZW5kTmV0d29ya1JlcXVlc3RBc3luYzxUPihcbiAgICAgICAgaHR0cE1ldGhvZDogSHR0cE1ldGhvZCxcbiAgICAgICAgdXJsOiBzdHJpbmcsXG4gICAgICAgIG9wdGlvbnM/OiBOZXR3b3JrUmVxdWVzdE9wdGlvbnNcbiAgICApOiBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxUPj4ge1xuICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBuZXR3b3JrIG1vZHVsZSAoY3VzdG9tIG9yIEh0dHBDbGllbnQpIHdpbGwgbWFrZSB0aGUgY2FsbFxuICAgICAgICBsZXQgcmVzcG9uc2U6IE5ldHdvcmtSZXNwb25zZTxUPiA9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmROZXR3b3JrUmVxdWVzdEFzeW5jSGVscGVyKGh0dHBNZXRob2QsIHVybCwgb3B0aW9ucyk7XG5cbiAgICAgICAgbGV0IGN1cnJlbnRSZXRyeTogbnVtYmVyID0gMDtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXRyeVBvbGljeS5wYXVzZUZvclJldHJ5KFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBjdXJyZW50UmV0cnksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVyc1tIZWFkZXJOYW1lcy5SRVRSWV9BRlRFUl1cbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE5ldHdvcmtSZXF1ZXN0QXN5bmNIZWxwZXIoXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnRSZXRyeSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZW5kR2V0UmVxdWVzdEFzeW5jPFQ+KFxuICAgICAgICB1cmw6IHN0cmluZyxcbiAgICAgICAgb3B0aW9ucz86IE5ldHdvcmtSZXF1ZXN0T3B0aW9uc1xuICAgICk6IFByb21pc2U8TmV0d29ya1Jlc3BvbnNlPFQ+PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmROZXR3b3JrUmVxdWVzdEFzeW5jKEh0dHBNZXRob2QuR0VULCB1cmwsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZW5kUG9zdFJlcXVlc3RBc3luYzxUPihcbiAgICAgICAgdXJsOiBzdHJpbmcsXG4gICAgICAgIG9wdGlvbnM/OiBOZXR3b3JrUmVxdWVzdE9wdGlvbnNcbiAgICApOiBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxUPj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kTmV0d29ya1JlcXVlc3RBc3luYyhIdHRwTWV0aG9kLlBPU1QsIHVybCwgb3B0aW9ucyk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEF1dGhFcnJvcixcbiAgICBBdXRob3JpdHksXG4gICAgQ2xpZW50QXV0aEVycm9yQ29kZXMsXG4gICAgQ29uc3RhbnRzLFxuICAgIEhlYWRlck5hbWVzLFxuICAgIElOZXR3b3JrTW9kdWxlLFxuICAgIExvZ2dlcixcbiAgICBOZXR3b3JrUmVxdWVzdE9wdGlvbnMsXG4gICAgTmV0d29ya1Jlc3BvbnNlLFxuICAgIFJlc3BvbnNlSGFuZGxlcixcbiAgICBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZSxcbiAgICBUaW1lVXRpbHMsXG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIEF1dGhlbnRpY2F0aW9uUmVzdWx0LFxuICAgIFVybFN0cmluZyxcbn0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlJZCB9IGZyb20gXCIuLi8uLi9jb25maWcvTWFuYWdlZElkZW50aXR5SWQuanNcIjtcbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uLy4uL2NvbmZpZy9NYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycy5qc1wiO1xuaW1wb3J0IHsgQ3J5cHRvUHJvdmlkZXIgfSBmcm9tIFwiLi4vLi4vY3J5cHRvL0NyeXB0b1Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0IH0gZnJvbSBcIi4uLy4uL3JlcXVlc3QvTWFuYWdlZElkZW50aXR5UmVxdWVzdC5qc1wiO1xuaW1wb3J0IHsgSHR0cE1ldGhvZCwgTWFuYWdlZElkZW50aXR5SWRUeXBlIH0gZnJvbSBcIi4uLy4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5VG9rZW5SZXNwb25zZSB9IGZyb20gXCIuLi8uLi9yZXNwb25zZS9NYW5hZ2VkSWRlbnRpdHlUb2tlblJlc3BvbnNlLmpzXCI7XG5pbXBvcnQgeyBOb2RlU3RvcmFnZSB9IGZyb20gXCIuLi8uLi9jYWNoZS9Ob2RlU3RvcmFnZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLFxuICAgIGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yLFxufSBmcm9tIFwiLi4vLi4vZXJyb3IvTWFuYWdlZElkZW50aXR5RXJyb3IuanNcIjtcbmltcG9ydCB7IGlzSXNvODYwMSB9IGZyb20gXCIuLi8uLi91dGlscy9UaW1lVXRpbHMuanNcIjtcbmltcG9ydCB7IEh0dHBDbGllbnRXaXRoUmV0cmllcyB9IGZyb20gXCIuLi8uLi9uZXR3b3JrL0h0dHBDbGllbnRXaXRoUmV0cmllcy5qc1wiO1xuXG4vKipcbiAqIE1hbmFnZWQgSWRlbnRpdHkgVXNlciBBc3NpZ25lZCBJZCBRdWVyeSBQYXJhbWV0ZXIgTmFtZXNcbiAqL1xuZXhwb3J0IGNvbnN0IE1hbmFnZWRJZGVudGl0eVVzZXJBc3NpZ25lZElkUXVlcnlQYXJhbWV0ZXJOYW1lcyA9IHtcbiAgICBNQU5BR0VEX0lERU5USVRZX0NMSUVOVF9JRDogXCJjbGllbnRfaWRcIixcbiAgICBNQU5BR0VEX0lERU5USVRZX09CSkVDVF9JRDogXCJvYmplY3RfaWRcIixcbiAgICBNQU5BR0VEX0lERU5USVRZX1JFU09VUkNFX0lEX0lNRFM6IFwibXNpX3Jlc19pZFwiLFxuICAgIE1BTkFHRURfSURFTlRJVFlfUkVTT1VSQ0VfSURfTk9OX0lNRFM6IFwibWlfcmVzX2lkXCIsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgTWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlck5hbWVzID1cbiAgICAodHlwZW9mIE1hbmFnZWRJZGVudGl0eVVzZXJBc3NpZ25lZElkUXVlcnlQYXJhbWV0ZXJOYW1lcylba2V5b2YgdHlwZW9mIE1hbmFnZWRJZGVudGl0eVVzZXJBc3NpZ25lZElkUXVlcnlQYXJhbWV0ZXJOYW1lc107XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIHtcbiAgICBwcm90ZWN0ZWQgbG9nZ2VyOiBMb2dnZXI7XG4gICAgcHJpdmF0ZSBub2RlU3RvcmFnZTogTm9kZVN0b3JhZ2U7XG4gICAgcHJpdmF0ZSBuZXR3b3JrQ2xpZW50OiBJTmV0d29ya01vZHVsZTtcbiAgICBwcml2YXRlIGNyeXB0b1Byb3ZpZGVyOiBDcnlwdG9Qcm92aWRlcjtcbiAgICBwcml2YXRlIGRpc2FibGVJbnRlcm5hbFJldHJpZXM6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgbG9nZ2VyOiBMb2dnZXIsXG4gICAgICAgIG5vZGVTdG9yYWdlOiBOb2RlU3RvcmFnZSxcbiAgICAgICAgbmV0d29ya0NsaWVudDogSU5ldHdvcmtNb2R1bGUsXG4gICAgICAgIGNyeXB0b1Byb3ZpZGVyOiBDcnlwdG9Qcm92aWRlcixcbiAgICAgICAgZGlzYWJsZUludGVybmFsUmV0cmllczogYm9vbGVhblxuICAgICkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5ub2RlU3RvcmFnZSA9IG5vZGVTdG9yYWdlO1xuICAgICAgICB0aGlzLm5ldHdvcmtDbGllbnQgPSBuZXR3b3JrQ2xpZW50O1xuICAgICAgICB0aGlzLmNyeXB0b1Byb3ZpZGVyID0gY3J5cHRvUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuZGlzYWJsZUludGVybmFsUmV0cmllcyA9IGRpc2FibGVJbnRlcm5hbFJldHJpZXM7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgY3JlYXRlUmVxdWVzdChcbiAgICAgICAgcmVxdWVzdDogc3RyaW5nLFxuICAgICAgICBtYW5hZ2VkSWRlbnRpdHlJZDogTWFuYWdlZElkZW50aXR5SWRcbiAgICApOiBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycztcblxuICAgIHB1YmxpYyBhc3luYyBnZXRTZXJ2ZXJUb2tlblJlc3BvbnNlQXN5bmMoXG4gICAgICAgIHJlc3BvbnNlOiBOZXR3b3JrUmVzcG9uc2U8TWFuYWdlZElkZW50aXR5VG9rZW5SZXNwb25zZT4sXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgX25ldHdvcmtDbGllbnQ6IElOZXR3b3JrTW9kdWxlLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIF9uZXR3b3JrUmVxdWVzdDogTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgX25ldHdvcmtSZXF1ZXN0T3B0aW9uczogTmV0d29ya1JlcXVlc3RPcHRpb25zXG4gICAgKTogUHJvbWlzZTxTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2ZXJUb2tlblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U2VydmVyVG9rZW5SZXNwb25zZShcbiAgICAgICAgcmVzcG9uc2U6IE5ldHdvcmtSZXNwb25zZTxNYW5hZ2VkSWRlbnRpdHlUb2tlblJlc3BvbnNlPlxuICAgICk6IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlIHtcbiAgICAgICAgbGV0IHJlZnJlc2hJbiwgZXhwaXJlc0luOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXNwb25zZS5ib2R5LmV4cGlyZXNfb24pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBleHBpcmVzX29uIGZpZWxkIGluIHRoZSByZXNwb25zZSBib2R5IGlzIGEgc3RyaW5nIGFuZCBpbiBJU08gODYwMSBmb3JtYXQsIGNvbnZlcnQgaXQgdG8gYSBVbml4IHRpbWVzdGFtcCAoc2Vjb25kcyBzaW5jZSBlcG9jaClcbiAgICAgICAgICAgIGlmIChpc0lzbzg2MDEocmVzcG9uc2UuYm9keS5leHBpcmVzX29uKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkuZXhwaXJlc19vbiA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKHJlc3BvbnNlLmJvZHkuZXhwaXJlc19vbikuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwaXJlc0luID0gcmVzcG9uc2UuYm9keS5leHBpcmVzX29uIC0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcblxuICAgICAgICAgICAgLy8gY29tcHV0ZSByZWZyZXNoX2luIGFzIDEvMiBvZiBleHBpcmVzX2luLCBidXQgb25seSBpZiBleHBpcmVzX2luID4gMmhcbiAgICAgICAgICAgIGlmIChleHBpcmVzSW4gPiAyICogMzYwMCkge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hJbiA9IGV4cGlyZXNJbiAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXJ2ZXJUb2tlblJlc3BvbnNlOiBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuXG4gICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHJlc3BvbnNlLmJvZHkuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0luLFxuICAgICAgICAgICAgc2NvcGU6IHJlc3BvbnNlLmJvZHkucmVzb3VyY2UsXG4gICAgICAgICAgICB0b2tlbl90eXBlOiByZXNwb25zZS5ib2R5LnRva2VuX3R5cGUsXG4gICAgICAgICAgICByZWZyZXNoX2luOiByZWZyZXNoSW4sXG5cbiAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICBjb3JyZWxhdGlvbl9pZDpcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5LmNvcnJlbGF0aW9uX2lkIHx8IHJlc3BvbnNlLmJvZHkuY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgIGVycm9yOlxuICAgICAgICAgICAgICAgIHR5cGVvZiByZXNwb25zZS5ib2R5LmVycm9yID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuYm9keS5lcnJvclxuICAgICAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLmJvZHkuZXJyb3I/LmNvZGUsXG4gICAgICAgICAgICBlcnJvcl9kZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5Lm1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIHJlc3BvbnNlLmJvZHkuZXJyb3IgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5ib2R5LmVycm9yX2Rlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIDogcmVzcG9uc2UuYm9keS5lcnJvcj8ubWVzc2FnZSksXG4gICAgICAgICAgICBlcnJvcl9jb2RlczogcmVzcG9uc2UuYm9keS5lcnJvcl9jb2RlcyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcmVzcG9uc2UuYm9keS50aW1lc3RhbXAsXG4gICAgICAgICAgICB0cmFjZV9pZDogcmVzcG9uc2UuYm9keS50cmFjZV9pZCxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VydmVyVG9rZW5SZXNwb25zZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgYWNxdWlyZVRva2VuV2l0aE1hbmFnZWRJZGVudGl0eShcbiAgICAgICAgbWFuYWdlZElkZW50aXR5UmVxdWVzdDogTWFuYWdlZElkZW50aXR5UmVxdWVzdCxcbiAgICAgICAgbWFuYWdlZElkZW50aXR5SWQ6IE1hbmFnZWRJZGVudGl0eUlkLFxuICAgICAgICBmYWtlQXV0aG9yaXR5OiBBdXRob3JpdHksXG4gICAgICAgIHJlZnJlc2hBY2Nlc3NUb2tlbj86IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPEF1dGhlbnRpY2F0aW9uUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtSZXF1ZXN0OiBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyA9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICAgICAgICAgICAgbWFuYWdlZElkZW50aXR5UmVxdWVzdC5yZXNvdXJjZSxcbiAgICAgICAgICAgICAgICBtYW5hZ2VkSWRlbnRpdHlJZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gbmV0d29ya1JlcXVlc3QuaGVhZGVycztcbiAgICAgICAgaGVhZGVyc1tIZWFkZXJOYW1lcy5DT05URU5UX1RZUEVdID0gQ29uc3RhbnRzLlVSTF9GT1JNX0NPTlRFTlRfVFlQRTtcblxuICAgICAgICBjb25zdCBuZXR3b3JrUmVxdWVzdE9wdGlvbnM6IE5ldHdvcmtSZXF1ZXN0T3B0aW9ucyA9IHsgaGVhZGVycyB9O1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXR3b3JrUmVxdWVzdC5ib2R5UGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXR3b3JrUmVxdWVzdE9wdGlvbnMuYm9keSA9XG4gICAgICAgICAgICAgICAgbmV0d29ya1JlcXVlc3QuY29tcHV0ZVBhcmFtZXRlcnNCb2R5U3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIG5ldHdvcmsgY2xpZW50IGhlbHBlciBiYXNlZCBvbiB0aGUgcmV0cnkgcG9saWN5IGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIElmIGludGVybmFsIHJldHJpZXMgYXJlIGRpc2FibGVkLCBpdCB1c2VzIHRoZSBwcm92aWRlZCBuZXR3b3JrIGNsaWVudCBkaXJlY3RseS5cbiAgICAgICAgICogT3RoZXJ3aXNlLCBpdCB3cmFwcyB0aGUgbmV0d29yayBjbGllbnQgd2l0aCBhbiBIVFRQIGNsaWVudCB0aGF0IHN1cHBvcnRzIHJldHJpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBuZXR3b3JrQ2xpZW50SGVscGVyOiBJTmV0d29ya01vZHVsZSA9IHRoaXMuZGlzYWJsZUludGVybmFsUmV0cmllc1xuICAgICAgICAgICAgPyB0aGlzLm5ldHdvcmtDbGllbnRcbiAgICAgICAgICAgIDogbmV3IEh0dHBDbGllbnRXaXRoUmV0cmllcyhcbiAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya0NsaWVudCxcbiAgICAgICAgICAgICAgICAgIG5ldHdvcmtSZXF1ZXN0LnJldHJ5UG9saWN5XG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVxVGltZXN0YW1wID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlOiBOZXR3b3JrUmVzcG9uc2U8TWFuYWdlZElkZW50aXR5VG9rZW5SZXNwb25zZT47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTb3VyY2VzIHRoYXQgc2VuZCBQT1NUIHJlcXVlc3RzOiBDbG91ZCBTaGVsbFxuICAgICAgICAgICAgaWYgKG5ldHdvcmtSZXF1ZXN0Lmh0dHBNZXRob2QgPT09IEh0dHBNZXRob2QuUE9TVCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV0d29ya0NsaWVudEhlbHBlci5zZW5kUG9zdFJlcXVlc3RBc3luYzxNYW5hZ2VkSWRlbnRpdHlUb2tlblJlc3BvbnNlPihcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtSZXF1ZXN0LmNvbXB1dGVVcmkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtSZXF1ZXN0T3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIFNvdXJjZXMgdGhhdCBzZW5kIEdFVCByZXF1ZXN0czogQXBwIFNlcnZpY2UsIEF6dXJlIEFyYywgSU1EUywgU2VydmljZSBGYWJyaWNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXR3b3JrQ2xpZW50SGVscGVyLnNlbmRHZXRSZXF1ZXN0QXN5bmM8TWFuYWdlZElkZW50aXR5VG9rZW5SZXNwb25zZT4oXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrUmVxdWVzdC5jb21wdXRlVXJpKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrUmVxdWVzdE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubmV0d29ya0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IG5ldyBSZXNwb25zZUhhbmRsZXIoXG4gICAgICAgICAgICBtYW5hZ2VkSWRlbnRpdHlJZC5pZCxcbiAgICAgICAgICAgIHRoaXMubm9kZVN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLmNyeXB0b1Byb3ZpZGVyLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHNlcnZlclRva2VuUmVzcG9uc2U6IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlID1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0U2VydmVyVG9rZW5SZXNwb25zZUFzeW5jKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtDbGllbnRIZWxwZXIsXG4gICAgICAgICAgICAgICAgbmV0d29ya1JlcXVlc3QsXG4gICAgICAgICAgICAgICAgbmV0d29ya1JlcXVlc3RPcHRpb25zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHJlc3BvbnNlSGFuZGxlci52YWxpZGF0ZVRva2VuUmVzcG9uc2UoXG4gICAgICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlLFxuICAgICAgICAgICAgcmVmcmVzaEFjY2Vzc1Rva2VuXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY2FjaGVzIHRoZSB0b2tlblxuICAgICAgICByZXR1cm4gcmVzcG9uc2VIYW5kbGVyLmhhbmRsZVNlcnZlclRva2VuUmVzcG9uc2UoXG4gICAgICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlLFxuICAgICAgICAgICAgZmFrZUF1dGhvcml0eSxcbiAgICAgICAgICAgIHJlcVRpbWVzdGFtcCxcbiAgICAgICAgICAgIG1hbmFnZWRJZGVudGl0eVJlcXVlc3RcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlcktleShcbiAgICAgICAgbWFuYWdlZElkZW50aXR5SWRUeXBlOiBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUsXG4gICAgICAgIGltZHM/OiBib29sZWFuXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoIChtYW5hZ2VkSWRlbnRpdHlJZFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWFuYWdlZElkZW50aXR5SWRUeXBlLlVTRVJfQVNTSUdORURfQ0xJRU5UX0lEOlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIFwiW01hbmFnZWQgSWRlbnRpdHldIEFkZGluZyB1c2VyIGFzc2lnbmVkIGNsaWVudCBpZCB0byB0aGUgcmVxdWVzdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hbmFnZWRJZGVudGl0eVVzZXJBc3NpZ25lZElkUXVlcnlQYXJhbWV0ZXJOYW1lcy5NQU5BR0VEX0lERU5USVRZX0NMSUVOVF9JRDtcblxuICAgICAgICAgICAgY2FzZSBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUuVVNFUl9BU1NJR05FRF9SRVNPVVJDRV9JRDpcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICBcIltNYW5hZ2VkIElkZW50aXR5XSBBZGRpbmcgdXNlciBhc3NpZ25lZCByZXNvdXJjZSBpZCB0byB0aGUgcmVxdWVzdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltZHNcbiAgICAgICAgICAgICAgICAgICAgPyBNYW5hZ2VkSWRlbnRpdHlVc2VyQXNzaWduZWRJZFF1ZXJ5UGFyYW1ldGVyTmFtZXMuTUFOQUdFRF9JREVOVElUWV9SRVNPVVJDRV9JRF9JTURTXG4gICAgICAgICAgICAgICAgICAgIDogTWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlck5hbWVzLk1BTkFHRURfSURFTlRJVFlfUkVTT1VSQ0VfSURfTk9OX0lNRFM7XG5cbiAgICAgICAgICAgIGNhc2UgTWFuYWdlZElkZW50aXR5SWRUeXBlLlVTRVJfQVNTSUdORURfT0JKRUNUX0lEOlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIFwiW01hbmFnZWQgSWRlbnRpdHldIEFkZGluZyB1c2VyIGFzc2lnbmVkIG9iamVjdCBpZCB0byB0aGUgcmVxdWVzdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hbmFnZWRJZGVudGl0eVVzZXJBc3NpZ25lZElkUXVlcnlQYXJhbWV0ZXJOYW1lcy5NQU5BR0VEX0lERU5USVRZX09CSkVDVF9JRDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIE1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuaW52YWxpZE1hbmFnZWRJZGVudGl0eUlkVHlwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldFZhbGlkYXRlZEVudlZhcmlhYmxlVXJsU3RyaW5nID0gKFxuICAgICAgICBlbnZWYXJpYWJsZVN0cmluZ05hbWU6IHN0cmluZyxcbiAgICAgICAgZW52VmFyaWFibGU6IHN0cmluZyxcbiAgICAgICAgc291cmNlTmFtZTogc3RyaW5nLFxuICAgICAgICBsb2dnZXI6IExvZ2dlclxuICAgICk6IHN0cmluZyA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFN0cmluZyhlbnZWYXJpYWJsZSkudXJsU3RyaW5nO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgYFtNYW5hZ2VkIElkZW50aXR5XSAke3NvdXJjZU5hbWV9IG1hbmFnZWQgaWRlbnRpdHkgaXMgdW5hdmFpbGFibGUgYmVjYXVzZSB0aGUgJyR7ZW52VmFyaWFibGVTdHJpbmdOYW1lfScgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWFsZm9ybWVkLmBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKFxuICAgICAgICAgICAgICAgIE1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXNcbiAgICAgICAgICAgICAgICAgICAgLk1zaUVudmlyb25tZW50VmFyaWFibGVVcmxNYWxmb3JtZWRFcnJvckNvZGVzW1xuICAgICAgICAgICAgICAgICAgICBlbnZWYXJpYWJsZVN0cmluZ05hbWVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBBdXRoRXJyb3IsXG4gICAgQ2xpZW50QXV0aEVycm9yQ29kZXMsXG4gICAgY3JlYXRlQ2xpZW50QXV0aEVycm9yLFxuICAgIEh0dHBTdGF0dXMsXG4gICAgSU5ldHdvcmtNb2R1bGUsXG4gICAgTmV0d29ya1Jlc3BvbnNlLFxuICAgIE5ldHdvcmtSZXF1ZXN0T3B0aW9ucyxcbiAgICBMb2dnZXIsXG4gICAgU2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2UsXG59IGZyb20gXCJAYXp1cmUvbXNhbC1jb21tb24vbm9kZVwiO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vLi4vY29uZmlnL01hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzLmpzXCI7XG5pbXBvcnQgeyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIH0gZnJvbSBcIi4vQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZS5qc1wiO1xuaW1wb3J0IHsgQ3J5cHRvUHJvdmlkZXIgfSBmcm9tIFwiLi4vLi4vY3J5cHRvL0NyeXB0b1Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQge1xuICAgIE1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMsXG4gICAgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IsXG59IGZyb20gXCIuLi8uLi9lcnJvci9NYW5hZ2VkSWRlbnRpdHlFcnJvci5qc1wiO1xuaW1wb3J0IHtcbiAgICBBUElfVkVSU0lPTl9RVUVSWV9QQVJBTUVURVJfTkFNRSxcbiAgICBBVVRIT1JJWkFUSU9OX0hFQURFUl9OQU1FLFxuICAgIEFaVVJFX0FSQ19TRUNSRVRfRklMRV9NQVhfU0laRV9CWVRFUyxcbiAgICBIdHRwTWV0aG9kLFxuICAgIE1FVEFEQVRBX0hFQURFUl9OQU1FLFxuICAgIE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcyxcbiAgICBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUsXG4gICAgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMsXG4gICAgUkVTT1VSQ0VfQk9EWV9PUl9RVUVSWV9QQVJBTUVURVJfTkFNRSxcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgTm9kZVN0b3JhZ2UgfSBmcm9tIFwiLi4vLi4vY2FjaGUvTm9kZVN0b3JhZ2UuanNcIjtcbmltcG9ydCB7XG4gICAgYWNjZXNzU3luYyxcbiAgICBjb25zdGFudHMgYXMgZnNDb25zdGFudHMsXG4gICAgcmVhZEZpbGVTeW5jLFxuICAgIHN0YXRTeW5jLFxufSBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eVRva2VuUmVzcG9uc2UgfSBmcm9tIFwiLi4vLi4vcmVzcG9uc2UvTWFuYWdlZElkZW50aXR5VG9rZW5SZXNwb25zZS5qc1wiO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5SWQgfSBmcm9tIFwiLi4vLi4vY29uZmlnL01hbmFnZWRJZGVudGl0eUlkLmpzXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY29uc3QgQVJDX0FQSV9WRVJTSU9OOiBzdHJpbmcgPSBcIjIwMTktMTEtMDFcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0FaVVJFX0FSQ19JREVOVElUWV9FTkRQT0lOVDogc3RyaW5nID1cbiAgICBcImh0dHA6Ly8xMjcuMC4wLjE6NDAzNDIvbWV0YWRhdGEvaWRlbnRpdHkvb2F1dGgyL3Rva2VuXCI7XG5jb25zdCBISU1EU19FWEVDVVRBQkxFX0hFTFBFUl9TVFJJTkcgPSBcIk4vQTogaGltZHMgZXhlY3V0YWJsZSBleGlzdHNcIjtcblxudHlwZSBGaWxlUGF0aE1hcCA9IHtcbiAgICB3aW4zMjogc3RyaW5nO1xuICAgIGxpbnV4OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0FaVVJFX0FSQ19QTEFURk9STVM6IEZpbGVQYXRoTWFwID0ge1xuICAgIHdpbjMyOiBgJHtwcm9jZXNzLmVudltcIlByb2dyYW1EYXRhXCJdfVxcXFxBenVyZUNvbm5lY3RlZE1hY2hpbmVBZ2VudFxcXFxUb2tlbnNcXFxcYCxcbiAgICBsaW51eDogXCIvdmFyL29wdC9hemNtYWdlbnQvdG9rZW5zL1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IEFaVVJFX0FSQ19GSUxFX0RFVEVDVElPTjogRmlsZVBhdGhNYXAgPSB7XG4gICAgd2luMzI6IGAke3Byb2Nlc3MuZW52W1wiUHJvZ3JhbUZpbGVzXCJdfVxcXFxBenVyZUNvbm5lY3RlZE1hY2hpbmVBZ2VudFxcXFxoaW1kcy5leGVgLFxuICAgIGxpbnV4OiBcIi9vcHQvYXpjbWFnZW50L2Jpbi9oaW1kc1wiLFxufTtcblxuLyoqXG4gKiBPcmlnaW5hbCBzb3VyY2Ugb2YgY29kZTogaHR0cHM6Ly9naXRodWIuY29tL0F6dXJlL2F6dXJlLXNkay1mb3ItbmV0L2Jsb2IvbWFpbi9zZGsvaWRlbnRpdHkvQXp1cmUuSWRlbnRpdHkvc3JjL0F6dXJlQXJjTWFuYWdlZElkZW50aXR5U291cmNlLmNzXG4gKi9cbmV4cG9ydCBjbGFzcyBBenVyZUFyYyBleHRlbmRzIEJhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2Uge1xuICAgIHByaXZhdGUgaWRlbnRpdHlFbmRwb2ludDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGxvZ2dlcjogTG9nZ2VyLFxuICAgICAgICBub2RlU3RvcmFnZTogTm9kZVN0b3JhZ2UsXG4gICAgICAgIG5ldHdvcmtDbGllbnQ6IElOZXR3b3JrTW9kdWxlLFxuICAgICAgICBjcnlwdG9Qcm92aWRlcjogQ3J5cHRvUHJvdmlkZXIsXG4gICAgICAgIGRpc2FibGVJbnRlcm5hbFJldHJpZXM6IGJvb2xlYW4sXG4gICAgICAgIGlkZW50aXR5RW5kcG9pbnQ6IHN0cmluZ1xuICAgICkge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICAgIG5vZGVTdG9yYWdlLFxuICAgICAgICAgICAgbmV0d29ya0NsaWVudCxcbiAgICAgICAgICAgIGNyeXB0b1Byb3ZpZGVyLFxuICAgICAgICAgICAgZGlzYWJsZUludGVybmFsUmV0cmllc1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuaWRlbnRpdHlFbmRwb2ludCA9IGlkZW50aXR5RW5kcG9pbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgbGV0IGlkZW50aXR5RW5kcG9pbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudltcbiAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfRU5EUE9JTlRcbiAgICAgICAgICAgIF07XG4gICAgICAgIGxldCBpbWRzRW5kcG9pbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudltNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSU1EU19FTkRQT0lOVF07XG5cbiAgICAgICAgLy8gaWYgZWl0aGVyIG9mIHRoZSBpZGVudGl0eSBvciBpbWRzIGVuZHBvaW50cyBhcmUgdW5kZWZpbmVkLCBjaGVjayBpZiB0aGUgaGltZHMgZXhlY3V0YWJsZSBleGlzdHNcbiAgICAgICAgaWYgKCFpZGVudGl0eUVuZHBvaW50IHx8ICFpbWRzRW5kcG9pbnQpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgZXhwZWN0ZWQgV2luZG93cyBvciBMaW51eCBmaWxlIHBhdGggb2YgdGhlIGhpbWRzIGV4ZWN1dGFibGVcbiAgICAgICAgICAgIGNvbnN0IGZpbGVEZXRlY3Rpb25QYXRoOiBzdHJpbmcgPVxuICAgICAgICAgICAgICAgIEFaVVJFX0FSQ19GSUxFX0RFVEVDVElPTltwcm9jZXNzLnBsYXRmb3JtIGFzIGtleW9mIEZpbGVQYXRoTWFwXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBjaGVjayBpZiB0aGUgaGltZHMgZXhlY3V0YWJsZSBleGlzdHMgYW5kIGl0cyBwZXJtaXNzaW9ucyBhbGxvdyBpdCB0byBiZSByZWFkXG4gICAgICAgICAgICAgICAgICogcmV0dXJucyB1bmRlZmluZWQgaWYgdHJ1ZSwgdGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFjY2Vzc1N5bmMoXG4gICAgICAgICAgICAgICAgICAgIGZpbGVEZXRlY3Rpb25QYXRoLFxuICAgICAgICAgICAgICAgICAgICBmc0NvbnN0YW50cy5GX09LIHwgZnNDb25zdGFudHMuUl9PS1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZGVudGl0eUVuZHBvaW50ID0gREVGQVVMVF9BWlVSRV9BUkNfSURFTlRJVFlfRU5EUE9JTlQ7XG4gICAgICAgICAgICAgICAgaW1kc0VuZHBvaW50ID0gSElNRFNfRVhFQ1VUQUJMRV9IRUxQRVJfU1RSSU5HO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICogYWNjZXNzU3luYyByZXR1cm5zIHVuZGVmaW5lZCBvbiBzdWNjZXNzLCBhbmQgdGhyb3dzIGFuIGVycm9yIG9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbaWRlbnRpdHlFbmRwb2ludCwgaW1kc0VuZHBvaW50XTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHRyeUNyZWF0ZShcbiAgICAgICAgbG9nZ2VyOiBMb2dnZXIsXG4gICAgICAgIG5vZGVTdG9yYWdlOiBOb2RlU3RvcmFnZSxcbiAgICAgICAgbmV0d29ya0NsaWVudDogSU5ldHdvcmtNb2R1bGUsXG4gICAgICAgIGNyeXB0b1Byb3ZpZGVyOiBDcnlwdG9Qcm92aWRlcixcbiAgICAgICAgZGlzYWJsZUludGVybmFsUmV0cmllczogYm9vbGVhbixcbiAgICAgICAgbWFuYWdlZElkZW50aXR5SWQ6IE1hbmFnZWRJZGVudGl0eUlkXG4gICAgKTogQXp1cmVBcmMgfCBudWxsIHtcbiAgICAgICAgY29uc3QgW2lkZW50aXR5RW5kcG9pbnQsIGltZHNFbmRwb2ludF0gPVxuICAgICAgICAgICAgQXp1cmVBcmMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKTtcblxuICAgICAgICAvLyBpZiBlaXRoZXIgb2YgdGhlIGlkZW50aXR5IG9yIGltZHMgZW5kcG9pbnRzIGFyZSB1bmRlZmluZWQgKGV2ZW4gYWZ0ZXIgaGltZHMgZmlsZSBkZXRlY3Rpb24pXG4gICAgICAgIGlmICghaWRlbnRpdHlFbmRwb2ludCB8fCAhaW1kc0VuZHBvaW50KSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBgW01hbmFnZWQgSWRlbnRpdHldICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDfSBtYW5hZ2VkIGlkZW50aXR5IGlzIHVuYXZhaWxhYmxlIHRocm91Z2ggZW52aXJvbm1lbnQgdmFyaWFibGVzIGJlY2F1c2Ugb25lIG9yIGJvdGggb2YgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklERU5USVRZX0VORFBPSU5UfScgYW5kICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JTURTX0VORFBPSU5UfScgYXJlIG5vdCBkZWZpbmVkLiAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQ30gbWFuYWdlZCBpZGVudGl0eSBpcyBhbHNvIHVuYXZhaWxhYmxlIHRocm91Z2ggZmlsZSBkZXRlY3Rpb24uYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgaW1kcyBlbmRwb2ludCBpcyBzZXQgdG8gdGhlIGRlZmF1bHQgZm9yIGZpbGUgZGV0ZWN0aW9uXG4gICAgICAgIGlmIChpbWRzRW5kcG9pbnQgPT09IEhJTURTX0VYRUNVVEFCTEVfSEVMUEVSX1NUUklORykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgYFtNYW5hZ2VkIElkZW50aXR5XSAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQ30gbWFuYWdlZCBpZGVudGl0eSBpcyBhdmFpbGFibGUgdGhyb3VnaCBmaWxlIGRldGVjdGlvbi4gRGVmYXVsdGluZyB0byBrbm93biAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQ30gZW5kcG9pbnQ6ICR7REVGQVVMVF9BWlVSRV9BUkNfSURFTlRJVFlfRU5EUE9JTlR9LiBDcmVhdGluZyAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQ30gbWFuYWdlZCBpZGVudGl0eS5gXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBib3RoIHRoZSBpZGVudGl0eSBhbmQgaW1kcyBlbmRwb2ludHMgYXJlIGRlZmluZWQgd2l0aG91dCBmaWxlIGRldGVjdGlvbjsgdmFsaWRhdGUgdGhlbVxuXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50OiBzdHJpbmcgPVxuICAgICAgICAgICAgICAgIEF6dXJlQXJjLmdldFZhbGlkYXRlZEVudlZhcmlhYmxlVXJsU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfRU5EUE9JTlQsXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5RW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQyxcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICAgICAgdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludC5lbmRzV2l0aChcIi9cIilcbiAgICAgICAgICAgICAgICA/IHZhbGlkYXRlZElkZW50aXR5RW5kcG9pbnQuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgOiB2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50O1xuXG4gICAgICAgICAgICBBenVyZUFyYy5nZXRWYWxpZGF0ZWRFbnZWYXJpYWJsZVVybFN0cmluZyhcbiAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSU1EU19FTkRQT0lOVCxcbiAgICAgICAgICAgICAgICBpbWRzRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDLFxuICAgICAgICAgICAgICAgIGxvZ2dlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgYFtNYW5hZ2VkIElkZW50aXR5XSBFbnZpcm9ubWVudCB2YXJpYWJsZXMgdmFsaWRhdGlvbiBwYXNzZWQgZm9yICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDfSBtYW5hZ2VkIGlkZW50aXR5LiBFbmRwb2ludCBVUkk6ICR7dmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludH0uIENyZWF0aW5nICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDfSBtYW5hZ2VkIGlkZW50aXR5LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBtYW5hZ2VkSWRlbnRpdHlJZC5pZFR5cGUgIT09IE1hbmFnZWRJZGVudGl0eUlkVHlwZS5TWVNURU1fQVNTSUdORURcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvcihcbiAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnVuYWJsZVRvQ3JlYXRlQXp1cmVBcmNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEF6dXJlQXJjKFxuICAgICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgICAgbm9kZVN0b3JhZ2UsXG4gICAgICAgICAgICBuZXR3b3JrQ2xpZW50LFxuICAgICAgICAgICAgY3J5cHRvUHJvdmlkZXIsXG4gICAgICAgICAgICBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzLFxuICAgICAgICAgICAgaWRlbnRpdHlFbmRwb2ludFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVSZXF1ZXN0KHJlc291cmNlOiBzdHJpbmcpOiBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3Q6IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzID1cbiAgICAgICAgICAgIG5ldyBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyhcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kLkdFVCxcbiAgICAgICAgICAgICAgICB0aGlzLmlkZW50aXR5RW5kcG9pbnQucmVwbGFjZShcImxvY2FsaG9zdFwiLCBcIjEyNy4wLjAuMVwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbTUVUQURBVEFfSEVBREVSX05BTUVdID0gXCJ0cnVlXCI7XG5cbiAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbQVBJX1ZFUlNJT05fUVVFUllfUEFSQU1FVEVSX05BTUVdID1cbiAgICAgICAgICAgIEFSQ19BUElfVkVSU0lPTjtcbiAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbUkVTT1VSQ0VfQk9EWV9PUl9RVUVSWV9QQVJBTUVURVJfTkFNRV0gPVxuICAgICAgICAgICAgcmVzb3VyY2U7XG5cbiAgICAgICAgLy8gYm9keVBhcmFtZXRlcnMgY2FsY3VsYXRlZCBpbiBCYXNlTWFuYWdlZElkZW50aXR5LmFjcXVpcmVUb2tlbldpdGhNYW5hZ2VkSWRlbnRpdHlcblxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2VydmVyVG9rZW5SZXNwb25zZUFzeW5jKFxuICAgICAgICBvcmlnaW5hbFJlc3BvbnNlOiBOZXR3b3JrUmVzcG9uc2U8TWFuYWdlZElkZW50aXR5VG9rZW5SZXNwb25zZT4sXG4gICAgICAgIG5ldHdvcmtDbGllbnQ6IElOZXR3b3JrTW9kdWxlLFxuICAgICAgICBuZXR3b3JrUmVxdWVzdDogTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMsXG4gICAgICAgIG5ldHdvcmtSZXF1ZXN0T3B0aW9uczogTmV0d29ya1JlcXVlc3RPcHRpb25zXG4gICAgKTogUHJvbWlzZTxTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZT4ge1xuICAgICAgICBsZXQgcmV0cnlSZXNwb25zZTpcbiAgICAgICAgICAgIHwgTmV0d29ya1Jlc3BvbnNlPE1hbmFnZWRJZGVudGl0eVRva2VuUmVzcG9uc2U+XG4gICAgICAgICAgICB8IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAob3JpZ2luYWxSZXNwb25zZS5zdGF0dXMgPT09IEh0dHBTdGF0dXMuVU5BVVRIT1JJWkVEKSB7XG4gICAgICAgICAgICBjb25zdCB3d3dBdXRoSGVhZGVyOiBzdHJpbmcgPVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVzcG9uc2UuaGVhZGVyc1tcInd3dy1hdXRoZW50aWNhdGVcIl07XG4gICAgICAgICAgICBpZiAoIXd3d0F1dGhIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy53d3dBdXRoZW50aWNhdGVIZWFkZXJNaXNzaW5nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghd3d3QXV0aEhlYWRlci5pbmNsdWRlcyhcIkJhc2ljIHJlYWxtPVwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnd3d0F1dGhlbnRpY2F0ZUhlYWRlclVuc3VwcG9ydGVkRm9ybWF0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2VjcmV0RmlsZVBhdGggPSB3d3dBdXRoSGVhZGVyLnNwbGl0KFwiQmFzaWMgcmVhbG09XCIpWzFdO1xuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBpZiB0aGUgbWFuYWdlZCBpZGVudGl0eSBhcHBsaWNhdGlvbiBpcyBub3QgYmVpbmcgcnVuIG9uIFdpbmRvd3Mgb3IgTGludXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhU1VQUE9SVEVEX0FaVVJFX0FSQ19QTEFURk9STVMuaGFzT3duUHJvcGVydHkocHJvY2Vzcy5wbGF0Zm9ybSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnBsYXRmb3JtTm90U3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBleHBlY3RlZCBXaW5kb3dzIG9yIExpbnV4IGZpbGUgcGF0aFxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTZWNyZXRGaWxlUGF0aDogc3RyaW5nID1cbiAgICAgICAgICAgICAgICBTVVBQT1JURURfQVpVUkVfQVJDX1BMQVRGT1JNU1tcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybSBhcyBrZXlvZiBGaWxlUGF0aE1hcFxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIGluIHRoZSBmaWxlIHBhdGggaXMgbm90IGEgLmtleSBmaWxlXG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZTogc3RyaW5nID0gcGF0aC5iYXNlbmFtZShzZWNyZXRGaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIWZpbGVOYW1lLmVuZHNXaXRoKFwiLmtleVwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLmludmFsaWRGaWxlRXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIHBhdGggZnJvbSB0aGUgd3d3LWF1dGhlbnRpY2F0ZSBoZWFkZXIgZG9lcyBub3QgbWF0Y2ggdGhlXG4gICAgICAgICAgICAgKiBleHBlY3RlZCBmaWxlIHBhdGggZm9yIHRoZSBwbGF0Zm9ybSAoV2luZG93cyBvciBMaW51eCkgdGhlIG1hbmFnZWQgaWRlbnRpdHkgYXBwbGljYXRpb25cbiAgICAgICAgICAgICAqIGlzIHJ1bm5pbmcgb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkU2VjcmV0RmlsZVBhdGggKyBmaWxlTmFtZSAhPT0gc2VjcmV0RmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5pbnZhbGlkRmlsZVBhdGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc2VjcmV0RmlsZVNpemU7XG4gICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGdldCB0aGUgc2VjcmV0IGZpbGUncyBzaXplLCBpbiBieXRlc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWNyZXRGaWxlU2l6ZSA9IGF3YWl0IHN0YXRTeW5jKHNlY3JldEZpbGVQYXRoKS5zaXplO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnVuYWJsZVRvUmVhZFNlY3JldEZpbGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNlY3JldCBmaWxlJ3Mgc2l6ZSBpcyBncmVhdGVyIHRoYW4gNDA5NiBieXRlc1xuICAgICAgICAgICAgaWYgKHNlY3JldEZpbGVTaXplID4gQVpVUkVfQVJDX1NFQ1JFVF9GSUxFX01BWF9TSVpFX0JZVEVTKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIE1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuaW52YWxpZFNlY3JldFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCB0aGUgY29udGVudHMgb2YgdGhlIHNlY3JldCBmaWxlXG4gICAgICAgICAgICBsZXQgc2VjcmV0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWNyZXQgPSByZWFkRmlsZVN5bmMoc2VjcmV0RmlsZVBhdGgsIFwidXRmLThcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIE1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMudW5hYmxlVG9SZWFkU2VjcmV0RmlsZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRoSGVhZGVyVmFsdWUgPSBgQmFzaWMgJHtzZWNyZXR9YDtcblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBgW01hbmFnZWQgSWRlbnRpdHldIEFkZGluZyBhdXRob3JpemF0aW9uIGhlYWRlciB0byB0aGUgcmVxdWVzdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV0d29ya1JlcXVlc3QuaGVhZGVyc1tBVVRIT1JJWkFUSU9OX0hFQURFUl9OQU1FXSA9IGF1dGhIZWFkZXJWYWx1ZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXRyeVJlc3BvbnNlID1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV0d29ya0NsaWVudC5zZW5kR2V0UmVxdWVzdEFzeW5jPE1hbmFnZWRJZGVudGl0eVRva2VuUmVzcG9uc2U+KFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya1JlcXVlc3QuY29tcHV0ZVVyaSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya1JlcXVlc3RPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JDb2Rlcy5uZXR3b3JrRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2ZXJUb2tlblJlc3BvbnNlKHJldHJ5UmVzcG9uc2UgfHwgb3JpZ2luYWxSZXNwb25zZSk7XG4gICAgfVxufVxuIiwgIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJTmV0d29ya01vZHVsZSwgTG9nZ2VyIH0gZnJvbSBcIkBhenVyZS9tc2FsLWNvbW1vbi9ub2RlXCI7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlJZCB9IGZyb20gXCIuLi8uLi9jb25maWcvTWFuYWdlZElkZW50aXR5SWQuanNcIjtcbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uLy4uL2NvbmZpZy9NYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycy5qc1wiO1xuaW1wb3J0IHsgQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZSB9IGZyb20gXCIuL0Jhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2UuanNcIjtcbmltcG9ydCB7IENyeXB0b1Byb3ZpZGVyIH0gZnJvbSBcIi4uLy4uL2NyeXB0by9DcnlwdG9Qcm92aWRlci5qc1wiO1xuaW1wb3J0IHtcbiAgICBBUElfVkVSU0lPTl9RVUVSWV9QQVJBTUVURVJfTkFNRSxcbiAgICBIdHRwTWV0aG9kLFxuICAgIE1FVEFEQVRBX0hFQURFUl9OQU1FLFxuICAgIE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcyxcbiAgICBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUsXG4gICAgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMsXG4gICAgUkVTT1VSQ0VfQk9EWV9PUl9RVUVSWV9QQVJBTUVURVJfTkFNRSxcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgTm9kZVN0b3JhZ2UgfSBmcm9tIFwiLi4vLi4vY2FjaGUvTm9kZVN0b3JhZ2UuanNcIjtcblxuLy8gSU1EUyBjb25zdGFudHMuIERvY3MgZm9yIElNRFMgYXJlIGF2YWlsYWJsZSBoZXJlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2F6dXJlL2FjdGl2ZS1kaXJlY3RvcnkvbWFuYWdlZC1pZGVudGl0aWVzLWF6dXJlLXJlc291cmNlcy9ob3ctdG8tdXNlLXZtLXRva2VuI2dldC1hLXRva2VuLXVzaW5nLWh0dHBcbmNvbnN0IElNRFNfVE9LRU5fUEFUSDogc3RyaW5nID0gXCIvbWV0YWRhdGEvaWRlbnRpdHkvb2F1dGgyL3Rva2VuXCI7XG5jb25zdCBERUZBVUxUX0lNRFNfRU5EUE9JTlQ6IHN0cmluZyA9IGBodHRwOi8vMTY5LjI1NC4xNjkuMjU0JHtJTURTX1RPS0VOX1BBVEh9YDtcblxuY29uc3QgSU1EU19BUElfVkVSU0lPTjogc3RyaW5nID0gXCIyMDE4LTAyLTAxXCI7XG5cbi8vIE9yaWdpbmFsIHNvdXJjZSBvZiBjb2RlOiBodHRwczovL2dpdGh1Yi5jb20vQXp1cmUvYXp1cmUtc2RrLWZvci1uZXQvYmxvYi9tYWluL3Nkay9pZGVudGl0eS9BenVyZS5JZGVudGl0eS9zcmMvSW1kc01hbmFnZWRJZGVudGl0eVNvdXJjZS5jc1xuZXhwb3J0IGNsYXNzIEltZHMgZXh0ZW5kcyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIHtcbiAgICBwcml2YXRlIGlkZW50aXR5RW5kcG9pbnQ6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICAgICAgbm9kZVN0b3JhZ2U6IE5vZGVTdG9yYWdlLFxuICAgICAgICBuZXR3b3JrQ2xpZW50OiBJTmV0d29ya01vZHVsZSxcbiAgICAgICAgY3J5cHRvUHJvdmlkZXI6IENyeXB0b1Byb3ZpZGVyLFxuICAgICAgICBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzOiBib29sZWFuLFxuICAgICAgICBpZGVudGl0eUVuZHBvaW50OiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgc3VwZXIoXG4gICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgICBub2RlU3RvcmFnZSxcbiAgICAgICAgICAgIG5ldHdvcmtDbGllbnQsXG4gICAgICAgICAgICBjcnlwdG9Qcm92aWRlcixcbiAgICAgICAgICAgIGRpc2FibGVJbnRlcm5hbFJldHJpZXNcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmlkZW50aXR5RW5kcG9pbnQgPSBpZGVudGl0eUVuZHBvaW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgdHJ5Q3JlYXRlKFxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICAgICAgbm9kZVN0b3JhZ2U6IE5vZGVTdG9yYWdlLFxuICAgICAgICBuZXR3b3JrQ2xpZW50OiBJTmV0d29ya01vZHVsZSxcbiAgICAgICAgY3J5cHRvUHJvdmlkZXI6IENyeXB0b1Byb3ZpZGVyLFxuICAgICAgICBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzOiBib29sZWFuXG4gICAgKTogSW1kcyB7XG4gICAgICAgIGxldCB2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50OiBzdHJpbmc7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbXG4gICAgICAgICAgICAgICAgTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzXG4gICAgICAgICAgICAgICAgICAgIC5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICBgW01hbmFnZWQgSWRlbnRpdHldIEVudmlyb25tZW50IHZhcmlhYmxlICR7XG4gICAgICAgICAgICAgICAgICAgIE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RcbiAgICAgICAgICAgICAgICB9IGZvciAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLklNRFN9IHJldHVybmVkIGVuZHBvaW50OiAke1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudltcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludCA9IEltZHMuZ2V0VmFsaWRhdGVkRW52VmFyaWFibGVVcmxTdHJpbmcoXG4gICAgICAgICAgICAgICAgTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLkFaVVJFX1BPRF9JREVOVElUWV9BVVRIT1JJVFlfSE9TVCxcbiAgICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnZbXG4gICAgICAgICAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NUXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9JHtJTURTX1RPS0VOX1BBVEh9YCxcbiAgICAgICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5JTURTLFxuICAgICAgICAgICAgICAgIGxvZ2dlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgIGBbTWFuYWdlZCBJZGVudGl0eV0gVW5hYmxlIHRvIGZpbmQgJHtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NUfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5JTURTfSwgdXNpbmcgdGhlIGRlZmF1bHQgZW5kcG9pbnQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhbGlkYXRlZElkZW50aXR5RW5kcG9pbnQgPSBERUZBVUxUX0lNRFNfRU5EUE9JTlQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEltZHMoXG4gICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgICBub2RlU3RvcmFnZSxcbiAgICAgICAgICAgIG5ldHdvcmtDbGllbnQsXG4gICAgICAgICAgICBjcnlwdG9Qcm92aWRlcixcbiAgICAgICAgICAgIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsXG4gICAgICAgICAgICB2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZVJlcXVlc3QoXG4gICAgICAgIHJlc291cmNlOiBzdHJpbmcsXG4gICAgICAgIG1hbmFnZWRJZGVudGl0eUlkOiBNYW5hZ2VkSWRlbnRpdHlJZFxuICAgICk6IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdDogTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgPVxuICAgICAgICAgICAgbmV3IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgIEh0dHBNZXRob2QuR0VULFxuICAgICAgICAgICAgICAgIHRoaXMuaWRlbnRpdHlFbmRwb2ludFxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbTUVUQURBVEFfSEVBREVSX05BTUVdID0gXCJ0cnVlXCI7XG5cbiAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbQVBJX1ZFUlNJT05fUVVFUllfUEFSQU1FVEVSX05BTUVdID1cbiAgICAgICAgICAgIElNRFNfQVBJX1ZFUlNJT047XG4gICAgICAgIHJlcXVlc3QucXVlcnlQYXJhbWV0ZXJzW1JFU09VUkNFX0JPRFlfT1JfUVVFUllfUEFSQU1FVEVSX05BTUVdID1cbiAgICAgICAgICAgIHJlc291cmNlO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1hbmFnZWRJZGVudGl0eUlkLmlkVHlwZSAhPT0gTWFuYWdlZElkZW50aXR5SWRUeXBlLlNZU1RFTV9BU1NJR05FRFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJlcXVlc3QucXVlcnlQYXJhbWV0ZXJzW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlcktleShcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlZElkZW50aXR5SWQuaWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICB0cnVlIC8vIGluZGljYXRlcyBzb3VyY2UgaXMgSU1EU1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0gPSBtYW5hZ2VkSWRlbnRpdHlJZC5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJvZHlQYXJhbWV0ZXJzIGNhbGN1bGF0ZWQgaW4gQmFzZU1hbmFnZWRJZGVudGl0eS5hY3F1aXJlVG9rZW5XaXRoTWFuYWdlZElkZW50aXR5XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufVxuIiwgIi8vIHNyYy9hdXRoLnRzXG5pbXBvcnQgeyBDb25maWRlbnRpYWxDbGllbnRBcHBsaWNhdGlvbiwgQ29uZmlndXJhdGlvbiB9IGZyb20gXCJAYXp1cmUvbXNhbC1ub2RlXCI7XG5pbXBvcnQgeyBCcm93c2VyV2luZG93IH0gZnJvbSBcIkBlbGVjdHJvbi9yZW1vdGVcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuXG5jb25zdCBBVVRIT1JJVFkgPSBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb25zdW1lcnNcIjtcbmNvbnN0IFJFRElSRUNUX1VSSSA9IFwiaHR0cDovL2xvY2FsaG9zdDo1MDAwXCI7IC8vIE11c3QgbWF0Y2ggeW91ciBBenVyZSByZWdpc3RyYXRpb25cbmNvbnN0IFNDT1BFUyA9IFtcIlRhc2tzLlJlYWRXcml0ZVwiLCBcIm9mZmxpbmVfYWNjZXNzXCJdO1xuXG4vKipcbiAqIEF1dGhNYW5hZ2VyIGhhbmRsZXMgYXV0aGVudGljYXRpb24sIHRva2VuIGNhY2hpbmcsIGFuZCB0b2tlbiByZWZyZXNoaW5nIHVzaW5nIE1TQUwuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoTWFuYWdlciB7XG5cdGNjYTogQ29uZmlkZW50aWFsQ2xpZW50QXBwbGljYXRpb247XG5cdHRva2VuRmlsZVBhdGg6IHN0cmluZztcblx0Y2xpZW50SWQ6IHN0cmluZztcblx0Y2xpZW50U2VjcmV0OiBzdHJpbmc7XG5cdHJlZGlyZWN0VXJsOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQXV0aE1hbmFnZXIuXG5cdCAqIEBwYXJhbSBjbGllbnRJZCAtIFRoZSBjbGllbnQgSUQgb2YgeW91ciBBenVyZSBBRCBhcHBsaWNhdGlvbi5cblx0ICogQHBhcmFtIGNsaWVudFNlY3JldCAtIFRoZSBjbGllbnQgc2VjcmV0IG9mIHlvdXIgQXp1cmUgQUQgYXBwbGljYXRpb24uXG5cdCAqIEBwYXJhbSByZWRpcmVjdFVybCAtIFRoZSByZWRpcmVjdCBVUkwgcmVnaXN0ZXJlZCBpbiB5b3VyIEF6dXJlIEFEIGFwcC5cblx0ICogQHBhcmFtIHRva2VuRmlsZVBhdGggLSBQYXRoIHRvIHRoZSBmaWxlIHdoZXJlIHRoZSB0b2tlbiBjYWNoZSB3aWxsIGJlIHN0b3JlZC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGNsaWVudElkOiBzdHJpbmcsXG5cdFx0Y2xpZW50U2VjcmV0OiBzdHJpbmcsXG5cdFx0cmVkaXJlY3RVcmw6IHN0cmluZyxcblx0XHR0b2tlbkZpbGVQYXRoOiBzdHJpbmcsXG5cdCkge1xuXHRcdHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcblx0XHR0aGlzLmNsaWVudFNlY3JldCA9IGNsaWVudFNlY3JldDtcblx0XHR0aGlzLnJlZGlyZWN0VXJsID0gcmVkaXJlY3RVcmw7XG5cdFx0dGhpcy50b2tlbkZpbGVQYXRoID0gdG9rZW5GaWxlUGF0aDtcblx0XHR0aGlzLmluaXRDbGllbnQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgTVNBTCBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cblx0ICovXG5cdGluaXRDbGllbnQoKTogdm9pZCB7XG5cdFx0Y29uc3QgY29uZmlnOiBDb25maWd1cmF0aW9uID0ge1xuXHRcdFx0YXV0aDoge1xuXHRcdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcblx0XHRcdFx0YXV0aG9yaXR5OiBBVVRIT1JJVFksXG5cdFx0XHRcdGNsaWVudFNlY3JldDogdGhpcy5jbGllbnRTZWNyZXQsXG5cdFx0XHR9LFxuXHRcdH07XG5cdFx0dGhpcy5jY2EgPSBuZXcgQ29uZmlkZW50aWFsQ2xpZW50QXBwbGljYXRpb24oY29uZmlnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTYXZlcyB0aGUgY3VycmVudCB0b2tlbiBjYWNoZSB0byBkaXNrLlxuXHQgKi9cblx0c2F2ZVRva2VuQ2FjaGUoKTogdm9pZCB7XG5cdFx0Y29uc3QgdG9rZW5DYWNoZVNlcmlhbGl6ZWQgPSB0aGlzLmNjYS5nZXRUb2tlbkNhY2hlKCkuc2VyaWFsaXplKCk7XG5cdFx0ZnMud3JpdGVGaWxlU3luYyh0aGlzLnRva2VuRmlsZVBhdGgsIHRva2VuQ2FjaGVTZXJpYWxpemVkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhbiBpbnRlcmFjdGl2ZSBsb2dpbiB0byBhY3F1aXJlIGFuIGFjY2VzcyB0b2tlbi5cblx0ICogT3BlbnMgYSBCcm93c2VyV2luZG93IHRvIGxldCB0aGUgdXNlciBzaWduIGluLlxuXHQgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgdmFsaWQgYWNjZXNzIHRva2VuLlxuXHQgKi9cblx0YXN5bmMgZ2V0QWNjZXNzVG9rZW4oKTogUHJvbWlzZTx7IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfT4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRjb25zdCBhdXRoVXJsID1cblx0XHRcdFx0YCR7QVVUSE9SSVRZfS9vYXV0aDIvdjIuMC9hdXRob3JpemU/Y2xpZW50X2lkPSR7dGhpcy5jbGllbnRJZH1gICtcblx0XHRcdFx0YCZyZXNwb25zZV90eXBlPWNvZGVgICtcblx0XHRcdFx0YCZyZWRpcmVjdF91cmk9JHtlbmNvZGVVUklDb21wb25lbnQoUkVESVJFQ1RfVVJJKX1gICtcblx0XHRcdFx0YCZyZXNwb25zZV9tb2RlPXF1ZXJ5YCArXG5cdFx0XHRcdGAmc2NvcGU9JHtlbmNvZGVVUklDb21wb25lbnQoU0NPUEVTLmpvaW4oXCIgXCIpKX1gICtcblx0XHRcdFx0YCZwcm9tcHQ9Y29uc2VudGA7XG5cblx0XHRcdGNvbnN0IGF1dGhXaW5kb3cgPSBuZXcgQnJvd3NlcldpbmRvdyh7XG5cdFx0XHRcdHdpZHRoOiA2MDAsXG5cdFx0XHRcdGhlaWdodDogNzAwLFxuXHRcdFx0XHR3ZWJQcmVmZXJlbmNlczoge1xuXHRcdFx0XHRcdG5vZGVJbnRlZ3JhdGlvbjogZmFsc2UsXG5cdFx0XHRcdFx0Y29udGV4dElzb2xhdGlvbjogdHJ1ZSxcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHRhdXRoV2luZG93LmxvYWRVUkwoYXV0aFVybCk7XG5cblx0XHRcdGF1dGhXaW5kb3cud2ViQ29udGVudHMub24oXCJ3aWxsLXJlZGlyZWN0XCIsIGFzeW5jIChldmVudCwgdXJsKSA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVkaXJlY3RVUkwgPSBuZXcgVVJMKHVybCk7XG5cdFx0XHRcdFx0Y29uc3QgZXJyb3IgPSByZWRpcmVjdFVSTC5zZWFyY2hQYXJhbXMuZ2V0KFwiZXJyb3JcIik7XG5cdFx0XHRcdFx0aWYgKGVycm9yKSB0aHJvdyBuZXcgRXJyb3IoXCJPQXV0aCBlcnJvcjogXCIgKyBlcnJvcik7XG5cblx0XHRcdFx0XHRjb25zdCBhdXRoQ29kZSA9IHJlZGlyZWN0VVJMLnNlYXJjaFBhcmFtcy5nZXQoXCJjb2RlXCIpO1xuXHRcdFx0XHRcdGlmICghYXV0aENvZGUpIHJldHVybjsgLy8gSWYgbm8gYXV0aCBjb2RlLCBleGl0IGVhcmx5LlxuXG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRhdXRoV2luZG93LmNsb3NlKCk7XG5cblx0XHRcdFx0XHRjb25zdCB0b2tlblJlcXVlc3QgPSB7XG5cdFx0XHRcdFx0XHRjb2RlOiBhdXRoQ29kZSxcblx0XHRcdFx0XHRcdHNjb3BlczogU0NPUEVTLFxuXHRcdFx0XHRcdFx0cmVkaXJlY3RVcmk6IFJFRElSRUNUX1VSSSxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGNvbnN0IHRva2VuUmVzcG9uc2UgPVxuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5jY2EuYWNxdWlyZVRva2VuQnlDb2RlKHRva2VuUmVxdWVzdCk7XG5cdFx0XHRcdFx0aWYgKCF0b2tlblJlc3BvbnNlKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gdG9rZW4gcmVzcG9uc2UgcmVjZWl2ZWQuXCIpO1xuXHRcdFx0XHRcdHRoaXMuc2F2ZVRva2VuQ2FjaGUoKTtcblx0XHRcdFx0XHRyZXNvbHZlKHsgYWNjZXNzVG9rZW46IHRva2VuUmVzcG9uc2UuYWNjZXNzVG9rZW4gfSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGlmICghYXV0aFdpbmRvdy5pc0Rlc3Ryb3llZCgpKSBhdXRoV2luZG93LmNsb3NlKCk7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuIHVzaW5nIHRoZSByZWZyZXNoIHRva2VuIHN0b3JlZCBpbiB0aGUgdG9rZW4gY2FjaGUuXG5cdCAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBuZXcgYWNjZXNzIHRva2VuLlxuXHQgKi9cblx0YXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuV2l0aENDQSgpOiBQcm9taXNlPHsgYWNjZXNzVG9rZW46IHN0cmluZyB9PiB7XG5cdFx0aWYgKCFmcy5leGlzdHNTeW5jKHRoaXMudG9rZW5GaWxlUGF0aCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk5vIHRva2VuIGNhY2hlIGZvdW5kLiBQbGVhc2UgbG9naW4gZmlyc3QuXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNhY2hlRGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLnRva2VuRmlsZVBhdGgsIFwidXRmOFwiKTtcblx0XHR0aGlzLmNjYS5nZXRUb2tlbkNhY2hlKCkuZGVzZXJpYWxpemUoY2FjaGVEYXRhKTtcblxuXHRcdGNvbnN0IHRva2VuQ2FjaGVTZXJpYWxpemVkID0gdGhpcy5jY2EuZ2V0VG9rZW5DYWNoZSgpLnNlcmlhbGl6ZSgpO1xuXHRcdGNvbnN0IHBhcnNlZENhY2hlID0gSlNPTi5wYXJzZSh0b2tlbkNhY2hlU2VyaWFsaXplZCk7XG5cdFx0aWYgKCFwYXJzZWRDYWNoZS5SZWZyZXNoVG9rZW4pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk5vIHJlZnJlc2ggdG9rZW4gZm91bmQgaW4gdGhlIGNhY2hlLlwiKTtcblx0XHR9XG5cdFx0Y29uc3QgcmVmcmVzaFRva2VuT2JqZWN0ID0gcGFyc2VkQ2FjaGUuUmVmcmVzaFRva2VuO1xuXHRcdGNvbnN0IHJlZnJlc2hUb2tlbktleSA9IE9iamVjdC5rZXlzKHJlZnJlc2hUb2tlbk9iamVjdClbMF07XG5cdFx0Y29uc3QgcmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuT2JqZWN0W3JlZnJlc2hUb2tlbktleV0uc2VjcmV0O1xuXG5cdFx0Y29uc3QgdG9rZW5SZXF1ZXN0ID0ge1xuXHRcdFx0cmVmcmVzaFRva2VuOiByZWZyZXNoVG9rZW4sXG5cdFx0XHRzY29wZXM6IFNDT1BFUyxcblx0XHRcdHJlZGlyZWN0VXJpOiBSRURJUkVDVF9VUkksXG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB0b2tlblJlc3BvbnNlID1cblx0XHRcdFx0YXdhaXQgdGhpcy5jY2EuYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW4odG9rZW5SZXF1ZXN0KTtcblx0XHRcdGlmICghdG9rZW5SZXNwb25zZSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gdG9rZW4gcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSByZWZyZXNoLlwiKTtcblx0XHRcdHRoaXMuc2F2ZVRva2VuQ2FjaGUoKTtcblx0XHRcdHJldHVybiB7IGFjY2Vzc1Rva2VuOiB0b2tlblJlc3BvbnNlLmFjY2Vzc1Rva2VuIH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsaWQgYWNjZXNzIHRva2VuIGJ5IGNoZWNraW5nIHRoZSB0b2tlbiBjYWNoZS5cblx0ICogSWYgYSB0b2tlbiBpcyBhdmFpbGFibGUsIGl0IHJlZnJlc2hlcyBpdDsgb3RoZXJ3aXNlLCBpdCBwZXJmb3JtcyBhbiBpbnRlcmFjdGl2ZSBsb2dpbi5cblx0ICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIHZhbGlkIGFjY2VzcyB0b2tlbi5cblx0ICovXG5cdGFzeW5jIGdldFRva2VuKCk6IFByb21pc2U8eyBhY2Nlc3NUb2tlbjogc3RyaW5nIH0+IHtcblx0XHRpZiAoZnMuZXhpc3RzU3luYyh0aGlzLnRva2VuRmlsZVBhdGgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5XaXRoQ0NBKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XG5cdFx0fVxuXHR9XG59XG4iLCAiaW1wb3J0IHsgTW9kYWwsIEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG4vKipcbiAqIEEgc2ltcGxlIG1vZGFsIHRoYXQgcHJvbXB0cyB0aGUgdXNlciB0byBlbnRlciBhIHRhc2sgdGl0bGUuXG4gKiBUaGUgbW9kYWwgaXMgY2VudGVyZWQsIGFuZCB0aGUgdGFzayBpcyBzdWJtaXR0ZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIEVudGVyLlxuICovXG5leHBvcnQgY2xhc3MgVGFza1RpdGxlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cdHJlc3VsdDogc3RyaW5nO1xuXHRvblN1Ym1pdDogKHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIHRoZSBtb2RhbC5cblx0ICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBhcHAgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSBvblN1Ym1pdCAtIEEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZW50ZXJlZCB0YXNrIHRpdGxlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIG9uU3VibWl0OiAocmVzdWx0OiBzdHJpbmcpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHApO1xuXHRcdHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkLiBSZW5kZXJzIHRoZSBpbnB1dCBVSSBhbmQgY2VudGVycyBpdC5cblx0ICovXG5cdG9uT3BlbigpIHtcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblxuXHRcdC8vIEFwcGx5IGNlbnRlcmluZyBzdHlsZXMgdG8gdGhlIG1vZGFsIGNvbnRlbnQuXG5cdFx0Y29udGVudEVsLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcblx0XHRjb250ZW50RWwuc3R5bGUuZmxleERpcmVjdGlvbiA9IFwiY29sdW1uXCI7XG5cdFx0Y29udGVudEVsLnN0eWxlLmFsaWduSXRlbXMgPSBcImNlbnRlclwiO1xuXHRcdGNvbnRlbnRFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XG5cdFx0Y29udGVudEVsLnN0eWxlLmdhcCA9IFwiMTBweFwiO1xuXHRcdGNvbnRlbnRFbC5zdHlsZS5taW5IZWlnaHQgPSBcIjEwMHB4XCI7XG5cblx0XHQvLyBDcmVhdGUgYW5kIGFwcGVuZCB0aGUgaGVhZGVyLlxuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJFbnRlciBUYXNrIFRpdGxlXCIgfSk7XG5cblx0XHQvLyBDcmVhdGUgYW5kIGFwcGVuZCB0aGUgaW5wdXQgZWxlbWVudC5cblx0XHRjb25zdCBpbnB1dEVsID0gY29udGVudEVsLmNyZWF0ZUVsKFwiaW5wdXRcIiwge1xuXHRcdFx0dHlwZTogXCJ0ZXh0XCIsXG5cdFx0XHRwbGFjZWhvbGRlcjogXCJUYXNrIFRpdGxlXCIsXG5cdFx0fSk7XG5cdFx0Ly8gT3B0aW9uYWxseSBzZXQgYSB3aWR0aCBmb3IgdGhlIGlucHV0LlxuXHRcdGlucHV0RWwuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcblx0XHRpbnB1dEVsLmZvY3VzKCk7XG5cblx0XHQvLyBXaGVuIHRoZSB1c2VyIHByZXNzZXMgRW50ZXIsIHN1Ym1pdCB0aGUgaW5wdXQuXG5cdFx0aW5wdXRFbC5vbmtleWRvd24gPSAoZSkgPT4ge1xuXHRcdFx0aWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcblx0XHRcdFx0dGhpcy5yZXN1bHQgPSBpbnB1dEVsLnZhbHVlO1xuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHRcdHRoaXMub25TdWJtaXQodGhpcy5yZXN1bHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZC4gQ2xlYXJzIHRoZSBjb250ZW50LlxuXHQgKi9cblx0b25DbG9zZSgpIHtcblx0XHR0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgR2VuZXJpY1NlbGVjdE1vZGFsPFQ+IGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8VD4ge1xuXHRpdGVtczogVFtdO1xuXHRnZXRUZXh0OiAoaXRlbTogVCkgPT4gc3RyaW5nO1xuXHRvblNlbGVjdDogKGl0ZW06IFQpID0+IFByb21pc2U8dm9pZD47XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0YXBwOiBBcHAsXG5cdFx0aXRlbXM6IFRbXSxcblx0XHRnZXRUZXh0OiAoaXRlbTogVCkgPT4gc3RyaW5nLFxuXHRcdG9uU2VsZWN0OiAoaXRlbTogVCkgPT4gUHJvbWlzZTx2b2lkPixcblx0KSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLml0ZW1zID0gaXRlbXM7XG5cdFx0dGhpcy5nZXRUZXh0ID0gZ2V0VGV4dDtcblx0XHR0aGlzLm9uU2VsZWN0ID0gb25TZWxlY3Q7XG5cdH1cblxuXHRnZXRJdGVtcygpOiBUW10ge1xuXHRcdHJldHVybiB0aGlzLml0ZW1zO1xuXHR9XG5cblx0Z2V0SXRlbVRleHQoaXRlbTogVCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGV4dChpdGVtKTtcblx0fVxuXG5cdGFzeW5jIG9uQ2hvb3NlSXRlbShpdGVtOiBUKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0YXdhaXQgdGhpcy5vblNlbGVjdChpdGVtKTtcblx0fVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsOENBQUFBLFNBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsTUFDRSxNQUFRO0FBQUEsTUFDUixTQUFXO0FBQUEsTUFDWCxhQUFlO0FBQUEsTUFDZixNQUFRO0FBQUEsTUFDUixPQUFTO0FBQUEsTUFDVCxTQUFXO0FBQUEsUUFDVCxLQUFLO0FBQUEsVUFDSCxPQUFTO0FBQUEsVUFDVCxTQUFXO0FBQUEsVUFDWCxTQUFXO0FBQUEsUUFDYjtBQUFBLFFBQ0EsWUFBWTtBQUFBLFFBQ1osZUFBZTtBQUFBLFFBQ2YscUJBQXFCO0FBQUEsUUFDckIsd0JBQXdCO0FBQUEsUUFDeEIscUJBQXFCO0FBQUEsUUFDckIsd0JBQXdCO0FBQUEsUUFDeEIsa0JBQWtCO0FBQUEsTUFDcEI7QUFBQSxNQUNBLFNBQVc7QUFBQSxRQUNULGFBQWE7QUFBQSxRQUNiLE1BQVE7QUFBQSxRQUNSLFNBQVc7QUFBQSxRQUNYLE1BQVE7QUFBQSxRQUNSLGlCQUFpQjtBQUFBLFFBQ2pCLFlBQWM7QUFBQSxRQUNkLFNBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSxZQUFjO0FBQUEsUUFDWixNQUFRO0FBQUEsUUFDUixLQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsU0FBVztBQUFBLE1BQ1gsVUFBWTtBQUFBLFFBQ1Y7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFB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QyxZQUFNLFFBQVEsTUFBTSxLQUFLLHlCQUF5QjtBQUNsRCxZQUFNLGlCQUFpQixNQUFNLEtBQUssTUFBTSxPQUFPLENBQUMsRUFBRTtBQUFBLFFBQ2pELENBQUMsU0FBUyxLQUFLLFdBQVc7QUFBQSxNQUMzQjtBQUVBLGlCQUFXLFFBQVEsZ0JBQWdCO0FBQ2xDLGdCQUFRLElBQUksa0JBQWtCLElBQUk7QUFDbEMsY0FBTSxXQUFXLEtBQUssVUFBVSxhQUFhLEtBQUssRUFBRTtBQUNwRDtBQUFBLE1BQ0Q7QUFFQSxXQUFLLG9CQUFvQjtBQUN6QixhQUFPO0FBQUEsSUFDUixTQUFTLE9BQU87QUFDZixjQUFRLE1BQU0seUJBQXlCLEtBQUs7QUFDNUMsYUFBTztBQUFBLElBQ1I7QUFBQSxFQUNEO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLHNCQUFzQjtBQUMzQixVQUFNLFFBQVEsTUFBTSxLQUFLLGlCQUFpQjtBQUMxQyxRQUFJLEtBQUssYUFBYTtBQUNyQixZQUFNLEtBQUssWUFBWSxPQUFPLEtBQUs7QUFBQSxJQUNwQyxPQUFPO0FBQ04sY0FBUSxLQUFLLDZCQUE2QjtBQUFBLElBQzNDO0FBQUEsRUFDRDtBQUNEOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgImZzIiwgInBhdGgiLCAiY3J5cHRvIiwgInZlcnNpb24iLCAiY29uZmlnIiwgIm1vZHVsZSIsICJCdWZmZXIiLCAibW9kdWxlIiwgIkJ1ZmZlciIsICJtb2R1bGUiLCAiQnVmZmVyIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiQnVmZmVyIiwgIm1vZHVsZSIsICJCdWZmZXIiLCAiY3J5cHRvIiwgIm1vZHVsZSIsICJCdWZmZXIiLCAibW9kdWxlIiwgIkJ1ZmZlciIsICJtb2R1bGUiLCAiQnVmZmVyIiwgIm1vZHVsZSIsICJqd3QiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm5hbWUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm5hbWUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbjIiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgInZlcnNpb24iLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicmVxdWlyZV92YWxpZCIsICJtb2R1bGUiLCAibW9kdWxlIiwgInZlcnNpb24iLCAibW9kdWxlIiwgInZlcnNpb24iLCAibW9kdWxlIiwgInZlcnNpb24iLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJyZXF1aXJlX3NlbXZlciIsICJtb2R1bGUiLCAiY29uc3RhbnRzIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiaGVhZGVyIiwgInNlY3JldE9yUHVibGljS2V5IiwgIl8iLCAibW9kdWxlIiwgInJlcXVpcmVfbG9kYXNoIiwgIm1vZHVsZSIsICJyZXF1aXJlX2xvZGFzaCIsICJtb2R1bGUiLCAicmVxdWlyZV9sb2Rhc2giLCAibW9kdWxlIiwgInJlcXVpcmVfbG9kYXNoIiwgIm1vZHVsZSIsICJyZXF1aXJlX2xvZGFzaCIsICJtb2R1bGUiLCAicmVxdWlyZV9sb2Rhc2giLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ2YWxpZGF0ZSIsICJfIiwgIm1vZHVsZSIsICJuYW1lIiwgIlByb21pc2UiLCAibmFtZSIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJyZXF1aXJlX3JlbmRlcmVyIiwgIm1vZHVsZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZnMiLCAicGF0aCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJBdXRoRXJyb3JDb2Rlcy51bmV4cGVjdGVkRXJyb3IiLCAiQXV0aEVycm9yQ29kZXMucG9zdFJlcXVlc3RGYWlsZWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuY2xpZW50SW5mb0RlY29kaW5nRXJyb3IiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuY2xpZW50SW5mb0VtcHR5RXJyb3IiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5QYXJzaW5nRXJyb3IiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubnVsbE9yRW1wdHlUb2tlbiIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5lbmRwb2ludFJlc29sdXRpb25FcnJvciIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5uZXR3b3JrRXJyb3IiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMub3BlbklkQ29uZmlnRXJyb3IiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuaGFzaE5vdERlc2VyaWFsaXplZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkU3RhdGUiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuc3RhdGVNaXNtYXRjaCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5zdGF0ZU5vdEZvdW5kIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm5vbmNlTWlzbWF0Y2giLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aFRpbWVOb3RGb3VuZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5tYXhBZ2VUcmFuc3BpcmVkIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdUb2tlbnMiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubXVsdGlwbGVNYXRjaGluZ0FjY291bnRzIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdBcHBNZXRhZGF0YSIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5yZXF1ZXN0Q2Fubm90QmVNYWRlIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmNhbm5vdFJlbW92ZUVtcHR5U2NvcGUiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuY2Fubm90QXBwZW5kU2NvcGVTZXQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuZW1wdHlJbnB1dFNjb3BlU2V0IiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmRldmljZUNvZGVQb2xsaW5nQ2FuY2VsbGVkIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmRldmljZUNvZGVFeHBpcmVkIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmRldmljZUNvZGVVbmtub3duRXJyb3IiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0IiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDYWNoZVJlY29yZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQ2FjaGVFbnZpcm9ubWVudCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub0FjY291bnRGb3VuZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub0NyeXB0b09iamVjdCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy51bmV4cGVjdGVkQ3JlZGVudGlhbFR5cGUiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuaW52YWxpZEFzc2VydGlvbiIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQ2xpZW50Q3JlZGVudGlhbCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblJlZnJlc2hSZXF1aXJlZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy51c2VyVGltZW91dFJlYWNoZWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5DbGFpbXNDbmZSZXF1aXJlZEZvclNpZ25lZEp3dCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5hdXRob3JpemF0aW9uQ29kZU1pc3NpbmdGcm9tU2VydmVyUmVzcG9uc2UiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuYmluZGluZ0tleU5vdFJlbW92ZWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kU2Vzc2lvbkVuZHBvaW50Tm90U3VwcG9ydGVkIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmtleUlkTWlzc2luZyIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub05ldHdvcmtDb25uZWN0aXZpdHkiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMudXNlckNhbmNlbGVkIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm1pc3NpbmdUZW5hbnRJZEVycm9yIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm1ldGhvZE5vdEltcGxlbWVudGVkIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm5lc3RlZEFwcEF1dGhCcmlkZ2VEaXNhYmxlZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5tZXRob2ROb3RJbXBsZW1lbnRlZCIsICJMb2dMZXZlbCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblBhcnNpbmdFcnJvciIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5udWxsT3JFbXB0eVRva2VuIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm1heEFnZVRyYW5zcGlyZWQiLCAiVGltZVV0aWxzLm5vd1NlY29uZHMiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5DbGFpbXNDbmZSZXF1aXJlZEZvclNpZ25lZEp3dCIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5yZWRpcmVjdFVyaUVtcHR5IiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3IiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuYXV0aG9yaXR5VXJpSW5zZWN1cmUiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudXJsUGFyc2VFcnJvciIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy51cmxFbXB0eUVycm9yIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmVtcHR5SW5wdXRTY29wZXNFcnJvciIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkUHJvbXB0VmFsdWUiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZENsYWltcyIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy50b2tlblJlcXVlc3RFbXB0eSIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5sb2dvdXRSZXF1ZXN0RW1wdHkiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZENvZGVDaGFsbGVuZ2VNZXRob2QiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMucGtjZVBhcmFtc01pc3NpbmciLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZENsb3VkRGlzY292ZXJ5TWV0YWRhdGEiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZEF1dGhvcml0eU1ldGFkYXRhIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVudHJ1c3RlZEF1dGhvcml0eSIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5taXNzaW5nU3NoSndrIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1pc3NpbmdTc2hLaWQiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXIiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZEF1dGhlbnRpY2F0aW9uSGVhZGVyIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmNhbm5vdFNldE9JRENPcHRpb25zIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmNhbm5vdEFsbG93UGxhdGZvcm1Ccm9rZXIiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuYXV0aG9yaXR5TWlzbWF0Y2giLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuZW1wdHlJbnB1dFNjb3Blc0Vycm9yIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmNhbm5vdEFwcGVuZFNjb3BlU2V0IiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmNhbm5vdFJlbW92ZUVtcHR5U2NvcGUiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuZW1wdHlJbnB1dFNjb3BlU2V0IiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmNsaWVudEluZm9FbXB0eUVycm9yIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmNsaWVudEluZm9EZWNvZGluZ0Vycm9yIiwgIm5hbWUiLCAidGVuYW50SWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuaW52YWxpZENhY2hlRW52aXJvbm1lbnQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuaGFzaE5vdERlc2VyaWFsaXplZCIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy51cmxFbXB0eUVycm9yIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybFBhcnNlRXJyb3IiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuYXV0aG9yaXR5VXJpSW5zZWN1cmUiLCAiVXJsVXRpbHMuZ2V0RGVzZXJpYWxpemVkUmVzcG9uc2UiLCAiQ2FjaGVFcnJvckNvZGVzLmNhY2hlUXVvdGFFeGNlZWRlZEVycm9yQ29kZSIsICJDYWNoZUVycm9yQ29kZXMuY2FjaGVVbmtub3duRXJyb3JDb2RlIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDYWNoZVJlY29yZCIsICJDYWNoZUVycm9yQ29kZXMuY2FjaGVRdW90YUV4Y2VlZGVkRXJyb3JDb2RlIiwgIkNhY2hlRXJyb3JDb2Rlcy5jYWNoZVVua25vd25FcnJvckNvZGUiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuYmluZGluZ0tleU5vdFJlbW92ZWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubXVsdGlwbGVNYXRjaGluZ0FwcE1ldGFkYXRhIiwgIm5hbWUiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubWV0aG9kTm90SW1wbGVtZW50ZWQiLCAiY29uZmlnIiwgIkNMSUVOVF9JTkZPIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSUQiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkJST0tFUl9DTElFTlRfSUQiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlJFRElSRUNUX1VSSSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuUkVTUE9OU0VfVFlQRSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuUkVTUE9OU0VfTU9ERSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuTkFUSVZFX0JST0tFUiIsICJBQURTZXJ2ZXJQYXJhbUtleXMuU0NPUEUiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlBPU1RfTE9HT1VUX1VSSSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuSURfVE9LRU5fSElOVCIsICJBQURTZXJ2ZXJQYXJhbUtleXMuRE9NQUlOX0hJTlQiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkxPR0lOX0hJTlQiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlNJRCIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQ2xhaW1zIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5DTEFJTVMiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9SRVFVRVNUX0lEIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5YX0NMSUVOVF9TS1UiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX1ZFUiIsICJBQURTZXJ2ZXJQYXJhbUtleXMuWF9DTElFTlRfT1MiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX0NQVSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuWF9BUFBfTkFNRSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuWF9BUFBfVkVSIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5QUk9NUFQiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlNUQVRFIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5OT05DRSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuQ09ERV9DSEFMTEVOR0UiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkNPREVfQ0hBTExFTkdFX01FVEhPRCIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5wa2NlUGFyYW1zTWlzc2luZyIsICJBQURTZXJ2ZXJQYXJhbUtleXMuQ09ERSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuREVWSUNFX0NPREUiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlJFRlJFU0hfVE9LRU4iLCAiQUFEU2VydmVyUGFyYW1LZXlzLkNPREVfVkVSSUZJRVIiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9TRUNSRVQiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9BU1NFUlRJT04iLCAiQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9BU1NFUlRJT05fVFlQRSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuT0JPX0FTU0VSVElPTiIsICJBQURTZXJ2ZXJQYXJhbUtleXMuUkVRVUVTVEVEX1RPS0VOX1VTRSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuR1JBTlRfVFlQRSIsICJBQURTZXJ2ZXJQYXJhbUtleXMuSU5TVEFOQ0VfQVdBUkUiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlRPS0VOX1RZUEUiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlJFUV9DTkYiLCAiQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX0NVUlJfVEVMRU0iLCAiQUFEU2VydmVyUGFyYW1LZXlzLlhfQ0xJRU5UX0xBU1RfVEVMRU0iLCAiQUFEU2VydmVyUGFyYW1LZXlzLlhfTVNfTElCX0NBUEFCSUxJVFkiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkxPR09VVF9ISU5UIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5CUk9LRVJfUkVESVJFQ1RfVVJJIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5FQVJfSldLIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5FQVJfSldFX0NSWVBUTyIsICJlIiwgInZlcnNpb24iLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3IiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuZW5kU2Vzc2lvbkVuZHBvaW50Tm90U3VwcG9ydGVkIiwgIkNhY2hlSGVscGVycy5nZW5lcmF0ZUF1dGhvcml0eU1ldGFkYXRhRXhwaXJlc0F0IiwgIkNhY2hlSGVscGVycy51cGRhdGVBdXRob3JpdHlFbmRwb2ludE1ldGFkYXRhIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm9wZW5JZENvbmZpZ0Vycm9yIiwgIkNhY2hlSGVscGVycy5pc0F1dGhvcml0eU1ldGFkYXRhRXhwaXJlZCIsICJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5pbnZhbGlkQXV0aG9yaXR5TWV0YWRhdGEiLCAiQ2FjaGVIZWxwZXJzLnVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudW50cnVzdGVkQXV0aG9yaXR5IiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLmVuZHBvaW50UmVzb2x1dGlvbkVycm9yIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm5ldHdvcmtFcnJvciIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRCcm9rZXJQYXJhbWV0ZXJzIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENvcnJlbGF0aW9uSWQiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuaW5zdHJ1bWVudEJyb2tlclBhcmFtcyIsICJVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nIiwgIkludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5pbnRlcmFjdGlvblJlcXVpcmVkIiwgIkludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5jb25zZW50UmVxdWlyZWQiLCAiSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLmxvZ2luUmVxdWlyZWQiLCAiSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLmJhZFRva2VuIiwgIkludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5ub1Rva2Vuc0ZvdW5kIiwgIkludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5uYXRpdmVBY2NvdW50VW5hdmFpbGFibGUiLCAiSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLnJlZnJlc2hUb2tlbkV4cGlyZWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubm9DcnlwdG9PYmplY3QiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuaW52YWxpZFN0YXRlIiwgIlRpbWVVdGlscy5ub3dTZWNvbmRzIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLm5vbmNlTWlzbWF0Y2giLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aFRpbWVOb3RGb3VuZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQ2FjaGVFbnZpcm9ubWVudCIsICJDYWNoZUhlbHBlcnMuY3JlYXRlSWRUb2tlbkVudGl0eSIsICJDYWNoZUhlbHBlcnMuY3JlYXRlQWNjZXNzVG9rZW5FbnRpdHkiLCAiQ2FjaGVIZWxwZXJzLmNyZWF0ZVJlZnJlc2hUb2tlbkVudGl0eSIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5rZXlJZE1pc3NpbmciLCAiVGltZVV0aWxzLnRvRGF0ZUZyb21TZWNvbmRzIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnJlZGlyZWN0VXJpRW1wdHkiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZFByb21wdFZhbHVlIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLmludmFsaWRDbGFpbXMiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMucGtjZVBhcmFtc01pc3NpbmciLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMuaW52YWxpZENvZGVDaGFsbGVuZ2VNZXRob2QiLCAiY29uZmlnIiwgIkNsaWVudEF1dGhFcnJvckNvZGVzLnJlcXVlc3RDYW5ub3RCZU1hZGUiLCAiVGltZVV0aWxzLm5vd1NlY29uZHMiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubG9nb3V0UmVxdWVzdEVtcHR5IiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudElkIiwgIkFBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSUQiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUmVkaXJlY3RVcmkiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU2NvcGVzIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEF1dGhvcml6YXRpb25Db2RlIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZExpYnJhcnlJbmZvIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEFwcGxpY2F0aW9uVGVsZW1ldHJ5IiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFRocm90dGxpbmciLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU2VydmVyVGVsZW1ldHJ5IiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENvZGVWZXJpZmllciIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRTZWNyZXQiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50QXNzZXJ0aW9uIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEFzc2VydGlvblR5cGUiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkR3JhbnRUeXBlIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEluZm8iLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUG9wVG9rZW4iLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU3NoSndrIiwgIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1pc3NpbmdTc2hKd2siLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xhaW1zIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc09pZCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDY3NVcG4iLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQnJva2VyUGFyYW1ldGVycyIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRFeHRyYVF1ZXJ5UGFyYW1ldGVycyIsICJBQURTZXJ2ZXJQYXJhbUtleXMuUkVUVVJOX1NQQV9DT0RFIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmluc3RydW1lbnRCcm9rZXJQYXJhbXMiLCAiVXJsVXRpbHMubWFwVG9RdWVyeVN0cmluZyIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRQb3N0TG9nb3V0UmVkaXJlY3RVcmkiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ29ycmVsYXRpb25JZCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRJZFRva2VuSGludCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTdGF0ZSIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMb2dvdXRIaW50IiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEluc3RhbmNlQXdhcmUiLCAiVGltZVV0aWxzLm5vd1NlY29uZHMiLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMudG9rZW5SZXF1ZXN0RW1wdHkiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMubm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0IiwgIkludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5ub1Rva2Vuc0ZvdW5kIiwgIlRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZCIsICJJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMucmVmcmVzaFRva2VuRXhwaXJlZCIsICJJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMuYmFkVG9rZW4iLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SWQiLCAiQUFEU2VydmVyUGFyYW1LZXlzLkNMSUVOVF9JRCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRSZWRpcmVjdFVyaSIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTY29wZXMiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkR3JhbnRUeXBlIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEluZm8iLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkTGlicmFyeUluZm8iLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQXBwbGljYXRpb25UZWxlbWV0cnkiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTZXJ2ZXJUZWxlbWV0cnkiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkUmVmcmVzaFRva2VuIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudFNlY3JldCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb24iLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50QXNzZXJ0aW9uVHlwZSIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRQb3BUb2tlbiIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTc2hKd2siLCAiQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWlzc2luZ1NzaEp3ayIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGFpbXMiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2NzT2lkIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc1VwbiIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRCcm9rZXJQYXJhbWV0ZXJzIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmluc3RydW1lbnRCcm9rZXJQYXJhbXMiLCAiVXJsVXRpbHMubWFwVG9RdWVyeVN0cmluZyIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy50b2tlblJlZnJlc2hSZXF1aXJlZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5ub0FjY291bnRJblNpbGVudFJlcXVlc3QiLCAiVGltZVV0aWxzLndhc0Nsb2NrVHVybmVkQmFjayIsICJUaW1lVXRpbHMuaXNUb2tlbkV4cGlyZWQiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuYXV0aFRpbWVOb3RGb3VuZCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRJZCIsICJBQURTZXJ2ZXJQYXJhbUtleXMuQ0xJRU5UX0lEIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNjb3BlcyIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRSZWRpcmVjdFVyaSIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDb3JyZWxhdGlvbklkIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFJlc3BvbnNlTW9kZSIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRJbmZvIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFByb21wdCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGREb21haW5IaW50IiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNpZCIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMb2dpbkhpbnQiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2NzT2lkIiwgIlJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENjc1VwbiIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGROb25jZSIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTdGF0ZSIsICJSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGFpbXMiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQnJva2VyUGFyYW1ldGVycyIsICJBQURTZXJ2ZXJQYXJhbUtleXMuSU5TVEFOQ0VfQVdBUkUiLCAiUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkSW5zdGFuY2VBd2FyZSIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5hdXRob3JpemF0aW9uQ29kZU1pc3NpbmdGcm9tU2VydmVyUmVzcG9uc2UiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuc3RhdGVOb3RGb3VuZCIsICJDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkU3RhdGUiLCAiQ2xpZW50QXV0aEVycm9yQ29kZXMuc3RhdGVNaXNtYXRjaCIsICJDb25zdGFudHMiLCAiaHR0cCIsICJoZWFkZXJzIiwgIkNvbnN0YW50cyIsICJodHRwcyIsICJib2R5IiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuaW52YWxpZEZpbGVFeHRlbnNpb24iLCAiTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5pbnZhbGlkRmlsZVBhdGgiLCAiTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5pbnZhbGlkTWFuYWdlZElkZW50aXR5SWRUeXBlIiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuaW52YWxpZFNlY3JldCIsICJNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnBsYXRmb3JtTm90U3VwcG9ydGVkIiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMubWlzc2luZ0lkIiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMuTXNpRW52aXJvbm1lbnRWYXJpYWJsZVVybE1hbGZvcm1lZEVycm9yQ29kZXMiLCAiTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5uZXR3b3JrVW5hdmFpbGFibGUiLCAiTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy51bmFibGVUb0NyZWF0ZUF6dXJlQXJjIiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMudW5hYmxlVG9DcmVhdGVDbG91ZFNoZWxsIiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMudW5hYmxlVG9DcmVhdGVTb3VyY2UiLCAiTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy51bmFibGVUb1JlYWRTZWNyZXRGaWxlIiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMudXNlckFzc2lnbmVkTm90QXZhaWxhYmxlQXRSdW50aW1lIiwgIk1hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMud3d3QXV0aGVudGljYXRlSGVhZGVyTWlzc2luZyIsICJNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLnd3d0F1dGhlbnRpY2F0ZUhlYWRlclVuc3VwcG9ydGVkRm9ybWF0IiwgIkRFRkFVTFRfQ0FDSEVfT1BUSU9OUyIsICJERUZBVUxUX1NZU1RFTV9PUFRJT05TIiwgIkRFRkFVTFRfVEVMRU1FVFJZX09QVElPTlMiLCAidXVpZHY0IiwgImNyeXB0byIsICJjcnlwdG8iLCAiand0IiwgIm5hbWUiLCAidmVyc2lvbiIsICJjb25maWciLCAiTm9kZUNvbnN0YW50cyIsICJ2ZXJzaW9uIiwgIm5hbWUiLCAidmVyc2lvbiIsICJOb2RlQ29uc3RhbnRzIiwgIkNvbnN0YW50cyIsICJjb25maWciLCAiTm9kZUNvbnN0YW50cyIsICJNYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLmludmFsaWRNYW5hZ2VkSWRlbnRpdHlJZFR5cGUiLCAiTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlc1xyXG4gICAgICAgICAgICAuTXNpRW52aXJvbm1lbnRWYXJpYWJsZVVybE1hbGZvcm1lZEVycm9yQ29kZXMiLCAiUkVESVJFQ1RfVVJJIiwgImNvbmZpZyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIl0KfQo=
